var gO = Object.defineProperty;
var $G = Object.getPrototypeOf;
var AG = Reflect.get;
var EG = (i, e, t) => e in i ? gO(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t;
var f = (i, e) => gO(i, "name", { value: e, configurable: !0 });
var Ge = (i, e, t) => (EG(i, typeof e != "symbol" ? e + "" : e, t), t), $b = (i, e, t) => {
  if (!e.has(i))
    throw TypeError("Cannot " + t);
};
var M = (i, e, t) => ($b(i, e, "read from private field"), t ? t.call(i) : e.get(i)), Y = (i, e, t) => {
  if (e.has(i))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(i) : e.set(i, t);
}, ye = (i, e, t, s) => ($b(i, e, "write to private field"), s ? s.call(i, t) : e.set(i, t), t);
var Lr = (i, e, t, s) => ({
  set _(n) {
    ye(i, e, n, t);
  },
  get _() {
    return M(i, e, s);
  }
}), Z = (i, e, t) => ($b(i, e, "access private method"), t), Ab = (i, e, t) => AG($G(i), t, e);
var Hc;
let ul = (Hc = class {
  static getDisableFilePoster(e) {
    return e.getParam("oembed_disable_file_poster", !1);
  }
  static getDisableFileSource(e) {
    return e.getParam("oembed_disable_file_source", !1);
  }
  static getMediaHeight(e) {
    return e.getParam("oembed_default_height", 288);
  }
  static getMediaWidth(e) {
    return e.getParam("oembed_default_width", 512);
  }
  static getUrlResolver(e) {
    return e.getParam("oembed_url_resolver");
  }
  static hasDimensions(e) {
    return e.getParam("oembed_dimensions", !0);
  }
  static hasLiveEmbeds(e) {
    return e.getParam("oembed_live_embeds", !0);
  }
  static hasPoster(e) {
    return e.getParam("oembed_poster", !0);
  }
  static shouldFilterHtml(e) {
    return e.getParam("oembed_filter_html", !0);
  }
}, f(Hc, "e"), Hc);
const e7 = /* @__PURE__ */ f((i, e) => {
  if (ul.shouldFilterHtml(i) === !1)
    return e;
  const t = tinymce.html.Writer();
  let s;
  return tinymce.html.SaxParser({ validate: !1, allow_conditional_comments: !1, comment: (n) => {
    s || t.comment(n);
  }, cdata: (n) => {
    s || t.cdata(n);
  }, text: (n, l) => {
    s || t.text(n, l);
  }, start: (n, l, r) => {
    if (s = !0, n !== "script" && n !== "noscript" && n !== "svg") {
      for (let o = l.length - 1; o >= 0; o--) {
        const a = l[o].name;
        a.indexOf("on") === 0 && (delete l.map[a], l.splice(o, 1)), a === "style" && (l[o].value = i.dom.serializeStyle(i.dom.parseStyle(l[o].value), n));
      }
      t.start(n, l, r), s = !1;
    }
  }, end: (n) => {
    s || t.end(n);
  } }, tinymce.html.Schema({})).parse(e), t.getContent();
}, "t$1");
let gc;
var Uc;
let Nb = (Uc = class {
  static placeHolderConverter(e) {
    return (t) => {
      let s, n = t.length;
      for (; n--; )
        s = t[n], s.parent && !s.parent.attr("data-mce-object") && (CG(s) && ul.hasLiveEmbeds(e) ? _O(s) || s.replace(SG(e, s)) : _O(s) || s.replace(TG(e, s)));
    };
  }
  static setPoster(e) {
    gc = e;
  }
}, f(Uc, "r"), Uc);
const SG = /* @__PURE__ */ f((i, e) => {
  const t = e.name;
  gc !== void 0 && e.attr("data-oembed-poster", gc);
  const s = new tinymce.html.Node("span", 1);
  s.attr({ contentEditable: "false", style: e.attr("style"), "data-mce-object": t, class: `mce-preview-object mce-object-${t}` }), t7(i, e, s);
  const n = i.dom.parseStyle(e.attr("style")), l = new tinymce.html.Node(t, 1);
  if (s7(e, l, n), l.attr({ src: e.attr("src"), style: e.attr("style"), class: e.attr("class") }), t === "iframe")
    l.attr({ allowfullscreen: e.attr("allowfullscreen"), frameborder: "0" });
  else {
    const o = ["controls", "crossorigin", "currentTime", "loop", "muted", "poster", "preload"];
    for (const c of o)
      l.attr(c, e.attr(c));
    const a = s.attr("data-mce-html");
    a != null && ((c, u, d, p) => {
      const m = tinymce.html.DomParser({ forced_root_block: !1, validate: !1 }, c.schema).parse(p, { context: u });
      for (; m.firstChild; )
        d.append(m.firstChild);
    })(i, t, l, a);
  }
  const r = new tinymce.html.Node("span", 1);
  return r.attr("class", "mce-shim"), s.append(l), s.append(r), s;
}, "s$1"), TG = /* @__PURE__ */ f((i, e) => {
  const t = e.name;
  gc !== void 0 && e.attr("data-oembed-poster", gc);
  const s = new tinymce.html.Node("img", 1);
  s.shortEnded = !0, t7(i, e, s);
  const n = e.attr("data-oembed-poster");
  return s7(e, s, {}), s.attr({ style: e.attr("style"), src: n || "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", "data-mce-object": t, class: `mce-object mce-object-${t}` }), s;
}, "o$1"), bO = /* @__PURE__ */ f((i, e, t, s = null) => {
  const n = i.attr(t);
  return n ?? (Object.hasOwnProperty.call(e, t) ? null : s);
}, "n$1"), CG = /* @__PURE__ */ f((i) => {
  const e = i.name;
  return e === "iframe" || e === "video" || e === "audio";
}, "i$1"), OG = /* @__PURE__ */ f((i) => {
  const e = i.attr("class");
  return e && /\btiny-pageembed\b/.test(e);
}, "c$1"), _O = /* @__PURE__ */ f((i) => {
  for (; i = i.parent; )
    if (OG(i))
      return !0;
  return !1;
}, "l$1"), t7 = /* @__PURE__ */ f((i, e, t) => {
  const s = e.attributes;
  let n = s.length;
  for (; n--; ) {
    const r = s[n].name;
    let o = s[n].value;
    r !== "width" && r !== "height" && r !== "style" && (r !== "data" && r !== "src" || (o = i.convertURL(o, r)), t.attr(`data-mce-p-${r}`, o));
  }
  const l = e.firstChild && e.firstChild.value;
  l && (t.attr("data-mce-html", escape(e7(i, l))), t.firstChild = null);
}, "m$1"), s7 = /* @__PURE__ */ f((i, e, t) => {
  const s = e.name === "img" || i.name === "video", n = s ? "300" : null, l = i.name === "audio" ? "30" : "150", r = s ? l : null;
  e.attr({ width: bO(i, t, "width", n), height: bO(i, t, "height", r) });
}, "d$1"), Br = /* @__PURE__ */ f((i, e) => {
  const t = Object.keys(e);
  for (let s = 0, n = t.length; s < n; s++) {
    const l = t[s], r = `${e[l]}`;
    if (i.map[l]) {
      let o = i.length;
      for (; o--; ) {
        const a = i[o];
        a.name === l && (r ? (i.map[l] = r, a.value = r) : (delete i.map[l], i.splice(o, 1)));
      }
    } else
      r && (i.push({ name: l, value: r }), i.map[l] = r);
  }
}, "u$1"), qr = ["source"], j5 = /* @__PURE__ */ f((i, e, t) => {
  const s = tinymce.html.Writer();
  let n, l = 0;
  return tinymce.html.SaxParser({ validate: !1, allow_conditional_comments: !0, comment: (r) => {
    s.comment(r);
  }, cdata: (r) => {
    s.cdata(r);
  }, text: (r, o) => {
    s.text(r, o);
  }, start: (r, o, a) => {
    switch (r) {
      case "video":
      case "object":
      case "embed":
      case "img":
      case "iframe":
        e.height !== void 0 && e.width !== void 0 && Br(o, { width: e.width, height: e.height });
    }
    if (t)
      switch (r) {
        case "video":
          Br(o, { poster: e.poster, src: "" });
          break;
        case "iframe":
          Br(o, { src: e.source });
          break;
        case "source":
          if (l < 2 && (Br(o, { src: e[qr[l]], type: e[`${qr[l]}mime`] }), !e[qr[l]]))
            return;
          l++;
          break;
        case "img":
          if (!e.poster)
            return;
          n = !0;
      }
    s.start(r, o, a);
  }, end: (r) => {
    if (r === "video" && t) {
      for (let o = 0; o < 2; o++)
        if (e[qr[o]]) {
          const a = [];
          a.map = {}, l <= o && (Br(a, { src: e[qr[o]], type: e[`${qr[o]}mime`] }), s.start("source", a, !0));
        }
    }
    if (e.poster && r === "object" && t && !n) {
      const o = [];
      o.map = {}, Br(o, { src: e.poster, width: e.width, height: e.height }), s.start("img", o, !0);
    }
    s.end(r);
  } }, tinymce.html.Schema({})).parse(i), s.getContent();
}, "p$1"), DG = /* @__PURE__ */ f((i, e) => (t) => i.selection.selectorChangedWithUnbind(e.join(","), t.setActive).unbind, "g$1");
var Ws;
let cl = (Ws = class {
  constructor(e, t) {
    this.tag = e, this.value = t;
  }
  static some(e) {
    return new Ws(!0, e);
  }
  static none() {
    return Ws.singletonNone;
  }
  fold(e, t) {
    return this.tag ? t(this.value) : e();
  }
  isSome() {
    return this.tag;
  }
  isNone() {
    return !this.tag;
  }
  map(e) {
    return this.tag ? Ws.some(e(this.value)) : Ws.none();
  }
  bind(e) {
    return this.tag ? e(this.value) : Ws.none();
  }
  exists(e) {
    return this.tag && e(this.value);
  }
  forall(e) {
    return !this.tag || e(this.value);
  }
  filter(e) {
    return !this.tag || e(this.value) ? this : Ws.none();
  }
  getOr(e) {
    return this.tag ? this.value : e;
  }
  or(e) {
    return this.tag ? this : e;
  }
  getOrThunk(e) {
    return this.tag ? this.value : e();
  }
  orThunk(e) {
    return this.tag ? this : e();
  }
  getOrDie(e) {
    if (this.tag)
      return this.value;
    throw new Error(e ?? "Called getOrDie on None");
  }
  static from(e) {
    return e == null ? Ws.none() : Ws.some(e);
  }
  getOrNull() {
    return this.tag ? this.value : null;
  }
  getOrUndefined() {
    return this.value;
  }
  each(e) {
    this.tag && e(this.value);
  }
  toArray() {
    return this.tag ? [this.value] : [];
  }
  toString() {
    return this.tag ? `some(${this.value})` : "none()";
  }
}, f(Ws, "b"), Ws);
cl.singletonNone = new cl(!1);
const IG = Object.hasOwnProperty, Cn = /* @__PURE__ */ f((i, e) => PG(i, e) ? cl.from(i[e]) : cl.none(), "y$1"), PG = /* @__PURE__ */ f((i, e) => IG.call(i, e), "v$1"), n7 = /* @__PURE__ */ f((i) => {
  let e = {};
  return tinymce.html.SaxParser({ validate: !1, allow_conditional_comments: !0, start: (t, s) => {
    e.source || t !== "param" || (e.source = s.map.movie), t !== "iframe" && t !== "object" && t !== "embed" && t !== "video" && t !== "audio" || (e.type || (e.type = t), e = Object.assign({}, s.map, e)), t === "source" && (e.source || (e.source = s.map.src)), t !== "img" || e.poster || (e.poster = s.map.src), s.map["data-oembed-poster"] !== void 0 && (e.poster = s.map["data-oembed-poster"]);
  } }).parse(i), e.source = e.source || e.src || e.data, e.poster = e.poster || "", e;
}, "w$1"), Nf = /* @__PURE__ */ new Map(), MG = [{ name: "Vimeo", regex: /^(https:\/\/vimeo.com\/(.*)|https:\/\/vimeo.com\/album\/(.*)\/video\/(.*)|https:\/\/vimeo.com\/channels\/(.*)\/(.*)|https:\/\/vimeo.com\/groups\/(.*)\/videos\/(.*)|https:\/\/vimeo.com\/ondemand\/(.*)\/(.*)|https:\/\/player.vimeo.com\/video\/(.*))/, url: (i, e, t) => `https://vimeo.com/api/oembed.json?url=${i}&maxwidth=${e}&maxheight=${t}` }, { name: "YouTube", regex: /^(https:\/\/(.*).youtube.com\/watch(.*)|https:\/\/(.*).youtube.com\/v\/(.*)|https:\/\/youtu.be\/(.*)|https:\/\/(.*).youtube.com\/playlist?list=(.*))/, url: (i, e, t) => `https://www.youtube.com/oembed?url=${i}&format=json&maxwidth=${e}&maxheight=${t}` }];
var Vc;
let jb = (Vc = class {
  static async getEmbedHtml(e, t) {
    let s;
    if (Nf.has(t.source))
      return Nf.get(t.source);
    const n = ul.getUrlResolver(e);
    if (n)
      try {
        const l = await n({ url: t.source });
        s = { url: t.source, html: l.html, poster: l.poster };
      } catch (l) {
        const r = l.msg || l.message || "Unknown error.";
        return void e.notificationManager.open({ type: "error", text: `Media embed error: ${r}` });
      }
    else {
      let l, r;
      const o = ul.getMediaWidth(e), a = ul.getMediaHeight(e);
      for (const d of MG)
        d.regex.exec(t.source) && (r = d.url(t.source, o, a), l = d.name);
      if (r === void 0)
        return void e.notificationManager.open({ type: "error", text: "Media embed error: URL did not match any providers available." });
      const c = await window.fetch(r);
      if (!c || c.status !== 200)
        return void e.notificationManager.open({ type: "error", text: `Media embed error: Could not fetch ${l} embed URL.` });
      const u = await c.json();
      if (u.html === void 0) {
        const d = u.error ? u.error : `Could not fetch ${l} embed URL.`;
        return void e.notificationManager.open({ type: "error", text: `Media embed error: ${d}` });
      }
      s = { url: t.source, html: u.html, poster: u.thumbnail_url };
    }
    return Nf.set(t.source, s), s;
  }
  static isCached(e) {
    return Nf.has(e);
  }
}, f(Vc, "x"), Vc);
var Er;
let Q1 = (Er = class {
  static showDialog(e) {
    const t = NG(e);
    let s = t;
    const n = x1(t), l = ul.getDisableFilePoster(e), r = ul.getDisableFileSource(e), o = [];
    o.push({ name: "source", type: "urlinput", filetype: r ? void 0 : "media", label: "Source" }), ul.hasDimensions(e) && o.push({ type: "sizeinput", name: "dimensions", label: "Constrain proportions", constrain: !0 }), o.push({ name: "poster", type: "urlinput", filetype: l ? void 0 : "image", label: "Media poster (Image URL)" }), o.push({ name: "embed", type: "textarea", label: "Generated Embed:", disabled: !0 });
    const a = { type: "panel", items: o };
    e.windowManager.open({ title: "Insert/Edit Media (oEmbed)", size: "normal", body: a, buttons: [{ type: "cancel", name: "cancel", text: "Cancel" }, { type: "submit", name: "save", text: "Save", primary: !0 }], onSubmit: async (c) => {
      const u = Er.unwrap(c.getData());
      await HG(s, u, e), c.close();
    }, onChange: async (c, u) => {
      try {
        switch (u.name) {
          case "source":
            await LG(s, c, e);
            break;
          case "embed":
            BG(c, e);
            break;
          case "dimensions":
          case "poster":
            qG(c, u.name);
        }
        s = Er.unwrap(c.getData());
      } catch (d) {
        console.log(d);
      }
    }, initialData: n }, void 0);
  }
  static unwrap(e, t) {
    const s = t ? RG(t, e).getOr({}) : {}, n = jG(e, s, t);
    return { ...n("source"), ...n("poster"), ...n("embed"), ...FG(e, s) };
  }
}, f(Er, "_"), Er);
const i7 = ["width", "height"], yO = /* @__PURE__ */ f((i, e, t) => {
  if (typeof i.url == "string" && i.url.trim().length > 0) {
    const s = i.html, n = { ...l7(t, s), source: i.url, embed: s, poster: i.poster };
    e.setData(x1(n));
  }
}, "O$1"), RG = /* @__PURE__ */ f((i, e) => Cn(e, i).bind((t) => Cn(t, "meta")), "P$1"), FG = /* @__PURE__ */ f((i, e) => {
  const t = {};
  return Cn(i, "dimensions").each((s) => {
    for (const n of i7)
      Cn(e, n).orThunk(() => Cn(s, n)).each((l) => t[n] = l);
  }), t;
}, "D$1"), NG = /* @__PURE__ */ f((i) => {
  const e = i.selection.getNode(), t = GG(e) ? i.serializer.serialize(e, { selection: !0 }) : "";
  return { embed: t, ...n7(t) };
}, "M$1"), jG = /* @__PURE__ */ f((i, e, t) => (s) => {
  const n = /* @__PURE__ */ f(() => Cn(i, s), "s"), l = /* @__PURE__ */ f(() => Cn(e, s), "o"), r = /* @__PURE__ */ f((o) => Cn(o, "value").bind((a) => a.length > 0 ? cl.some(a) : cl.none()), "n");
  return { [s]: (s === t ? n().bind((o) => typeof o == "object" ? r(o).orThunk(l) : l().orThunk(() => cl.from(o))) : l().orThunk(() => n().bind((o) => typeof o == "object" ? r(o) : cl.from(o)))).getOr("") };
}, "S$1"), LG = /* @__PURE__ */ f(async (i, e, t) => {
  const s = Q1.unwrap(e.getData(), "source");
  if (i.source !== s.source) {
    yO({ url: s.source, html: "", poster: "" }, e, t);
    const n = await jb.getEmbedHtml(t, s);
    n && yO(n, e, t);
  }
}, "$$1"), BG = /* @__PURE__ */ f((i, e) => {
  const t = Q1.unwrap(i.getData()), s = l7(e, t.embed);
  i.setData(x1(s));
}, "k$1"), qG = /* @__PURE__ */ f((i, e) => {
  const t = Q1.unwrap(i.getData(), e), s = t.embed ? j5(t.embed, t, !1) : "";
  i.setData(x1({ ...t, embed: s }));
}, "N$1"), vO = /* @__PURE__ */ f((i, e, t) => {
  const s = i.dom.select("*[data-mce-object]");
  Nb.setPoster(t.poster), i.insertContent(e), Nb.setPoster(void 0), zG(i, s).dataset.oembedPoster = t.poster, i.nodeChanged();
}, "E$1"), GG = /* @__PURE__ */ f((i) => i.getAttribute("data-mce-object"), "R$1"), zG = /* @__PURE__ */ f((i, e) => {
  const t = i.dom.select("*[data-mce-object]");
  for (let s = 0; s < e.length; s++)
    for (let n = t.length - 1; n >= 0; n--)
      e[s] === t[n] && t.splice(n, 1);
  return i.selection.select(t[0]), t[0];
}, "T$1"), l7 = /* @__PURE__ */ f((i, e) => n7(e), "H$1"), HG = /* @__PURE__ */ f(async (i, e, t) => {
  if (e.embed = j5(e.embed, e), e.embed && (i.source === e.source || jb.isCached(e.source)))
    vO(t, e.embed, e);
  else {
    const s = await jb.getEmbedHtml(t, e);
    s && vO(t, s.html, e);
  }
}, "U$1"), x1 = /* @__PURE__ */ f((i) => {
  const e = { ...i, source: { value: Cn(i, "source").getOr("") }, poster: { value: Cn(i, "poster").getOr("") } };
  for (const t of i7)
    Cn(i, t).each((s) => {
      const n = e.dimensions || {};
      n[t] = s, e.dimensions = n;
    });
  return e;
}, "F$1"), i$ = class i$ {
  constructor(e) {
    e.addCommand("typhonjsOembed", () => Q1.showDialog(e)), (class {
      static register(t) {
        t.ui.registry.addToggleButton("typhonjs-oembed", { tooltip: "Insert/edit media", icon: "embed", onAction: () => {
          t.execCommand("typhonjsOembed");
        }, onSetup: DG(t, ["img[data-mce-object]", "span[data-mce-object]"]) }), t.ui.registry.addMenuItem("typhonjs-oembed", { icon: "embed", text: "Media...", onAction: () => {
          t.execCommand("typhonjsOembed");
        } });
      }
    }).register(e), (class {
      static setup(t) {
        t.on("ResolveName", (s) => {
          let n;
          s.target.nodeType === 1 && (n = s.target.getAttribute("data-mce-object")) && (s.name = n);
        });
      }
    }).setup(e), (class {
      static setup(t) {
        t.on("preInit", () => {
          t.parser.addNodeFilter("iframe,video,audio,object,embed", Nb.placeHolderConverter(t)), t.serializer.addAttributeFilter("data-mce-object", (s, n) => {
            let l, r, o, a, c, u, d, p, m = s.length;
            for (; m--; )
              if (l = s[m], l.parent) {
                for (d = l.attr(n), r = new tinymce.html.Node(d, 1), d !== "audio" && (p = l.attr("class"), p && p.indexOf("mce-preview-object") !== -1 ? r.attr({ width: l.firstChild.attr("width"), height: l.firstChild.attr("height") }) : r.attr({ width: l.attr("width"), height: l.attr("height") })), r.attr({ style: l.attr("style") }), a = l.attributes, o = a.length; o--; ) {
                  const g = a[o].name;
                  g.indexOf("data-mce-p-") === 0 && r.attr(g.substr(11), a[o].value);
                }
                c = l.attr("data-mce-html"), c && (u = new tinymce.html.Node("#text", 3), u.raw = !0, u.value = e7(t, unescape(c)), r.append(u)), l.replace(r);
              }
          });
        });
      }
    }).setup(e), (class {
      static setup(t) {
        t.on("click keyup touchend", () => {
          const s = t.selection.getNode();
          s && t.dom.hasClass(s, "mce-preview-object") && t.dom.getAttrib(s, "data-mce-selected") && s.setAttribute("data-mce-selected", "2");
        }), t.on("ObjectSelected", (s) => {
          s.target.getAttribute("data-mce-object") === "script" && s.preventDefault();
        }), t.on("ObjectResized", (s) => {
          const n = s.target;
          let l;
          n.getAttribute("data-mce-object") && (l = n.getAttribute("data-mce-html"), l && (l = unescape(l), n.setAttribute("data-mce-html", escape(j5(l, { width: String(s.width), height: String(s.height) })))));
        });
      }
    }).setup(e);
  }
  getMetadata() {
    return { name: "TyphonJS oEmbed", url: "https://github.com/typhonjs-tinymce/oembed" };
  }
};
f(i$, "L");
let Lb = i$;
const UG = /* @__PURE__ */ f(() => {
  tinymce.PluginManager.add("typhonjs-oembed", Lb);
}, "z$1"), l$ = class l$ {
  static getDisableFilePoster(e) {
    return e.getParam("oembed_disable_file_poster", !1);
  }
  static getDisableFileSource(e) {
    return e.getParam("oembed_disable_file_source", !1);
  }
  static getMediaHeight(e) {
    return e.getParam("oembed_default_height", 288);
  }
  static getMediaWidth(e) {
    return e.getParam("oembed_default_width", 512);
  }
  static getUrlResolver(e) {
    return e.getParam("oembed_url_resolver");
  }
  static hasDimensions(e) {
    return e.getParam("oembed_dimensions", !0);
  }
  static hasLiveEmbeds(e) {
    return e.getParam("oembed_live_embeds", !0);
  }
  static hasPoster(e) {
    return e.getParam("oembed_poster", !0);
  }
  static shouldFilterHtml(e) {
    return e.getParam("oembed_filter_html", !0);
  }
};
f(l$, "e");
let xn = l$;
const r7 = /* @__PURE__ */ f((i, e) => {
  if (xn.shouldFilterHtml(i) === !1)
    return e;
  const t = tinymce.html.Writer();
  let s;
  return tinymce.html.SaxParser({ validate: !1, allow_conditional_comments: !1, comment: (n) => {
    s || t.comment(n);
  }, cdata: (n) => {
    s || t.cdata(n);
  }, text: (n, l) => {
    s || t.text(n, l);
  }, start: (n, l, r) => {
    if (s = !0, n !== "script" && n !== "noscript" && n !== "svg") {
      for (let o = l.length - 1; o >= 0; o--) {
        const a = l[o].name;
        a.indexOf("on") === 0 && (delete l.map[a], l.splice(o, 1)), a === "style" && (l[o].value = i.dom.serializeStyle(i.dom.parseStyle(l[o].value), n));
      }
      t.start(n, l, r), s = !1;
    }
  }, end: (n) => {
    s || t.end(n);
  } }, tinymce.html.Schema({})).parse(e), t.getContent();
}, "t");
let bc;
const r$ = class r$ {
  static placeHolderConverter(e) {
    return (t) => {
      let s, n = t.length;
      for (; n--; )
        s = t[n], s.parent && !s.parent.attr("data-mce-object") && (KG(s) && xn.hasLiveEmbeds(e) ? wO(s) || s.replace(VG(e, s)) : wO(s) || s.replace(WG(e, s)));
    };
  }
  static setPoster(e) {
    bc = e;
  }
};
f(r$, "a");
let _c = r$;
const VG = /* @__PURE__ */ f((i, e) => {
  const t = e.name;
  bc !== void 0 && e.attr("data-oembed-poster", bc);
  const s = new tinymce.html.Node("span", 1);
  s.attr({ contentEditable: "false", style: e.attr("style"), "data-mce-object": t, class: `mce-preview-object mce-object-${t}` }), o7(i, e, s);
  const n = i.dom.parseStyle(e.attr("style")), l = new tinymce.html.Node(t, 1);
  if (a7(e, l, n), l.attr({ src: e.attr("src"), style: e.attr("style"), class: e.attr("class") }), t === "iframe")
    l.attr({ allowfullscreen: e.attr("allowfullscreen"), frameborder: "0" });
  else {
    const o = ["controls", "crossorigin", "currentTime", "loop", "muted", "poster", "preload"];
    for (const c of o)
      l.attr(c, e.attr(c));
    const a = s.attr("data-mce-html");
    a != null && ((c, u, d, p) => {
      const m = tinymce.html.DomParser({ forced_root_block: !1, validate: !1 }, c.schema).parse(p, { context: u });
      for (; m.firstChild; )
        d.append(m.firstChild);
    })(i, t, l, a);
  }
  const r = new tinymce.html.Node("span", 1);
  return r.attr("class", "mce-shim"), s.append(l), s.append(r), s;
}, "s"), WG = /* @__PURE__ */ f((i, e) => {
  const t = e.name;
  bc !== void 0 && e.attr("data-oembed-poster", bc);
  const s = new tinymce.html.Node("img", 1);
  s.shortEnded = !0, o7(i, e, s);
  const n = e.attr("data-oembed-poster");
  return a7(e, s, {}), s.attr({ style: e.attr("style"), src: n || "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", "data-mce-object": t, class: `mce-object mce-object-${t}` }), s;
}, "o"), kO = /* @__PURE__ */ f((i, e, t, s = null) => {
  const n = i.attr(t);
  return n ?? (Object.hasOwnProperty.call(e, t) ? null : s);
}, "n"), KG = /* @__PURE__ */ f((i) => {
  const e = i.name;
  return e === "iframe" || e === "video" || e === "audio";
}, "i"), YG = /* @__PURE__ */ f((i) => {
  const e = i.attr("class");
  return e && /\btiny-pageembed\b/.test(e);
}, "c"), wO = /* @__PURE__ */ f((i) => {
  for (; i = i.parent; )
    if (YG(i))
      return !0;
  return !1;
}, "l"), o7 = /* @__PURE__ */ f((i, e, t) => {
  const s = e.attributes;
  let n = s.length;
  for (; n--; ) {
    const r = s[n].name;
    let o = s[n].value;
    r !== "width" && r !== "height" && r !== "style" && (r !== "data" && r !== "src" || (o = i.convertURL(o, r)), t.attr(`data-mce-p-${r}`, o));
  }
  const l = e.firstChild && e.firstChild.value;
  l && (t.attr("data-mce-html", escape(r7(i, l))), t.firstChild = null);
}, "m"), a7 = /* @__PURE__ */ f((i, e, t) => {
  const s = e.name === "img" || i.name === "video", n = s ? "300" : null, l = i.name === "audio" ? "30" : "150", r = s ? l : null;
  e.attr({ width: kO(i, t, "width", n), height: kO(i, t, "height", r) });
}, "d"), Eb = ["source"], L5 = /* @__PURE__ */ f((i, e, t, s) => {
  let n = 0;
  const l = tinymce.html.DomParser(s);
  l.addNodeFilter("source", (o) => o.length);
  const r = l.parse(i);
  for (let o = r; o; o = o.walk())
    if (o.type === 1) {
      const a = o.name;
      switch (a) {
        case "video":
        case "object":
        case "embed":
        case "img":
        case "iframe":
          e.height !== void 0 && e.width !== void 0 && (o.attr("width", e.width), o.attr("height", e.height));
      }
      if (t)
        switch (a) {
          case "video":
            o.attr("poster", e.poster), o.attr("src", null);
            break;
          case "iframe":
            o.attr("src", e.source);
            break;
          case "source":
            if (n < 2 && (o.attr("src", e[Eb[n]]), o.attr("type", e[Eb[n] + "mime"] || null), !e[Eb[n]])) {
              o.remove();
              continue;
            }
            n++;
            break;
          case "img":
            e.poster || o.remove();
        }
    }
  return tinymce.html.Serializer({}, s).serialize(r);
}, "h"), XG = /* @__PURE__ */ f((i, e) => (t) => i.selection.selectorChangedWithUnbind(e.join(","), t.setActive).unbind, "p"), kn = class kn {
  constructor(e, t) {
    this.tag = e, this.value = t;
  }
  static some(e) {
    return new kn(!0, e);
  }
  static none() {
    return kn.singletonNone;
  }
  fold(e, t) {
    return this.tag ? t(this.value) : e();
  }
  isSome() {
    return this.tag;
  }
  isNone() {
    return !this.tag;
  }
  map(e) {
    return this.tag ? kn.some(e(this.value)) : kn.none();
  }
  bind(e) {
    return this.tag ? e(this.value) : kn.none();
  }
  exists(e) {
    return this.tag && e(this.value);
  }
  forall(e) {
    return !this.tag || e(this.value);
  }
  filter(e) {
    return !this.tag || e(this.value) ? this : kn.none();
  }
  getOr(e) {
    return this.tag ? this.value : e;
  }
  or(e) {
    return this.tag ? this : e;
  }
  getOrThunk(e) {
    return this.tag ? this.value : e();
  }
  orThunk(e) {
    return this.tag ? this : e();
  }
  getOrDie(e) {
    if (this.tag)
      return this.value;
    throw new Error(e ?? "Called getOrDie on None");
  }
  static from(e) {
    return e == null ? kn.none() : kn.some(e);
  }
  getOrNull() {
    return this.tag ? this.value : null;
  }
  getOrUndefined() {
    return this.value;
  }
  each(e) {
    this.tag && e(this.value);
  }
  toArray() {
    return this.tag ? [this.value] : [];
  }
  toString() {
    return this.tag ? `some(${this.value})` : "none()";
  }
};
f(kn, "b");
let Xn = kn;
Xn.singletonNone = new Xn(!1);
const JG = Object.hasOwnProperty, On = /* @__PURE__ */ f((i, e) => ZG(i, e) ? Xn.from(i[e]) : Xn.none(), "f"), ZG = /* @__PURE__ */ f((i, e) => JG.call(i, e), "y"), c7 = /* @__PURE__ */ f((i, e) => {
  let t = {};
  for (let s = tinymce.html.DomParser({ validate: !1, forced_root_block: !1 }, e).parse(i); s; s = s.walk())
    if (s.type === 1) {
      const n = s.name;
      t.source || n !== "param" || (t.source = s.attributes.map.movie), n !== "iframe" && n !== "object" && n !== "embed" && n !== "video" && n !== "audio" || (t.type || (t.type = n), t = Object.assign({}, s.attributes.map, t)), n === "source" && (t.source || (t.source = s.attr("src"))), n !== "img" || t.poster || (t.poster = s.attr("src")), s.attributes.map["data-oembed-poster"] !== void 0 && (t.poster = s.attributes.map["data-oembed-poster"]);
    }
  return t.source = t.source || t.src || t.data, t.poster = t.poster || "", t;
}, "v"), jf = /* @__PURE__ */ new Map(), QG = [{ name: "Vimeo", regex: /^(https:\/\/vimeo.com\/(.*)|https:\/\/vimeo.com\/album\/(.*)\/video\/(.*)|https:\/\/vimeo.com\/channels\/(.*)\/(.*)|https:\/\/vimeo.com\/groups\/(.*)\/videos\/(.*)|https:\/\/vimeo.com\/ondemand\/(.*)\/(.*)|https:\/\/player.vimeo.com\/video\/(.*))/, url: (i, e, t) => `https://vimeo.com/api/oembed.json?url=${i}&maxwidth=${e}&maxheight=${t}` }, { name: "YouTube", regex: /^(https:\/\/(.*).youtube.com\/watch(.*)|https:\/\/(.*).youtube.com\/v\/(.*)|https:\/\/youtu.be\/(.*)|https:\/\/(.*).youtube.com\/playlist?list=(.*))/, url: (i, e, t) => `https://www.youtube.com/oembed?url=${i}&format=json&maxwidth=${e}&maxheight=${t}` }], o$ = class o$ {
  static async getEmbedHtml(e, t) {
    let s;
    if (jf.has(t.source))
      return jf.get(t.source);
    const n = xn.getUrlResolver(e);
    if (n)
      try {
        const l = await n({ url: t.source });
        s = { url: t.source, html: l.html, poster: l.poster };
      } catch (l) {
        const r = l.msg || l.message || "Unknown error.";
        return void e.notificationManager.open({ type: "error", text: `Media embed error: ${r}` });
      }
    else {
      let l, r;
      const o = xn.getMediaWidth(e), a = xn.getMediaHeight(e);
      for (const d of QG)
        d.regex.exec(t.source) && (r = d.url(t.source, o, a), l = d.name);
      if (r === void 0)
        return void e.notificationManager.open({ type: "error", text: "Media embed error: URL did not match any providers available." });
      const c = await window.fetch(r);
      if (!c || c.status !== 200)
        return void e.notificationManager.open({ type: "error", text: `Media embed error: Could not fetch ${l} embed URL.` });
      const u = await c.json();
      if (u.html === void 0) {
        const d = u.error ? u.error : `Could not fetch ${l} embed URL.`;
        return void e.notificationManager.open({ type: "error", text: `Media embed error: ${d}` });
      }
      s = { url: t.source, html: u.html, poster: u.thumbnail_url };
    }
    return jf.set(t.source, s), s;
  }
  static isCached(e) {
    return jf.has(e);
  }
};
f(o$, "j");
let yc = o$;
const lc = class lc {
  static showDialog(e) {
    const t = tz(e);
    let s = t;
    const n = eb(t), l = xn.getDisableFilePoster(e), r = xn.getDisableFileSource(e), o = [];
    o.push({ name: "source", type: "urlinput", filetype: r ? void 0 : "media", label: "Source" }), xn.hasDimensions(e) && o.push({ type: "sizeinput", name: "dimensions", label: "Constrain proportions", constrain: !0 }), o.push({ name: "poster", type: "urlinput", filetype: l ? void 0 : "image", label: "Media poster (Image URL)" }), o.push({ name: "embed", type: "textarea", label: "Generated Embed:", enabled: !1 });
    const a = { type: "panel", items: o };
    e.windowManager.open({ title: "Insert/Edit Media (oEmbed)", size: "normal", body: a, buttons: [{ type: "cancel", name: "cancel", text: "Cancel" }, { type: "submit", name: "save", text: "Save", primary: !0 }], onSubmit: async (c) => {
      const u = lc.unwrap(c.getData());
      await az(s, u, e), c.close();
    }, onChange: async (c, u) => {
      try {
        switch (u.name) {
          case "source":
            await nz(s, c, e);
            break;
          case "embed":
            iz(c, e);
            break;
          case "dimensions":
          case "poster":
            lz(c, u.name);
        }
        s = lc.unwrap(c.getData());
      } catch (d) {
        console.log(d);
      }
    }, initialData: n }, void 0);
  }
  static unwrap(e, t) {
    const s = t ? xG(t, e).getOr({}) : {}, n = sz(e, s, t);
    return { ...n("source"), ...n("poster"), ...n("embed"), ...ez(e, s) };
  }
};
f(lc, "x");
let aa = lc;
const u7 = ["width", "height"], $O = /* @__PURE__ */ f((i, e, t) => {
  if (typeof i.url == "string" && i.url.trim().length > 0) {
    const s = i.html, n = { ...f7(t, s), source: i.url, embed: s, poster: i.poster };
    e.setData(eb(n));
  }
}, "_"), xG = /* @__PURE__ */ f((i, e) => On(e, i).bind((t) => On(t, "meta")), "D"), ez = /* @__PURE__ */ f((i, e) => {
  const t = {};
  return On(i, "dimensions").each((s) => {
    for (const n of u7)
      On(e, n).orThunk(() => On(s, n)).each((l) => t[n] = l);
  }), t;
}, "O"), tz = /* @__PURE__ */ f((i) => {
  const e = i.selection.getNode(), t = rz(e) ? i.serializer.serialize(e, { selection: !0 }) : "";
  return { embed: t, ...c7(t) };
}, "P"), sz = /* @__PURE__ */ f((i, e, t) => (s) => {
  const n = /* @__PURE__ */ f(() => On(i, s), "s"), l = /* @__PURE__ */ f(() => On(e, s), "o"), r = /* @__PURE__ */ f((o) => On(o, "value").bind((a) => a.length > 0 ? Xn.some(a) : Xn.none()), "n");
  return { [s]: (s === t ? n().bind((o) => typeof o == "object" ? r(o).orThunk(l) : l().orThunk(() => Xn.from(o))) : l().orThunk(() => n().bind((o) => typeof o == "object" ? r(o) : Xn.from(o)))).getOr("") };
}, "M"), nz = /* @__PURE__ */ f(async (i, e, t) => {
  const s = aa.unwrap(e.getData(), "source");
  if (i.source !== s.source) {
    $O({ url: s.source, html: "", poster: "" }, e, t);
    const n = await yc.getEmbedHtml(t, s);
    n && $O(n, e, t);
  }
}, "k"), iz = /* @__PURE__ */ f((i, e) => {
  const t = aa.unwrap(i.getData()), s = f7(e, t.embed);
  i.setData(eb(s));
}, "S"), lz = /* @__PURE__ */ f((i, e) => {
  const t = aa.unwrap(i.getData(), e), s = t.embed ? L5(t.embed, t, !1) : "";
  i.setData(eb({ ...t, embed: s }));
}, "N"), AO = /* @__PURE__ */ f((i, e, t) => {
  const s = i.dom.select("*[data-mce-object]");
  _c.setPoster(t.poster), i.insertContent(e), _c.setPoster(void 0), oz(i, s).dataset.oembedPoster = t.poster, i.nodeChanged();
}, "E"), rz = /* @__PURE__ */ f((i) => i.getAttribute("data-mce-object"), "$$2"), oz = /* @__PURE__ */ f((i, e) => {
  const t = i.dom.select("*[data-mce-object]");
  for (let s = 0; s < e.length; s++)
    for (let n = t.length - 1; n >= 0; n--)
      e[s] === t[n] && t.splice(n, 1);
  return i.selection.select(t[0]), t[0];
}, "R"), f7 = /* @__PURE__ */ f((i, e) => c7(e), "T"), az = /* @__PURE__ */ f(async (i, e, t) => {
  if (e.embed = L5(e.embed, e), e.embed && (i.source === e.source || yc.isCached(e.source)))
    AO(t, e.embed, e);
  else {
    const s = await yc.getEmbedHtml(t, e);
    s && AO(t, s.html, e);
  }
}, "H"), eb = /* @__PURE__ */ f((i) => {
  const e = { ...i, source: { value: On(i, "source").getOr("") }, poster: { value: On(i, "poster").getOr("") } };
  for (const t of u7)
    On(i, t).each((s) => {
      const n = e.dimensions || {};
      n[t] = s, e.dimensions = n;
    });
  return e;
}, "U"), a$ = class a$ {
  constructor(e) {
    e.addCommand("typhonjsOembed", () => aa.showDialog(e)), (class {
      static register(t) {
        t.ui.registry.addToggleButton("typhonjs-oembed", { tooltip: "Insert/edit media", icon: "embed", onAction: () => {
          t.execCommand("typhonjsOembed");
        }, onSetup: XG(t, ["img[data-mce-object]", "span[data-mce-object]"]) }), t.ui.registry.addMenuItem("typhonjs-oembed", { icon: "embed", text: "Media...", onAction: () => {
          t.execCommand("typhonjsOembed");
        } });
      }
    }).register(e), (class {
      static setup(t) {
        t.on("ResolveName", (s) => {
          let n;
          s.target.nodeType === 1 && (n = s.target.getAttribute("data-mce-object")) && (s.name = n);
        });
      }
    }).setup(e), (class {
      static setup(t) {
        t.on("preInit", () => {
          t.parser.addNodeFilter("iframe,video,audio,object,embed", _c.placeHolderConverter(t)), t.serializer.addAttributeFilter("data-mce-object", (s, n) => {
            let l, r, o, a, c, u, d, p, m = s.length;
            for (; m--; )
              if (l = s[m], l.parent) {
                for (d = l.attr(n), r = new tinymce.html.Node(d, 1), d !== "audio" && (p = l.attr("class"), p && p.indexOf("mce-preview-object") !== -1 ? r.attr({ width: l.firstChild.attr("width"), height: l.firstChild.attr("height") }) : r.attr({ width: l.attr("width"), height: l.attr("height") })), r.attr({ style: l.attr("style") }), a = l.attributes, o = a.length; o--; ) {
                  const g = a[o].name;
                  g.indexOf("data-mce-p-") === 0 && r.attr(g.substr(11), a[o].value);
                }
                c = l.attr("data-mce-html"), c && (u = new tinymce.html.Node("#text", 3), u.raw = !0, u.value = r7(t, unescape(c)), r.append(u)), l.replace(r);
              }
          });
        });
      }
    }).setup(e), (class {
      static setup(t) {
        t.on("click keyup touchend", () => {
          const s = t.selection.getNode();
          s && t.dom.hasClass(s, "mce-preview-object") && t.dom.getAttrib(s, "data-mce-selected") && s.setAttribute("data-mce-selected", "2");
        }), t.on("ObjectSelected", (s) => {
          s.target.getAttribute("data-mce-object") === "script" && s.preventDefault();
        }), t.on("ObjectResized", (s) => {
          const n = s.target;
          let l;
          n.getAttribute("data-mce-object") && (l = n.getAttribute("data-mce-html"), l && (l = unescape(l), n.setAttribute("data-mce-html", escape(L5(l, { width: String(s.width), height: String(s.height) })))));
        });
      }
    }).setup(e);
  }
  getMetadata() {
    return { name: "TyphonJS oEmbed", url: "https://github.com/typhonjs-tinymce/oembed" };
  }
};
f(a$, "z");
let Bb = a$;
const cz = /* @__PURE__ */ f(() => {
  tinymce.PluginManager.add("typhonjs-oembed", (i) => new Bb(i));
}, "F");
let EO = !1;
EO || (EO = !0, Hooks.once("init", async () => {
  var e;
  const i = !foundry.utils.isNewerVersion(10, game.version ?? ((e = game == null ? void 0 : game.data) == null ? void 0 : e.version));
  try {
    i ? cz() : UG();
  } catch {
    console.warn("TyphonJS Runtime Library warning: Failed to load TyphonJS oEmbed plugin.");
  }
}));
function SO(i, e, t) {
  typeof t.value == "object" && (t.value = Wr(t.value)), !t.enumerable || t.get || t.set || !t.configurable || !t.writable || e === "__proto__" ? Object.defineProperty(i, e, t) : i[e] = t.value;
}
f(SO, "set");
function Wr(i) {
  if (typeof i != "object")
    return i;
  var e = 0, t, s, n, l = Object.prototype.toString.call(i);
  if (l === "[object Object]" ? n = Object.create(i.__proto__ || null) : l === "[object Array]" ? n = Array(i.length) : l === "[object Set]" ? (n = /* @__PURE__ */ new Set(), i.forEach(function(r) {
    n.add(Wr(r));
  })) : l === "[object Map]" ? (n = /* @__PURE__ */ new Map(), i.forEach(function(r, o) {
    n.set(Wr(o), Wr(r));
  })) : l === "[object Date]" ? n = /* @__PURE__ */ new Date(+i) : l === "[object RegExp]" ? n = new RegExp(i.source, i.flags) : l === "[object DataView]" ? n = new i.constructor(Wr(i.buffer)) : l === "[object ArrayBuffer]" ? n = i.slice(0) : l.slice(-6) === "Array]" && (n = new i.constructor(i)), n) {
    for (s = Object.getOwnPropertySymbols(i); e < s.length; e++)
      SO(n, s[e], Object.getOwnPropertyDescriptor(i, s[e]));
    for (e = 0, s = Object.getOwnPropertyNames(i); e < s.length; e++)
      Object.hasOwnProperty.call(n, t = s[e]) && n[t] === i[t] || SO(n, t, Object.getOwnPropertyDescriptor(i, t));
  }
  return n || i;
}
f(Wr, "klona");
const qb = "[object Object]";
function Ii(i = {}, ...e) {
  if (Object.prototype.toString.call(i) !== qb)
    throw new TypeError("deepMerge error: 'target' is not an 'object'.");
  for (let t = 0; t < e.length; t++)
    if (Object.prototype.toString.call(e[t]) !== qb)
      throw new TypeError(`deepMerge error: 'sourceObj[${t}]' is not an 'object'.`);
  return m7(i, ...e);
}
f(Ii, "deepMerge");
function Lf(i, e) {
  if (typeof i != "object" || i === null || i === void 0)
    return !1;
  const t = Object.getOwnPropertyDescriptor(i, e);
  if (t !== void 0 && t.get !== void 0)
    return !0;
  for (let s = Object.getPrototypeOf(i); s; s = Object.getPrototypeOf(s)) {
    const n = Object.getOwnPropertyDescriptor(s, e);
    if (n !== void 0 && n.get !== void 0)
      return !0;
  }
  return !1;
}
f(Lf, "hasGetter");
function TO(i, e) {
  if (typeof i != "function")
    return !1;
  if (i === e)
    return !0;
  for (let t = Object.getPrototypeOf(i); t; t = Object.getPrototypeOf(t))
    if (t === e)
      return !0;
  return !1;
}
f(TO, "hasPrototype");
function vt(i) {
  return i == null || typeof i != "object" ? !1 : Symbol.iterator in i;
}
f(vt, "isIterable");
function ke(i) {
  return i !== null && typeof i == "object" && !Array.isArray(i);
}
f(ke, "isObject");
function d7(i) {
  if (Object.prototype.toString.call(i) !== qb)
    return !1;
  const e = Object.getPrototypeOf(i);
  return e === null || e === Object.prototype;
}
f(d7, "isPlainObject");
function _d(i, e, t) {
  if (typeof i != "object" || typeof e != "string")
    return t;
  const s = e.split(".");
  for (let n = 0; n < s.length; n++) {
    if (typeof i[s[n]] > "u" || i[s[n]] === null)
      return t;
    i = i[s[n]];
  }
  return i;
}
f(_d, "safeAccess");
function p7(i, e, t, s = "set", n = !0) {
  if (typeof i != "object")
    throw new TypeError("safeSet Error: 'data' is not an 'object'.");
  if (typeof e != "string")
    throw new TypeError("safeSet Error: 'accessor' is not a 'string'.");
  const l = e.split(".");
  for (let r = 0; r < l.length; r++) {
    if (Array.isArray(i)) {
      const o = +l[r];
      if (!Number.isInteger(o) || o < 0)
        return !1;
    }
    if (r === l.length - 1)
      switch (s) {
        case "add":
          i[l[r]] += t;
          break;
        case "div":
          i[l[r]] /= t;
          break;
        case "mult":
          i[l[r]] *= t;
          break;
        case "set":
          i[l[r]] = t;
          break;
        case "set-undefined":
          typeof i[l[r]] > "u" && (i[l[r]] = t);
          break;
        case "sub":
          i[l[r]] -= t;
          break;
      }
    else {
      if (n && typeof i[l[r]] > "u" && (i[l[r]] = {}), i[l[r]] === null || typeof i[l[r]] != "object")
        return !1;
      i = i[l[r]];
    }
  }
  return !0;
}
f(p7, "safeSet");
function m7(i = {}, ...e) {
  var t, s;
  for (let n = 0; n < e.length; n++) {
    const l = e[n];
    for (const r in l)
      if (Object.prototype.hasOwnProperty.call(l, r)) {
        if (r.startsWith("-=")) {
          delete i[r.slice(2)];
          continue;
        }
        i[r] = Object.prototype.hasOwnProperty.call(i, r) && ((t = i[r]) == null ? void 0 : t.constructor) === Object && ((s = l[r]) == null ? void 0 : s.constructor) === Object ? m7({}, i[r], l[r]) : l[r];
      }
  }
  return i;
}
f(m7, "_deepMerge");
function K(i, e) {
  const t = ke(e) ? globalThis.game.i18n.format(i, e) : globalThis.game.i18n.localize(i);
  return t !== void 0 ? t : "";
}
f(K, "localize");
const c$ = class c$ extends TokenHUD {
  /** @override */
  getData() {
    var n, l, r, o;
    const e = foundry.utils.mergeObject(super.getData(), {
      AC: ((o = (r = (l = (n = this.object.actor) == null ? void 0 : n.system) == null ? void 0 : l.attributes) == null ? void 0 : r.ac) == null ? void 0 : o.value) ?? 10
    }), [t, s] = Object.entries(e.statusEffects).reduce((a, [c, u]) => (u.id.includes("generic") ? a[0][c] = u : a[1][c] = u, a), [{}, {}]);
    return e.statusEffects = s, e.genericConditions = t, e;
  }
  /** @override */
  get template() {
    return "systems/a5e/templates/hud/token-hud.hbs";
  }
  /** @override */
  activateListeners(e) {
    super.activateListeners(e), e.find(".clear-all-conditions").click(this._clearAllConditions.bind(this));
  }
  /** @override */
  _getStatusEffectChoices() {
    return CONFIG.statusEffects = CONFIG.statusEffects.sort((e, t) => {
      const s = e.label !== void 0 ? K(e.label) : e.id || e, n = t.label !== void 0 ? K(t.label) : t.id || t;
      return s > n ? 1 : s < n ? -1 : 0;
    }), super._getStatusEffectChoices();
  }
  /**
   * Removes all conditions on the current object
   * @param {*} event
   */
  async _clearAllConditions(e) {
    e.preventDefault(), e.stopPropagation();
    const t = [], s = CONFIG.statusEffects;
    for (const n of s) {
      const l = this.object.actor.effects.reduce((r, o) => (o.statuses.size === 1 && o.statuses.has(n.id) && r.push(o.id), r), []);
      l.length && t.push(...l);
    }
    this.object.actor.deleteEmbeddedDocuments("ActiveEffect", t), this.object.actor.update({
      "system.attributes.fatigue": 0,
      "system.attributes.strife": 0,
      "flags.a5e.autoApplyFSConditions": !1
    });
  }
  /**
   * Destroy svelte components when the HUD is closed
   */
  clear() {
    var e;
    super.clear(), (e = this == null ? void 0 : this._svelteComponent) != null && e.$destroy && (this._svelteComponent.$destroy(), this._svelteComponent = null);
  }
};
f(c$, "TokenHUDA5e");
let Gb = c$;
function uz(i, e = {}) {
  if (!e.gridSpaces)
    return BaseGrid.prototype.measureDistances.call(this, i, e);
  let t = 0;
  const s = canvas.dimensions, n = this.parent.diagonalRule, l = canvas.scene.grid.distance;
  return i.map((r) => {
    const { ray: o } = r, a = Math.abs(Math.ceil(o.dx / s.size)), c = Math.abs(Math.ceil(o.dy / s.size)), u = Math.min(a, c), d = Math.abs(c - a);
    if (t += u, n === "euclidean")
      return Math.round(Math.hypot(a, c) * l);
    if (n === "5105") {
      const p = Math.floor(t / 2) - Math.floor((t - u) / 2);
      return (p * 2 + (u - p) + d) * canvas.dimensions.distance;
    }
    return (u + d) * l;
  });
}
f(uz, "measureDistances");
function fz() {
  canvas.grid.diagonalRule = game.settings.get("a5e", "diagonalRule"), SquareGrid.prototype.measureDistances = uz, game.canvas.hud.token = new Gb();
}
f(fz, "canvasInit");
function ee() {
}
f(ee, "noop");
const ei = /* @__PURE__ */ f((i) => i, "identity");
function fs(i, e) {
  for (const t in e)
    i[t] = e[t];
  return (
    /** @type {T & S} */
    i
  );
}
f(fs, "assign");
function dz(i) {
  return !!i && (typeof i == "object" || typeof i == "function") && typeof /** @type {any} */
  i.then == "function";
}
f(dz, "is_promise");
function h7(i) {
  return i();
}
f(h7, "run");
function CO() {
  return /* @__PURE__ */ Object.create(null);
}
f(CO, "blank_object");
function Ne(i) {
  i.forEach(h7);
}
f(Ne, "run_all");
function $t(i) {
  return typeof i == "function";
}
f($t, "is_function");
function ne(i, e) {
  return i != i ? e == e : i !== e || i && typeof i == "object" || typeof i == "function";
}
f(ne, "safe_not_equal");
let Bf;
function ze(i, e) {
  return i === e ? !0 : (Bf || (Bf = document.createElement("a")), Bf.href = e, i === Bf.href);
}
f(ze, "src_url_equal");
function pz(i) {
  return Object.keys(i).length === 0;
}
f(pz, "is_empty");
function Et(i, ...e) {
  if (i == null) {
    for (const s of e)
      s(void 0);
    return ee;
  }
  const t = i.subscribe(...e);
  return t.unsubscribe ? () => t.unsubscribe() : t;
}
f(Et, "subscribe");
function fn(i) {
  let e;
  return Et(i, (t) => e = t)(), e;
}
f(fn, "get_store_value");
function pe(i, e, t) {
  i.$$.on_destroy.push(Et(e, t));
}
f(pe, "component_subscribe");
function Pt(i, e, t, s) {
  if (i) {
    const n = g7(i, e, t, s);
    return i[0](n);
  }
}
f(Pt, "create_slot");
function g7(i, e, t, s) {
  return i[1] && s ? fs(t.ctx.slice(), i[1](s(e))) : t.ctx;
}
f(g7, "get_slot_context");
function Mt(i, e, t, s) {
  if (i[2] && s) {
    const n = i[2](s(t));
    if (e.dirty === void 0)
      return n;
    if (typeof n == "object") {
      const l = [], r = Math.max(e.dirty.length, n.length);
      for (let o = 0; o < r; o += 1)
        l[o] = e.dirty[o] | n[o];
      return l;
    }
    return e.dirty | n;
  }
  return e.dirty;
}
f(Mt, "get_slot_changes");
function Rt(i, e, t, s, n, l) {
  if (n) {
    const r = g7(e, t, s, l);
    i.p(r, n);
  }
}
f(Rt, "update_slot_base");
function Ft(i) {
  if (i.ctx.length > 32) {
    const e = [], t = i.ctx.length / 32;
    for (let s = 0; s < t; s++)
      e[s] = -1;
    return e;
  }
  return -1;
}
f(Ft, "get_all_dirty_from_scope");
function b7(i) {
  const e = {};
  for (const t in i)
    e[t] = !0;
  return e;
}
f(b7, "compute_slots");
function ni(i) {
  return i ?? "";
}
f(ni, "null_to_empty");
function fl(i, e, t) {
  return i.set(t), e;
}
f(fl, "set_store_value");
function At(i) {
  return i && $t(i.destroy) ? i.destroy : ee;
}
f(At, "action_destroyer");
const _7 = typeof window < "u";
let vc = _7 ? () => window.performance.now() : () => Date.now(), B5 = _7 ? (i) => requestAnimationFrame(i) : ee;
const xr = /* @__PURE__ */ new Set();
function y7(i) {
  xr.forEach((e) => {
    e.c(i) || (xr.delete(e), e.f());
  }), xr.size !== 0 && B5(y7);
}
f(y7, "run_tasks");
function tb(i) {
  let e;
  return xr.size === 0 && B5(y7), {
    promise: new Promise((t) => {
      xr.add(e = { c: i, f: t });
    }),
    abort() {
      xr.delete(e);
    }
  };
}
f(tb, "loop");
const q5 = typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);
function A(i, e) {
  i.appendChild(e);
}
f(A, "append");
function v7(i) {
  if (!i)
    return document;
  const e = i.getRootNode ? i.getRootNode() : i.ownerDocument;
  return e && /** @type {ShadowRoot} */
  e.host ? (
    /** @type {ShadowRoot} */
    e
  ) : i.ownerDocument;
}
f(v7, "get_root_for_style");
function mz(i) {
  const e = E("style");
  return e.textContent = "/* empty */", hz(v7(i), e), e.sheet;
}
f(mz, "append_empty_stylesheet");
function hz(i, e) {
  return A(
    /** @type {Document} */
    i.head || i,
    e
  ), e.sheet;
}
f(hz, "append_stylesheet");
function T(i, e, t) {
  i.insertBefore(e, t || null);
}
f(T, "insert");
function S(i) {
  i.parentNode && i.parentNode.removeChild(i);
}
f(S, "detach");
function Le(i, e) {
  for (let t = 0; t < i.length; t += 1)
    i[t] && i[t].d(e);
}
f(Le, "destroy_each");
function E(i) {
  return document.createElement(i);
}
f(E, "element");
function pn(i) {
  return document.createElementNS("http://www.w3.org/2000/svg", i);
}
f(pn, "svg_element");
function x(i) {
  return document.createTextNode(i);
}
f(x, "text");
function R() {
  return x(" ");
}
f(R, "space");
function $e() {
  return x("");
}
f($e, "empty");
function V(i, e, t, s) {
  return i.addEventListener(e, t, s), () => i.removeEventListener(e, t, s);
}
f(V, "listen");
function tt(i) {
  return function(e) {
    return e.preventDefault(), i.call(this, e);
  };
}
f(tt, "prevent_default");
function We(i) {
  return function(e) {
    return e.stopPropagation(), i.call(this, e);
  };
}
f(We, "stop_propagation");
function b(i, e, t) {
  t == null ? i.removeAttribute(e) : i.getAttribute(e) !== t && i.setAttribute(e, t);
}
f(b, "attr");
const gz = ["width", "height"];
function yd(i, e) {
  const t = Object.getOwnPropertyDescriptors(i.__proto__);
  for (const s in e)
    e[s] == null ? i.removeAttribute(s) : s === "style" ? i.style.cssText = e[s] : s === "__value" ? i.value = i[s] = e[s] : t[s] && t[s].set && gz.indexOf(s) === -1 ? i[s] = e[s] : b(i, s, e[s]);
}
f(yd, "set_attributes");
function ii(i) {
  return i === "" ? null : +i;
}
f(ii, "to_number");
function bz(i) {
  return Array.from(i.childNodes);
}
f(bz, "children");
function _e(i, e) {
  e = "" + e, i.data !== e && (i.data = /** @type {string} */
  e);
}
f(_e, "set_data");
function qe(i, e) {
  i.value = e ?? "";
}
f(qe, "set_input_value");
function z(i, e, t, s) {
  t == null ? i.style.removeProperty(e) : i.style.setProperty(e, t, s ? "important" : "");
}
f(z, "set_style");
function ds(i, e, t) {
  for (let s = 0; s < i.options.length; s += 1) {
    const n = i.options[s];
    if (n.__value === e) {
      n.selected = !0;
      return;
    }
  }
  (!t || e !== void 0) && (i.selectedIndex = -1);
}
f(ds, "select_option");
function ca(i) {
  const e = i.querySelector(":checked");
  return e && e.__value;
}
f(ca, "select_value");
let qf;
function _z() {
  if (qf === void 0) {
    qf = !1;
    try {
      typeof window < "u" && window.parent && window.parent.document;
    } catch {
      qf = !0;
    }
  }
  return qf;
}
f(_z, "is_crossorigin");
function yz(i, e) {
  getComputedStyle(i).position === "static" && (i.style.position = "relative");
  const s = E("iframe");
  s.setAttribute(
    "style",
    "display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;"
  ), s.setAttribute("aria-hidden", "true"), s.tabIndex = -1;
  const n = _z();
  let l;
  return n ? (s.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>", l = V(
    window,
    "message",
    /** @param {MessageEvent} event */
    (r) => {
      r.source === s.contentWindow && e();
    }
  )) : (s.src = "about:blank", s.onload = () => {
    l = V(s.contentWindow, "resize", e), e();
  }), A(i, s), () => {
    (n || l && s.contentWindow) && l(), S(s);
  };
}
f(yz, "add_iframe_resize_listener");
function Q(i, e, t) {
  i.classList.toggle(e, !!t);
}
f(Q, "toggle_class");
function k7(i, e, { bubbles: t = !1, cancelable: s = !1 } = {}) {
  return new CustomEvent(i, { detail: e, bubbles: t, cancelable: s });
}
f(k7, "custom_event");
const u$ = class u$ {
  constructor(e = !1) {
    /**
     * @private
     * @default false
     */
    Ge(this, "is_svg", !1);
    /** parent for creating node */
    Ge(this, "e");
    /** html tag nodes */
    Ge(this, "n");
    /** target */
    Ge(this, "t");
    /** anchor */
    Ge(this, "a");
    this.is_svg = e, this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(e) {
    this.h(e);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(e, t, s = null) {
    this.e || (this.is_svg ? this.e = pn(
      /** @type {keyof SVGElementTagNameMap} */
      t.nodeName
    ) : this.e = E(
      /** @type {keyof HTMLElementTagNameMap} */
      t.nodeType === 11 ? "TEMPLATE" : t.nodeName
    ), this.t = t.tagName !== "TEMPLATE" ? t : (
      /** @type {HTMLTemplateElement} */
      t.content
    ), this.c(e)), this.i(s);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(e) {
    this.e.innerHTML = e, this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(e) {
    for (let t = 0; t < this.n.length; t += 1)
      T(this.t, this.n[t], e);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(e) {
    this.d(), this.h(e), this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(S);
  }
};
f(u$, "HtmlTag");
let As = u$;
function nt(i, e) {
  return new i(e);
}
f(nt, "construct_svelte_component");
const vd = /* @__PURE__ */ new Map();
let kd = 0;
function vz(i) {
  let e = 5381, t = i.length;
  for (; t--; )
    e = (e << 5) - e ^ i.charCodeAt(t);
  return e >>> 0;
}
f(vz, "hash");
function kz(i, e) {
  const t = { stylesheet: mz(e), rules: {} };
  return vd.set(i, t), t;
}
f(kz, "create_style_information");
function wd(i, e, t, s, n, l, r, o = 0) {
  const a = 16.666 / s;
  let c = `{
`;
  for (let _ = 0; _ <= 1; _ += a) {
    const y = e + (t - e) * l(_);
    c += _ * 100 + `%{${r(y, 1 - y)}}
`;
  }
  const u = c + `100% {${r(t, 1 - t)}}
}`, d = `__svelte_${vz(u)}_${o}`, p = v7(i), { stylesheet: m, rules: g } = vd.get(p) || kz(p, i);
  g[d] || (g[d] = !0, m.insertRule(`@keyframes ${d} ${u}`, m.cssRules.length));
  const h = i.style.animation || "";
  return i.style.animation = `${h ? `${h}, ` : ""}${d} ${s}ms linear ${n}ms 1 both`, kd += 1, d;
}
f(wd, "create_rule");
function $d(i, e) {
  const t = (i.style.animation || "").split(", "), s = t.filter(
    e ? (l) => l.indexOf(e) < 0 : (l) => l.indexOf("__svelte") === -1
    // remove all Svelte animations
  ), n = t.length - s.length;
  n && (i.style.animation = s.join(", "), kd -= n, kd || wz());
}
f($d, "delete_rule");
function wz() {
  B5(() => {
    kd || (vd.forEach((i) => {
      const { ownerNode: e } = i.stylesheet;
      e && S(e);
    }), vd.clear());
  });
}
f(wz, "clear_rules");
let kc;
function Pi(i) {
  kc = i;
}
f(Pi, "set_current_component");
function Nr() {
  if (!kc)
    throw new Error("Function called outside component initialization");
  return kc;
}
f(Nr, "get_current_component");
function $z(i) {
  Nr().$$.before_update.push(i);
}
f($z, "beforeUpdate");
function Sr(i) {
  Nr().$$.on_mount.push(i);
}
f(Sr, "onMount");
function Nt(i) {
  Nr().$$.on_destroy.push(i);
}
f(Nt, "onDestroy");
function it() {
  const i = Nr();
  return (e, t, { cancelable: s = !1 } = {}) => {
    const n = i.$$.callbacks[e];
    if (n) {
      const l = k7(
        /** @type {string} */
        e,
        t,
        { cancelable: s }
      );
      return n.slice().forEach((r) => {
        r.call(i, l);
      }), !l.defaultPrevented;
    }
    return !0;
  };
}
f(it, "createEventDispatcher");
function et(i, e) {
  return Nr().$$.context.set(i, e), e;
}
f(et, "setContext");
function fe(i) {
  return Nr().$$.context.get(i);
}
f(fe, "getContext");
function gt(i, e) {
  const t = i.$$.callbacks[e.type];
  t && t.slice().forEach((s) => s.call(this, e));
}
f(gt, "bubble");
const Hr = [], st = [];
let eo = [];
const zb = [], w7 = /* @__PURE__ */ Promise.resolve();
let Hb = !1;
function $7() {
  Hb || (Hb = !0, w7.then(Ke));
}
f($7, "schedule_update");
function A7() {
  return $7(), w7;
}
f(A7, "tick");
function is(i) {
  eo.push(i);
}
f(is, "add_render_callback");
function _t(i) {
  zb.push(i);
}
f(_t, "add_flush_callback");
const Sb = /* @__PURE__ */ new Set();
let Gr = 0;
function Ke() {
  if (Gr !== 0)
    return;
  const i = kc;
  do {
    try {
      for (; Gr < Hr.length; ) {
        const e = Hr[Gr];
        Gr++, Pi(e), Az(e.$$);
      }
    } catch (e) {
      throw Hr.length = 0, Gr = 0, e;
    }
    for (Pi(null), Hr.length = 0, Gr = 0; st.length; )
      st.pop()();
    for (let e = 0; e < eo.length; e += 1) {
      const t = eo[e];
      Sb.has(t) || (Sb.add(t), t());
    }
    eo.length = 0;
  } while (Hr.length);
  for (; zb.length; )
    zb.pop()();
  Hb = !1, Sb.clear(), Pi(i);
}
f(Ke, "flush");
function Az(i) {
  if (i.fragment !== null) {
    i.update(), Ne(i.before_update);
    const e = i.dirty;
    i.dirty = [-1], i.fragment && i.fragment.p(i.ctx, e), i.after_update.forEach(is);
  }
}
f(Az, "update");
function Ez(i) {
  const e = [], t = [];
  eo.forEach((s) => i.indexOf(s) === -1 ? e.push(s) : t.push(s)), t.forEach((s) => s()), eo = e;
}
f(Ez, "flush_render_callbacks");
let La;
function G5() {
  return La || (La = Promise.resolve(), La.then(() => {
    La = null;
  })), La;
}
f(G5, "wait");
function kr(i, e, t) {
  i.dispatchEvent(k7(`${e ? "intro" : "outro"}${t}`));
}
f(kr, "dispatch");
const Zf = /* @__PURE__ */ new Set();
let Jn;
function ce() {
  Jn = {
    r: 0,
    c: [],
    p: Jn
    // parent group
  };
}
f(ce, "group_outros");
function ue() {
  Jn.r || Ne(Jn.c), Jn = Jn.p;
}
f(ue, "check_outros");
function w(i, e) {
  i && i.i && (Zf.delete(i), i.i(e));
}
f(w, "transition_in");
function C(i, e, t, s) {
  if (i && i.o) {
    if (Zf.has(i))
      return;
    Zf.add(i), Jn.c.push(() => {
      Zf.delete(i), s && (t && i.d(1), s());
    }), i.o(e);
  } else
    s && s();
}
f(C, "transition_out");
const z5 = { duration: 0 };
function sb(i, e, t) {
  const s = { direction: "in" };
  let n = e(i, t, s), l = !1, r, o, a = 0;
  function c() {
    r && $d(i, r);
  }
  f(c, "cleanup");
  function u() {
    const {
      delay: p = 0,
      duration: m = 300,
      easing: g = ei,
      tick: h = ee,
      css: _
    } = n || z5;
    _ && (r = wd(i, 0, 1, m, p, g, _, a++)), h(0, 1);
    const y = vc() + p, k = y + m;
    o && o.abort(), l = !0, is(() => kr(i, !0, "start")), o = tb((v) => {
      if (l) {
        if (v >= k)
          return h(1, 0), kr(i, !0, "end"), c(), l = !1;
        if (v >= y) {
          const O = g((v - y) / m);
          h(O, 1 - O);
        }
      }
      return l;
    });
  }
  f(u, "go");
  let d = !1;
  return {
    start() {
      d || (d = !0, $d(i), $t(n) ? (n = n(s), G5().then(u)) : u());
    },
    invalidate() {
      d = !1;
    },
    end() {
      l && (c(), l = !1);
    }
  };
}
f(sb, "create_in_transition");
function nb(i, e, t) {
  const s = { direction: "out" };
  let n = e(i, t, s), l = !0, r;
  const o = Jn;
  o.r += 1;
  let a;
  function c() {
    const {
      delay: u = 0,
      duration: d = 300,
      easing: p = ei,
      tick: m = ee,
      css: g
    } = n || z5;
    g && (r = wd(i, 1, 0, d, u, p, g));
    const h = vc() + u, _ = h + d;
    is(() => kr(i, !1, "start")), "inert" in i && (a = /** @type {HTMLElement} */
    i.inert, i.inert = !0), tb((y) => {
      if (l) {
        if (y >= _)
          return m(0, 1), kr(i, !1, "end"), --o.r || Ne(o.c), !1;
        if (y >= h) {
          const k = p((y - h) / d);
          m(1 - k, k);
        }
      }
      return l;
    });
  }
  return f(c, "go"), $t(n) ? G5().then(() => {
    n = n(s), c();
  }) : c(), {
    end(u) {
      u && "inert" in i && (i.inert = a), u && n.tick && n.tick(1, 0), l && (r && $d(i, r), l = !1);
    }
  };
}
f(nb, "create_out_transition");
function dl(i, e, t, s) {
  let l = e(i, t, { direction: "both" }), r = s ? 0 : 1, o = null, a = null, c = null, u;
  function d() {
    c && $d(i, c);
  }
  f(d, "clear_animation");
  function p(g, h) {
    const _ = (
      /** @type {Program['d']} */
      g.b - r
    );
    return h *= Math.abs(_), {
      a: r,
      b: g.b,
      d: _,
      duration: h,
      start: g.start,
      end: g.start + h,
      group: g.group
    };
  }
  f(p, "init");
  function m(g) {
    const {
      delay: h = 0,
      duration: _ = 300,
      easing: y = ei,
      tick: k = ee,
      css: v
    } = l || z5, O = {
      start: vc() + h,
      b: g
    };
    g || (O.group = Jn, Jn.r += 1), "inert" in i && (g ? u !== void 0 && (i.inert = u) : (u = /** @type {HTMLElement} */
    i.inert, i.inert = !0)), o || a ? a = O : (v && (d(), c = wd(i, r, g, _, h, y, v)), g && k(0, 1), o = p(O, _), is(() => kr(i, g, "start")), tb((P) => {
      if (a && P > a.start && (o = p(a, _), a = null, kr(i, o.b, "start"), v && (d(), c = wd(
        i,
        r,
        o.b,
        o.duration,
        0,
        y,
        l.css
      ))), o) {
        if (P >= o.end)
          k(r = o.b, 1 - r), kr(i, o.b, "end"), a || (o.b ? d() : --o.group.r || Ne(o.group.c)), o = null;
        else if (P >= o.start) {
          const D = P - o.start;
          r = o.a + o.d * y(D / o.duration), k(r, 1 - r);
        }
      }
      return !!(o || a);
    }));
  }
  return f(m, "go"), {
    run(g) {
      $t(l) ? G5().then(() => {
        l = l({ direction: g ? "in" : "out" }), m(g);
      }) : m(g);
    },
    end() {
      d(), o = a = null;
    }
  };
}
f(dl, "create_bidirectional_transition");
function OO(i, e) {
  const t = e.token = {};
  function s(n, l, r, o) {
    if (e.token !== t)
      return;
    e.resolved = o;
    let a = e.ctx;
    r !== void 0 && (a = a.slice(), a[r] = o);
    const c = n && (e.current = n)(a);
    let u = !1;
    e.block && (e.blocks ? e.blocks.forEach((d, p) => {
      p !== l && d && (ce(), C(d, 1, 1, () => {
        e.blocks[p] === d && (e.blocks[p] = null);
      }), ue());
    }) : e.block.d(1), c.c(), w(c, 1), c.m(e.mount(), e.anchor), u = !0), e.block = c, e.blocks && (e.blocks[l] = c), u && Ke();
  }
  if (f(s, "update"), dz(i)) {
    const n = Nr();
    if (i.then(
      (l) => {
        Pi(n), s(e.then, 1, e.value, l), Pi(null);
      },
      (l) => {
        if (Pi(n), s(e.catch, 2, e.error, l), Pi(null), !e.hasCatch)
          throw l;
      }
    ), e.current !== e.pending)
      return s(e.pending, 0), !0;
  } else {
    if (e.current !== e.then)
      return s(e.then, 1, e.value, i), !0;
    e.resolved = /** @type {T} */
    i;
  }
}
f(OO, "handle_promise");
function Sz(i, e, t) {
  const s = e.slice(), { resolved: n } = i;
  i.current === i.then && (s[i.value] = n), i.current === i.catch && (s[i.error] = n), i.block.p(s, t);
}
f(Sz, "update_await_block_branch");
function oe(i) {
  return (i == null ? void 0 : i.length) !== void 0 ? i : Array.from(i);
}
f(oe, "ensure_array_like");
function vs(i, e) {
  i.d(1), e.delete(i.key);
}
f(vs, "destroy_block");
function ks(i, e) {
  C(i, 1, 1, () => {
    e.delete(i.key);
  });
}
f(ks, "outro_and_destroy_block");
function kt(i, e, t, s, n, l, r, o, a, c, u, d) {
  let p = i.length, m = l.length, g = p;
  const h = {};
  for (; g--; )
    h[i[g].key] = g;
  const _ = [], y = /* @__PURE__ */ new Map(), k = /* @__PURE__ */ new Map(), v = [];
  for (g = m; g--; ) {
    const I = d(n, l, g), B = t(I);
    let F = r.get(B);
    F ? s && v.push(() => F.p(I, e)) : (F = c(B, I), F.c()), y.set(B, _[g] = F), B in h && k.set(B, Math.abs(g - h[B]));
  }
  const O = /* @__PURE__ */ new Set(), P = /* @__PURE__ */ new Set();
  function D(I) {
    w(I, 1), I.m(o, u), r.set(I.key, I), u = I.first, m--;
  }
  for (f(D, "insert"); p && m; ) {
    const I = _[m - 1], B = i[p - 1], F = I.key, H = B.key;
    I === B ? (u = I.first, p--, m--) : y.has(H) ? !r.has(F) || O.has(F) ? D(I) : P.has(H) ? p-- : k.get(F) > k.get(H) ? (P.add(F), D(I)) : (O.add(H), p--) : (a(B, r), p--);
  }
  for (; p--; ) {
    const I = i[p];
    y.has(I.key) || a(I, r);
  }
  for (; m; )
    D(_[m - 1]);
  return Ne(v), _;
}
f(kt, "update_keyed_each");
function hs(i, e) {
  const t = {}, s = {}, n = { $$scope: 1 };
  let l = i.length;
  for (; l--; ) {
    const r = i[l], o = e[l];
    if (o) {
      for (const a in r)
        a in o || (s[a] = 1);
      for (const a in o)
        n[a] || (t[a] = o[a], n[a] = 1);
      i[l] = o;
    } else
      for (const a in r)
        n[a] = 1;
  }
  for (const r in s)
    r in t || (t[r] = void 0);
  return t;
}
f(hs, "get_spread_update");
function Es(i) {
  return typeof i == "object" && i !== null ? i : {};
}
f(Es, "get_spread_object");
function mt(i, e, t) {
  const s = i.$$.props[e];
  s !== void 0 && (i.$$.bound[s] = t, t(i.$$.ctx[s]));
}
f(mt, "bind");
function L(i) {
  i && i.c();
}
f(L, "create_component");
function N(i, e, t) {
  const { fragment: s, after_update: n } = i.$$;
  s && s.m(e, t), is(() => {
    const l = i.$$.on_mount.map(h7).filter($t);
    i.$$.on_destroy ? i.$$.on_destroy.push(...l) : Ne(l), i.$$.on_mount = [];
  }), n.forEach(is);
}
f(N, "mount_component");
function j(i, e) {
  const t = i.$$;
  t.fragment !== null && (Ez(t.after_update), Ne(t.on_destroy), t.fragment && t.fragment.d(e), t.on_destroy = t.fragment = null, t.ctx = []);
}
f(j, "destroy_component");
function Tz(i, e) {
  i.$$.dirty[0] === -1 && (Hr.push(i), $7(), i.$$.dirty.fill(0)), i.$$.dirty[e / 31 | 0] |= 1 << e % 31;
}
f(Tz, "make_dirty");
function le(i, e, t, s, n, l, r = null, o = [-1]) {
  const a = kc;
  Pi(i);
  const c = i.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: l,
    update: ee,
    not_equal: n,
    bound: CO(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(e.context || (a ? a.$$.context : [])),
    // everything else
    callbacks: CO(),
    dirty: o,
    skip_bound: !1,
    root: e.target || a.$$.root
  };
  r && r(c.root);
  let u = !1;
  if (c.ctx = t ? t(i, e.props || {}, (d, p, ...m) => {
    const g = m.length ? m[0] : p;
    return c.ctx && n(c.ctx[d], c.ctx[d] = g) && (!c.skip_bound && c.bound[d] && c.bound[d](g), u && Tz(i, d)), p;
  }) : [], c.update(), u = !0, Ne(c.before_update), c.fragment = s ? s(c.ctx) : !1, e.target) {
    if (e.hydrate) {
      const d = bz(e.target);
      c.fragment && c.fragment.l(d), d.forEach(S);
    } else
      c.fragment && c.fragment.c();
    e.intro && w(i.$$.fragment), N(i, e.target, e.anchor), Ke();
  }
  Pi(a);
}
f(le, "init$1");
const f$ = class f$ {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    Ge(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    Ge(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    j(this, 1), this.$destroy = ee;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(e, t) {
    if (!$t(t))
      return ee;
    const s = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
    return s.push(t), () => {
      const n = s.indexOf(t);
      n !== -1 && s.splice(n, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(e) {
    this.$$set && !pz(e) && (this.$$.skip_bound = !0, this.$$set(e), this.$$.skip_bound = !1);
  }
};
f(f$, "SvelteComponent");
let ie = f$;
const Cz = "4";
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(Cz);
var Np;
const jp = class jp {
  /**
   * Provides a solid string hashing algorithm.
   *
   * Sourced from: https://stackoverflow.com/a/52171480
   *
   * @param {string}   str - String to hash.
   *
   * @param {number}   seed - A seed value altering the hash.
   *
   * @returns {number} Hash code.
   */
  static hashCode(e, t = 0) {
    if (typeof e != "string")
      return 0;
    let s = 3735928559 ^ t, n = 1103547991 ^ t;
    for (let l, r = 0; r < e.length; r++)
      l = e.charCodeAt(r), s = Math.imul(s ^ l, 2654435761), n = Math.imul(n ^ l, 1597334677);
    return s = Math.imul(s ^ s >>> 16, 2246822507) ^ Math.imul(n ^ n >>> 13, 3266489909), n = Math.imul(n ^ n >>> 16, 2246822507) ^ Math.imul(s ^ s >>> 13, 3266489909), 4294967296 * (2097151 & n) + (s >>> 0);
  }
  /**
   * Validates that the given string is formatted as a UUIDv4 string.
   *
   * @param {string}   uuid - UUID string to test.
   *
   * @returns {boolean} Is UUIDv4 string.
   */
  static isUuidv4(e) {
    return M(this, Np).test(e);
  }
  /**
   * Generates a UUID v4 compliant ID. Please use a complete UUID generation package for guaranteed compliance.
   *
   * This code is an evolution of the following Gist.
   * https://gist.github.com/jed/982883
   *
   * There is a public domain / free copy license attached to it that is not a standard OSS license...
   * https://gist.github.com/jed/982883#file-license-txt
   *
   * @returns {string} UUIDv4
   */
  static uuidv4() {
    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (e) => (e ^ (globalThis.crypto ?? globalThis.msCrypto).getRandomValues(
      new Uint8Array(1)
    )[0] & 15 >> e / 4).toString(16));
  }
};
Np = new WeakMap(), f(jp, "Hashing"), Y(jp, Np, /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i);
let Ub = jp;
const d$ = class d$ {
  /**
   * Escape a given input string prefacing special characters with backslashes for use in a regular expression.
   *
   * @param {string}   string - An un-escaped input string.
   *
   * @returns {string} The escaped string suitable for use in a regular expression.
   */
  static escape(e) {
    return e.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  /**
   * Normalizes a string.
   *
   * @param {string}   string - A string to normalize for comparisons.
   *
   * @returns {string} Cleaned string.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize
   */
  static normalize(e) {
    return e.trim().normalize("NFD").replace(/[\x00-\x1F]/gm, "");
  }
};
f(d$, "Strings");
let Wi = d$;
const p$ = class p$ {
  /**
   * Wraps a callback in a debounced timeout.
   *
   * Delay execution of the callback function until the function has not been called for the given delay in milliseconds.
   *
   * @param {Function} callback - A function to execute once the debounced threshold has been passed.
   *
   * @param {number}   delay - An amount of time in milliseconds to delay.
   *
   * @returns {Function} A wrapped function that can be called to debounce execution.
   */
  static debounce(e, t) {
    let s;
    return function(...n) {
      globalThis.clearTimeout(s), s = globalThis.setTimeout(() => {
        e.apply(this, n);
      }, t);
    };
  }
  /**
   * @param {object}   opts - Optional parameters.
   *
   * @param {Function} opts.single - Single click callback.
   *
   * @param {Function} opts.double - Double click callback.
   *
   * @param {number}   [opts.delay=400] - Double click delay.
   *
   * @returns {(event: Event) => void} The gated double-click handler.
   */
  static doubleClick({ single: e, double: t, delay: s = 400 }) {
    let n = 0, l;
    return (r) => {
      n++, n === 1 ? l = globalThis.setTimeout(() => {
        typeof e == "function" && e(r), n = 0;
      }, s) : (globalThis.clearTimeout(l), typeof t == "function" && t(r), n = 0);
    };
  }
};
f(p$, "Timing");
let Ad = p$;
const zr = [];
function Oz(i, e) {
  return {
    subscribe: It(i, e).subscribe
  };
}
f(Oz, "readable");
function It(i, e = ee) {
  let t;
  const s = /* @__PURE__ */ new Set();
  function n(o) {
    if (ne(i, o) && (i = o, t)) {
      const a = !zr.length;
      for (const c of s)
        c[1](), zr.push(c, i);
      if (a) {
        for (let c = 0; c < zr.length; c += 2)
          zr[c][0](zr[c + 1]);
        zr.length = 0;
      }
    }
  }
  f(n, "set");
  function l(o) {
    n(o(i));
  }
  f(l, "update");
  function r(o, a = ee) {
    const c = [o, a];
    return s.add(c), s.size === 1 && (t = e(n, l) || ee), o(i), () => {
      s.delete(c), s.size === 0 && t && (t(), t = null);
    };
  }
  return f(r, "subscribe"), { set: n, update: l, subscribe: r };
}
f(It, "writable");
function wc(i, e, t) {
  const s = !Array.isArray(i), n = s ? [i] : i;
  if (!n.every(Boolean))
    throw new Error("derived() expects stores as input, got a falsy value");
  const l = e.length < 2;
  return Oz(t, (r, o) => {
    let a = !1;
    const c = [];
    let u = 0, d = ee;
    const p = /* @__PURE__ */ f(() => {
      if (u)
        return;
      d();
      const g = e(s ? c[0] : c, r, o);
      l ? r(g) : d = $t(g) ? g : ee;
    }, "sync"), m = n.map(
      (g, h) => Et(
        g,
        (_) => {
          c[h] = _, u &= ~(1 << h), a && p();
        },
        () => {
          u |= 1 << h;
        }
      )
    );
    return a = !0, p(), /* @__PURE__ */ f(function() {
      Ne(m), d(), a = !1;
    }, "stop");
  });
}
f(wc, "derived");
function Kr(i) {
  if (i == null)
    return !1;
  switch (typeof i) {
    case "function":
    case "object":
      return typeof i.subscribe == "function";
  }
  return !1;
}
f(Kr, "isReadableStore");
function DO(i) {
  if (i == null)
    return !1;
  switch (typeof i) {
    case "function":
    case "object":
      return typeof i.subscribe == "function" && typeof i.update == "function";
  }
  return !1;
}
f(DO, "isUpdatableStore");
function pl(i) {
  if (i == null)
    return !1;
  switch (typeof i) {
    case "function":
    case "object":
      return typeof i.subscribe == "function" && typeof i.set == "function";
  }
  return !1;
}
f(pl, "isWritableStore");
function tc(i, e) {
  let t = !1;
  return i.subscribe((s) => {
    t ? e(s) : t = !0;
  });
}
f(tc, "subscribeIgnoreFirst");
const m$ = class m$ {
  /**
   * Checks for array equality between two arrays of numbers.
   *
   * @param a - Array A
   *
   * @param b - Array B
   *
   * @returns Arrays are equal.
   */
  static arrayEquals(e, t) {
    if (e === t)
      return !0;
    if (e === null || t === null || e.length !== t.length)
      return !1;
    for (let s = e.length; --s >= 0; )
      if (e[s] !== t[s])
        return !1;
    return !0;
  }
  /**
   * Provides a solid string hashing algorithm.
   *
   * Sourced from: https://stackoverflow.com/a/52171480
   *
   * @param str - String to hash.
   *
   * @param seed - A seed value altering the hash.
   *
   * @returns Hash code.
   */
  static hashString(e, t = 0) {
    let s = 3735928559 ^ t, n = 1103547991 ^ t;
    for (let l, r = 0; r < e.length; r++)
      l = e.charCodeAt(r), s = Math.imul(s ^ l, 2654435761), n = Math.imul(n ^ l, 1597334677);
    return s = Math.imul(s ^ s >>> 16, 2246822507) ^ Math.imul(n ^ n >>> 13, 3266489909), n = Math.imul(n ^ n >>> 16, 2246822507) ^ Math.imul(s ^ s >>> 13, 3266489909), 4294967296 * (2097151 & n) + (s >>> 0);
  }
  /**
   * Converts an unknown value for hashing purposes in {@link AdapterIndexer.calcHashUpdate}.
   *
   * Currently objects / Map w/ object keys is not supported. Potentially can include `object-hash` to handle this
   * case, but it is not common to use objects as keys in Maps.
   *
   * @param value - An unknown value to convert to a number.
   */
  static hashUnknown(e) {
    if (e == null)
      return 0;
    let t = 0;
    switch (typeof e) {
      case "boolean":
        t = e ? 1 : 0;
        break;
      case "bigint":
        t = Number(BigInt.asIntN(64, e));
        break;
      case "function":
        t = this.hashString(e.name);
        break;
      case "number":
        t = Number.isFinite(e) ? e : 0;
        break;
      case "object":
        break;
      case "string":
        t = this.hashString(e);
        break;
      case "symbol":
        t = this.hashString(Symbol.keyFor(e));
        break;
    }
    return t;
  }
  /**
   * @param target -
   *
   * @param Prototype -
   *
   * @returns target constructor function has Prototype.
   */
  static hasPrototype(e, t) {
    if (typeof e != "function")
      return !1;
    if (e === t)
      return !0;
    for (let s = Object.getPrototypeOf(e); s; s = Object.getPrototypeOf(s))
      if (s === t)
        return !0;
    return !1;
  }
  /**
   * Provides a utility method to determine if the given data is iterable / implements iterator protocol.
   *
   * @param data - Data to verify as iterable.
   *
   * @returns Is data iterable.
   */
  static isIterable(e) {
    return e != null && typeof e == "object" && typeof e[Symbol.iterator] == "function";
  }
};
f(m$, "DynReducerUtils");
let Ri = m$;
var oo, Wc, ao, Fn, Nn;
const h$ = class h$ {
  /**
   * @param hostData - Hosted data structure.
   *
   * @param parentIndex - Any associated parent index API.
   *
   * @param DerivedReducerCtor - The default derived reducer constructor function.
   */
  constructor(e, t, s) {
    Y(this, oo, void 0);
    Y(this, Wc, void 0);
    Y(this, ao, void 0);
    Y(this, Fn, /* @__PURE__ */ new Map());
    Y(this, Nn, !1);
    ye(this, oo, e), ye(this, ao, t), ye(this, Wc, s), Object.freeze(this);
  }
  /**
   * Creates a new derived reducer.
   *
   * @param options - Options defining the new derived reducer.
   *
   * @returns Newly created derived reducer.
   */
  create(e) {
    if (M(this, Nn))
      throw Error("AdapterDerived.create error: this instance has been destroyed.");
    let t, s = {}, n;
    const l = M(this, Wc);
    if (typeof e == "string")
      t = e, n = l;
    else if (typeof e == "function" && Ri.hasPrototype(e, l))
      n = e;
    else if (typeof e == "object" && e !== null)
      ({ name: t, ctor: n = l, ...s } = e);
    else
      throw new TypeError("AdapterDerived.create error: 'options' does not conform to allowed parameters.");
    if (!Ri.hasPrototype(n, l))
      throw new TypeError(`AdapterDerived.create error: 'ctor' is not a '${l == null ? void 0 : l.name}'.`);
    if (t = t ?? (n == null ? void 0 : n.name), typeof t != "string")
      throw new TypeError("AdapterDerived.create error: 'name' is not a string.");
    const r = new n(M(this, oo), M(this, ao), s);
    return M(this, Fn).set(t, r), r;
  }
  /**
   * Removes all derived reducers and associated subscriptions.
   */
  clear() {
    if (!M(this, Nn)) {
      for (const e of M(this, Fn).values())
        e.destroy();
      M(this, Fn).clear();
    }
  }
  /**
   * Deletes and destroys a derived reducer by name.
   *
   * @param name - Name of the derived reducer.
   */
  delete(e) {
    if (M(this, Nn))
      throw Error("AdapterDerived.delete error: this instance has been destroyed.");
    const t = M(this, Fn).get(e);
    return t && t.destroy(), M(this, Fn).delete(e);
  }
  /**
   * Removes all derived reducers, subscriptions, and cleans up all resources.
   */
  destroy() {
    M(this, Nn) || (this.clear(), ye(this, oo, [null]), ye(this, ao, null), ye(this, Nn, !0));
  }
  /**
   * Returns an existing derived reducer.
   *
   * @param name - Name of derived reducer.
   */
  get(e) {
    if (M(this, Nn))
      throw Error("AdapterDerived.get error: this instance has been destroyed.");
    return M(this, Fn).get(e);
  }
  /**
   * Updates all managed derived reducer indexes.
   *
   * @param [force] - Force an update to subscribers.
   */
  update(e = !1) {
    if (!M(this, Nn))
      for (const t of M(this, Fn).values())
        t.index.update(e);
  }
};
oo = new WeakMap(), Wc = new WeakMap(), ao = new WeakMap(), Fn = new WeakMap(), Nn = new WeakMap(), f(h$, "AdapterDerived");
let Ed = h$;
var Kt, jn, Ls;
const g$ = class g$ {
  /**
   * @param indexUpdate - update function for the indexer.
   *
   * @param filtersAdapter - Stores the filter function data.
   */
  constructor(e, t) {
    Y(this, Kt, void 0);
    Y(this, jn, void 0);
    Y(this, Ls, /* @__PURE__ */ new Map());
    ye(this, jn, e), ye(this, Kt, t), Object.freeze(this);
  }
  /**
   * @returns Returns the length of the filter data.
   */
  get length() {
    return M(this, Kt).filters.length;
  }
  /**
   * Provides an iterator for filters.
   *
   * @yields {DataFilter<T>}
   */
  *[Symbol.iterator]() {
    if (M(this, Kt).filters.length !== 0)
      for (const e of M(this, Kt).filters)
        yield { ...e };
  }
  /**
   * @param filters -
   */
  add(...e) {
    let t = 0;
    for (const s of e) {
      const n = typeof s;
      if (n !== "function" && (n !== "object" || s === null))
        throw new TypeError("AdapterFilters error: 'filter' is not a function or object.");
      let l, r;
      if (n === "function")
        l = {
          id: void 0,
          filter: s,
          weight: 1
        }, r = s.subscribe;
      else if (n === "object")
        if ("filter" in s) {
          if (typeof s.filter != "function")
            throw new TypeError("AdapterFilters error: 'filter' attribute is not a function.");
          if (s.weight !== void 0 && typeof s.weight != "number" || s.weight < 0 || s.weight > 1)
            throw new TypeError("AdapterFilters error: 'weight' attribute is not a number between '0 - 1' inclusive.");
          l = {
            id: s.id !== void 0 ? s.id : void 0,
            filter: s.filter,
            weight: s.weight || 1
          }, r = s.filter.subscribe ?? s.subscribe;
        } else
          throw new TypeError("AdapterFilters error: 'filter' attribute is not a function.");
      const o = M(this, Kt).filters.findIndex((a) => l.weight < a.weight);
      if (o >= 0 ? M(this, Kt).filters.splice(o, 0, l) : M(this, Kt).filters.push(l), typeof r == "function") {
        const a = r(M(this, jn));
        if (typeof a != "function")
          throw new TypeError("AdapterFilters error: Filter has subscribe function, but no unsubscribe function is returned.");
        if (M(this, Ls).has(l.filter))
          throw new Error("AdapterFilters error: Filter added already has an unsubscribe function registered.");
        M(this, Ls).set(l.filter, a), t++;
      }
    }
    t < e.length && M(this, jn).call(this);
  }
  /**
   * Clears and removes all filters.
   */
  clear() {
    M(this, Kt).filters.length = 0;
    for (const e of M(this, Ls).values())
      e();
    M(this, Ls).clear(), M(this, jn).call(this);
  }
  /**
   * @param filters -
   */
  remove(...e) {
    const t = M(this, Kt).filters.length;
    if (t !== 0) {
      for (const s of e) {
        const n = typeof s == "function" ? s : s !== null && typeof s == "object" ? s.filter : void 0;
        if (n) {
          for (let l = M(this, Kt).filters.length; --l >= 0; )
            if (M(this, Kt).filters[l].filter === n) {
              M(this, Kt).filters.splice(l, 1);
              let r;
              typeof (r = M(this, Ls).get(n)) == "function" && (r(), M(this, Ls).delete(n));
            }
        }
      }
      t !== M(this, Kt).filters.length && M(this, jn).call(this);
    }
  }
  /**
   * Remove filters by the provided callback. The callback takes 3 parameters: `id`, `filter`, and `weight`.
   * Any truthy value returned will remove that filter.
   *
   * @param callback - Callback function to evaluate each filter entry.
   */
  removeBy(e) {
    const t = M(this, Kt).filters.length;
    if (t !== 0) {
      if (typeof e != "function")
        throw new TypeError("AdapterFilters error: 'callback' is not a function.");
      M(this, Kt).filters = M(this, Kt).filters.filter((s) => {
        const n = e.call(e, { ...s });
        if (n) {
          let l;
          typeof (l = M(this, Ls).get(s.filter)) == "function" && (l(), M(this, Ls).delete(s.filter));
        }
        return !n;
      }), t !== M(this, Kt).filters.length && M(this, jn).call(this);
    }
  }
  /**
   * @param ids - Removes filters by ID.
   */
  removeById(...e) {
    const t = M(this, Kt).filters.length;
    t !== 0 && (M(this, Kt).filters = M(this, Kt).filters.filter((s) => {
      let n = 0;
      for (const l of e)
        n |= s.id === l ? 1 : 0;
      if (n) {
        let l;
        typeof (l = M(this, Ls).get(s.filter)) == "function" && (l(), M(this, Ls).delete(s.filter));
      }
      return !n;
    }), t !== M(this, Kt).filters.length && M(this, jn).call(this));
  }
};
Kt = new WeakMap(), jn = new WeakMap(), Ls = new WeakMap(), f(g$, "AdapterFilters");
let Sd = g$;
const b$ = class b$ {
  /**
   * @param hostData - Hosted data structure.
   *
   * @param hostUpdate - Host update function invoked on index updates.
   *
   * @param [parentIndexer] - Any associated parent index API.
   *
   * @returns Indexer adapter instance.
   */
  constructor(e, t, s) {
    Ge(this, "derivedAdapter");
    Ge(this, "filtersData");
    Ge(this, "hostData");
    Ge(this, "hostUpdate");
    Ge(this, "indexData");
    Ge(this, "sortData");
    Ge(this, "sortFn");
    Ge(this, "destroyed", !1);
    this.hostData = e, this.hostUpdate = t, this.indexData = { index: null, hash: null, reversed: !1, parent: s };
  }
  /**
   * @returns Returns whether the index is active.
   */
  get active() {
    var e;
    return this.filtersData.filters.length > 0 || this.sortData.compareFn !== null || ((e = this.indexData.parent) == null ? void 0 : e.active) === !0;
  }
  /**
   * @returns Returns length of reduced index.
   */
  get length() {
    return this.indexData.index ? this.indexData.index.length : 0;
  }
  /* c8 ignore start */
  /**
   * @returns Returns reversed state.
   */
  get reversed() {
    return this.indexData.reversed;
  }
  /* c8 ignore end */
  /**
   * @param reversed - New reversed state.
   */
  set reversed(e) {
    this.indexData.reversed = e;
  }
  // -------------------------------------------------------------------------------------------------------------------
  /**
   * Calculates a new hash value for the new index array if any. If the new index array is null then the hash value
   * is set to null. Set calculated new hash value to the index adapter hash value.
   *
   * After hash generation compare old and new hash values and perform an update if they are different. If they are
   * equal check for array equality between the old and new index array and perform an update if they are not equal.
   *
   * @param oldIndex - Old index array.
   *
   * @param oldHash - Old index hash value.
   *
   * @param [force=false] - When true forces an update to subscribers.
   */
  calcHashUpdate(e, t, s = !1) {
    const n = typeof s == "boolean" ? s : (
      /* c8 ignore next */
      !1
    );
    let l = null;
    const r = this.indexData.index;
    if (r)
      for (let o = r.length; --o >= 0; )
        l ^= Ri.hashUnknown(r[o]) + 2654435769 + (l << 6) + (l >> 2);
    this.indexData.hash = l, (n || (t !== l || !Ri.arrayEquals(e, r))) && this.hostUpdate();
  }
  /**
   * Destroys all resources.
   */
  destroy() {
    this.destroyed || (this.indexData.index = null, this.indexData.hash = null, this.indexData.reversed = null, this.indexData.parent = null, this.destroyed = !0);
  }
  /**
   * Store associated filter and sort data that are constructed after the indexer.
   *
   * @param filtersData - Associated AdapterFilters instance.
   *
   * @param sortData - Associated AdapterSort instance.
   *
   * @param derivedAdapter - Associated AdapterDerived instance.
   */
  initAdapters(e, t, s) {
    this.filtersData = e, this.sortData = t, this.derivedAdapter = s, this.sortFn = this.createSortFn();
  }
};
f(b$, "AdapterIndexer");
let Vb = b$;
var bi, Yi, wn;
const _$ = class _$ {
  /**
   * @param indexUpdate - Function to update indexer.
   *
   * @param sortData - Storage for compare function.
   */
  constructor(e, t) {
    Y(this, bi, void 0);
    Y(this, Yi, void 0);
    Y(this, wn, void 0);
    ye(this, Yi, e), ye(this, bi, t), Object.freeze(this);
  }
  /**
   * Clears & removes any assigned sort function and triggers an index update.
   */
  clear() {
    const e = M(this, bi).compareFn;
    M(this, bi).compareFn = null, typeof M(this, wn) == "function" && (M(this, wn).call(this), ye(this, wn, void 0)), typeof e == "function" && M(this, Yi).call(this);
  }
  /**
   * @param data - A callback function that compares two values. Return > 0 to sort b before a;
   * < 0 to sort a before b; or 0 to keep original order of a & b.
   *
   * Note: You can set a compare function that also has a subscribe function attached as the `subscribe` attribute.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#parameters
   */
  set(e) {
    typeof M(this, wn) == "function" && (M(this, wn).call(this), ye(this, wn, void 0));
    let t, s;
    switch (typeof e) {
      case "function":
        t = e, s = e.subscribe;
        break;
      case "object":
        if (e === null)
          break;
        if (typeof e.compare != "function")
          throw new TypeError("AdapterSort error: 'compare' attribute is not a function.");
        t = e.compare, s = e.compare.subscribe ?? e.subscribe;
        break;
    }
    if (typeof t == "function")
      M(this, bi).compareFn = t;
    else {
      const n = M(this, bi).compareFn;
      M(this, bi).compareFn = null, typeof n == "function" && M(this, Yi).call(this);
      return;
    }
    if (typeof s == "function") {
      if (ye(this, wn, s(M(this, Yi))), typeof M(this, wn) != "function")
        throw new Error("AdapterSort error: sort has 'subscribe' function, but no 'unsubscribe' function is returned.");
    } else
      M(this, Yi).call(this);
  }
};
bi = new WeakMap(), Yi = new WeakMap(), wn = new WeakMap(), f(_$, "AdapterSort");
let Td = _$;
var co;
const y$ = class y$ {
  constructor(e) {
    Y(this, co, void 0);
    /**
     * Provides a getter to determine if the index is active.
     */
    Ge(this, "active");
    /**
     * Provides length of reduced / indexed elements.
     */
    Ge(this, "length");
    /**
     * Manually invoke an update of the index.
     *
     * @param force - Force update to any subscribers.
     */
    Ge(this, "update");
    ye(this, co, e.indexData), this.update = e.update.bind(e), Object.defineProperties(this, {
      active: { get: () => e.active },
      length: { get: () => e.length }
    }), Object.freeze(this);
  }
  /**
   * - Current hash value of the index.
   */
  get hash() {
    return M(this, co).hash;
  }
  /**
   * Provides an iterator over the index array.
   *
   * @yields {K}
   */
  *[Symbol.iterator]() {
    const e = M(this, co);
    if (!e.index)
      return;
    const t = e.reversed, s = e.index.length;
    if (t)
      for (let n = s; --n >= 0; )
        yield e.index[n];
    else
      for (let n = 0; n < s; n++)
        yield e.index[n];
  }
};
co = new WeakMap(), f(y$, "IndexerAPI");
let Cd = y$;
const v$ = class v$ {
  constructor(e) {
    /**
     * Removes all derived reducers and associated subscriptions.
     */
    Ge(this, "clear");
    /**
     * @param options - Options for creating a reducer.
     *
     * @returns Newly created derived reducer.
     */
    Ge(this, "create");
    /**
     * Deletes and destroys a derived reducer.
     *
     * @param name - Name of the derived reducer
     */
    Ge(this, "delete");
    /**
     * Removes all derived reducers, associated subscriptions, and cleans up all resources.
     */
    Ge(this, "destroy");
    /**
     * Returns an existing derived reducer.
     *
     * @param name - Name of derived reducer.
     */
    Ge(this, "get");
    this.clear = e.clear.bind(e), this.create = e.create.bind(e), this.delete = e.delete.bind(e), this.destroy = e.destroy.bind(e), this.get = e.get.bind(e), Object.freeze(this);
  }
};
f(v$, "DerivedAPI");
let Od = v$;
const k$ = class k$ extends Vb {
  /**
   * @inheritDoc
   */
  createSortFn() {
    return (e, t) => this.sortData.compareFn(this.hostData[0].get(e), this.hostData[0].get(t));
  }
  /**
   * Provides the custom filter / reduce step that is ~25-40% faster than implementing with `Array.reduce`.
   *
   * Note: Other loop unrolling techniques like Duff's Device gave a slight faster lower bound on large data sets,
   * but the maintenance factor is not worth the extra complication.
   *
   * @returns New filtered index array.
   */
  reduceImpl() {
    const e = [], t = this.hostData[0];
    if (!t)
      return e;
    const s = this.filtersData.filters;
    let n = !0;
    const l = this.indexData.parent;
    if (Ri.isIterable(l) && l.active)
      for (const r of l) {
        const o = t.get(r);
        n = !0;
        for (let a = 0, c = s.length; a < c; a++)
          if (!s[a].filter(o)) {
            n = !1;
            break;
          }
        n && e.push(r);
      }
    else
      for (const r of t.keys()) {
        n = !0;
        const o = t.get(r);
        for (let a = 0, c = s.length; a < c; a++)
          if (!s[a].filter(o)) {
            n = !1;
            break;
          }
        n && e.push(r);
      }
    return e;
  }
  /**
   * Update the reducer indexes. If there are changes subscribers are notified. If data order is changed externally
   * pass in true to force an update to subscribers.
   *
   * @param [force=false] - When true forces an update to subscribers.
   */
  update(e = !1) {
    var r;
    if (this.destroyed)
      return;
    const t = this.indexData.index, s = this.indexData.hash, n = this.hostData[0], l = this.indexData.parent;
    (this.filtersData.filters.length === 0 && !this.sortData.compareFn || this.indexData.index && (n == null ? void 0 : n.size) !== this.indexData.index.length) && (this.indexData.index = null), this.filtersData.filters.length > 0 && (this.indexData.index = this.reduceImpl()), !this.indexData.index && (l != null && l.active) && (this.indexData.index = [...l]), this.sortData.compareFn && n instanceof Map && (this.indexData.index || (this.indexData.index = this.indexData.index = [...n.keys()]), this.indexData.index.sort(this.sortFn)), this.calcHashUpdate(t, s, e), (r = this.derivedAdapter) == null || r.update(e);
  }
};
f(k$, "Indexer");
let Dd = k$;
var Ln, Rl, Kc, uo, Yc, $n, Xi, Xc, fo, Jc, _i, po, Lp, E7;
const Bp = class Bp {
  /**
   * @param map - Data host Map.
   *
   * @param parentIndex - Parent indexer.
   *
   * @param options - Any filters and sort functions to apply.
   */
  constructor(e, t, s) {
    /**
     * Updates subscribers on changes.
     */
    Y(this, Lp);
    Y(this, Ln, void 0);
    Y(this, Rl, void 0);
    Y(this, Kc, void 0);
    Y(this, uo, void 0);
    Y(this, Yc, { filters: [] });
    Y(this, $n, void 0);
    Y(this, Xi, void 0);
    Y(this, Xc, !1);
    Y(this, fo, void 0);
    Y(this, Jc, { compareFn: null });
    Y(this, _i, []);
    Y(this, po, !1);
    ye(this, Ln, e), ye(this, $n, new Dd(M(this, Ln), Z(this, Lp, E7).bind(this), t)), ye(this, Xi, new Cd(M(this, $n))), ye(this, uo, new Sd(M(this, Xi).update, M(this, Yc))), ye(this, fo, new Td(M(this, Xi).update, M(this, Jc))), ye(this, Rl, new Ed(M(this, Ln), M(this, Xi), Bp)), ye(this, Kc, new Od(M(this, Rl))), M(this, $n).initAdapters(M(this, Yc), M(this, Jc), M(this, Rl));
    let n, l;
    if (s !== void 0 && ("filters" in s || "sort" in s)) {
      if (s.filters !== void 0)
        if (Ri.isIterable(s.filters))
          n = s.filters;
        else
          throw new TypeError("DerivedMapReducer error (DataDerivedOptions): 'filters' attribute is not iterable.");
      if (s.sort !== void 0)
        if (typeof s.sort == "function")
          l = s.sort;
        else if (typeof s.sort == "object" && s.sort !== null)
          l = s.sort;
        else
          throw new TypeError("DerivedMapReducer error (DataDerivedOptions): 'sort' attribute is not a function or object.");
    }
    n && this.filters.add(...n), l && this.sort.set(l), this.initialize();
  }
  /**
   * Returns the internal data of this instance. Be careful!
   *
   * Note: The returned map is the same map set by the main reducer. If any changes are performed to the data
   * externally do invoke {@link IndexerAPI.update} with `true` to recalculate the index and notify all subscribers.
   *
   * @returns The internal data.
   */
  get data() {
    return M(this, Ln)[0];
  }
  /**
   * @returns Derived public API.
   */
  get derived() {
    return M(this, Kc);
  }
  /**
   * @returns The filters adapter.
   */
  get filters() {
    return M(this, uo);
  }
  /**
   * Returns the Indexer public API.
   *
   * @returns Indexer API - is also iterable.
   */
  get index() {
    return M(this, Xi);
  }
  /**
   * Returns whether this derived reducer is destroyed.
   */
  get destroyed() {
    return M(this, po);
  }
  /**
   * @returns Main data / items length or indexed length.
   */
  get length() {
    const e = M(this, Ln)[0];
    return M(this, $n).active ? this.index.length : e ? e.size : 0;
  }
  /**
   * @returns Gets current reversed state.
   */
  get reversed() {
    return M(this, Xc);
  }
  /**
   * @returns The sort adapter.
   */
  get sort() {
    return M(this, fo);
  }
  /**
   * Sets reversed state and notifies subscribers.
   *
   * @param reversed - New reversed state.
   */
  set reversed(e) {
    if (typeof e != "boolean")
      throw new TypeError("DerivedMapReducer.reversed error: 'reversed' is not a boolean.");
    ye(this, Xc, e), M(this, $n).reversed = e, this.index.update(!0);
  }
  /**
   * Removes all derived reducers, subscriptions, and cleans up all resources.
   */
  destroy() {
    ye(this, po, !0), ye(this, Ln, [null]), M(this, $n).update(!0), M(this, _i).length = 0, M(this, Rl).destroy(), M(this, $n).destroy(), M(this, uo).clear(), M(this, fo).clear();
  }
  /**
   * Provides a callback for custom derived reducers to initialize any data / custom configuration. This allows
   * child classes to avoid implementing the constructor.
   *
   * @protected
   */
  initialize() {
  }
  /**
   * Provides an iterator for data stored in DerivedMapReducer.
   *
   * @yields {T}
   */
  *[Symbol.iterator]() {
    const e = M(this, Ln)[0];
    if (!(M(this, po) || e === null || (e == null ? void 0 : e.size) === 0))
      if (M(this, $n).active)
        for (const t of this.index)
          yield e.get(t);
      else if (this.reversed) {
        const t = [...e.values()];
        for (let s = t.length; --s >= 0; )
          yield t[s];
      } else
        for (const t of e.values())
          yield t;
  }
  // -------------------------------------------------------------------------------------------------------------------
  /**
   * Subscribe to this DerivedMapReducer.
   *
   * @param handler - Callback function that is invoked on update / changes. Receives `this` reference.
   *
   * @returns Unsubscribe function.
   */
  subscribe(e) {
    return M(this, _i).push(e), e(this), () => {
      const t = M(this, _i).findIndex((s) => s === e);
      t >= 0 && M(this, _i).splice(t, 1);
    };
  }
};
Ln = new WeakMap(), Rl = new WeakMap(), Kc = new WeakMap(), uo = new WeakMap(), Yc = new WeakMap(), $n = new WeakMap(), Xi = new WeakMap(), Xc = new WeakMap(), fo = new WeakMap(), Jc = new WeakMap(), _i = new WeakMap(), po = new WeakMap(), Lp = new WeakSet(), E7 = /* @__PURE__ */ f(function() {
  for (let e = 0; e < M(this, _i).length; e++)
    M(this, _i)[e](this);
}, "#updateSubscribers"), f(Bp, "DynMapReducerDerived");
let Wb = Bp;
var Bs, Fl, Zc, mo, Qc, Bn, yi, xc, ho, eu, vi, Nl, qp, S7;
const w$ = class w$ {
  /**
   * Initializes DynMapReducer. Any iterable is supported for initial data. Take note that if `data` is an array it
   * will be used as the host array and not copied. All non-array iterables otherwise create a new array / copy.
   *
   * @param [data] - Data iterable to store if array or copy otherwise.
   */
  constructor(e) {
    /**
     * Updates subscribers on changes.
     */
    Y(this, qp);
    Y(this, Bs, [null]);
    Y(this, Fl, void 0);
    Y(this, Zc, void 0);
    Y(this, mo, void 0);
    Y(this, Qc, { filters: [] });
    Y(this, Bn, void 0);
    Y(this, yi, void 0);
    Y(this, xc, !1);
    Y(this, ho, void 0);
    Y(this, eu, { compareFn: null });
    Y(this, vi, []);
    Y(this, Nl, !1);
    let t, s, n;
    if (e === null)
      throw new TypeError("DynMapReducer error: 'data' is not an object or Map.");
    if (e !== void 0 && typeof e != "object" && !(e instanceof Map))
      throw new TypeError("DynMapReducer error: 'data' is not an object or Map.");
    if (e !== void 0 && e instanceof Map)
      t = e;
    else if (e !== void 0 && ("data" in e || "filters" in e || "sort" in e)) {
      if (e.data !== void 0 && !(e.data instanceof Map))
        throw new TypeError("DynMapReducer error (DataDynMap): 'data' attribute is not a Map.");
      if (t = e.data, e.filters !== void 0)
        if (Ri.isIterable(e.filters))
          s = e.filters;
        else
          throw new TypeError("DynMapReducer error (DataDynMap): 'filters' attribute is not iterable.");
      if (e.sort !== void 0)
        if (typeof e.sort == "function")
          n = e.sort;
        else if (typeof e.sort == "object" && e.sort !== null)
          n = e.sort;
        else
          throw new TypeError("DynMapReducer error (DataDynMap): 'sort' attribute is not a function or object.");
    }
    t && (M(this, Bs)[0] = t), ye(this, Bn, new Dd(M(this, Bs), Z(this, qp, S7).bind(this))), ye(this, yi, new Cd(M(this, Bn))), ye(this, mo, new Sd(M(this, yi).update, M(this, Qc))), ye(this, ho, new Td(M(this, yi).update, M(this, eu))), ye(this, Fl, new Ed(M(this, Bs), M(this, yi), Wb)), ye(this, Zc, new Od(M(this, Fl))), M(this, Bn).initAdapters(M(this, Qc), M(this, eu), M(this, Fl)), s && this.filters.add(...s), n && this.sort.set(n), this.initialize();
  }
  /**
   * Returns the internal data of this instance. Be careful!
   *
   * Note: When a map is set as data then that map is used as the internal data. If any changes are
   * performed to the data externally do invoke {@link AdapterIndexer.index.update} with `true` to recalculate the
   * index and notify all subscribers.
   *
   * @returns The internal data.
   */
  get data() {
    return M(this, Bs)[0];
  }
  /**
   * @returns Derived public API.
   */
  get derived() {
    return M(this, Zc);
  }
  /**
   * @returns The filters adapter.
   */
  get filters() {
    return M(this, mo);
  }
  /**
   * @returns Returns the Indexer public API.
   */
  get index() {
    return M(this, yi);
  }
  /**
   * Returns whether this instance is destroyed.
   */
  get destroyed() {
    return M(this, Nl);
  }
  /**
   * Gets the main data / items length.
   *
   * @returns {number} Main data / items length.
   */
  get length() {
    const e = M(this, Bs)[0];
    return M(this, Bn).active ? M(this, yi).length : e ? e.size : 0;
  }
  /**
   * Gets current reversed state.
   *
   * @returns {boolean} Reversed state.
   */
  get reversed() {
    return M(this, xc);
  }
  /**
   * @returns The sort adapter.
   */
  get sort() {
    return M(this, ho);
  }
  /**
   * Sets reversed state and notifies subscribers.
   *
   * @param reversed - New reversed state.
   */
  set reversed(e) {
    if (typeof e != "boolean")
      throw new TypeError("DynMapReducer.reversed error: 'reversed' is not a boolean.");
    ye(this, xc, e), M(this, Bn).reversed = e, this.index.update(!0);
  }
  /**
   * Removes all derived reducers, subscriptions, and cleans up all resources.
   */
  destroy() {
    M(this, Nl) || (ye(this, Nl, !0), M(this, Fl).destroy(), ye(this, Bs, [null]), this.index.update(!0), M(this, vi).length = 0, M(this, Bn).destroy(), M(this, mo).clear(), M(this, ho).clear());
  }
  /**
   * Provides a callback for custom reducers to initialize any data / custom configuration. This allows
   * child classes to avoid implementing the constructor.
   *
   * @protected
   */
  initialize() {
  }
  /**
   * Removes internal data and pushes new data. This does not destroy any initial array set to internal data unless
   * `replace` is set to true.
   *
   * @param data - New data to set to internal data.
   *
   * @param replace=false - New data to set to internal data.
   */
  setData(e, t = !1) {
    if (e !== null && !(e instanceof Map))
      throw new TypeError("DynMapReducer.setData error: 'data' is not iterable.");
    if (typeof t != "boolean")
      throw new TypeError("DynMapReducer.setData error: 'replace' is not a boolean.");
    const s = M(this, Bs)[0];
    if (!(s instanceof Map) || t)
      M(this, Bs)[0] = e instanceof Map ? e : null;
    else if (e instanceof Map && s instanceof Map) {
      const n = new Set(s.keys());
      for (const l of e.keys())
        s.set(l, e.get(l)), n.has(l) && n.delete(l);
      for (const l of n)
        s.delete(l);
    } else
      e === null && (M(this, Bs)[0] = null);
    this.index.update(!0);
  }
  /**
   * Add a subscriber to this DynMapReducer instance.
   *
   * @param handler - Callback function that is invoked on update / changes. Receives `this` reference.
   *
   * @returns Unsubscribe function.
   */
  subscribe(e) {
    return M(this, vi).push(e), e(this), () => {
      const t = M(this, vi).findIndex((s) => s === e);
      t >= 0 && M(this, vi).splice(t, 1);
    };
  }
  /**
   * Provides an iterator for data stored in DynMapReducer.
   *
   * @yields {T}
   */
  *[Symbol.iterator]() {
    const e = M(this, Bs)[0];
    if (!(M(this, Nl) || e === null || (e == null ? void 0 : e.size) === 0))
      if (M(this, Bn).active)
        for (const t of this.index)
          yield e.get(t);
      else if (this.reversed) {
        const t = [...e.values()];
        for (let s = t.length; --s >= 0; )
          yield t[s];
      } else
        for (const t of e.values())
          yield t;
  }
};
Bs = new WeakMap(), Fl = new WeakMap(), Zc = new WeakMap(), mo = new WeakMap(), Qc = new WeakMap(), Bn = new WeakMap(), yi = new WeakMap(), xc = new WeakMap(), ho = new WeakMap(), eu = new WeakMap(), vi = new WeakMap(), Nl = new WeakMap(), qp = new WeakSet(), S7 = /* @__PURE__ */ f(function() {
  for (let e = 0; e < M(this, vi).length; e++)
    M(this, vi)[e](this);
}, "#updateSubscribers"), f(w$, "DynMapReducer");
let Ms = w$;
function Dz(i, { accessWarn: e = !1, caseSensitive: t = !1, store: s } = {}) {
  let n = "", l;
  if (s !== void 0 && !pl(s))
    throw new TypeError("createObjectQuery error: 'store' is not a writable store.");
  const r = s || It(n);
  if (s) {
    const a = fn(s);
    typeof a == "string" ? (n = Wi.normalize(a), l = new RegExp(Wi.escape(n), t ? "" : "i")) : s.set(n);
  }
  function o(a) {
    if (n === "" || !l)
      return !0;
    if (vt(i)) {
      for (const c of i) {
        const u = _d(a, c);
        if (typeof u != "string") {
          e && console.warn(`regexObjectQuery warning: could not access string data from '${c}'.`);
          continue;
        }
        if (l.test(Wi.normalize(u)))
          return !0;
      }
      return !1;
    } else {
      const c = _d(a, i);
      return typeof c != "string" ? (e && console.warn(`regexObjectQuery warning: could not access string data from '${i}'.`), !1) : l.test(Wi.normalize(c));
    }
  }
  return f(o, "filterQuery"), o.subscribe = (a) => r.subscribe(a), o.set = (a) => {
    typeof a == "string" && (n = Wi.normalize(a), l = new RegExp(Wi.escape(n), t ? "" : "i"), r.set(n));
  }, o;
}
f(Dz, "regexObjectQuery");
const Iz = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  regexObjectQuery: Dz
}), $$ = class $$ {
  /**
   * Returns the following filter functions:
   * - regexObjectQuery(accessors, options); suitable for object reducers matching one or more property keys /
   *   accessors against the store value as a regex. To access deeper entries into the object format the accessor
   *   string with `.` between entries to walk. Optional parameters include logging access warnings, case sensitivity,
   *   and passing in an existing store.
   *
   * @returns {{
   *    regexObjectQuery: (accessors: string|Iterable<string>, options?: {accessWarn?: boolean, caseSensitive?: boolean, store?: import('svelte/store').Writable<string>}) => (((data: {}) => boolean) & import('svelte/store').Writable<string>)
   * }} All available filters.
   */
  static get filters() {
    return Iz;
  }
};
f($$, "DynReducerHelper");
let Kb = $$;
var Gp, os, go, Ji, Qs;
const rc = class rc {
  /**
   * @param {foundry.abstract.Document[]} document - The associated document holder.
   */
  constructor(e) {
    /**
     * @type {Map<string, EmbeddedCollectionData<any>>}
     */
    Y(this, os, /* @__PURE__ */ new Map());
    /**
     * @type {foundry.abstract.Document[]}
     */
    Y(this, go, void 0);
    /**
     * @type {Map<string, string>}
     */
    Y(this, Ji, /* @__PURE__ */ new Map());
    /**
     * @type {Set<string>}
     */
    Y(this, Qs, /* @__PURE__ */ new Set());
    ye(this, go, e), this.handleDocChange(), Object.seal(this);
  }
  /**
   * @template [T=import('./types').NamedDocumentConstructor]
   *
   * @param {T} FoundryDoc - A Foundry document class / constructor.
   *
   * @param {import('#runtime/svelte/store/reducer').DynOptionsMapCreate<string, T>} options - DynMapReducer
   *        creation options.
   *
   * @returns {import('#runtime/svelte/store/reducer').DynMapReducer<string, T>} DynMapReducer instance.
   */
  create(e, t) {
    const s = e == null ? void 0 : e.documentName;
    if (typeof s != "string")
      throw new TypeError(
        "EmbeddedStoreManager.create error: 'FoundryDoc' does not have a valid 'documentName' property."
      );
    const n = M(this, go)[0];
    let l = null;
    if (n)
      try {
        l = n.getEmbeddedCollection(s);
      } catch {
        console.warn(`EmbeddedStoreManager.create error: No valid embedded collection for: ${s}`);
      }
    let r;
    M(this, os).has(s) ? r = M(this, os).get(s) : (r = {
      collection: l,
      stores: /* @__PURE__ */ new Map()
    }, M(this, os).set(s, r));
    let o, a = {}, c;
    if (typeof t == "string")
      o = t, c = Ms;
    else if (typeof t == "function" && TO(t, Ms))
      c = t;
    else if (ke(t))
      ({ name: o, ctor: c = Ms, ...a } = t);
    else
      throw new TypeError("EmbeddedStoreManager.create error: 'options' does not conform to allowed parameters.");
    if (!TO(c, Ms))
      throw new TypeError("EmbeddedStoreManager.create error: 'ctor' is not a 'DynMapReducer'.");
    if (o = o ?? (c == null ? void 0 : c.name), typeof o != "string")
      throw new TypeError("EmbeddedStoreManager.create error: 'name' is not a string.");
    if (r.stores.has(o))
      return r.stores.get(o);
    {
      const u = l ? { data: l, ...a } : { ...a }, d = new c(u);
      return r.stores.set(o, d), d;
    }
  }
  /**
   * @template [T=import('./types').NamedDocumentConstructor]
   *
   * Destroys and removes embedded collection stores. Invoking this method with no parameters destroys all stores.
   * Invoking with an embedded name destroys all stores for that particular collection. If you provide an embedded and
   * store name just that particular store is destroyed and removed.
   *
   * @param {T}   [FoundryDoc] - A Foundry document class / constructor.
   *
   * @param {string}   [storeName] - Specific store name.
   *
   * @returns {boolean} One or more stores destroyed?
   */
  destroy(e, t) {
    let s = 0;
    if (e === void 0) {
      for (const n of M(this, os).values()) {
        n.collection = null;
        for (const l of n.stores.values())
          l.destroy(), s++;
      }
      M(this, os).clear();
    } else {
      const n = e == null ? void 0 : e.documentName;
      if (typeof n != "string")
        throw new TypeError(
          "EmbeddedStoreManager.delete error: 'FoundryDoc' does not have a valid 'documentName' property."
        );
      if (t === void 0) {
        const l = M(this, os).get(n);
        if (l) {
          l.collection = null;
          for (const r of l.stores.values())
            r.destroy(), s++;
        }
        M(this, os).delete(n);
      } else if (t === "string") {
        const l = M(this, os).get(n);
        if (l) {
          const r = l.stores.get(t);
          r && (r.destroy(), s++);
        }
      }
    }
    return s > 0;
  }
  /**
   * @template [T=import('./types').NamedDocumentConstructor]
   *
   * @param {T} FoundryDoc - A Foundry document class / constructor.
   *
   * @param {string} storeName - Name of the embedded collection to retrieve.
   *
   * @returns {import('#runtime/svelte/store/reducer').DynMapReducer<string, InstanceType<T>>} DynMapReducer
   *          instance.
   */
  get(e, t) {
    const s = e == null ? void 0 : e.documentName;
    if (typeof s != "string")
      throw new TypeError(
        "EmbeddedStoreManager.get error: 'FoundryDoc' does not have a valid 'documentName' property."
      );
    if (M(this, os).has(s))
      return M(this, os).get(s).stores.get(t);
  }
  /**
   * Updates all existing embedded collection stores with the associated embedded collection
   */
  handleDocChange() {
    var t, s;
    const e = M(this, go)[0];
    if (e instanceof globalThis.foundry.abstract.Document) {
      const n = new Set(M(this, os).keys()), l = Object.entries(((s = (t = e.constructor) == null ? void 0 : t.metadata) == null ? void 0 : s.embedded) ?? []);
      M(this, Ji).clear(), M(this, Qs).clear();
      for (const [r, o] of l) {
        n.delete(r), M(this, Qs).add(`create${r}`), M(this, Qs).add(`delete${r}`), M(this, Qs).add(`update${r}`), M(this, Qs).add(`create.${o}`), M(this, Qs).add(`delete.${o}`), M(this, Qs).add(`update.${o}`), M(this, Ji).set(r, r), M(this, Ji).set(o, r);
        let a = null;
        try {
          a = e.getEmbeddedCollection(r);
        } catch {
          console.warn(`EmbeddedStoreManager.handleDocUpdate error: No valid embedded collection for: ${r}`);
        }
        const c = M(this, os).get(r);
        if (c) {
          c.collection = a;
          for (const u of c.stores.values())
            u.setData(a, !0);
        }
      }
      for (const r of n) {
        const o = M(this, os).get(r);
        if (o) {
          o.collection = null;
          for (const a of o.stores.values())
            a.setData(null, !0);
        }
      }
    } else {
      M(this, Ji).clear(), M(this, Qs).clear();
      for (const n of M(this, os).values()) {
        n.collection = null;
        for (const l of n.stores.values())
          l.setData(null, !0);
      }
    }
  }
  /**
   * Handles updates to embedded stores parsing the render context for valid embedded store types.
   *
   * On create, delete, update parse the type being modified then force index updates for the embedded type.
   *
   * @param {string}   renderContext - render context update from document.
   */
  handleUpdate(e) {
    if (!M(this, Qs).has(e))
      return;
    const t = M(rc, Gp).exec(e);
    if (t) {
      const s = t.groups.name, n = M(this, Ji).get(s);
      if (!M(this, os).has(n))
        return;
      for (const l of M(this, os).get(n).stores.values())
        l.index.update(!0);
    }
  }
};
Gp = new WeakMap(), os = new WeakMap(), go = new WeakMap(), Ji = new WeakMap(), Qs = new WeakMap(), f(rc, "EmbeddedStoreManager"), /**
 * RegExp for detecting CRUD updates for renderContext.
 *
 * @type {RegExp}
 */
Y(rc, Gp, /(?<action>create|delete|update)(?<sep>\.?)(?<name>\w+)/);
let Yb = rc;
var xs, Os, jl, ki, qn, wi, Ll, zp, T7, bo, Qf, _o, xf;
const Hp = class Hp {
  /**
   * @param {T | TJSDocumentOptions}  [document] - Document to wrap or TJSDocumentOptions.
   *
   * @param {TJSDocumentOptions}      [options] - TJSDocument options.
   */
  constructor(e, t = {}) {
    /**
     * Handles cleanup when the document is deleted. Invoking any optional delete function set in the constructor.
     *
     * @returns {Promise<void>}
     */
    Y(this, zp);
    /**
     * @param {boolean}  [force] - unused - signature from Foundry render function.
     *
     * @param {object}   [options] - Options from render call; will have document update context.
     */
    Y(this, bo);
    /**
     *
     * @param {T | undefined} doc -
     */
    Y(this, _o);
    /**
     * @type {T[]}
     */
    Y(this, xs, [void 0]);
    /**
     * @type {EmbeddedStoreManager}
     */
    Y(this, Os, void 0);
    /**
     * @type {import('./types').EmbeddedAPI}
     */
    Y(this, jl, void 0);
    /**
     * @type {string}
     */
    Y(this, ki, void 0);
    /**
     * @type {TJSDocumentOptions}
     */
    Y(this, qn, { delete: void 0, preDelete: void 0 });
    /**
     * @type {((value: T, updateOptions?: TJSDocumentUpdateOptions) => void)[]}
     */
    Y(this, wi, []);
    /**
     * @type {TJSDocumentUpdateOptions}
     */
    Y(this, Ll, void 0);
    ye(this, ki, `tjs-document-${Ub.uuidv4()}`), d7(e) ? this.setOptions(e) : (this.setOptions(t), this.set(e));
  }
  /**
   * @returns {import('./types').EmbeddedAPI} Embedded store manager.
   */
  get embedded() {
    return M(this, jl) || (ye(this, Os, new Yb(M(this, xs))), ye(this, jl, {
      create: (e, t) => M(this, Os).create(e, t),
      destroy: (e, t) => M(this, Os).destroy(e, t),
      get: (e, t) => M(this, Os).get(e, t)
    })), M(this, jl);
  }
  /**
   * Returns the options passed on last update.
   *
   * @returns {TJSDocumentUpdateOptions} Last update options.
   */
  get updateOptions() {
    return M(this, Ll) ?? {};
  }
  /**
   * Returns the UUID assigned to this store.
   *
   * @returns {string} UUID
   */
  get uuidv4() {
    return M(this, ki);
  }
  /**
   * Completely removes all internal subscribers, any optional delete callback, and unregisters from the
   * ClientDocumentMixin `apps` tracking object.
   */
  destroy() {
    const e = M(this, xs)[0];
    M(this, Os) && (M(this, Os).destroy(), ye(this, Os, void 0), ye(this, jl, void 0)), e instanceof globalThis.foundry.abstract.Document && (e == null || delete e.apps[M(this, ki)], Z(this, _o, xf).call(this, void 0)), M(this, qn).delete = void 0, M(this, wi).length = 0;
  }
  /**
   * @returns {T} Current document
   */
  get() {
    return M(this, xs)[0];
  }
  /**
   * Attempts to create a Foundry UUID from standard drop data. This may not work for all systems.
   *
   * @param {object}   data - Drop transfer data.
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.actor=true] - Accept actor owned documents.
   *
   * @param {boolean}  [opts.compendium=true] - Accept compendium documents.
   *
   * @param {boolean}  [opts.world=true] - Accept world documents.
   *
   * @param {string[]|undefined}   [opts.types] - Require the `data.type` to match entry in `types`.
   *
   * @returns {string|undefined} Foundry UUID for drop data.
   */
  static getUUIDFromDataTransfer(e, { actor: t = !0, compendium: s = !0, world: n = !0, types: l = void 0 } = {}) {
    if (!ke(e) || Array.isArray(l) && !l.includes(e.type))
      return;
    let r;
    return typeof e.uuid == "string" ? (e.uuid.startsWith("Compendium") && s || n) && (r = e.uuid) : t && n && e.actorId && e.type ? r = `Actor.${e.actorId}.${e.type}.${e.data._id}` : typeof e.id == "string" && (s && typeof e.pack == "string" ? r = `Compendium.${e.pack}.${e.id}` : n && (r = `${e.type}.${e.id}`)), r;
  }
  /**
   * @param {T | undefined}  document - New document to set.
   *
   * @param {TJSDocumentUpdateOptions}   [options] - New document update options to set.
   */
  set(e, t = {}) {
    if (M(this, xs)[0] && delete M(this, xs)[0].apps[M(this, ki)], e !== void 0 && !(e instanceof globalThis.foundry.abstract.Document))
      throw new TypeError("TJSDocument set error: 'document' is not a valid Document or undefined.");
    if (!ke(t))
      throw new TypeError("TJSDocument set error: 'options' is not an object.");
    e instanceof globalThis.foundry.abstract.Document && (e.apps[M(this, ki)] = {
      close: Z(this, zp, T7).bind(this),
      render: Z(this, bo, Qf).bind(this)
    }), Z(this, _o, xf).call(this, e), ye(this, Ll, t), Z(this, bo, Qf).call(this);
  }
  /**
   * Potentially sets new document from data transfer object.
   *
   * @param {object}   data - Document transfer data.
   *
   * @param {{ actor?: boolean, compendium?: boolean, world?: boolean, types?: string[] } & TJSDocumentOptions}   [options] - Optional
   *        parameters.
   *
   * @returns {Promise<boolean>} Returns true if new document set from data transfer blob.
   */
  async setFromDataTransfer(e, t) {
    return this.setFromUUID(Hp.getUUIDFromDataTransfer(e, t), t);
  }
  /**
   * Sets the document by Foundry UUID performing a lookup and setting the document if found.
   *
   * @param {string}   uuid - A Foundry UUID to lookup.
   *
   * @param {TJSDocumentOptions}   [options] - New document update options to set.
   *
   * @returns {Promise<boolean>} True if successfully set document from UUID.
   */
  async setFromUUID(e, t = {}) {
    if (typeof e != "string" || e.length === 0)
      return !1;
    try {
      const s = await globalThis.fromUuid(e);
      if (s)
        return this.set(s, t), !0;
    } catch {
    }
    return !1;
  }
  /**
   * Sets options for this document wrapper / store.
   *
   * @param {TJSDocumentOptions}   options - Options for TJSDocument.
   */
  setOptions(e) {
    if (!ke(e))
      throw new TypeError("TJSDocument error: 'options' is not a plain object.");
    if (e.delete !== void 0 && typeof e.delete != "function")
      throw new TypeError("TJSDocument error: 'delete' attribute in options is not a function.");
    if (e.preDelete !== void 0 && typeof e.preDelete != "function")
      throw new TypeError("TJSDocument error: 'preDelete' attribute in options is not a function.");
    (e.delete === void 0 || typeof e.delete == "function") && (M(this, qn).delete = e.delete), (e.preDelete === void 0 || typeof e.preDelete == "function") && (M(this, qn).preDelete = e.preDelete);
  }
  /**
   * @param {(value: T, updateOptions?: TJSDocumentUpdateOptions) => void} handler - Callback function that is
   * invoked on update / changes.
   *
   * @returns {import('svelte/store').Unsubscriber} Unsubscribe function.
   */
  subscribe(e) {
    M(this, wi).push(e);
    const t = { action: "subscribe", data: void 0 };
    return e(M(this, xs)[0], t), () => {
      const s = M(this, wi).findIndex((n) => n === e);
      s >= 0 && M(this, wi).splice(s, 1);
    };
  }
};
xs = new WeakMap(), Os = new WeakMap(), jl = new WeakMap(), ki = new WeakMap(), qn = new WeakMap(), wi = new WeakMap(), Ll = new WeakMap(), zp = new WeakSet(), T7 = /* @__PURE__ */ f(async function() {
  var t;
  const e = M(this, xs)[0];
  e instanceof globalThis.foundry.abstract.Document && !((t = e == null ? void 0 : e.collection) != null && t.has(e.id)) && (e == null || delete e.apps[M(this, ki)], Z(this, _o, xf).call(this, void 0), typeof M(this, qn).preDelete == "function" && await M(this, qn).preDelete(e), Z(this, bo, Qf).call(this, !1, { action: "delete", data: void 0 }), typeof M(this, qn).delete == "function" && await M(this, qn).delete(e), ye(this, Ll, void 0));
}, "#deleted"), bo = new WeakSet(), Qf = /* @__PURE__ */ f(function(e = !1, t = {}) {
  ye(this, Ll, t);
  const s = M(this, xs)[0];
  for (let n = 0; n < M(this, wi).length; n++)
    M(this, wi)[n](s, t);
  M(this, Os) && M(this, Os).handleUpdate(t.renderContext);
}, "#updateSubscribers"), _o = new WeakSet(), xf = /* @__PURE__ */ f(function(e) {
  M(this, xs)[0] = e, M(this, Os) && M(this, Os).handleDocChange();
}, "#setDocument"), f(Hp, "TJSDocument");
let Bt = Hp;
function Pz({
  duration: i = 600,
  background: e = "rgba(255, 255, 255, 0.7)",
  events: t = ["click", "keyup"],
  keyCode: s = "Enter",
  debounce: n
} = {}) {
  return (l) => {
    function r(u) {
      const d = l.getBoundingClientRect(), p = Math.max(d.width, d.height), m = p / 2, g = u.clientX ? `${u.clientX - (d.left + m)}px` : "0", h = u.clientY ? `${u.clientY - (d.top + m)}px` : "0", _ = document.createElement("span");
      _.style.position = "absolute", _.style.width = `${p}px`, _.style.height = `${p}px`, _.style.left = g, _.style.top = h, _.style.background = `var(--tjs-action-ripple-background, ${e})`, _.style.borderRadius = "50%", _.style.pointerEvents = "none", _.style.transform = "translateZ(-1px)", l.prepend(_);
      const y = _.animate(
        [
          {
            // from
            transform: "scale(.7)",
            opacity: 0.5,
            filter: "blur(2px)"
          },
          {
            // to
            transform: "scale(4)",
            opacity: 0,
            filter: "blur(5px)"
          }
        ],
        i
      );
      y.onfinish = () => {
        _ && _.isConnected && _.remove();
      };
    }
    f(r, "createRipple");
    function o(u) {
      (u == null ? void 0 : u.code) === s && r(u);
    }
    f(o, "keyHandler");
    const a = Number.isInteger(n) && n > 0 ? Ad.debounce(r, n) : r, c = Number.isInteger(n) && n > 0 ? Ad.debounce(o, n) : o;
    for (const u of t)
      ["keydown", "keyup"].includes(u) ? l.addEventListener(u, c) : l.addEventListener(u, a);
    return {
      destroy: () => {
        for (const u of t)
          ["keydown", "keyup"].includes(u) ? l.removeEventListener(u, c) : l.removeEventListener(u, a);
      }
    };
  };
}
f(Pz, "ripple");
function IO({ duration: i = 300, background: e = "rgba(255, 255, 255, 0.7)", selectors: t } = {}) {
  return (s) => {
    const n = typeof t == "string" ? s.querySelector(t) : s.firstChild instanceof HTMLElement ? s.firstChild : s;
    let l, r = -1, o = -1;
    function a() {
      if (!(l instanceof HTMLElement) || document.activeElement === n)
        return;
      const d = l.animate(
        [
          {
            // from
            transform: "scale(3)",
            opacity: 0.3
          },
          {
            // to
            transform: "scale(.7)",
            opacity: 0
          }
        ],
        {
          duration: i,
          fill: "forwards"
        }
      );
      d.onfinish = () => {
        r = o = -1, l && l.isConnected && l.remove(), l = void 0;
      };
    }
    f(a, "blurRipple");
    function c() {
      if (l instanceof HTMLElement)
        return;
      const d = s.getBoundingClientRect(), p = r >= 0 ? r : d.left + d.width / 2, m = r >= 0 ? o : d.top + d.height / 2, g = Math.max(d.width, d.height), h = g / 2, _ = `${p - (d.left + h)}px`, y = `${m - (d.top + h)}px`;
      l = document.createElement("span"), l.style.position = "absolute", l.style.width = `${g}px`, l.style.height = `${g}px`, l.style.left = _, l.style.top = y, l.style.background = `var(--tjs-action-ripple-background-focus, var(--tjs-action-ripple-background, ${e}))`, l.style.borderRadius = "50%", l.style.pointerEvents = "none", l.style.transform = "translateZ(-1px)", s.prepend(l), l.animate(
        [
          {
            // from
            transform: "scale(.7)",
            opacity: 0.5
          },
          {
            // to
            transform: "scale(3)",
            opacity: 0.3
          }
        ],
        {
          duration: i,
          fill: "forwards"
        }
      );
    }
    f(c, "focusRipple");
    function u(d) {
      r = d.clientX, o = d.clientY;
    }
    return f(u, "onPointerDown"), n.addEventListener("pointerdown", u), n.addEventListener("blur", a), n.addEventListener("focus", c), {
      destroy: () => {
        n.removeEventListener("pointerdown", u), n.removeEventListener("blur", a), n.removeEventListener("focus", c);
      }
    };
  };
}
f(IO, "rippleFocus");
function PO(i) {
  var s, n, l;
  const e = (s = i == null ? void 0 : i.constructor) == null ? void 0 : s.name;
  if (typeof e == "string" && (e.startsWith("Proxy<") || e === "ProxyComponent"))
    return !0;
  const t = (l = (n = i == null ? void 0 : i.prototype) == null ? void 0 : n.constructor) == null ? void 0 : l.name;
  return typeof t == "string" && (t.startsWith("Proxy<") || t === "ProxyComponent");
}
f(PO, "isHMRProxy");
function ti(i) {
  var t, s;
  if (i == null || typeof i != "function")
    return !1;
  const e = (s = (t = i == null ? void 0 : i.prototype) == null ? void 0 : t.constructor) == null ? void 0 : s.name;
  return typeof e == "string" && (e.startsWith("Proxy<") || e === "ProxyComponent") ? !0 : typeof window < "u" ? typeof i.prototype.$destroy == "function" && typeof i.prototype.$on == "function" : (
    // client-side
    typeof i.render == "function"
  );
}
f(ti, "isSvelteComponent");
async function Mz(i) {
  return new Promise((e) => {
    i.$$.fragment && i.$$.fragment.o ? (ce(), C(i.$$.fragment, 0, 0, () => {
      i.$destroy(), e();
    }), ue()) : (i.$destroy(), e());
  });
}
f(Mz, "outroAndDestroy");
function C7(i, e = void 0) {
  if (!ke(i))
    throw new TypeError(`parseSvelteConfig - 'config' is not an object:
${JSON.stringify(i)}.`);
  if (!ti(i.class))
    throw new TypeError(
      `parseSvelteConfig - 'class' is not a Svelte component constructor for config:
${JSON.stringify(i)}.`
    );
  if (i.hydrate !== void 0 && typeof i.hydrate != "boolean")
    throw new TypeError(
      `parseSvelteConfig - 'hydrate' is not a boolean for config:
${JSON.stringify(i)}.`
    );
  if (i.intro !== void 0 && typeof i.intro != "boolean")
    throw new TypeError(
      `parseSvelteConfig - 'intro' is not a boolean for config:
${JSON.stringify(i)}.`
    );
  if (i.target !== void 0 && typeof i.target != "string" && !(i.target instanceof HTMLElement) && !(i.target instanceof ShadowRoot) && !(i.target instanceof DocumentFragment))
    throw new TypeError(
      `parseSvelteConfig - 'target' is not a string, HTMLElement, ShadowRoot, or DocumentFragment for config:
${JSON.stringify(i)}.`
    );
  if (i.anchor !== void 0 && typeof i.anchor != "string" && !(i.anchor instanceof HTMLElement) && !(i.anchor instanceof ShadowRoot) && !(i.anchor instanceof DocumentFragment))
    throw new TypeError(
      `parseSvelteConfig - 'anchor' is not a string, HTMLElement, ShadowRoot, or DocumentFragment for config:
${JSON.stringify(i)}.`
    );
  if (i.context !== void 0 && typeof i.context != "function" && !(i.context instanceof Map) && !ke(i.context))
    throw new TypeError(
      `parseSvelteConfig - 'context' is not a Map, function or object for config:
${JSON.stringify(i)}.`
    );
  if (i.selectorTarget !== void 0 && typeof i.selectorTarget != "string")
    throw new TypeError(
      `parseSvelteConfig - 'selectorTarget' is not a string for config:
${JSON.stringify(i)}.`
    );
  if (i.options !== void 0 && !ke(i.options))
    throw new TypeError(
      `parseSvelteConfig - 'options' is not an object for config:
${JSON.stringify(i)}.`
    );
  if (i.options !== void 0) {
    if (i.options.injectApp !== void 0 && typeof i.options.injectApp != "boolean")
      throw new TypeError(
        `parseSvelteConfig - 'options.injectApp' is not a boolean for config:
${JSON.stringify(i)}.`
      );
    if (i.options.injectEventbus !== void 0 && typeof i.options.injectEventbus != "boolean")
      throw new TypeError(
        `parseSvelteConfig - 'options.injectEventbus' is not a boolean for config:
${JSON.stringify(i)}.`
      );
    if (i.options.selectorElement !== void 0 && typeof i.options.selectorElement != "string")
      throw new TypeError(
        `parseSvelteConfig - 'selectorElement' is not a string for config:
${JSON.stringify(i)}.`
      );
  }
  const t = { ...i };
  delete t.options;
  let s = {};
  if (typeof t.context == "function") {
    const n = t.context;
    delete t.context;
    const l = n.call(e);
    if (ke(l))
      s = { ...l };
    else
      throw new Error(`parseSvelteConfig - 'context' is a function that did not return an object for config:
${JSON.stringify(i)}`);
  } else
    t.context instanceof Map ? (s = Object.fromEntries(t.context), delete t.context) : ke(t.context) && (s = t.context, delete t.context);
  if (t.props = Tb(t.props, e, i), Array.isArray(t.children)) {
    const n = [];
    for (let l = 0; l < t.children.length; l++) {
      const r = t.children[l];
      if (!ti(r.class))
        throw new Error(`parseSvelteConfig - 'class' is not a Svelte component for child[${l}] for config:
${JSON.stringify(i)}`);
      r.props = Tb(r.props, e, i), n.push(r);
    }
    n.length > 0 && (s.children = n), delete t.children;
  } else if (ke(t.children)) {
    if (!ti(t.children.class))
      throw new Error(`parseSvelteConfig - 'class' is not a Svelte component for children object for config:
${JSON.stringify(i)}`);
    t.children.props = Tb(t.children.props, e, i), s.children = [t.children], delete t.children;
  }
  return t.context instanceof Map || (t.context = /* @__PURE__ */ new Map()), t.context.set("#external", s), t;
}
f(C7, "parseTJSSvelteConfig");
function Tb(i, e, t) {
  if (typeof i == "function") {
    const s = i.call(e);
    if (ke(s))
      return s;
    throw new Error(`parseSvelteConfig - 'props' is a function that did not return an object for config:
${JSON.stringify(t)}`);
  } else {
    if (ke(i))
      return i;
    if (i !== void 0)
      throw new Error(
        `parseSvelteConfig - 'props' is not a function or an object for config:
${JSON.stringify(t)}`
      );
  }
  return {};
}
f(Tb, "s_PROCESS_PROPS");
function MO(i, e, t, s) {
  var n, l, r = !1, o = t.length >= 2, a = /* @__PURE__ */ f((g, h, _) => {
    if (n = h, o && (l = g), !r) {
      let y = e(g, h, _);
      if (e.length < 2)
        h(y);
      else
        return y;
    }
    r = !1;
  }, "wrappedDerive"), c = wc(i, a, s), u = !Array.isArray(i);
  function d(g) {
    var h = t(g, l);
    u ? (r = !0, i.set(h)) : h.forEach((_, y) => {
      r = !0, i[y].set(_);
    }), r = !1;
  }
  f(d, "doReflect");
  var p = !1;
  function m(g) {
    var h, _, y, k;
    if (p) {
      k = g(fn(c)), n(k);
      return;
    }
    var v = c.subscribe((O) => {
      p ? h ? _ = !0 : h = !0 : y = O;
    });
    k = g(y), p = !0, n(k), v(), p = !1, _ && (k = fn(c)), h && d(k);
  }
  return f(m, "update"), {
    subscribe: c.subscribe,
    set(g) {
      m(() => g);
    },
    update: m
  };
}
f(MO, "writableDerived");
function dt(i, e) {
  if (Array.isArray(e)) {
    let t = e.concat();
    return MO(
      i,
      (s) => {
        for (let n = 0; n < t.length; ++n)
          s = s[t[n]];
        return s;
      },
      (s, n) => {
        let l = n;
        for (let r = 0; r < t.length - 1; ++r)
          l = l[t[r]];
        return l[t[t.length - 1]] = s, n;
      }
    );
  } else
    return MO(
      i,
      (t) => t[e],
      (t, s) => (s[e] = t, s)
    );
}
f(dt, "propertyStore");
function Zn(i) {
  const e = i - 1;
  return e * e * e + 1;
}
f(Zn, "cubicOut");
function Rz(i) {
  return --i * i * i * i * i + 1;
}
f(Rz, "quintOut");
function Pl(i, e, t) {
  return (1 - t) * i + t * e;
}
f(Pl, "lerp");
function RO(i) {
  return i == " " || i == `
` || i == "\r" || i == "	";
}
f(RO, "isSpace");
function Fz(i) {
  return i == '"' || i == "'";
}
f(Fz, "isQuote");
const to = "<", ib = ">", Id = "&lt;", O7 = "&gt;", A$ = class A$ {
  constructor(e) {
    this.options = e;
  }
  consume(e, t) {
    return e == to ? (t(new Xb(this.options)), "") : e == ib && this.options.encodePlaintextTagDelimiters ? O7 : e;
  }
};
f(A$, "InPlaintextState");
let Tr = A$;
const E$ = class E$ {
  constructor(e) {
    this.options = e, this.nameBuffer = "", this.isClosingTag = !1;
  }
  consume(e, t) {
    if (this.nameBuffer.length == 0) {
      if (RO(e))
        return t(new Tr(this.options)), (this.options.encodePlaintextTagDelimiters ? Id : "<") + e;
      if (e == "/")
        return this.isClosingTag = !0, "";
    }
    return RO(e) ? this.isNameBufferAnAllowedTag() ? (t(new $c(0, this.options)), to + (this.isClosingTag ? "/" : "") + this.nameBuffer + e) : (t(new $c(1, this.options)), this.options.tagReplacementText) : e == to ? (this.nameBuffer += Id, "") : e == ib ? (t(new Tr(this.options)), this.isNameBufferAnAllowedTag() ? to + (this.isClosingTag ? "/" : "") + this.nameBuffer + e : this.options.tagReplacementText) : e == "-" && this.nameBuffer == "!-" ? (t(new Zb(this.options)), "") : (this.nameBuffer += e, "");
  }
  isNameBufferAnAllowedTag() {
    const e = this.nameBuffer.toLowerCase();
    return this.options.allowedTags ? this.options.allowedTags.has(e) : this.options.disallowedTags ? !this.options.disallowedTags.has(e) : !1;
  }
};
f(E$, "InTagNameState");
let Xb = E$;
const S$ = class S$ {
  constructor(e, t) {
    this.mode = e, this.options = t;
  }
  consume(e, t) {
    return e == ib ? t(new Tr(this.options)) : Fz(e) && t(new Jb(this.mode, e, this.options)), this.mode == 1 ? "" : e == to ? Id : e;
  }
};
f(S$, "InTagState");
let $c = S$;
const T$ = class T$ {
  constructor(e, t, s) {
    this.mode = e, this.quoteCharacter = t, this.options = s;
  }
  consume(e, t) {
    return e == this.quoteCharacter && t(new $c(this.mode, this.options)), this.mode == 1 ? "" : e == to ? Id : e == ib ? O7 : e;
  }
};
f(T$, "InQuotedStringInTagState");
let Jb = T$;
const C$ = class C$ {
  constructor(e) {
    this.options = e, this.consecutiveHyphens = 0;
  }
  consume(e, t) {
    return e == ">" && this.consecutiveHyphens >= 2 ? t(new Tr(this.options)) : e == "-" ? this.consecutiveHyphens++ : this.consecutiveHyphens = 0, "";
  }
};
f(C$, "InCommentState");
let Zb = C$;
const Nz = {
  tagReplacementText: "",
  encodePlaintextTagDelimiters: !0
}, O$ = class O$ {
  constructor(e = {}) {
    this.state = new Tr(Object.assign(Object.assign({}, Nz), e)), this.transitionFunction = ((t) => {
      this.state = t;
    }).bind(this);
  }
  consume(e) {
    let t = "";
    for (const s of e)
      t += this.state.consume(s, this.transitionFunction);
    return t;
  }
};
f(O$, "StateMachine");
let Qb = O$;
function jz(i, e = {}) {
  return new Qb(e).consume(i);
}
f(jz, "striptags");
var Up, D7;
const Vp = class Vp {
  /**
   * Apply focus to the HTMLElement targets in a given A11yFocusSource data object. An iterable list `options.focusEl`
   * can contain HTMLElements or selector strings. If multiple focus targets are provided in a list then the first
   * valid target found will be focused. If focus target is a string then a lookup via `document.querySelector` is
   * performed. In this case you should provide a unique selector for the desired focus target.
   *
   * Note: The body of this method is postponed to the next clock tick to allow any changes in the DOM to occur that
   * might alter focus targets before applying.
   *
   * @param {A11yFocusSource|{ focusSource: A11yFocusSource }}   options - The focus options instance to apply.
   */
  static applyFocusSource(e) {
    if (!ke(e))
      return;
    const t = ke(e == null ? void 0 : e.focusSource) ? e.focusSource : e;
    setTimeout(() => {
      const s = typeof t.debug == "boolean" ? t.debug : !1;
      if (vt(t.focusEl)) {
        s && console.debug("A11yHelper.applyFocusSource debug - Attempting to apply focus target: ", t.focusEl);
        for (const n of t.focusEl)
          if (n instanceof HTMLElement && n.isConnected) {
            n.focus(), s && console.debug("A11yHelper.applyFocusSource debug - Applied focus to target: ", n);
            break;
          } else if (typeof n == "string") {
            const l = document.querySelector(n);
            if (l instanceof HTMLElement && l.isConnected) {
              l.focus(), s && console.debug("A11yHelper.applyFocusSource debug - Applied focus to target: ", l);
              break;
            } else
              s && console.debug("A11yHelper.applyFocusSource debug - Could not query selector: ", n);
          }
      } else
        s && console.debug("A11yHelper.applyFocusSource debug - No focus targets defined.");
    }, 0);
  }
  /**
   * Returns first focusable element within a specified element.
   *
   * @param {HTMLElement|Document} [element=document] - Optional element to start query.
   *
   * @param {object} [options] - Optional parameters.
   *
   * @param {Iterable<string>} [options.ignoreClasses] - Iterable list of classes to ignore elements.
   *
   * @param {Set<HTMLElement>} [options.ignoreElements] - Set of elements to ignore.
   *
   * @returns {HTMLElement} First focusable child element
   */
  static getFirstFocusableElement(e = document, t) {
    const s = this.getFocusableElements(e, t);
    return s.length > 0 ? s[0] : void 0;
  }
  /**
   * Returns all focusable elements within a specified element.
   *
   * @param {HTMLElement|Document} [element=document] Optional element to start query.
   *
   * @param {object}            [options] - Optional parameters.
   *
   * @param {boolean}           [options.anchorHref=true] - When true anchors must have an HREF.
   *
   * @param {Iterable<string>}  [options.ignoreClasses] - Iterable list of classes to ignore elements.
   *
   * @param {Set<HTMLElement>}  [options.ignoreElements] - Set of elements to ignore.
   *
   * @param {string}            [options.selectors] - Custom list of focusable selectors for `querySelectorAll`.
   *
   * @returns {Array<HTMLElement>} Child keyboard focusable
   */
  static getFocusableElements(e = document, { anchorHref: t = !0, ignoreClasses: s, ignoreElements: n, selectors: l } = {}) {
    if (!(e instanceof HTMLElement) && !(e instanceof Document))
      throw new TypeError("'element' is not a HTMLElement or Document instance.");
    if (typeof t != "boolean")
      throw new TypeError("'anchorHref' is not a boolean.");
    if (s !== void 0 && !vt(s))
      throw new TypeError("'ignoreClasses' is not an iterable list.");
    if (n !== void 0 && !(n instanceof Set))
      throw new TypeError("'ignoreElements' is not a Set.");
    if (l !== void 0 && typeof l != "string")
      throw new TypeError("'selectors' is not a string.");
    const r = l ?? Z(this, Up, D7).call(this, t), o = [...e.querySelectorAll(r)];
    return n && s ? o.filter((a) => {
      let c = !1;
      for (const u of s)
        if (a.classList.contains(u)) {
          c = !0;
          break;
        }
      return !c && !n.has(a) && a.style.display !== "none" && a.style.visibility !== "hidden" && !a.hasAttribute("disabled") && !a.hasAttribute("inert") && a.getAttribute("aria-hidden") !== "true";
    }) : s ? o.filter((a) => {
      let c = !1;
      for (const u of s)
        if (a.classList.contains(u)) {
          c = !0;
          break;
        }
      return !c && a.style.display !== "none" && a.style.visibility !== "hidden" && !a.hasAttribute("disabled") && !a.hasAttribute("inert") && a.getAttribute("aria-hidden") !== "true";
    }) : n ? o.filter((a) => !n.has(a) && a.style.display !== "none" && a.style.visibility !== "hidden" && !a.hasAttribute("disabled") && !a.hasAttribute("inert") && a.getAttribute("aria-hidden") !== "true") : o.filter((a) => a.style.display !== "none" && a.style.visibility !== "hidden" && !a.hasAttribute("disabled") && !a.hasAttribute("inert") && a.getAttribute("aria-hidden") !== "true");
  }
  /**
   * Gets a A11yFocusSource object from the given DOM event allowing for optional X / Y screen space overrides.
   * Browsers (Firefox / Chrome) forwards a mouse event for the context menu keyboard button. Provides detection of
   * when the context menu event is from the keyboard. Firefox as of (1/23) does not provide the correct screen space
   * coordinates, so for keyboard context menu presses coordinates are generated from the centroid point of the
   * element.
   *
   * A default fallback element or selector string may be provided to provide the focus target. If the event comes from
   * the keyboard however the source focused element is inserted as the target with the fallback value appended to the
   * list of focus targets. When A11yFocusSource is applied by {@link A11yHelper.applyFocusSource} the target focus
   * list is iterated through until a connected target is found and focus applied.
   *
   * @param {object} options - Options
   *
   * @param {KeyboardEvent|MouseEvent}   [options.event] - The source DOM event.
   *
   * @param {boolean} [options.debug] - When true {@link A11yHelper.applyFocusSource} logs focus target data.
   *
   * @param {HTMLElement|string} [options.focusEl] - A specific HTMLElement or selector string as the focus target.
   *
   * @param {number}   [options.x] - Used when an event isn't provided; integer of event source in screen space.
   *
   * @param {number}   [options.y] - Used when an event isn't provided; integer of event source in screen space.
   *
   * @returns {A11yFocusSource} A A11yFocusSource object.
   *
   * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1426671
   * @see https://bugzilla.mozilla.org/show_bug.cgi?id=314314
   *
   * TODO: Evaluate / test against touch input devices.
   */
  static getFocusSource({ event: e, x: t, y: s, focusEl: n, debug: l = !1 }) {
    if (n !== void 0 && !(n instanceof HTMLElement) && typeof n != "string")
      throw new TypeError(
        "A11yHelper.getFocusSource error: 'focusEl' is not a HTMLElement or string."
      );
    if (l !== void 0 && typeof l != "boolean")
      throw new TypeError("A11yHelper.getFocusSource error: 'debug' is not a boolean.");
    if (e === void 0) {
      if (typeof t != "number")
        throw new TypeError("A11yHelper.getFocusSource error: 'event' not defined and 'x' is not a number.");
      if (typeof s != "number")
        throw new TypeError("A11yHelper.getFocusSource error: 'event' not defined and 'y' is not a number.");
      return {
        debug: l,
        focusEl: n !== void 0 ? [n] : void 0,
        x: t,
        y: s
      };
    }
    if (!(e instanceof KeyboardEvent) && !(e instanceof MouseEvent))
      throw new TypeError("A11yHelper.getFocusSource error: 'event' is not a KeyboardEvent or MouseEvent.");
    if (t !== void 0 && !Number.isInteger(t))
      throw new TypeError("A11yHelper.getFocusSource error: 'x' is not a number.");
    if (s !== void 0 && !Number.isInteger(s))
      throw new TypeError("A11yHelper.getFocusSource error: 'y' is not a number.");
    const r = e.target;
    if (!(r instanceof HTMLElement))
      throw new TypeError("A11yHelper.getFocusSource error: 'event.target' is not an HTMLElement.");
    const o = { debug: l };
    if (e instanceof MouseEvent)
      if ((e == null ? void 0 : e.button) !== 2 && e.type === "contextmenu") {
        const a = r.getBoundingClientRect();
        o.x = t ?? a.left + a.width / 2, o.y = s ?? a.top + a.height / 2, o.focusEl = n !== void 0 ? [r, n] : [r], o.source = "keyboard";
      } else
        o.x = t ?? e.pageX, o.y = s ?? e.pageY, o.focusEl = n !== void 0 ? [n] : void 0;
    else {
      const a = r.getBoundingClientRect();
      o.x = t ?? a.left + a.width / 2, o.y = s ?? a.top + a.height / 2, o.focusEl = n !== void 0 ? [r, n] : [r], o.source = "keyboard";
    }
    return o;
  }
  /**
   * Returns first focusable element within a specified element.
   *
   * @param {HTMLElement|Document} [element=document] - Optional element to start query.
   *
   * @param {object} [options] - Optional parameters.
   *
   * @param {Iterable<string>} [options.ignoreClasses] - Iterable list of classes to ignore elements.
   *
   * @param {Set<HTMLElement>} [options.ignoreElements] - Set of elements to ignore.
   *
   * @returns {HTMLElement} First focusable child element
   */
  static getLastFocusableElement(e = document, t) {
    const s = this.getFocusableElements(e, t);
    return s.length > 0 ? s[s.length - 1] : void 0;
  }
  /**
   * Tests if the given element is focusable.
   *
   * @param {HTMLElement} [el] - Element to test.
   *
   * @param {object} [options] - Optional parameters.
   *
   * @param {boolean} [options.anchorHref=true] - When true anchors must have an HREF.
   *
   * @param {Iterable<string>} [options.ignoreClasses] - Iterable list of classes to ignore elements.
   *
   * @returns {boolean} Element is focusable.
   */
  static isFocusable(e, { anchorHref: t = !0, ignoreClasses: s } = {}) {
    if (e == null || !(e instanceof HTMLElement) || e != null && e.hidden || !(e != null && e.isConnected))
      return !1;
    if (typeof t != "boolean")
      throw new TypeError("'anchorHref' is not a boolean.");
    if (s !== void 0 && !vt(s))
      throw new TypeError("'ignoreClasses' is not an iterable list.");
    const n = e.getAttribute("contenteditable"), l = typeof n == "string" && (n === "" || n === "true"), r = e.getAttribute("tabindex"), o = typeof r == "string" && r !== "-1", a = e instanceof HTMLAnchorElement;
    return l || o || a || e instanceof HTMLButtonElement || e instanceof HTMLDetailsElement || e instanceof HTMLEmbedElement || e instanceof HTMLIFrameElement || e instanceof HTMLInputElement || e instanceof HTMLObjectElement || e instanceof HTMLSelectElement || e instanceof HTMLTextAreaElement ? a && t && typeof e.getAttribute("href") != "string" ? !1 : e.style.display !== "none" && e.style.visibility !== "hidden" && !e.hasAttribute("disabled") && !e.hasAttribute("inert") && e.getAttribute("aria-hidden") !== "true" : !1;
  }
  /**
   * Convenience method to check if the given data is a valid focus source.
   *
   * @param {HTMLElement|string}   data - Either an HTMLElement or selector string.
   *
   * @returns {boolean} Is valid focus source.
   */
  static isFocusSource(e) {
    return e instanceof HTMLElement || typeof e == "string";
  }
};
Up = new WeakSet(), D7 = /* @__PURE__ */ f(function(e = !0) {
  return `button, [contenteditable=""], [contenteditable="true"], details summary:not([tabindex="-1"]), embed, a${e ? "[href]" : ""}, iframe, object, input:not([type=hidden]), select, textarea, [tabindex]:not([tabindex="-1"])`;
}, "#getFocusableSelectors"), /**
 * Returns the default focusable selectors query.
 *
 * @param {boolean}  [anchorHref=true] - When true anchors must have an HREF.
 *
 * @returns {string} Focusable selectors for `querySelectorAll`.
 */
Y(Vp, Up), f(Vp, "A11yHelper");
let dn = Vp;
function xb(i) {
  if (!i || i.nodeName === "HTML")
    return { node: document.documentElement, reason: "root" };
  if (i.nodeName === "#document-fragment")
    return xb(i.host);
  const e = globalThis.getComputedStyle(i);
  if (e.position === "fixed" || e.position === "sticky")
    return { node: i, reason: `position: ${e.position}` };
  if (e.zIndex !== "auto" && e.position !== "static")
    return { node: i, reason: `position: ${e.position}; z-index: ${e.zIndex}` };
  if (e.opacity !== "1")
    return { node: i, reason: `opacity: ${e.opacity}` };
  if (e.transform !== "none")
    return { node: i, reason: `transform: ${e.transform}` };
  if (e.mixBlendMode !== "normal")
    return { node: i, reason: `mixBlendMode: ${e.mixBlendMode}` };
  if (e.filter !== "none")
    return { node: i, reason: `filter: ${e.filter}` };
  if (e.perspective !== "none")
    return { node: i, reason: `perspective: ${e.perspective}` };
  if (e.clipPath !== "none")
    return { node: i, reason: `clip-path: ${e.clipPath} ` };
  const t = e.mask || e.webkitMask;
  if (t !== "none" && t !== void 0)
    return { node: i, reason: `mask:  ${t}` };
  const s = e.maskImage || e.webkitMaskImage;
  if (s !== "none" && s !== void 0)
    return { node: i, reason: `mask-image: ${s}` };
  const n = e.maskBorder || e.webkitMaskBorder;
  if (n !== "none" && n !== void 0)
    return { node: i, reason: `mask-border: ${n}` };
  if (e.isolation === "isolate")
    return { node: i, reason: `isolation: ${e.isolation}` };
  if (e.willChange === "transform" || e.willChange === "opacity")
    return { node: i, reason: `willChange: ${e.willChange}` };
  if (e.webkitOverflowScrolling === "touch")
    return { node: i, reason: "-webkit-overflow-scrolling: touch" };
  if (e.zIndex !== "auto") {
    const r = globalThis.getComputedStyle(i.parentNode);
    if (r.display === "flex" || r.display === "inline-flex")
      return { node: i, reason: `flex-item; z-index: ${e.zIndex}` };
    if (r.grid !== "none / none / none / row / auto / auto")
      return { node: i, reason: `child of grid container; z-index: ${e.zIndex}` };
  }
  const l = e.contain;
  return ["layout", "paint", "strict", "content"].indexOf(l) > -1 || l.indexOf("paint") > -1 || l.indexOf("layout") > -1 ? { node: i, reason: `contain: ${l}` } : xb(i.parentNode);
}
f(xb, "getStackingContext");
var Wp;
const Kp = class Kp {
  /**
   * Parses a pixel string / computed styles. Ex. `100px` returns `100`.
   *
   * @param {string}   value - Value to parse.
   *
   * @returns {number|undefined} The integer component of a pixel string.
   */
  static pixels(e) {
    if (typeof e != "string")
      return;
    const t = M(this, Wp).test(e), s = parseInt(e);
    return t && Number.isFinite(s) ? s : void 0;
  }
};
Wp = new WeakMap(), f(Kp, "StyleParse"), Y(Kp, Wp, /(\d+)\s*px/);
let ot = Kp;
var as, yo, tu, en, vo;
const Yp = class Yp {
  /**
   *
   * @param {object}   opts - Options.
   *
   * @param {string}   opts.docKey - Required key providing a link to a specific style sheet element.
   *
   * @param {string}   [opts.selector=:root] - Selector element.
   *
   * @param {Document} [opts.document] - Target document to load styles into.
   *
   * @param {number}   [opts.version] - An integer representing the version / level of styles being managed.
   */
  constructor({ docKey: e, selector: t = ":root", document: s = globalThis.document, version: n } = {}) {
    /** @type {CSSStyleRule} */
    Y(this, as, void 0);
    /** @type {string} */
    Y(this, yo, void 0);
    /** @type {string} */
    Y(this, tu, void 0);
    /** @type {HTMLStyleElement} */
    Y(this, en, void 0);
    /** @type {number} */
    Y(this, vo, void 0);
    if (typeof e != "string")
      throw new TypeError("StyleManager error: 'docKey' is not a string.");
    if (typeof t != "string")
      throw new TypeError("StyleManager error: 'selector' is not a string.");
    if (n !== void 0 && !Number.isSafeInteger(n) && n < 1)
      throw new TypeError("StyleManager error: 'version' is defined and is not a positive integer >= 1.");
    if (ye(this, tu, t), ye(this, yo, e), ye(this, vo, n), s[M(this, yo)] === void 0)
      ye(this, en, s.createElement("style")), s.head.append(M(this, en)), M(this, en)._STYLE_MANAGER_VERSION = n, M(this, en).sheet.insertRule(`${t} {}`, 0), ye(this, as, M(this, en).sheet.cssRules[0]), s[e] = M(this, en);
    else if (ye(this, en, s[e]), ye(this, as, M(this, en).sheet.cssRules[0]), n) {
      const l = M(this, en)._STYLE_MANAGER_VERSION ?? 0;
      n > l && (M(this, as).style.cssText = "");
    }
  }
  /**
   * @returns {string} Provides an accessor to get the `cssText` for the style sheet.
   */
  get cssText() {
    return M(this, as).style.cssText;
  }
  /**
   * @returns {number} Returns the version of this instance.
   */
  get version() {
    return M(this, vo);
  }
  /**
   * Provides a copy constructor to duplicate an existing TJSStyleManager instance into a new document.
   *
   * Note: This is used to support the `PopOut` module.
   *
   * @param {Document} [document] Target browser document to clone into.
   *
   * @returns {TJSStyleManager} New style manager instance.
   */
  clone(e = globalThis.document) {
    const t = new Yp({
      selector: M(this, tu),
      docKey: M(this, yo),
      document: e,
      version: M(this, vo)
    });
    return M(t, as).style.cssText = M(this, as).style.cssText, t;
  }
  get() {
    const e = M(this, as).style.cssText, t = {};
    if (e !== "") {
      for (const s of e.split(";"))
        if (s !== "") {
          const n = s.split(":");
          t[n[0].trim()] = n[1];
        }
    }
    return t;
  }
  /**
   * Gets a particular CSS variable.
   *
   * @param {string}   key - CSS variable property key.
   *
   * @returns {string} Returns CSS variable value.
   */
  getProperty(e) {
    if (typeof e != "string")
      throw new TypeError("StyleManager error: 'key' is not a string.");
    return M(this, as).style.getPropertyValue(e);
  }
  /**
   * Set rules by property / value; useful for CSS variables.
   *
   * @param {{ [key: string]: string }}  rules - An object with property / value string pairs to load.
   *
   * @param {boolean}                 [overwrite=true] - When true overwrites any existing values.
   */
  setProperties(e, t = !0) {
    if (!ke(e))
      throw new TypeError("StyleManager error: 'rules' is not an object.");
    if (typeof t != "boolean")
      throw new TypeError("StyleManager error: 'overwrite' is not a boolean.");
    if (t)
      for (const [s, n] of Object.entries(e))
        M(this, as).style.setProperty(s, n);
    else
      for (const [s, n] of Object.entries(e))
        M(this, as).style.getPropertyValue(s) === "" && M(this, as).style.setProperty(s, n);
  }
  /**
   * Sets a particular property.
   *
   * @param {string}   key - CSS variable property key.
   *
   * @param {string}   value - CSS variable value.
   *
   * @param {boolean}  [overwrite=true] - Overwrite any existing value.
   */
  setProperty(e, t, s = !0) {
    if (typeof e != "string")
      throw new TypeError("StyleManager error: 'key' is not a string.");
    if (typeof t != "string")
      throw new TypeError("StyleManager error: 'value' is not a string.");
    if (typeof s != "boolean")
      throw new TypeError("StyleManager error: 'overwrite' is not a boolean.");
    s ? M(this, as).style.setProperty(e, t) : M(this, as).style.getPropertyValue(e) === "" && M(this, as).style.setProperty(e, t);
  }
  /**
   * Removes the property keys specified. If `keys` is an iterable list then all property keys in the list are removed.
   *
   * @param {Iterable<string>} keys - The property keys to remove.
   */
  removeProperties(e) {
    if (!vt(e))
      throw new TypeError("StyleManager error: 'keys' is not an iterable list.");
    for (const t of e)
      typeof t == "string" && M(this, as).style.removeProperty(t);
  }
  /**
   * Removes a particular CSS variable.
   *
   * @param {string}   key - CSS variable property key.
   *
   * @returns {string} CSS variable value when removed.
   */
  removeProperty(e) {
    if (typeof e != "string")
      throw new TypeError("StyleManager error: 'key' is not a string.");
    return M(this, as).style.removeProperty(e);
  }
};
as = new WeakMap(), yo = new WeakMap(), tu = new WeakMap(), en = new WeakMap(), vo = new WeakMap(), f(Yp, "TJSStyleManager");
let Pd = Yp;
const Wt = 1e-6, FO = new Float32Array([
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1
]), Vt = class Vt extends Float32Array {
  /**
   * Create a {@link Mat4}.
   */
  constructor(...e) {
    switch (e.length) {
      case 16:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 16);
        break;
      case 1:
        const t = e[0];
        typeof t == "number" ? super([
          t,
          t,
          t,
          t,
          t,
          t,
          t,
          t,
          t,
          t,
          t,
          t,
          t,
          t,
          t,
          t
        ]) : super(t, 0, 16);
        break;
      default:
        super(FO);
        break;
    }
  }
  //============
  // Attributes
  //============
  /**
   * A string representation of `this`
   * Equivalent to `Mat4.str(this);`
   */
  get str() {
    return Vt.str(this);
  }
  //===================
  // Instance methods
  //===================
  /**
   * Copy the values from another {@link Mat4} into `this`.
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(e) {
    return this.set(e), this;
  }
  /**
   * Set `this` to the identity matrix
   * Equivalent to Mat4.identity(this)
   *
   * @returns `this`
   */
  identity() {
    return this.set(FO), this;
  }
  /**
   * Multiplies this {@link Mat4} against another one
   * Equivalent to `Mat4.multiply(this, this, b);`
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `this`
   */
  multiply(e) {
    return Vt.multiply(this, this, e);
  }
  /**
   * Alias for {@link Mat4.multiply}
   */
  mul(e) {
    return this;
  }
  /**
   * Transpose this {@link Mat4}
   * Equivalent to `Mat4.transpose(this, this);`
   *
   * @returns `this`
   */
  transpose() {
    return Vt.transpose(this, this);
  }
  /**
   * Inverts this {@link Mat4}
   * Equivalent to `Mat4.invert(this, this);`
   *
   * @returns `this`
   */
  invert() {
    return Vt.invert(this, this);
  }
  /**
   * Translate this {@link Mat4} by the given vector
   * Equivalent to `Mat4.translate(this, this, v);`
   *
   * @param v - The {@link Vec3} to translate by
   * @returns `this`
   */
  translate(e) {
    return Vt.translate(this, this, e);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the given axis
   * Equivalent to `Mat4.rotate(this, this, rad, axis);`
   *
   * @param rad - the angle to rotate the matrix by
   * @param axis - the axis to rotate around
   * @returns `out`
   */
  rotate(e, t) {
    return Vt.rotate(this, this, e, t);
  }
  /**
   * Scales this {@link Mat4} by the dimensions in the given vec3 not using vectorization
   * Equivalent to `Mat4.scale(this, this, v);`
   *
   * @param v - The {@link Vec3} to scale the matrix by
   * @returns `this`
   */
  scale(e) {
    return Vt.scale(this, this, e);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the X axis
   * Equivalent to `Mat4.rotateX(this, this, rad);`
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `this`
   */
  rotateX(e) {
    return Vt.rotateX(this, this, e);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the Y axis
   * Equivalent to `Mat4.rotateY(this, this, rad);`
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `this`
   */
  rotateY(e) {
    return Vt.rotateY(this, this, e);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the Z axis
   * Equivalent to `Mat4.rotateZ(this, this, rad);`
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `this`
   */
  rotateZ(e) {
    return Vt.rotateZ(this, this, e);
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * Equivalent to `Mat4.perspectiveNO(this, fovy, aspect, near, far);`
   *
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `this`
   */
  perspectiveNO(e, t, s, n) {
    return Vt.perspectiveNO(this, e, t, s, n);
  }
  /**
   * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * Equivalent to `Mat4.perspectiveZO(this, fovy, aspect, near, far);`
   *
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `this`
   */
  perspectiveZO(e, t, s, n) {
    return Vt.perspectiveZO(this, e, t, s, n);
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Equivalent to `Mat4.orthoNO(this, left, right, bottom, top, near, far);`
   *
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `this`
   */
  orthoNO(e, t, s, n, l, r) {
    return Vt.orthoNO(this, e, t, s, n, l, r);
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Equivalent to `Mat4.orthoZO(this, left, right, bottom, top, near, far);`
   *
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `this`
   */
  orthoZO(e, t, s, n, l, r) {
    return Vt.orthoZO(this, e, t, s, n, l, r);
  }
  //================
  // Static methods
  //================
  /**
   * Creates a new, identity {@link Mat4}
   * @category Static
   *
   * @returns A new {@link Mat4}
   */
  static create() {
    return new Vt();
  }
  /**
   * Creates a new {@link Mat4} initialized with values from an existing matrix
   * @category Static
   *
   * @param a - Matrix to clone
   * @returns A new {@link Mat4}
   */
  static clone(e) {
    return new Vt(e);
  }
  /**
   * Copy the values from one {@link Mat4} to another
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - Matrix to copy
   * @returns `out`
   */
  static copy(e, t) {
    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
  }
  /**
   * Create a new mat4 with the given values
   * @category Static
   *
   * @param values - Matrix components
   * @returns A new {@link Mat4}
   */
  static fromValues(...e) {
    return new Vt(...e);
  }
  /**
   * Set the components of a mat4 to the given values
   * @category Static
   *
   * @param out - The receiving matrix
   * @param values - Matrix components
   * @returns `out`
   */
  static set(e, ...t) {
    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
  }
  /**
   * Set a {@link Mat4} to the identity matrix
   * @category Static
   *
   * @param out - The receiving Matrix
   * @returns `out`
   */
  static identity(e) {
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Transpose the values of a {@link Mat4}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static transpose(e, t) {
    if (e === t) {
      const s = t[1], n = t[2], l = t[3], r = t[6], o = t[7], a = t[11];
      e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = s, e[6] = t[9], e[7] = t[13], e[8] = n, e[9] = r, e[11] = t[14], e[12] = l, e[13] = o, e[14] = a;
    } else
      e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];
    return e;
  }
  /**
   * Inverts a {@link Mat4}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static invert(e, t) {
    const s = t[0], n = t[1], l = t[2], r = t[3], o = t[4], a = t[5], c = t[6], u = t[7], d = t[8], p = t[9], m = t[10], g = t[11], h = t[12], _ = t[13], y = t[14], k = t[15], v = s * a - n * o, O = s * c - l * o, P = s * u - r * o, D = n * c - l * a, I = n * u - r * a, B = l * u - r * c, F = d * _ - p * h, H = d * y - m * h, G = d * k - g * h, U = p * y - m * _, q = p * k - g * _, W = m * k - g * y;
    let X = v * W - O * q + P * U + D * G - I * H + B * F;
    return X ? (X = 1 / X, e[0] = (a * W - c * q + u * U) * X, e[1] = (l * q - n * W - r * U) * X, e[2] = (_ * B - y * I + k * D) * X, e[3] = (m * I - p * B - g * D) * X, e[4] = (c * G - o * W - u * H) * X, e[5] = (s * W - l * G + r * H) * X, e[6] = (y * P - h * B - k * O) * X, e[7] = (d * B - m * P + g * O) * X, e[8] = (o * q - a * G + u * F) * X, e[9] = (n * G - s * q - r * F) * X, e[10] = (h * I - _ * P + k * v) * X, e[11] = (p * P - d * I - g * v) * X, e[12] = (a * H - o * U - c * F) * X, e[13] = (s * U - n * H + l * F) * X, e[14] = (_ * O - h * D - y * v) * X, e[15] = (d * D - p * O + m * v) * X, e) : null;
  }
  /**
   * Calculates the adjugate of a {@link Mat4}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static adjoint(e, t) {
    const s = t[0], n = t[1], l = t[2], r = t[3], o = t[4], a = t[5], c = t[6], u = t[7], d = t[8], p = t[9], m = t[10], g = t[11], h = t[12], _ = t[13], y = t[14], k = t[15], v = s * a - n * o, O = s * c - l * o, P = s * u - r * o, D = n * c - l * a, I = n * u - r * a, B = l * u - r * c, F = d * _ - p * h, H = d * y - m * h, G = d * k - g * h, U = p * y - m * _, q = p * k - g * _, W = m * k - g * y;
    return e[0] = a * W - c * q + u * U, e[1] = l * q - n * W - r * U, e[2] = _ * B - y * I + k * D, e[3] = m * I - p * B - g * D, e[4] = c * G - o * W - u * H, e[5] = s * W - l * G + r * H, e[6] = y * P - h * B - k * O, e[7] = d * B - m * P + g * O, e[8] = o * q - a * G + u * F, e[9] = n * G - s * q - r * F, e[10] = h * I - _ * P + k * v, e[11] = p * P - d * I - g * v, e[12] = a * H - o * U - c * F, e[13] = s * U - n * H + l * F, e[14] = _ * O - h * D - y * v, e[15] = d * D - p * O + m * v, e;
  }
  /**
   * Calculates the determinant of a {@link Mat4}
   * @category Static
   *
   * @param a - the source matrix
   * @returns determinant of a
   */
  static determinant(e) {
    const t = e[0], s = e[1], n = e[2], l = e[3], r = e[4], o = e[5], a = e[6], c = e[7], u = e[8], d = e[9], p = e[10], m = e[11], g = e[12], h = e[13], _ = e[14], y = e[15], k = t * o - s * r, v = t * a - n * r, O = s * a - n * o, P = u * h - d * g, D = u * _ - p * g, I = d * _ - p * h, B = t * I - s * D + n * P, F = r * I - o * D + a * P, H = u * O - d * v + p * k, G = g * O - h * v + _ * k;
    return c * B - l * F + y * H - m * G;
  }
  /**
   * Multiplies two {@link Mat4}s
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static multiply(e, t, s) {
    const n = t[0], l = t[1], r = t[2], o = t[3], a = t[4], c = t[5], u = t[6], d = t[7], p = t[8], m = t[9], g = t[10], h = t[11], _ = t[12], y = t[13], k = t[14], v = t[15];
    let O = s[0], P = s[1], D = s[2], I = s[3];
    return e[0] = O * n + P * a + D * p + I * _, e[1] = O * l + P * c + D * m + I * y, e[2] = O * r + P * u + D * g + I * k, e[3] = O * o + P * d + D * h + I * v, O = s[4], P = s[5], D = s[6], I = s[7], e[4] = O * n + P * a + D * p + I * _, e[5] = O * l + P * c + D * m + I * y, e[6] = O * r + P * u + D * g + I * k, e[7] = O * o + P * d + D * h + I * v, O = s[8], P = s[9], D = s[10], I = s[11], e[8] = O * n + P * a + D * p + I * _, e[9] = O * l + P * c + D * m + I * y, e[10] = O * r + P * u + D * g + I * k, e[11] = O * o + P * d + D * h + I * v, O = s[12], P = s[13], D = s[14], I = s[15], e[12] = O * n + P * a + D * p + I * _, e[13] = O * l + P * c + D * m + I * y, e[14] = O * r + P * u + D * g + I * k, e[15] = O * o + P * d + D * h + I * v, e;
  }
  /**
   * Alias for {@link Mat4.multiply}
   * @category Static
   */
  static mul(e, t, s) {
    return e;
  }
  /**
   * Translate a {@link Mat4} by the given vector
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to translate
   * @param v - vector to translate by
   * @returns `out`
   */
  static translate(e, t, s) {
    const n = s[0], l = s[1], r = s[2];
    if (t === e)
      e[12] = t[0] * n + t[4] * l + t[8] * r + t[12], e[13] = t[1] * n + t[5] * l + t[9] * r + t[13], e[14] = t[2] * n + t[6] * l + t[10] * r + t[14], e[15] = t[3] * n + t[7] * l + t[11] * r + t[15];
    else {
      const o = t[0], a = t[1], c = t[2], u = t[3], d = t[4], p = t[5], m = t[6], g = t[7], h = t[8], _ = t[9], y = t[10], k = t[11];
      e[0] = o, e[1] = a, e[2] = c, e[3] = u, e[4] = d, e[5] = p, e[6] = m, e[7] = g, e[8] = h, e[9] = _, e[10] = y, e[11] = k, e[12] = o * n + d * l + h * r + t[12], e[13] = a * n + p * l + _ * r + t[13], e[14] = c * n + m * l + y * r + t[14], e[15] = u * n + g * l + k * r + t[15];
    }
    return e;
  }
  /**
   * Scales the {@link Mat4} by the dimensions in the given {@link Vec3} not using vectorization
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param v - the {@link Vec3} to scale the matrix by
   * @returns `out`
   **/
  static scale(e, t, s) {
    const n = s[0], l = s[1], r = s[2];
    return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e[4] = t[4] * l, e[5] = t[5] * l, e[6] = t[6] * l, e[7] = t[7] * l, e[8] = t[8] * r, e[9] = t[9] * r, e[10] = t[10] * r, e[11] = t[11] * r, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
  }
  /**
   * Rotates a {@link Mat4} by the given angle around the given axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @param axis - the axis to rotate around
   * @returns `out`
   */
  static rotate(e, t, s, n) {
    let l = n[0], r = n[1], o = n[2], a = Math.sqrt(l * l + r * r + o * o);
    if (a < Wt)
      return null;
    a = 1 / a, l *= a, r *= a, o *= a;
    const c = Math.sin(s), u = Math.cos(s), d = 1 - u, p = t[0], m = t[1], g = t[2], h = t[3], _ = t[4], y = t[5], k = t[6], v = t[7], O = t[8], P = t[9], D = t[10], I = t[11], B = l * l * d + u, F = r * l * d + o * c, H = o * l * d - r * c, G = l * r * d - o * c, U = r * r * d + u, q = o * r * d + l * c, W = l * o * d + r * c, X = r * o * d - l * c, te = o * o * d + u;
    return e[0] = p * B + _ * F + O * H, e[1] = m * B + y * F + P * H, e[2] = g * B + k * F + D * H, e[3] = h * B + v * F + I * H, e[4] = p * G + _ * U + O * q, e[5] = m * G + y * U + P * q, e[6] = g * G + k * U + D * q, e[7] = h * G + v * U + I * q, e[8] = p * W + _ * X + O * te, e[9] = m * W + y * X + P * te, e[10] = g * W + k * X + D * te, e[11] = h * W + v * X + I * te, t !== e && (e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e;
  }
  /**
   * Rotates a matrix by the given angle around the X axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotateX(e, t, s) {
    let n = Math.sin(s), l = Math.cos(s), r = t[4], o = t[5], a = t[6], c = t[7], u = t[8], d = t[9], p = t[10], m = t[11];
    return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = r * l + u * n, e[5] = o * l + d * n, e[6] = a * l + p * n, e[7] = c * l + m * n, e[8] = u * l - r * n, e[9] = d * l - o * n, e[10] = p * l - a * n, e[11] = m * l - c * n, e;
  }
  /**
   * Rotates a matrix by the given angle around the Y axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotateY(e, t, s) {
    let n = Math.sin(s), l = Math.cos(s), r = t[0], o = t[1], a = t[2], c = t[3], u = t[8], d = t[9], p = t[10], m = t[11];
    return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = r * l - u * n, e[1] = o * l - d * n, e[2] = a * l - p * n, e[3] = c * l - m * n, e[8] = r * n + u * l, e[9] = o * n + d * l, e[10] = a * n + p * l, e[11] = c * n + m * l, e;
  }
  /**
   * Rotates a matrix by the given angle around the Z axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotateZ(e, t, s) {
    let n = Math.sin(s), l = Math.cos(s), r = t[0], o = t[1], a = t[2], c = t[3], u = t[4], d = t[5], p = t[6], m = t[7];
    return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = r * l + u * n, e[1] = o * l + d * n, e[2] = a * l + p * n, e[3] = c * l + m * n, e[4] = u * l - r * n, e[5] = d * l - o * n, e[6] = p * l - a * n, e[7] = m * l - c * n, e;
  }
  /**
   * Creates a {@link Mat4} from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, dest, vec);
   * @category Static
   *
   * @param out - {@link Mat4} receiving operation result
   * @param v - Translation vector
   * @returns `out`
   */
  static fromTranslation(e, t) {
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = t[0], e[13] = t[1], e[14] = t[2], e[15] = 1, e;
  }
  /**
   * Creates a {@link Mat4} from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.scale(dest, dest, vec);
   * @category Static
   *
   * @param out - {@link Mat4} receiving operation result
   * @param v - Scaling vector
   * @returns `out`
   */
  static fromScaling(e, t) {
    return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a {@link Mat4} from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotate(dest, dest, rad, axis);
   * @category Static
   *
   * @param out - {@link Mat4} receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @param axis - the axis to rotate around
   * @returns `out`
   */
  static fromRotation(e, t, s) {
    let n = s[0], l = s[1], r = s[2], o = Math.sqrt(n * n + l * l + r * r);
    if (o < Wt)
      return null;
    o = 1 / o, n *= o, l *= o, r *= o;
    const a = Math.sin(t), c = Math.cos(t), u = 1 - c;
    return e[0] = n * n * u + c, e[1] = l * n * u + r * a, e[2] = r * n * u - l * a, e[3] = 0, e[4] = n * l * u - r * a, e[5] = l * l * u + c, e[6] = r * l * u + n * a, e[7] = 0, e[8] = n * r * u + l * a, e[9] = l * r * u - n * a, e[10] = r * r * u + c, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a matrix from the given angle around the X axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateX(dest, dest, rad);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromXRotation(e, t) {
    let s = Math.sin(t), n = Math.cos(t);
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = n, e[6] = s, e[7] = 0, e[8] = 0, e[9] = -s, e[10] = n, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a matrix from the given angle around the Y axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateY(dest, dest, rad);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromYRotation(e, t) {
    let s = Math.sin(t), n = Math.cos(t);
    return e[0] = n, e[1] = 0, e[2] = -s, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = s, e[9] = 0, e[10] = n, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a matrix from the given angle around the Z axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateZ(dest, dest, rad);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromZRotation(e, t) {
    const s = Math.sin(t), n = Math.cos(t);
    return e[0] = n, e[1] = s, e[2] = 0, e[3] = 0, e[4] = -s, e[5] = n, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Creates a matrix from a quaternion rotation and vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Rotation quaternion
   * @param v - Translation vector
   * @returns `out`
   */
  static fromRotationTranslation(e, t, s) {
    const n = t[0], l = t[1], r = t[2], o = t[3], a = n + n, c = l + l, u = r + r, d = n * a, p = n * c, m = n * u, g = l * c, h = l * u, _ = r * u, y = o * a, k = o * c, v = o * u;
    return e[0] = 1 - (g + _), e[1] = p + v, e[2] = m - k, e[3] = 0, e[4] = p - v, e[5] = 1 - (d + _), e[6] = h + y, e[7] = 0, e[8] = m + k, e[9] = h - y, e[10] = 1 - (d + g), e[11] = 0, e[12] = s[0], e[13] = s[1], e[14] = s[2], e[15] = 1, e;
  }
  /**
   * Sets a {@link Mat4} from a {@link Quat2}.
   * @category Static
   *
   * @param out - Matrix
   * @param a - Dual Quaternion
   * @returns `out`
   */
  static fromQuat2(e, t) {
    let s = [0, 0, 0];
    const n = -t[0], l = -t[1], r = -t[2], o = t[3], a = t[4], c = t[5], u = t[6], d = t[7];
    let p = n * n + l * l + r * r + o * o;
    return p > 0 ? (s[0] = (a * o + d * n + c * r - u * l) * 2 / p, s[1] = (c * o + d * l + u * n - a * r) * 2 / p, s[2] = (u * o + d * r + a * l - c * n) * 2 / p) : (s[0] = (a * o + d * n + c * r - u * l) * 2, s[1] = (c * o + d * l + u * n - a * r) * 2, s[2] = (u * o + d * r + a * l - c * n) * 2), Vt.fromRotationTranslation(e, t, s), e;
  }
  /**
   * Returns the translation vector component of a transformation
   * matrix. If a matrix is built with fromRotationTranslation,
   * the returned vector will be the same as the translation vector
   * originally supplied.
   * @category Static
   *
   * @param  {vec3} out Vector to receive translation component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */
  static getTranslation(e, t) {
    return e[0] = t[12], e[1] = t[13], e[2] = t[14], e;
  }
  /**
   * Returns the scaling factor component of a transformation
   * matrix. If a matrix is built with fromRotationTranslationScale
   * with a normalized Quaternion paramter, the returned vector will be
   * the same as the scaling vector
   * originally supplied.
   * @category Static
   *
   * @param  {vec3} out Vector to receive scaling factor component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */
  static getScaling(e, t) {
    const s = t[0], n = t[1], l = t[2], r = t[4], o = t[5], a = t[6], c = t[8], u = t[9], d = t[10];
    return e[0] = Math.sqrt(s * s + n * n + l * l), e[1] = Math.sqrt(r * r + o * o + a * a), e[2] = Math.sqrt(c * c + u * u + d * d), e;
  }
  /**
   * Returns a quaternion representing the rotational component
   * of a transformation matrix. If a matrix is built with
   * fromRotationTranslation, the returned quaternion will be the
   * same as the quaternion originally supplied.
   * @category Static
   *
   * @param out - Quaternion to receive the rotation component
   * @param mat - Matrix to be decomposed (input)
   * @return `out`
   */
  static getRotation(e, t) {
    Vt.getScaling(Gf, t);
    const s = 1 / Gf[0], n = 1 / Gf[1], l = 1 / Gf[2], r = t[0] * s, o = t[1] * n, a = t[2] * l, c = t[4] * s, u = t[5] * n, d = t[6] * l, p = t[8] * s, m = t[9] * n, g = t[10] * l, h = r + u + g;
    let _ = 0;
    return h > 0 ? (_ = Math.sqrt(h + 1) * 2, e[3] = 0.25 * _, e[0] = (d - m) / _, e[1] = (p - a) / _, e[2] = (o - c) / _) : r > u && r > g ? (_ = Math.sqrt(1 + r - u - g) * 2, e[3] = (d - m) / _, e[0] = 0.25 * _, e[1] = (o + c) / _, e[2] = (p + a) / _) : u > g ? (_ = Math.sqrt(1 + u - r - g) * 2, e[3] = (p - a) / _, e[0] = (o + c) / _, e[1] = 0.25 * _, e[2] = (d + m) / _) : (_ = Math.sqrt(1 + g - r - u) * 2, e[3] = (o - c) / _, e[0] = (p + a) / _, e[1] = (d + m) / _, e[2] = 0.25 * _), e;
  }
  /**
   * Decomposes a transformation matrix into its rotation, translation
   * and scale components. Returns only the rotation component
   * @category Static
   *
   * @param out_r - Quaternion to receive the rotation component
   * @param out_t - Vector to receive the translation vector
   * @param out_s - Vector to receive the scaling factor
   * @param mat - Matrix to be decomposed (input)
   * @returns `out_r`
   */
  static decompose(e, t, s, n) {
    t[0] = n[12], t[1] = n[13], t[2] = n[14];
    const l = n[0], r = n[1], o = n[2], a = n[4], c = n[5], u = n[6], d = n[8], p = n[9], m = n[10];
    s[0] = Math.sqrt(l * l + r * r + o * o), s[1] = Math.sqrt(a * a + c * c + u * u), s[2] = Math.sqrt(d * d + p * p + m * m);
    const g = 1 / s[0], h = 1 / s[1], _ = 1 / s[2], y = l * g, k = r * h, v = o * _, O = a * g, P = c * h, D = u * _, I = d * g, B = p * h, F = m * _, H = y + P + F;
    let G = 0;
    return H > 0 ? (G = Math.sqrt(H + 1) * 2, e[3] = 0.25 * G, e[0] = (D - B) / G, e[1] = (I - v) / G, e[2] = (k - O) / G) : y > P && y > F ? (G = Math.sqrt(1 + y - P - F) * 2, e[3] = (D - B) / G, e[0] = 0.25 * G, e[1] = (k + O) / G, e[2] = (I + v) / G) : P > F ? (G = Math.sqrt(1 + P - y - F) * 2, e[3] = (I - v) / G, e[0] = (k + O) / G, e[1] = 0.25 * G, e[2] = (D + B) / G) : (G = Math.sqrt(1 + F - y - P) * 2, e[3] = (k - O) / G, e[0] = (I + v) / G, e[1] = (D + B) / G, e[2] = 0.25 * G), e;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Rotation quaternion
   * @param v - Translation vector
   * @param s - Scaling vector
   * @returns `out`
   */
  static fromRotationTranslationScale(e, t, s, n) {
    const l = t[0], r = t[1], o = t[2], a = t[3], c = l + l, u = r + r, d = o + o, p = l * c, m = l * u, g = l * d, h = r * u, _ = r * d, y = o * d, k = a * c, v = a * u, O = a * d, P = n[0], D = n[1], I = n[2];
    return e[0] = (1 - (h + y)) * P, e[1] = (m + O) * P, e[2] = (g - v) * P, e[3] = 0, e[4] = (m - O) * D, e[5] = (1 - (p + y)) * D, e[6] = (_ + k) * D, e[7] = 0, e[8] = (g + v) * I, e[9] = (_ - k) * I, e[10] = (1 - (p + h)) * I, e[11] = 0, e[12] = s[0], e[13] = s[1], e[14] = s[2], e[15] = 1, e;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     mat4.translate(dest, origin);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *     mat4.translate(dest, negativeOrigin);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Rotation quaternion
   * @param v - Translation vector
   * @param s - Scaling vector
   * @param o - The origin vector around which to scale and rotate
   * @returns `out`
   */
  static fromRotationTranslationScaleOrigin(e, t, s, n, l) {
    const r = t[0], o = t[1], a = t[2], c = t[3], u = r + r, d = o + o, p = a + a, m = r * u, g = r * d, h = r * p, _ = o * d, y = o * p, k = a * p, v = c * u, O = c * d, P = c * p, D = n[0], I = n[1], B = n[2], F = l[0], H = l[1], G = l[2], U = (1 - (_ + k)) * D, q = (g + P) * D, W = (h - O) * D, X = (g - P) * I, te = (1 - (m + k)) * I, J = (y + v) * I, re = (h + O) * B, ae = (y - v) * B, be = (1 - (m + _)) * B;
    return e[0] = U, e[1] = q, e[2] = W, e[3] = 0, e[4] = X, e[5] = te, e[6] = J, e[7] = 0, e[8] = re, e[9] = ae, e[10] = be, e[11] = 0, e[12] = s[0] + F - (U * F + X * H + re * G), e[13] = s[1] + H - (q * F + te * H + ae * G), e[14] = s[2] + G - (W * F + J * H + be * G), e[15] = 1, e;
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Quaternion to create matrix from
   * @returns `out`
   */
  static fromQuat(e, t) {
    const s = t[0], n = t[1], l = t[2], r = t[3], o = s + s, a = n + n, c = l + l, u = s * o, d = n * o, p = n * a, m = l * o, g = l * a, h = l * c, _ = r * o, y = r * a, k = r * c;
    return e[0] = 1 - p - h, e[1] = d + k, e[2] = m - y, e[3] = 0, e[4] = d - k, e[5] = 1 - u - h, e[6] = g + _, e[7] = 0, e[8] = m + y, e[9] = g - _, e[10] = 1 - u - p, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   * Generates a frustum matrix with the given bounds
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   */
  static frustum(e, t, s, n, l, r, o) {
    const a = 1 / (s - t), c = 1 / (l - n), u = 1 / (r - o);
    return e[0] = r * 2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = r * 2 * c, e[6] = 0, e[7] = 0, e[8] = (s + t) * a, e[9] = (l + n) * c, e[10] = (o + r) * u, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = o * r * 2 * u, e[15] = 0, e;
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static perspectiveNO(e, t, s, n, l) {
    const r = 1 / Math.tan(t / 2);
    if (e[0] = r / s, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = r, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, l != null && l !== 1 / 0) {
      const o = 1 / (n - l);
      e[10] = (l + n) * o, e[14] = 2 * l * n * o;
    } else
      e[10] = -1, e[14] = -2 * n;
    return e;
  }
  /**
   * Alias for {@link Mat4.perspectiveNO}
   * @category Static
   * @deprecated Use {@link Mat4.perspectiveNO} or {@link Mat4.perspectiveZO} explicitly
   */
  static perspective(e, t, s, n, l) {
    return e;
  }
  /**
   * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static perspectiveZO(e, t, s, n, l) {
    const r = 1 / Math.tan(t / 2);
    if (e[0] = r / s, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = r, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, l != null && l !== 1 / 0) {
      const o = 1 / (n - l);
      e[10] = l * o, e[14] = l * n * o;
    } else
      e[10] = -1, e[14] = -n;
    return e;
  }
  /**
   * Generates a perspective projection matrix with the given field of view.
   * This is primarily useful for generating projection matrices to be used
   * with the still experiemental WebVR API.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param fov - Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   * @deprecated
   */
  static perspectiveFromFieldOfView(e, t, s, n) {
    const l = Math.tan(t.upDegrees * Math.PI / 180), r = Math.tan(t.downDegrees * Math.PI / 180), o = Math.tan(t.leftDegrees * Math.PI / 180), a = Math.tan(t.rightDegrees * Math.PI / 180), c = 2 / (o + a), u = 2 / (l + r);
    return e[0] = c, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = u, e[6] = 0, e[7] = 0, e[8] = -((o - a) * c * 0.5), e[9] = (l - r) * u * 0.5, e[10] = n / (s - n), e[11] = -1, e[12] = 0, e[13] = 0, e[14] = n * s / (s - n), e[15] = 0, e;
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   */
  static orthoNO(e, t, s, n, l, r, o) {
    const a = 1 / (t - s), c = 1 / (n - l), u = 1 / (r - o);
    return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * u, e[11] = 0, e[12] = (t + s) * a, e[13] = (l + n) * c, e[14] = (o + r) * u, e[15] = 1, e;
  }
  /**
   * Alias for {@link Mat4.orthoNO}
   * @category Static
   * @deprecated Use {@link Mat4.orthoNO} or {@link Mat4.orthoZO} explicitly
   */
  static ortho(e, t, s, n, l, r, o) {
    return e;
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   */
  static orthoZO(e, t, s, n, l, r, o) {
    const a = 1 / (t - s), c = 1 / (n - l), u = 1 / (r - o);
    return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = u, e[11] = 0, e[12] = (t + s) * a, e[13] = (l + n) * c, e[14] = r * u, e[15] = 1, e;
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point, and up axis.
   * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param eye - Position of the viewer
   * @param center - Point the viewer is looking at
   * @param up - vec3 pointing up
   * @returns `out`
   */
  static lookAt(e, t, s, n) {
    const l = t[0], r = t[1], o = t[2], a = n[0], c = n[1], u = n[2], d = s[0], p = s[1], m = s[2];
    if (Math.abs(l - d) < Wt && Math.abs(r - p) < Wt && Math.abs(o - m) < Wt)
      return Vt.identity(e);
    let g = l - d, h = r - p, _ = o - m, y = 1 / Math.sqrt(g * g + h * h + _ * _);
    g *= y, h *= y, _ *= y;
    let k = c * _ - u * h, v = u * g - a * _, O = a * h - c * g;
    y = Math.sqrt(k * k + v * v + O * O), y ? (y = 1 / y, k *= y, v *= y, O *= y) : (k = 0, v = 0, O = 0);
    let P = h * O - _ * v, D = _ * k - g * O, I = g * v - h * k;
    return y = Math.sqrt(P * P + D * D + I * I), y ? (y = 1 / y, P *= y, D *= y, I *= y) : (P = 0, D = 0, I = 0), e[0] = k, e[1] = P, e[2] = g, e[3] = 0, e[4] = v, e[5] = D, e[6] = h, e[7] = 0, e[8] = O, e[9] = I, e[10] = _, e[11] = 0, e[12] = -(k * l + v * r + O * o), e[13] = -(P * l + D * r + I * o), e[14] = -(g * l + h * r + _ * o), e[15] = 1, e;
  }
  /**
   * Generates a matrix that makes something look at something else.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param eye - Position of the viewer
   * @param target - Point the viewer is looking at
   * @param up - vec3 pointing up
   * @returns `out`
   */
  static targetTo(e, t, s, n) {
    const l = t[0], r = t[1], o = t[2], a = n[0], c = n[1], u = n[2];
    let d = l - s[0], p = r - s[1], m = o - s[2], g = d * d + p * p + m * m;
    g > 0 && (g = 1 / Math.sqrt(g), d *= g, p *= g, m *= g);
    let h = c * m - u * p, _ = u * d - a * m, y = a * p - c * d;
    return g = h * h + _ * _ + y * y, g > 0 && (g = 1 / Math.sqrt(g), h *= g, _ *= g, y *= g), e[0] = h, e[1] = _, e[2] = y, e[3] = 0, e[4] = p * y - m * _, e[5] = m * h - d * y, e[6] = d * _ - p * h, e[7] = 0, e[8] = d, e[9] = p, e[10] = m, e[11] = 0, e[12] = l, e[13] = r, e[14] = o, e[15] = 1, e;
  }
  /**
   * Returns Frobenius norm of a {@link Mat4}
   * @category Static
   *
   * @param a - the matrix to calculate Frobenius norm of
   * @returns Frobenius norm
   */
  static frob(e) {
    return Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2] + e[3] * e[3] + e[4] * e[4] + e[5] * e[5] + e[6] * e[6] + e[7] * e[7] + e[8] * e[8] + e[9] * e[9] + e[10] * e[10] + e[11] * e[11] + e[12] * e[12] + e[13] * e[13] + e[14] * e[14] + e[15] * e[15]);
  }
  /**
   * Adds two {@link Mat4}'s
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static add(e, t, s) {
    return e[0] = t[0] + s[0], e[1] = t[1] + s[1], e[2] = t[2] + s[2], e[3] = t[3] + s[3], e[4] = t[4] + s[4], e[5] = t[5] + s[5], e[6] = t[6] + s[6], e[7] = t[7] + s[7], e[8] = t[8] + s[8], e[9] = t[9] + s[9], e[10] = t[10] + s[10], e[11] = t[11] + s[11], e[12] = t[12] + s[12], e[13] = t[13] + s[13], e[14] = t[14] + s[14], e[15] = t[15] + s[15], e;
  }
  /**
   * Subtracts matrix b from matrix a
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(e, t, s) {
    return e[0] = t[0] - s[0], e[1] = t[1] - s[1], e[2] = t[2] - s[2], e[3] = t[3] - s[3], e[4] = t[4] - s[4], e[5] = t[5] - s[5], e[6] = t[6] - s[6], e[7] = t[7] - s[7], e[8] = t[8] - s[8], e[9] = t[9] - s[9], e[10] = t[10] - s[10], e[11] = t[11] - s[11], e[12] = t[12] - s[12], e[13] = t[13] - s[13], e[14] = t[14] - s[14], e[15] = t[15] - s[15], e;
  }
  /**
   * Alias for {@link Mat4.subtract}
   * @category Static
   */
  static sub(e, t, s) {
    return e;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param b - amount to scale the matrix's elements by
   * @returns `out`
   */
  static multiplyScalar(e, t, s) {
    return e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s, e[3] = t[3] * s, e[4] = t[4] * s, e[5] = t[5] * s, e[6] = t[6] * s, e[7] = t[7] * s, e[8] = t[8] * s, e[9] = t[9] * s, e[10] = t[10] * s, e[11] = t[11] * s, e[12] = t[12] * s, e[13] = t[13] * s, e[14] = t[14] * s, e[15] = t[15] * s, e;
  }
  /**
   * Adds two mat4's after multiplying each element of the second operand by a scalar value.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b's elements by before adding
   * @returns `out`
   */
  static multiplyScalarAndAdd(e, t, s, n) {
    return e[0] = t[0] + s[0] * n, e[1] = t[1] + s[1] * n, e[2] = t[2] + s[2] * n, e[3] = t[3] + s[3] * n, e[4] = t[4] + s[4] * n, e[5] = t[5] + s[5] * n, e[6] = t[6] + s[6] * n, e[7] = t[7] + s[7] * n, e[8] = t[8] + s[8] * n, e[9] = t[9] + s[9] * n, e[10] = t[10] + s[10] * n, e[11] = t[11] + s[11] * n, e[12] = t[12] + s[12] * n, e[13] = t[13] + s[13] * n, e[14] = t[14] + s[14] * n, e[15] = t[15] + s[15] * n, e;
  }
  /**
   * Returns whether or not two {@link Mat4}s have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static exactEquals(e, t) {
    return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15];
  }
  /**
   * Returns whether or not two {@link Mat4}s have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static equals(e, t) {
    const s = e[0], n = e[1], l = e[2], r = e[3], o = e[4], a = e[5], c = e[6], u = e[7], d = e[8], p = e[9], m = e[10], g = e[11], h = e[12], _ = e[13], y = e[14], k = e[15], v = t[0], O = t[1], P = t[2], D = t[3], I = t[4], B = t[5], F = t[6], H = t[7], G = t[8], U = t[9], q = t[10], W = t[11], X = t[12], te = t[13], J = t[14], re = t[15];
    return Math.abs(s - v) <= Wt * Math.max(1, Math.abs(s), Math.abs(v)) && Math.abs(n - O) <= Wt * Math.max(1, Math.abs(n), Math.abs(O)) && Math.abs(l - P) <= Wt * Math.max(1, Math.abs(l), Math.abs(P)) && Math.abs(r - D) <= Wt * Math.max(1, Math.abs(r), Math.abs(D)) && Math.abs(o - I) <= Wt * Math.max(1, Math.abs(o), Math.abs(I)) && Math.abs(a - B) <= Wt * Math.max(1, Math.abs(a), Math.abs(B)) && Math.abs(c - F) <= Wt * Math.max(1, Math.abs(c), Math.abs(F)) && Math.abs(u - H) <= Wt * Math.max(1, Math.abs(u), Math.abs(H)) && Math.abs(d - G) <= Wt * Math.max(1, Math.abs(d), Math.abs(G)) && Math.abs(p - U) <= Wt * Math.max(1, Math.abs(p), Math.abs(U)) && Math.abs(m - q) <= Wt * Math.max(1, Math.abs(m), Math.abs(q)) && Math.abs(g - W) <= Wt * Math.max(1, Math.abs(g), Math.abs(W)) && Math.abs(h - X) <= Wt * Math.max(1, Math.abs(h), Math.abs(X)) && Math.abs(_ - te) <= Wt * Math.max(1, Math.abs(_), Math.abs(te)) && Math.abs(y - J) <= Wt * Math.max(1, Math.abs(y), Math.abs(J)) && Math.abs(k - re) <= Wt * Math.max(1, Math.abs(k), Math.abs(re));
  }
  /**
   * Returns a string representation of a {@link Mat4}
   * @category Static
   *
   * @param a - matrix to represent as a string
   * @returns string representation of the matrix
   */
  static str(e) {
    return `Mat4(${e.join(", ")})`;
  }
};
f(Vt, "Mat4"), /**
 * The number of bytes in a {@link Mat4}.
 */
Ge(Vt, "BYTE_LENGTH", 16 * Float32Array.BYTES_PER_ELEMENT);
let He = Vt;
const Gf = [0, 0, 0];
He.prototype.mul = He.prototype.multiply;
He.sub = He.subtract;
He.mul = He.multiply;
He.perspective = He.perspectiveNO;
He.ortho = He.orthoNO;
const js = class js extends Float32Array {
  /**
  * Create a {@link Vec3}.
  */
  constructor(...e) {
    switch (e.length) {
      case 3:
        super(e);
        break;
      case 2:
        super(e[0], e[1], 3);
        break;
      case 1: {
        const t = e[0];
        typeof t == "number" ? super([t, t, t]) : super(t, 0, 3);
        break;
      }
      default:
        super(3);
        break;
    }
  }
  //============
  // Attributes
  //============
  // Getters and setters to make component access read better.
  // These are likely to be a little bit slower than direct array access.
  /**
   * The x component of the vector. Equivalent to `this[0];`
   * @category Vector components
   */
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = e;
  }
  /**
   * The y component of the vector. Equivalent to `this[1];`
   * @category Vector components
   */
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = e;
  }
  /**
   * The z component of the vector. Equivalent to `this[2];`
   * @category Vector components
   */
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = e;
  }
  // Alternate set of getters and setters in case this is being used to define
  // a color.
  /**
   * The r component of the vector. Equivalent to `this[0];`
   * @category Color components
   */
  get r() {
    return this[0];
  }
  set r(e) {
    this[0] = e;
  }
  /**
   * The g component of the vector. Equivalent to `this[1];`
   * @category Color components
   */
  get g() {
    return this[1];
  }
  set g(e) {
    this[1] = e;
  }
  /**
   * The b component of the vector. Equivalent to `this[2];`
   * @category Color components
   */
  get b() {
    return this[2];
  }
  set b(e) {
    this[2] = e;
  }
  /**
   * The magnitude (length) of this.
   * Equivalent to `Vec3.magnitude(this);`
   *
   * Magnitude is used because the `length` attribute is already defined by
   * `Float32Array` to mean the number of elements in the array.
   */
  get magnitude() {
    const e = this[0], t = this[1], s = this[2];
    return Math.sqrt(e * e + t * t + s * s);
  }
  /**
   * Alias for {@link Vec3.magnitude}
   */
  get mag() {
    return this.magnitude;
  }
  /**
   * The squared magnitude (length) of `this`.
   * Equivalent to `Vec3.squaredMagnitude(this);`
   */
  get squaredMagnitude() {
    const e = this[0], t = this[1], s = this[2];
    return e * e + t * t + s * s;
  }
  /**
   * Alias for {@link Vec3.squaredMagnitude}
   */
  get sqrMag() {
    return this.squaredMagnitude;
  }
  /**
   * A string representation of `this`
   * Equivalent to `Vec3.str(this);`
   */
  get str() {
    return js.str(this);
  }
  //===================
  // Instances methods
  //===================
  /**
   * Copy the values from another {@link Vec3} into `this`.
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(e) {
    return this.set(e), this;
  }
  /**
   * Adds a {@link Vec3} to `this`.
   * Equivalent to `Vec3.add(this, this, b);`
   *
   * @param b - The vector to add to `this`
   * @returns `this`
   */
  add(e) {
    return this[0] += e[0], this[1] += e[1], this[2] += e[2], this;
  }
  /**
   * Subtracts a {@link Vec3} from `this`.
   * Equivalent to `Vec3.subtract(this, this, b);`
   *
   * @param b - The vector to subtract from `this`
   * @returns `this`
   */
  subtract(e) {
    return this[0] -= e[0], this[1] -= e[1], this[2] -= e[2], this;
  }
  /**
   * Alias for {@link Vec3.subtract}
   */
  sub(e) {
    return this;
  }
  /**
   * Multiplies `this` by a {@link Vec3}.
   * Equivalent to `Vec3.multiply(this, this, b);`
   *
   * @param b - The vector to multiply `this` by
   * @returns `this`
   */
  multiply(e) {
    return this[0] *= e[0], this[1] *= e[1], this[2] *= e[2], this;
  }
  /**
   * Alias for {@link Vec3.multiply}
   */
  mul(e) {
    return this;
  }
  /**
   * Divides `this` by a {@link Vec3}.
   * Equivalent to `Vec3.divide(this, this, b);`
   *
   * @param b - The vector to divide `this` by
   * @returns `this`
   */
  divide(e) {
    return this[0] /= e[0], this[1] /= e[1], this[2] /= e[2], this;
  }
  /**
   * Alias for {@link Vec3.divide}
   */
  div(e) {
    return this;
  }
  /**
   * Scales `this` by a scalar number.
   * Equivalent to `Vec3.scale(this, this, b);`
   *
   * @param b - Amount to scale `this` by
   * @returns `this`
   */
  scale(e) {
    return this[0] *= e, this[1] *= e, this[2] *= e, this;
  }
  /**
   * Calculates `this` scaled by a scalar value then adds the result to `this`.
   * Equivalent to `Vec3.scaleAndAdd(this, this, b, scale);`
   *
   * @param b - The vector to add to `this`
   * @param scale - The amount to scale `b` by before adding
   * @returns `this`
   */
  scaleAndAdd(e, t) {
    return this[0] += e[0] * t, this[1] += e[1] * t, this[2] += e[2] * t, this;
  }
  /**
   * Calculates the euclidian distance between another {@link Vec3} and `this`.
   * Equivalent to `Vec3.distance(this, b);`
   *
   * @param b - The vector to calculate the distance to
   * @returns Distance between `this` and `b`
   */
  distance(e) {
    return js.distance(this, e);
  }
  /**
   * Alias for {@link Vec3.distance}
   */
  dist(e) {
    return 0;
  }
  /**
   * Calculates the squared euclidian distance between another {@link Vec3} and `this`.
   * Equivalent to `Vec3.squaredDistance(this, b);`
   *
   * @param b The vector to calculate the squared distance to
   * @returns Squared distance between `this` and `b`
   */
  squaredDistance(e) {
    return js.squaredDistance(this, e);
  }
  /**
   * Alias for {@link Vec3.squaredDistance}
   */
  sqrDist(e) {
    return 0;
  }
  /**
   * Negates the components of `this`.
   * Equivalent to `Vec3.negate(this, this);`
   *
   * @returns `this`
   */
  negate() {
    return this[0] *= -1, this[1] *= -1, this[2] *= -1, this;
  }
  /**
   * Inverts the components of `this`.
   * Equivalent to `Vec3.inverse(this, this);`
   *
   * @returns `this`
   */
  invert() {
    return this[0] = 1 / this[0], this[1] = 1 / this[1], this[2] = 1 / this[2], this;
  }
  /**
   * Calculates the dot product of this and another {@link Vec3}.
   * Equivalent to `Vec3.dot(this, b);`
   *
   * @param b - The second operand
   * @returns Dot product of `this` and `b`
   */
  dot(e) {
    return this[0] * e[0] + this[1] * e[1] + this[2] * e[2];
  }
  /**
   * Normalize `this`.
   * Equivalent to `Vec3.normalize(this, this);`
   *
   * @returns `this`
   */
  normalize() {
    return js.normalize(this, this);
  }
  //================
  // Static methods
  //================
  /**
   * Creates a new, empty vec3
   * @category Static
   *
   * @returns a new 3D vector
   */
  static create() {
    return new js();
  }
  /**
   * Creates a new vec3 initialized with values from an existing vector
   * @category Static
   *
   * @param a - vector to clone
   * @returns a new 3D vector
   */
  static clone(e) {
    return new js(e);
  }
  /**
   * Calculates the magnitude (length) of a {@link Vec3}
   * @category Static
   *
   * @param a - Vector to calculate magnitude of
   * @returns Magnitude of a
   */
  static magnitude(e) {
    let t = e[0], s = e[1], n = e[2];
    return Math.sqrt(t * t + s * s + n * n);
  }
  /**
   * Alias for {@link Vec3.magnitude}
   * @category Static
   */
  static mag(e) {
    return 0;
  }
  /**
   * Alias for {@link Vec3.magnitude}
   * @category Static
   * @deprecated Use {@link Vec3.magnitude} to avoid conflicts with builtin `length` methods/attribs
   *
   * @param a - vector to calculate length of
   * @returns length of a
   */
  // @ts-ignore: Length conflicts with Function.length
  static length(e) {
    return 0;
  }
  /**
   * Alias for {@link Vec3.magnitude}
   * @category Static
   * @deprecated Use {@link Vec3.mag}
   */
  static len(e) {
    return 0;
  }
  /**
   * Creates a new vec3 initialized with the given values
   * @category Static
   *
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @returns a new 3D vector
   */
  static fromValues(e, t, s) {
    return new js(e, t, s);
  }
  /**
   * Copy the values from one vec3 to another
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the source vector
   * @returns `out`
   */
  static copy(e, t) {
    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;
  }
  /**
   * Set the components of a vec3 to the given values
   * @category Static
   *
   * @param out - the receiving vector
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @returns `out`
   */
  static set(e, t, s, n) {
    return e[0] = t, e[1] = s, e[2] = n, e;
  }
  /**
   * Adds two {@link Vec3}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static add(e, t, s) {
    return e[0] = t[0] + s[0], e[1] = t[1] + s[1], e[2] = t[2] + s[2], e;
  }
  /**
   * Subtracts vector b from vector a
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(e, t, s) {
    return e[0] = t[0] - s[0], e[1] = t[1] - s[1], e[2] = t[2] - s[2], e;
  }
  /**
   * Alias for {@link Vec3.subtract}
   * @category Static
   */
  static sub(e, t, s) {
    return [0, 0, 0];
  }
  /**
   * Multiplies two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static multiply(e, t, s) {
    return e[0] = t[0] * s[0], e[1] = t[1] * s[1], e[2] = t[2] * s[2], e;
  }
  /**
   * Alias for {@link Vec3.multiply}
   * @category Static
   */
  static mul(e, t, s) {
    return [0, 0, 0];
  }
  /**
   * Divides two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static divide(e, t, s) {
    return e[0] = t[0] / s[0], e[1] = t[1] / s[1], e[2] = t[2] / s[2], e;
  }
  /**
   * Alias for {@link Vec3.divide}
   * @category Static
   */
  static div(e, t, s) {
    return [0, 0, 0];
  }
  /**
   * Math.ceil the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to ceil
   * @returns `out`
   */
  static ceil(e, t) {
    return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e;
  }
  /**
   * Math.floor the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to floor
   * @returns `out`
   */
  static floor(e, t) {
    return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e;
  }
  /**
   * Returns the minimum of two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static min(e, t, s) {
    return e[0] = Math.min(t[0], s[0]), e[1] = Math.min(t[1], s[1]), e[2] = Math.min(t[2], s[2]), e;
  }
  /**
   * Returns the maximum of two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static max(e, t, s) {
    return e[0] = Math.max(t[0], s[0]), e[1] = Math.max(t[1], s[1]), e[2] = Math.max(t[2], s[2]), e;
  }
  /**
   * symmetric round the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to round
   * @returns `out`
   */
  /*static round(out: Vec3Like, a: Readonly<Vec3Like>): Vec3Like {
    out[0] = glMatrix.round(a[0]);
    out[1] = glMatrix.round(a[1]);
    out[2] = glMatrix.round(a[2]);
    return out;
  }*/
  /**
   * Scales a vec3 by a scalar number
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to scale
   * @param scale - amount to scale the vector by
   * @returns `out`
   */
  static scale(e, t, s) {
    return e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s, e;
  }
  /**
   * Adds two vec3's after scaling the second operand by a scalar value
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b by before adding
   * @returns `out`
   */
  static scaleAndAdd(e, t, s, n) {
    return e[0] = t[0] + s[0] * n, e[1] = t[1] + s[1] * n, e[2] = t[2] + s[2] * n, e;
  }
  /**
   * Calculates the euclidian distance between two vec3's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns distance between a and b
   */
  static distance(e, t) {
    const s = t[0] - e[0], n = t[1] - e[1], l = t[2] - e[2];
    return Math.sqrt(s * s + n * n + l * l);
  }
  /**
   * Alias for {@link Vec3.distance}
   */
  static dist(e, t) {
    return 0;
  }
  /**
   * Calculates the squared euclidian distance between two vec3's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns squared distance between a and b
   */
  static squaredDistance(e, t) {
    const s = t[0] - e[0], n = t[1] - e[1], l = t[2] - e[2];
    return s * s + n * n + l * l;
  }
  /**
   * Alias for {@link Vec3.squaredDistance}
   */
  static sqrDist(e, t) {
    return 0;
  }
  /**
   * Calculates the squared length of a vec3
   * @category Static
   *
   * @param a - vector to calculate squared length of
   * @returns squared length of a
   */
  static squaredLength(e) {
    const t = e[0], s = e[1], n = e[2];
    return t * t + s * s + n * n;
  }
  /**
   * Alias for {@link Vec3.squaredLength}
   */
  static sqrLen(e, t) {
    return 0;
  }
  /**
   * Negates the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to negate
   * @returns `out`
   */
  static negate(e, t) {
    return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e;
  }
  /**
   * Returns the inverse of the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to invert
   * @returns `out`
   */
  static inverse(e, t) {
    return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e;
  }
  /**
   * Normalize a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to normalize
   * @returns `out`
   */
  static normalize(e, t) {
    const s = t[0], n = t[1], l = t[2];
    let r = s * s + n * n + l * l;
    return r > 0 && (r = 1 / Math.sqrt(r)), e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e;
  }
  /**
   * Calculates the dot product of two vec3's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns dot product of a and b
   */
  static dot(e, t) {
    return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
  }
  /**
   * Computes the cross product of two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static cross(e, t, s) {
    const n = t[0], l = t[1], r = t[2], o = s[0], a = s[1], c = s[2];
    return e[0] = l * c - r * a, e[1] = r * o - n * c, e[2] = n * a - l * o, e;
  }
  /**
   * Performs a linear interpolation between two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static lerp(e, t, s, n) {
    const l = t[0], r = t[1], o = t[2];
    return e[0] = l + n * (s[0] - l), e[1] = r + n * (s[1] - r), e[2] = o + n * (s[2] - o), e;
  }
  /**
   * Performs a spherical linear interpolation between two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static slerp(e, t, s, n) {
    const l = Math.acos(Math.min(Math.max(js.dot(t, s), -1), 1)), r = Math.sin(l), o = Math.sin((1 - n) * l) / r, a = Math.sin(n * l) / r;
    return e[0] = o * t[0] + a * s[0], e[1] = o * t[1] + a * s[1], e[2] = o * t[2] + a * s[2], e;
  }
  /**
   * Performs a hermite interpolation with two control points
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param c - the third operand
   * @param d - the fourth operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static hermite(e, t, s, n, l, r) {
    const o = r * r, a = o * (2 * r - 3) + 1, c = o * (r - 2) + r, u = o * (r - 1), d = o * (3 - 2 * r);
    return e[0] = t[0] * a + s[0] * c + n[0] * u + l[0] * d, e[1] = t[1] * a + s[1] * c + n[1] * u + l[1] * d, e[2] = t[2] * a + s[2] * c + n[2] * u + l[2] * d, e;
  }
  /**
   * Performs a bezier interpolation with two control points
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param c - the third operand
   * @param d - the fourth operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static bezier(e, t, s, n, l, r) {
    const o = 1 - r, a = o * o, c = r * r, u = a * o, d = 3 * r * a, p = 3 * c * o, m = c * r;
    return e[0] = t[0] * u + s[0] * d + n[0] * p + l[0] * m, e[1] = t[1] * u + s[1] * d + n[1] * p + l[1] * m, e[2] = t[2] * u + s[2] * d + n[2] * p + l[2] * m, e;
  }
  /**
   * Generates a random vector with the given scale
   * @category Static
   *
   * @param out - the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
   * @returns `out`
   */
  /*static random(out: Vec3Like, scale) {
      scale = scale === undefined ? 1.0 : scale;
  
      let r = glMatrix.RANDOM() * 2.0 * Math.PI;
      let z = glMatrix.RANDOM() * 2.0 - 1.0;
      let zScale = Math.sqrt(1.0 - z * z) * scale;
  
      out[0] = Math.cos(r) * zScale;
      out[1] = Math.sin(r) * zScale;
      out[2] = z * scale;
      return out;
    }*/
  /**
   * Transforms the vec3 with a mat4.
   * 4th vector component is implicitly '1'
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param m - matrix to transform with
   * @returns `out`
   */
  static transformMat4(e, t, s) {
    const n = t[0], l = t[1], r = t[2], o = s[3] * n + s[7] * l + s[11] * r + s[15] || 1;
    return e[0] = (s[0] * n + s[4] * l + s[8] * r + s[12]) / o, e[1] = (s[1] * n + s[5] * l + s[9] * r + s[13]) / o, e[2] = (s[2] * n + s[6] * l + s[10] * r + s[14]) / o, e;
  }
  /**
   * Transforms the vec3 with a mat3.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param m - the 3x3 matrix to transform with
   * @returns `out`
   */
  static transformMat3(e, t, s) {
    let n = t[0], l = t[1], r = t[2];
    return e[0] = n * s[0] + l * s[3] + r * s[6], e[1] = n * s[1] + l * s[4] + r * s[7], e[2] = n * s[2] + l * s[5] + r * s[8], e;
  }
  /**
   * Transforms the vec3 with a quat
   * Can also be used for dual quaternions. (Multiply it with the real part)
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param q - quaternion to transform with
   * @returns `out`
   */
  static transformQuat(e, t, s) {
    const n = s[0], l = s[1], r = s[2], o = s[3] * 2, a = t[0], c = t[1], u = t[2], d = l * u - r * c, p = r * a - n * u, m = n * c - l * a, g = (l * m - r * p) * 2, h = (r * d - n * m) * 2, _ = (n * p - l * d) * 2;
    return e[0] = a + d * o + g, e[1] = c + p * o + h, e[2] = u + m * o + _, e;
  }
  /**
   * Rotate a 3D vector around the x-axis
   * @param out - The receiving vec3
   * @param a - The vec3 point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotateX(e, t, s, n) {
    const l = s[1], r = s[2], o = t[1] - l, a = t[2] - r;
    return e[0] = t[0], e[1] = o * Math.cos(n) - a * Math.sin(n) + l, e[2] = o * Math.sin(n) + a * Math.cos(n) + r, e;
  }
  /**
   * Rotate a 3D vector around the y-axis
   * @param out - The receiving vec3
   * @param a - The vec3 point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotateY(e, t, s, n) {
    const l = s[0], r = s[2], o = t[0] - l, a = t[2] - r;
    return e[0] = a * Math.sin(n) + o * Math.cos(n) + l, e[1] = t[1], e[2] = a * Math.cos(n) - o * Math.sin(n) + r, e;
  }
  /**
   * Rotate a 3D vector around the z-axis
   * @param out - The receiving vec3
   * @param a - The vec3 point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotateZ(e, t, s, n) {
    const l = s[0], r = s[1], o = t[0] - l, a = t[1] - r;
    return e[0] = o * Math.cos(n) - a * Math.sin(n) + l, e[1] = o * Math.sin(n) + a * Math.cos(n) + r, e[2] = s[2], e;
  }
  /**
   * Get the angle between two 3D vectors
   * @param a - The first operand
   * @param b - The second operand
   * @returns The angle in radians
   */
  static angle(e, t) {
    const s = e[0], n = e[1], l = e[2], r = t[0], o = t[1], a = t[2], c = Math.sqrt((s * s + n * n + l * l) * (r * r + o * o + a * a)), u = c && js.dot(e, t) / c;
    return Math.acos(Math.min(Math.max(u, -1), 1));
  }
  /**
   * Set the components of a vec3 to zero
   * @category Static
   *
   * @param out - the receiving vector
   * @returns `out`
   */
  static zero(e) {
    return e[0] = 0, e[1] = 0, e[2] = 0, e;
  }
  /**
   * Returns a string representation of a vector
   * @category Static
   *
   * @param a - vector to represent as a string
   * @returns string representation of the vector
   */
  static str(e) {
    return `Vec3(${e.join(", ")})`;
  }
  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are equal, false otherwise.
   */
  static exactEquals(e, t) {
    return e[0] === t[0] && e[1] === t[1] && e[2] === t[2];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are equal, false otherwise.
   */
  static equals(e, t) {
    const s = e[0], n = e[1], l = e[2], r = t[0], o = t[1], a = t[2];
    return Math.abs(s - r) <= Wt * Math.max(1, Math.abs(s), Math.abs(r)) && Math.abs(n - o) <= Wt * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(l - a) <= Wt * Math.max(1, Math.abs(l), Math.abs(a));
  }
};
f(js, "Vec3"), /**
* The number of bytes in a {@link Vec3}.
*/
Ge(js, "BYTE_LENGTH", 3 * Float32Array.BYTES_PER_ELEMENT);
let lt = js;
lt.prototype.sub = lt.prototype.subtract;
lt.prototype.mul = lt.prototype.multiply;
lt.prototype.div = lt.prototype.divide;
lt.prototype.dist = lt.prototype.distance;
lt.prototype.sqrDist = lt.prototype.squaredDistance;
lt.sub = lt.subtract;
lt.mul = lt.multiply;
lt.div = lt.divide;
lt.dist = lt.distance;
lt.sqrDist = lt.squaredDistance;
lt.sqrLen = lt.squaredLength;
lt.mag = lt.magnitude;
lt.length = lt.magnitude;
lt.len = lt.magnitude;
async function Lz(i = 1) {
  if (!Number.isInteger(i) || i < 1)
    throw new TypeError("nextAnimationFrame error: 'cntr' must be a positive integer greater than 0.");
  let e = performance.now();
  for (; --i >= 0; )
    e = await new Promise((t) => requestAnimationFrame(t));
  return e;
}
f(Lz, "nextAnimationFrame");
function Yr(i = 0, e = 0, t = 0) {
  return Math.min(Math.max(i, e), t);
}
f(Yr, "clamp$1");
function Js(i) {
  return i * (Math.PI / 180);
}
f(Js, "degToRad");
var Zi, ko, su, Xp;
const oc = class oc {
  /**
   * @param {object|null} [animationData] - Animation data from {@link AnimationAPI}.
   *
   * @param {boolean}     [willFinish] - Promise that tracks animation finished state.
   */
  constructor(e, t = !1) {
    /** @type {object} */
    Y(this, Zi, void 0);
    /** @type {Promise<void>} */
    Y(this, ko, void 0);
    Y(this, su, void 0);
    ye(this, Zi, e), ye(this, su, t), ke(e) && (e.control = this);
  }
  /**
   * Provides a static void / undefined AnimationControl that is automatically resolved.
   *
   * @returns {AnimationControl} Void AnimationControl
   */
  static get voidControl() {
    return M(this, Xp);
  }
  /**
   * Get a promise that resolves when animation is finished.
   *
   * @returns {Promise<void>}
   */
  get finished() {
    return M(this, ko) instanceof Promise || ye(this, ko, M(this, su) ? new Promise((e) => M(this, Zi).resolve = e) : Promise.resolve()), M(this, ko);
  }
  /**
   * Returns whether this animation is currently active / animating.
   *
   * Note: a delayed animation may not be started / active yet. Use {@link AnimationControl.isFinished} to determine
   * if an animation is actually finished.
   *
   * @returns {boolean} Animation active state.
   */
  get isActive() {
    return M(this, Zi).active;
  }
  /**
   * Returns whether this animation is completely finished.
   *
   * @returns {boolean} Animation finished state.
   */
  get isFinished() {
    return M(this, Zi).finished;
  }
  /**
   * Cancels the animation.
   */
  cancel() {
    const e = M(this, Zi);
    e != null && (e.cancelled = !0);
  }
};
Zi = new WeakMap(), ko = new WeakMap(), su = new WeakMap(), Xp = new WeakMap(), f(oc, "AnimationControl"), /**
 * Defines a static empty / void animation control.
 *
 * @type {AnimationControl}
 */
Y(oc, Xp, new oc(null));
let Sl = oc;
const ut = class ut {
  /**
   * Add animation data.
   *
   * @param {object}   data -
   */
  static add(e) {
    const t = performance.now();
    e.start = t + (ut.current - t), ut.newList.push(e);
  }
  /**
   * Manage all animation
   */
  static animate() {
    const e = ut.current = performance.now();
    if (ut.activeList.length === 0 && ut.newList.length === 0) {
      globalThis.requestAnimationFrame(ut.animate);
      return;
    }
    if (ut.newList.length)
      for (let t = ut.newList.length; --t >= 0; ) {
        const s = ut.newList[t];
        s.cancelled && (ut.newList.splice(t, 1), s.cleanup(s)), s.active && (ut.newList.splice(t, 1), ut.activeList.push(s));
      }
    for (let t = ut.activeList.length; --t >= 0; ) {
      const s = ut.activeList[t];
      if (s.cancelled || s.el !== void 0 && !s.el.isConnected) {
        ut.activeList.splice(t, 1), s.cleanup(s);
        continue;
      }
      if (s.current = e - s.start, s.current >= s.duration) {
        for (let l = s.keys.length; --l >= 0; ) {
          const r = s.keys[l];
          s.newData[r] = s.destination[r];
        }
        s.position.set(s.newData), ut.activeList.splice(t, 1), s.cleanup(s);
        continue;
      }
      const n = s.ease(s.current / s.duration);
      for (let l = s.keys.length; --l >= 0; ) {
        const r = s.keys[l];
        s.newData[r] = s.interpolate(s.initial[r], s.destination[r], n);
      }
      s.position.set(s.newData);
    }
    globalThis.requestAnimationFrame(ut.animate);
  }
  /**
   * Cancels all animations for given TJSPosition instance.
   *
   * @param {import('../').TJSPosition} position - TJSPosition instance.
   */
  static cancel(e) {
    for (let t = ut.activeList.length; --t >= 0; ) {
      const s = ut.activeList[t];
      s.position === e && (ut.activeList.splice(t, 1), s.cancelled = !0, s.cleanup(s));
    }
    for (let t = ut.newList.length; --t >= 0; ) {
      const s = ut.newList[t];
      s.position === e && (ut.newList.splice(t, 1), s.cancelled = !0, s.cleanup(s));
    }
  }
  /**
   * Cancels all active and delayed animations.
   */
  static cancelAll() {
    for (let e = ut.activeList.length; --e >= 0; ) {
      const t = ut.activeList[e];
      t.cancelled = !0, t.cleanup(t);
    }
    for (let e = ut.newList.length; --e >= 0; ) {
      const t = ut.newList[e];
      t.cancelled = !0, t.cleanup(t);
    }
    ut.activeList.length = 0, ut.newList.length = 0;
  }
  /**
   * Gets all {@link AnimationControl} instances for a given TJSPosition instance.
   *
   * @param {import('../index.js').TJSPosition} position - TJSPosition instance.
   *
   * @returns {import('#runtime/util/animate').TJSBasicAnimation[]} All scheduled AnimationControl instances for the
   *          given TJSPosition instance.
   */
  static getScheduled(e) {
    const t = [];
    for (let s = ut.activeList.length; --s >= 0; ) {
      const n = ut.activeList[s];
      n.position === e && t.push(n.control);
    }
    for (let s = ut.newList.length; --s >= 0; ) {
      const n = ut.newList[s];
      n.position === e && t.push(n.control);
    }
    return t;
  }
};
f(ut, "AnimationManager"), /**
 * @type {object[]}
 */
Ge(ut, "activeList", []), /**
 * @type {object[]}
 */
Ge(ut, "newList", []), /**
 * @type {number}
 */
Ge(ut, "current");
let Ps = ut;
Ps.animate();
const I7 = /* @__PURE__ */ new Set([
  // Main keys
  "left",
  "top",
  "maxWidth",
  "maxHeight",
  "minWidth",
  "minHeight",
  "width",
  "height",
  "rotateX",
  "rotateY",
  "rotateZ",
  "scale",
  "translateX",
  "translateY",
  "translateZ",
  "zIndex",
  // Aliases
  "rotation"
]), Al = ["rotateX", "rotateY", "rotateZ", "scale", "translateX", "translateY", "translateZ"];
Object.freeze(Al);
const Bz = /^([-+*])=(-?[\d]*\.?[\d]+)$/, P7 = {
  // Other keys
  height: 0,
  left: 0,
  maxHeight: null,
  maxWidth: null,
  minHeight: null,
  minWidth: null,
  top: 0,
  transformOrigin: null,
  width: 0,
  zIndex: null,
  rotateX: 0,
  rotateY: 0,
  rotateZ: 0,
  scale: 1,
  translateX: 0,
  translateY: 0,
  translateZ: 0,
  rotation: 0
};
Object.freeze(P7);
function za(i) {
  i.rotateX === null && (i.rotateX = 0), i.rotateY === null && (i.rotateY = 0), i.rotateZ === null && (i.rotateZ = 0), i.translateX === null && (i.translateX = 0), i.translateY === null && (i.translateY = 0), i.translateZ === null && (i.translateZ = 0), i.scale === null && (i.scale = 1), i.rotation === null && (i.rotation = 0);
}
f(za, "setNumericDefaults");
const Ns = {
  rotateX: 1,
  rotateY: 2,
  rotateZ: 4,
  scale: 8,
  translateX: 16,
  translateY: 32,
  translateZ: 64
};
Object.freeze(Ns);
const qz = "top left", Ur = [
  "top left",
  "top center",
  "top right",
  "center left",
  "center",
  "center right",
  "bottom left",
  "bottom center",
  "bottom right"
];
Object.freeze(Ur);
function Vr(i, e) {
  for (const t in i)
    if (I7.has(t)) {
      const s = i[t];
      if (typeof s != "string" || s === "auto" || s === "inherit")
        continue;
      const n = Bz.exec(s);
      if (!n)
        throw new Error(
          `convertRelative error: malformed relative key (${t}) with value (${s})`
        );
      const l = e[t];
      switch (n[1]) {
        case "-":
          i[t] = l - parseFloat(n[2]);
          break;
        case "+":
          i[t] = l + parseFloat(n[2]);
          break;
        case "*":
          i[t] = l * parseFloat(n[2]);
          break;
      }
    }
}
f(Vr, "convertRelative");
var Qi, tn, Bl, wo, $o, ed, Jp, M7;
const D$ = class D$ {
  /**
   * @param {import('../index.js').TJSPosition}       position -
   *
   * @param {import('../index.js').TJSPositionData}   data -
   */
  constructor(e, t) {
    /**
     * Adds / schedules an animation w/ the AnimationManager. This contains the final steps common to all tweens.
     *
     * @param {object}      initial -
     *
     * @param {object}      destination -
     *
     * @param {number}      duration -
     *
     * @param {HTMLElement} el -
     *
     * @param {number}      delay -
     *
     * @param {Function}    ease -
     *
     * @param {Function}    interpolate -
     *
     * @returns {import('#runtime/util/animate').TJSBasicAnimation} The associated animation control.
     */
    Y(this, $o);
    /**
     * Cleans up an animation instance.
     *
     * @param {object}   data - Animation data for an animation instance.
     */
    Y(this, Jp);
    /** @type {import('../').TJSPositionData} */
    Y(this, Qi, void 0);
    /** @type {import('../').TJSPosition} */
    Y(this, tn, void 0);
    /**
     * Tracks the number of animation control instances that are active.
     *
     * @type {number}
     */
    Y(this, Bl, 0);
    /**
     * Provides a bound function to pass as data to AnimationManager to invoke `AnimationAPI.#cleanupInstance`.
     *
     * @type {Function}
     */
    Y(this, wo, void 0);
    ye(this, tn, e), ye(this, Qi, t), ye(this, wo, Z(this, Jp, M7).bind(this));
  }
  /**
   * Returns whether there are scheduled animations whether active or delayed for this TJSPosition.
   *
   * @returns {boolean} Are there active animation instances.
   */
  get isScheduled() {
    return M(this, Bl) > 0;
  }
  /**
   * Cancels all animation instances for this TJSPosition instance.
   */
  cancel() {
    Ps.cancel(M(this, tn));
  }
  /**
   * Returns all currently scheduled AnimationControl instances for this TJSPosition instance.
   *
   * @returns {import('#runtime/util/animate').TJSBasicAnimation[]} All currently scheduled animation controls for
   *          this TJSPosition instance.
   */
  getScheduled() {
    return Ps.getScheduled(M(this, tn));
  }
  /**
   * Provides a tween from given position data to the current position.
   *
   * @param {import('../index.js').TJSPositionDataExtended} fromData - The starting position.
   *
   * @param {object}         [opts] - Optional parameters.
   *
   * @param {number}         [opts.delay=0] - Delay in seconds before animation starts.
   *
   * @param {number}         [opts.duration=1] - Duration in seconds.
   *
   * @param {Function}       [opts.ease=cubicOut] - Easing function.
   *
   * @param {Function}       [opts.interpolate=lerp] - Interpolation function.
   *
   * @returns {import('#runtime/util/animate').TJSBasicAnimation}  A control object that can cancel animation and
   *          provides a `finished` Promise.
   */
  from(e, { delay: t = 0, duration: s = 1, ease: n = Zn, interpolate: l = Pl } = {}) {
    var m, g;
    if (!ke(e))
      throw new TypeError("AnimationAPI.from error: 'fromData' is not an object.");
    const o = M(this, tn).parent;
    if (o !== void 0 && typeof ((m = o == null ? void 0 : o.options) == null ? void 0 : m.positionable) == "boolean" && !((g = o == null ? void 0 : o.options) != null && g.positionable))
      return Sl.voidControl;
    const a = o instanceof HTMLElement ? o : o == null ? void 0 : o.elementTarget, c = a instanceof HTMLElement && a.isConnected ? a : void 0;
    if (!Number.isFinite(t) || t < 0)
      throw new TypeError("AnimationAPI.from error: 'delay' is not a positive number.");
    if (!Number.isFinite(s) || s < 0)
      throw new TypeError("AnimationAPI.from error: 'duration' is not a positive number.");
    if (typeof n != "function")
      throw new TypeError("AnimationAPI.from error: 'ease' is not a function.");
    if (typeof l != "function")
      throw new TypeError("AnimationAPI.from error: 'interpolate' is not a function.");
    const u = {}, d = {}, p = M(this, Qi);
    for (const h in e)
      p[h] !== void 0 && e[h] !== p[h] && (u[h] = e[h], d[h] = p[h]);
    return Vr(u, p), Z(this, $o, ed).call(this, u, d, s, c, t, n, l);
  }
  /**
   * Provides a tween from given position data to the current position.
   *
   * @param {import('../index.js').TJSPositionDataExtended} fromData - The starting position.
   *
   * @param {import('../index.js').TJSPositionDataExtended} toData - The ending position.
   *
   * @param {object}         [opts] - Optional parameters.
   *
   * @param {number}         [opts.delay=0] - Delay in seconds before animation starts.
   *
   * @param {number}         [opts.duration=1] - Duration in seconds.
   *
   * @param {Function}       [opts.ease=cubicOut] - Easing function.
   *
   * @param {Function}       [opts.interpolate=lerp] - Interpolation function.
   *
   * @returns {import('#runtime/util/animate').TJSBasicAnimation}  A control object that can cancel animation and
   *          provides a `finished` Promise.
   */
  fromTo(e, t, { delay: s = 0, duration: n = 1, ease: l = Zn, interpolate: r = Pl } = {}) {
    var m, g;
    if (!ke(e))
      throw new TypeError("AnimationAPI.fromTo error: 'fromData' is not an object.");
    if (!ke(t))
      throw new TypeError("AnimationAPI.fromTo error: 'toData' is not an object.");
    const o = M(this, tn).parent;
    if (o !== void 0 && typeof ((m = o == null ? void 0 : o.options) == null ? void 0 : m.positionable) == "boolean" && !((g = o == null ? void 0 : o.options) != null && g.positionable))
      return Sl.voidControl;
    const a = o instanceof HTMLElement ? o : o == null ? void 0 : o.elementTarget, c = a instanceof HTMLElement && a.isConnected ? a : void 0;
    if (!Number.isFinite(s) || s < 0)
      throw new TypeError("AnimationAPI.fromTo error: 'delay' is not a positive number.");
    if (!Number.isFinite(n) || n < 0)
      throw new TypeError("AnimationAPI.fromTo error: 'duration' is not a positive number.");
    if (typeof l != "function")
      throw new TypeError("AnimationAPI.fromTo error: 'ease' is not a function.");
    if (typeof r != "function")
      throw new TypeError("AnimationAPI.fromTo error: 'interpolate' is not a function.");
    const u = {}, d = {}, p = M(this, Qi);
    for (const h in e) {
      if (t[h] === void 0) {
        console.warn(
          `AnimationAPI.fromTo warning: key ('${h}') from 'fromData' missing in 'toData'; skipping this key.`
        );
        continue;
      }
      p[h] !== void 0 && (u[h] = e[h], d[h] = t[h]);
    }
    return Vr(u, p), Vr(d, p), Z(this, $o, ed).call(this, u, d, n, c, s, l, r);
  }
  /**
   * Provides a tween to given position data from the current position.
   *
   * @param {import('../index.js').TJSPositionDataExtended} toData - The destination position.
   *
   * @param {object}         [opts] - Optional parameters.
   *
   * @param {number}         [opts.delay=0] - Delay in seconds before animation starts.
   *
   * @param {number}         [opts.duration=1] - Duration in seconds.
   *
   * @param {Function}       [opts.ease=cubicOut] - Easing function.
   *
   * @param {Function}       [opts.interpolate=lerp] - Interpolation function.
   *
   * @returns {import('#runtime/util/animate').TJSBasicAnimation}  A control object that can cancel animation and
   *          provides a `finished` Promise.
   */
  to(e, { delay: t = 0, duration: s = 1, ease: n = Zn, interpolate: l = Pl } = {}) {
    var p, m;
    if (!ke(e))
      throw new TypeError("AnimationAPI.to error: 'toData' is not an object.");
    const r = M(this, tn).parent;
    if (r !== void 0 && typeof ((p = r == null ? void 0 : r.options) == null ? void 0 : p.positionable) == "boolean" && !((m = r == null ? void 0 : r.options) != null && m.positionable))
      return Sl.voidControl;
    const o = r instanceof HTMLElement ? r : r == null ? void 0 : r.elementTarget, a = o instanceof HTMLElement && o.isConnected ? o : void 0;
    if (!Number.isFinite(t) || t < 0)
      throw new TypeError("AnimationAPI.to error: 'delay' is not a positive number.");
    if (!Number.isFinite(s) || s < 0)
      throw new TypeError("AnimationAPI.to error: 'duration' is not a positive number.");
    if (typeof n != "function")
      throw new TypeError("AnimationAPI.to error: 'ease' is not a function.");
    if (typeof l != "function")
      throw new TypeError("AnimationAPI.to error: 'interpolate' is not a function.");
    const c = {}, u = {}, d = M(this, Qi);
    for (const g in e)
      d[g] !== void 0 && e[g] !== d[g] && (u[g] = e[g], c[g] = d[g]);
    return Vr(u, d), Z(this, $o, ed).call(this, c, u, s, a, t, n, l);
  }
  /**
   * Returns a function that provides an optimized way to constantly update a to-tween.
   *
   * @param {Iterable<string>}  keys - The keys for quickTo.
   *
   * @param {object}            [opts] - Optional parameters.
   *
   * @param {number}            [opts.duration=1] - Duration in seconds.
   *
   * @param {Function}          [opts.ease=cubicOut] - Easing function.
   *
   * @param {Function}          [opts.interpolate=lerp] - Interpolation function.
   *
   * @returns {import('../index.js').quickToCallback} quick-to tween function.
   */
  quickTo(e, { duration: t = 1, ease: s = Zn, interpolate: n = Pl } = {}) {
    var m, g;
    if (!vt(e))
      throw new TypeError("AnimationAPI.quickTo error: 'keys' is not an iterable list.");
    const l = M(this, tn).parent;
    if (l !== void 0 && typeof ((m = l == null ? void 0 : l.options) == null ? void 0 : m.positionable) == "boolean" && !((g = l == null ? void 0 : l.options) != null && g.positionable))
      throw new Error("AnimationAPI.quickTo error: 'parent' is not positionable.");
    if (!Number.isFinite(t) || t < 0)
      throw new TypeError("AnimationAPI.quickTo error: 'duration' is not a positive number.");
    if (typeof s != "function")
      throw new TypeError("AnimationAPI.quickTo error: 'ease' is not a function.");
    if (typeof n != "function")
      throw new TypeError("AnimationAPI.quickTo error: 'interpolate' is not a function.");
    const r = {}, o = {}, a = M(this, Qi);
    for (const h of e) {
      if (typeof h != "string")
        throw new TypeError("AnimationAPI.quickTo error: key is not a string.");
      if (!I7.has(h))
        throw new Error(`AnimationAPI.quickTo error: key ('${h}') is not animatable.`);
      a[h] !== void 0 && (o[h] = a[h], r[h] = a[h]);
    }
    const c = [...e];
    Object.freeze(c);
    const u = Object.assign({ immediateElementUpdate: !0 }, r), d = {
      active: !0,
      cleanup: M(this, wo),
      cancelled: !1,
      control: void 0,
      current: 0,
      destination: o,
      duration: t * 1e3,
      // Internally the AnimationManager works in ms.
      ease: s,
      el: void 0,
      finished: !0,
      // Note: start in finished state to add to AnimationManager on first callback.
      initial: r,
      interpolate: n,
      keys: e,
      newData: u,
      position: M(this, tn),
      resolve: void 0,
      start: void 0
    }, p = /* @__PURE__ */ f((...h) => {
      const _ = h.length;
      if (_ === 0)
        return;
      for (let k = c.length; --k >= 0; ) {
        const v = c[k];
        a[v] !== void 0 && (r[v] = a[v]);
      }
      if (ke(h[0])) {
        const k = h[0];
        for (const v in k)
          o[v] !== void 0 && (o[v] = k[v]);
      } else
        for (let k = 0; k < _ && k < c.length; k++) {
          const v = c[k];
          o[v] !== void 0 && (o[v] = h[k]);
        }
      Vr(o, a), za(r), za(o);
      const y = l instanceof HTMLElement ? l : l == null ? void 0 : l.elementTarget;
      if (d.el = y instanceof HTMLElement && y.isConnected ? y : void 0, d.finished)
        d.finished = !1, d.active = !0, d.current = 0, Lr(this, Bl)._++, Ps.add(d);
      else {
        const k = performance.now();
        d.start = k + (Ps.current - k), d.current = 0;
      }
    }, "quickToCB");
    return p.keys = c, p.options = ({ duration: h, ease: _, interpolate: y } = {}) => {
      if (h !== void 0 && (!Number.isFinite(h) || h < 0))
        throw new TypeError("AnimationAPI.quickTo.options error: 'duration' is not a positive number.");
      if (_ !== void 0 && typeof _ != "function")
        throw new TypeError("AnimationAPI.quickTo.options error: 'ease' is not a function.");
      if (y !== void 0 && typeof y != "function")
        throw new TypeError("AnimationAPI.quickTo.options error: 'interpolate' is not a function.");
      return h >= 0 && (d.duration = h * 1e3), _ && (d.ease = _), y && (d.interpolate = y), p;
    }, p;
  }
};
Qi = new WeakMap(), tn = new WeakMap(), Bl = new WeakMap(), wo = new WeakMap(), $o = new WeakSet(), ed = /* @__PURE__ */ f(function(e, t, s, n, l, r, o) {
  za(e), za(t);
  for (const d in e)
    Number.isFinite(e[d]) || delete e[d];
  const a = Object.keys(e), c = Object.assign({ immediateElementUpdate: !0 }, e);
  if (a.length === 0)
    return Sl.voidControl;
  const u = {
    active: !0,
    cleanup: M(this, wo),
    cancelled: !1,
    control: void 0,
    current: 0,
    destination: t,
    duration: s * 1e3,
    // Internally the AnimationManager works in ms.
    ease: r,
    el: n,
    finished: !1,
    initial: e,
    interpolate: o,
    keys: a,
    newData: c,
    position: M(this, tn),
    resolve: void 0,
    start: void 0
  };
  return l > 0 && (u.active = !1, setTimeout(() => {
    if (!u.cancelled) {
      u.active = !0;
      const d = performance.now();
      u.start = d + (Ps.current - d);
    }
  }, l * 1e3)), Lr(this, Bl)._++, Ps.add(u), new Sl(u, !0);
}, "#addAnimation"), Jp = new WeakSet(), M7 = /* @__PURE__ */ f(function(e) {
  Lr(this, Bl)._--, e.active = !1, e.finished = !0, typeof e.resolve == "function" && e.resolve(e.cancelled);
}, "#cleanupInstance"), f(D$, "AnimationAPI");
let Md = D$;
var Gn, Ao, Zp;
const ac = class ac {
  /**
   * @param {import('./AnimationControl').AnimationControl[]} animationControls - An array of AnimationControl
   *        instances.
   */
  constructor(e) {
    /** @type {import('./AnimationControl').AnimationControl[]} */
    Y(this, Gn, void 0);
    /** @type {Promise<Awaited<unknown>[]>} */
    Y(this, Ao, void 0);
    ye(this, Gn, e);
  }
  /**
   * Provides a static void / undefined AnimationGroupControl that is automatically resolved.
   *
   * @returns {AnimationGroupControl} Void AnimationGroupControl
   */
  static get voidControl() {
    return M(this, Zp);
  }
  /**
   * Get a promise that resolves when all animations are finished.
   *
   * @returns {Promise<Awaited<unknown>[]>|Promise<void>} Finished Promise for all animations.
   */
  get finished() {
    const e = M(this, Gn);
    if (e == null)
      return Promise.resolve();
    if (!(M(this, Ao) instanceof Promise)) {
      const t = [];
      for (let s = e.length; --s >= 0; )
        t.push(e[s].finished);
      ye(this, Ao, Promise.all(t));
    }
    return M(this, Ao);
  }
  /**
   * Returns whether there are active animation instances for this group.
   *
   * Note: a delayed animation may not be started / active yet. Use {@link AnimationGroupControl.isFinished} to
   * determine if all animations in the group are finished.
   *
   * @returns {boolean} Are there active animation instances.
   */
  get isActive() {
    const e = M(this, Gn);
    if (e == null)
      return !1;
    for (let t = e.length; --t >= 0; )
      if (e[t].isActive)
        return !0;
    return !1;
  }
  /**
   * Returns whether all animations in the group are finished.
   *
   * @returns {boolean} Are all animation instances finished.
   */
  get isFinished() {
    const e = M(this, Gn);
    if (e == null)
      return !0;
    for (let t = e.length; --t >= 0; )
      if (!e[t].isFinished)
        return !1;
    return !1;
  }
  /**
   * Cancels the all animations.
   */
  cancel() {
    const e = M(this, Gn);
    if (e != null)
      for (let t = M(this, Gn).length; --t >= 0; )
        M(this, Gn)[t].cancel();
  }
};
Gn = new WeakMap(), Ao = new WeakMap(), Zp = new WeakMap(), f(ac, "AnimationGroupControl"), /**
 * Defines a static empty / void animation control.
 *
 * @type {AnimationGroupControl}
 */
Y(ac, Zp, new ac(null));
let Ki = ac;
var pt, ht;
const Qp = class Qp {
  /**
   * Cancels any animation for given TJSPosition data.
   *
   * @param {import('../').TJSPosition | {position: import('../').TJSPosition} | Iterable<import('../').TJSPosition> | Iterable<{position: import('../').TJSPosition}>} position -
   */
  static cancel(e) {
    if (vt(e)) {
      let t = -1;
      for (const s of e) {
        t++;
        const n = Z(this, pt, ht).call(this, s) ? s : s.position;
        if (!Z(this, pt, ht).call(this, n)) {
          console.warn(`AnimationGroupAPI.cancel warning: No Position instance found at index: ${t}.`);
          continue;
        }
        Ps.cancel(n);
      }
    } else {
      const t = Z(this, pt, ht).call(this, e) ? e : e.position;
      if (!Z(this, pt, ht).call(this, t)) {
        console.warn("AnimationGroupAPI.cancel warning: No Position instance found.");
        return;
      }
      Ps.cancel(t);
    }
  }
  /**
   * Cancels all TJSPosition animation.
   */
  static cancelAll() {
    Ps.cancelAll();
  }
  /**
   * Gets all animation controls for the given position data.
   *
   * @param {import('../').TJSPosition | {position: import('../').TJSPosition} | Iterable<import('../').TJSPosition> | Iterable<{position: import('../').TJSPosition}>} position -
   *
   * @returns {{ position: import('../').TJSPosition, data: object | void, controls: import('./AnimationControl').AnimationControl[]}[]} Results array.
   */
  static getScheduled(e) {
    const t = [];
    if (vt(e)) {
      let s = -1;
      for (const n of e) {
        s++;
        const l = Z(this, pt, ht).call(this, n), r = l ? n : n.position;
        if (!Z(this, pt, ht).call(this, r)) {
          console.warn(`AnimationGroupAPI.getScheduled warning: No Position instance found at index: ${s}.`);
          continue;
        }
        const o = Ps.getScheduled(r);
        t.push({ position: r, data: l ? void 0 : n, controls: o });
      }
    } else {
      const s = Z(this, pt, ht).call(this, e), n = s ? e : e.position;
      if (!Z(this, pt, ht).call(this, n))
        return console.warn("AnimationGroupAPI.getScheduled warning: No Position instance found."), t;
      const l = Ps.getScheduled(n);
      t.push({ position: n, data: s ? void 0 : e, controls: l });
    }
    return t;
  }
  /**
   * Provides the `from` animation tween for one or more TJSPosition instances as a group.
   *
   * @param {import('../').TJSPosition | {position: import('../').TJSPosition} | Iterable<import('../').TJSPosition> | Iterable<{position: import('../').TJSPosition}>} position -
   *
   * @param {object|Function}   fromData -
   *
   * @param {object|Function}   options -
   *
   * @returns {import('#runtime/util/animate').TJSBasicAnimation} Basic animation control.
   */
  static from(e, t, s) {
    if (!ke(t) && typeof t != "function")
      throw new TypeError("AnimationGroupAPI.from error: 'fromData' is not an object or function.");
    if (s !== void 0 && !ke(s) && typeof s != "function")
      throw new TypeError("AnimationGroupAPI.from error: 'options' is not an object or function.");
    const n = [];
    let l = -1, r;
    const o = typeof t == "function", a = typeof s == "function", c = o || a;
    c && (r = { index: l, position: void 0, data: void 0 });
    let u = t, d = s;
    if (vt(e))
      for (const p of e) {
        l++;
        const m = Z(this, pt, ht).call(this, p), g = m ? p : p.position;
        if (!Z(this, pt, ht).call(this, g)) {
          console.warn(`AnimationGroupAPI.from warning: No Position instance found at index: ${l}.`);
          continue;
        }
        if (c && (r.index = l, r.position = e, r.data = m ? void 0 : p), o) {
          if (u = t(r), u == null)
            continue;
          if (!ke(u))
            throw new TypeError(`AnimationGroupAPI.from error: fromData callback function iteration(${l}) failed to return an object.`);
        }
        if (a) {
          if (d = s(r), d == null)
            continue;
          if (!ke(d))
            throw new TypeError(`AnimationGroupAPI.from error: options callback function iteration(${l}) failed to return an object.`);
        }
        n.push(g.animate.from(u, d));
      }
    else {
      const p = Z(this, pt, ht).call(this, e), m = p ? e : e.position;
      if (!Z(this, pt, ht).call(this, m))
        return console.warn("AnimationGroupAPI.from warning: No Position instance found."), Ki.voidControl;
      if (c && (r.index = 0, r.position = e, r.data = p ? void 0 : e), o && (u = t(r), !ke(u)))
        throw new TypeError(
          "AnimationGroupAPI.from error: fromData callback function failed to return an object."
        );
      if (a && (d = s(r), !ke(d)))
        throw new TypeError(
          "AnimationGroupAPI.from error: options callback function failed to return an object."
        );
      n.push(m.animate.from(u, d));
    }
    return new Ki(n);
  }
  /**
   * Provides the `fromTo` animation tween for one or more TJSPosition instances as a group.
   *
   * @param {import('../').TJSPosition | {position: import('../').TJSPosition} | Iterable<import('../').TJSPosition> | Iterable<{position: import('../').TJSPosition}>} position -
   *
   * @param {object|Function}   fromData -
   *
   * @param {object|Function}   toData -
   *
   * @param {object|Function}   options -
   *
   * @returns {import('#runtime/util/animate').TJSBasicAnimation} Basic animation control.
   */
  static fromTo(e, t, s, n) {
    if (!ke(t) && typeof t != "function")
      throw new TypeError("AnimationGroupAPI.fromTo error: 'fromData' is not an object or function.");
    if (!ke(s) && typeof s != "function")
      throw new TypeError("AnimationGroupAPI.fromTo error: 'toData' is not an object or function.");
    if (n !== void 0 && !ke(n) && typeof n != "function")
      throw new TypeError("AnimationGroupAPI.fromTo error: 'options' is not an object or function.");
    const l = [];
    let r = -1, o;
    const a = typeof t == "function", c = typeof s == "function", u = typeof n == "function", d = a || c || u;
    d && (o = { index: r, position: void 0, data: void 0 });
    let p = t, m = s, g = n;
    if (vt(e))
      for (const h of e) {
        r++;
        const _ = Z(this, pt, ht).call(this, h), y = _ ? h : h.position;
        if (!Z(this, pt, ht).call(this, y)) {
          console.warn(`AnimationGroupAPI.fromTo warning: No Position instance found at index: ${r}.`);
          continue;
        }
        if (d && (o.index = r, o.position = e, o.data = _ ? void 0 : h), a) {
          if (p = t(o), p == null)
            continue;
          if (!ke(p))
            throw new TypeError(`AnimationGroupAPI.fromTo error: fromData callback function iteration(${r}) failed to return an object.`);
        }
        if (c) {
          if (m = s(o), m == null)
            continue;
          if (!ke(m))
            throw new TypeError(`AnimationGroupAPI.fromTo error: toData callback function iteration(${r}) failed to return an object.`);
        }
        if (u) {
          if (g = n(o), g == null)
            continue;
          if (!ke(g))
            throw new TypeError(`AnimationGroupAPI.fromTo error: options callback function iteration(${r}) failed to return an object.`);
        }
        l.push(y.animate.fromTo(p, m, g));
      }
    else {
      const h = Z(this, pt, ht).call(this, e), _ = h ? e : e.position;
      if (!Z(this, pt, ht).call(this, _))
        return console.warn("AnimationGroupAPI.fromTo warning: No Position instance found."), Ki.voidControl;
      if (d && (o.index = 0, o.position = e, o.data = h ? void 0 : e), a && (p = t(o), !ke(p)))
        throw new TypeError(
          "AnimationGroupAPI.fromTo error: fromData callback function failed to return an object."
        );
      if (c && (m = s(o), !ke(m)))
        throw new TypeError(
          "AnimationGroupAPI.fromTo error: toData callback function failed to return an object."
        );
      if (u && (g = n(o), !ke(g)))
        throw new TypeError(
          "AnimationGroupAPI.fromTo error: options callback function failed to return an object."
        );
      l.push(_.animate.fromTo(p, m, g));
    }
    return new Ki(l);
  }
  /**
   * Provides the `to` animation tween for one or more TJSPosition instances as a group.
   *
   * @param {import('../').TJSPosition | {position: import('../').TJSPosition} | Iterable<import('../').TJSPosition> | Iterable<{position: import('../').TJSPosition}>} position -
   *
   * @param {object|Function}   toData -
   *
   * @param {object|Function}   options -
   *
   * @returns {import('#runtime/util/animate').TJSBasicAnimation} Basic animation control.
   */
  static to(e, t, s) {
    if (!ke(t) && typeof t != "function")
      throw new TypeError("AnimationGroupAPI.to error: 'toData' is not an object or function.");
    if (s !== void 0 && !ke(s) && typeof s != "function")
      throw new TypeError("AnimationGroupAPI.to error: 'options' is not an object or function.");
    const n = [];
    let l = -1, r;
    const o = typeof t == "function", a = typeof s == "function", c = o || a;
    c && (r = { index: l, position: void 0, data: void 0 });
    let u = t, d = s;
    if (vt(e))
      for (const p of e) {
        l++;
        const m = Z(this, pt, ht).call(this, p), g = m ? p : p.position;
        if (!Z(this, pt, ht).call(this, g)) {
          console.warn(`AnimationGroupAPI.to warning: No Position instance found at index: ${l}.`);
          continue;
        }
        if (c && (r.index = l, r.position = e, r.data = m ? void 0 : p), o) {
          if (u = t(r), u == null)
            continue;
          if (!ke(u))
            throw new TypeError(`AnimationGroupAPI.to error: toData callback function iteration(${l}) failed to return an object.`);
        }
        if (a) {
          if (d = s(r), d == null)
            continue;
          if (!ke(d))
            throw new TypeError(`AnimationGroupAPI.to error: options callback function iteration(${l}) failed to return an object.`);
        }
        n.push(g.animate.to(u, d));
      }
    else {
      const p = Z(this, pt, ht).call(this, e), m = p ? e : e.position;
      if (!Z(this, pt, ht).call(this, m))
        return console.warn("AnimationGroupAPI.to warning: No Position instance found."), Ki.voidControl;
      if (c && (r.index = 0, r.position = e, r.data = p ? void 0 : e), o && (u = t(r), !ke(u)))
        throw new TypeError(
          "AnimationGroupAPI.to error: toData callback function failed to return an object."
        );
      if (a && (d = s(r), !ke(d)))
        throw new TypeError(
          "AnimationGroupAPI.to error: options callback function failed to return an object."
        );
      n.push(m.animate.to(u, d));
    }
    return new Ki(n);
  }
  /**
   * Provides the `to` animation tween for one or more TJSPosition instances as a group.
   *
   * @param {import('../').TJSPosition | {position: import('../').TJSPosition} | Iterable<import('../').TJSPosition> | Iterable<{position: import('../').TJSPosition}>} position -
   *
   * @param {Iterable<string>}  keys -
   *
   * @param {object|Function}   options -
   *
   * @returns {import('../').quickToCallback} Basic animation control.
   */
  static quickTo(e, t, s) {
    if (!vt(t))
      throw new TypeError("AnimationGroupAPI.quickTo error: 'keys' is not an iterable list.");
    if (s !== void 0 && !ke(s) && typeof s != "function")
      throw new TypeError("AnimationGroupAPI.quickTo error: 'options' is not an object or function.");
    const n = [];
    let l = -1;
    const r = typeof s == "function", o = { index: l, position: void 0, data: void 0 };
    let a = s;
    if (vt(e))
      for (const d of e) {
        l++;
        const p = Z(this, pt, ht).call(this, d), m = p ? d : d.position;
        if (!Z(this, pt, ht).call(this, m)) {
          console.warn(`AnimationGroupAPI.quickTo warning: No Position instance found at index: ${l}.`);
          continue;
        }
        if (o.index = l, o.position = e, o.data = p ? void 0 : d, r) {
          if (a = s(o), a == null)
            continue;
          if (!ke(a))
            throw new TypeError(`AnimationGroupAPI.quickTo error: options callback function iteration(${l}) failed to return an object.`);
        }
        n.push(m.animate.quickTo(t, a));
      }
    else {
      const d = Z(this, pt, ht).call(this, e), p = d ? e : e.position;
      if (!Z(this, pt, ht).call(this, p))
        return console.warn("AnimationGroupAPI.quickTo warning: No Position instance found."), () => null;
      if (o.index = 0, o.position = e, o.data = d ? void 0 : e, r && (a = s(o), !ke(a)))
        throw new TypeError(
          "AnimationGroupAPI.quickTo error: options callback function failed to return an object."
        );
      n.push(p.animate.quickTo(t, a));
    }
    const c = [...t];
    Object.freeze(c);
    const u = /* @__PURE__ */ f((...d) => {
      if (d.length !== 0)
        if (typeof d[0] == "function") {
          const m = d[0];
          l = -1;
          let g = 0;
          if (vt(e))
            for (const h of e) {
              l++;
              const _ = Z(this, pt, ht).call(this, h), y = _ ? h : h.position;
              if (!Z(this, pt, ht).call(this, y))
                continue;
              o.index = l, o.position = e, o.data = _ ? void 0 : h;
              const k = m(o);
              if (k == null)
                continue;
              const v = vt(k);
              if (!Number.isFinite(k) && !v && !ke(k))
                throw new TypeError(`AnimationGroupAPI.quickTo error: toData callback function iteration(${l}) failed to return a finite number, iterable list, or object.`);
              v ? n[g++](...k) : n[g++](k);
            }
          else {
            const h = Z(this, pt, ht).call(this, e), _ = h ? e : e.position;
            if (!Z(this, pt, ht).call(this, _))
              return;
            o.index = 0, o.position = e, o.data = h ? void 0 : e;
            const y = m(o);
            if (y == null)
              return;
            const k = vt(y);
            if (!Number.isFinite(y) && !k && !ke(y))
              throw new TypeError(`AnimationGroupAPI.quickTo error: toData callback function iteration(${l}) failed to return a finite number, iterable list, or object.`);
            k ? n[g++](...y) : n[g++](y);
          }
        } else
          for (let m = n.length; --m >= 0; )
            n[m](...d);
    }, "quickToCB");
    return u.keys = c, u.options = (d) => {
      if (d !== void 0 && !ke(d) && typeof d != "function")
        throw new TypeError("AnimationGroupAPI.quickTo error: 'options' is not an object or function.");
      if (ke(d))
        for (let p = n.length; --p >= 0; )
          n[p].options(d);
      else if (typeof d == "function")
        if (vt(e)) {
          l = -1;
          let p = 0;
          for (const m of e) {
            l++;
            const g = Z(this, pt, ht).call(this, m), h = g ? m : m.position;
            if (!Z(this, pt, ht).call(this, h)) {
              console.warn(
                `AnimationGroupAPI.quickTo.options warning: No Position instance found at index: ${l}.`
              );
              continue;
            }
            if (o.index = l, o.position = e, o.data = g ? void 0 : m, a = d(o), a != null) {
              if (!ke(a))
                throw new TypeError(
                  `AnimationGroupAPI.quickTo.options error: options callback function iteration(${l}) failed to return an object.`
                );
              n[p++].options(a);
            }
          }
        } else {
          const p = Z(this, pt, ht).call(this, e), m = p ? e : e.position;
          if (!Z(this, pt, ht).call(this, m))
            return console.warn("AnimationGroupAPI.quickTo.options warning: No Position instance found."), u;
          if (o.index = 0, o.position = e, o.data = p ? void 0 : e, a = d(o), !ke(a))
            throw new TypeError(
              "AnimationGroupAPI.quickTo error: options callback function failed to return an object."
            );
          n[0].options(a);
        }
      return u;
    }, u;
  }
};
pt = new WeakSet(), ht = /* @__PURE__ */ f(function(e) {
  return ke(e) && e.animate instanceof Md;
}, "#isPosition"), /**
 * Checks of the given object is a TJSPosition instance by checking for AnimationAPI.
 *
 * @param {*}  object - Any data.
 *
 * @returns {boolean} Is TJSPosition.
 */
Y(Qp, pt), f(Qp, "AnimationGroupAPI");
let e_ = Qp;
var ql, Gl, xi, zl;
const I$ = class I$ {
  /**
   * @param {object}      [options] - Initial options.
   *
   * @param {HTMLElement} [options.element] - Target element.
   *
   * @param {boolean}     [options.lock=false] - Lock parameters from being set.
   *
   * @param {number}      [options.width] - Manual width.
   *
   * @param {number}      [options.height] - Manual height.
   */
  constructor({ element: e, lock: t = !1, width: s, height: n } = {}) {
    /**
     * @type {HTMLElement}
     */
    Y(this, ql, void 0);
    /**
     * Provides a manual setting of the element height. As things go `offsetHeight` causes a browser layout and is not
     * performance oriented. If manually set this height is used instead of `offsetHeight`.
     *
     * @type {number}
     */
    Y(this, Gl, void 0);
    /**
     * Set from an optional value in the constructor to lock accessors preventing modification.
     */
    Y(this, xi, void 0);
    /**
     * Provides a manual setting of the element width. As things go `offsetWidth` causes a browser layout and is not
     * performance oriented. If manually set this width is used instead of `offsetWidth`.
     *
     * @type {number}
     */
    Y(this, zl, void 0);
    this.element = e, this.width = s, this.height = n, ye(this, xi, typeof t == "boolean" ? t : !1);
  }
  /**
   * @returns {HTMLElement|undefined|null} Target element.
   */
  get element() {
    return M(this, ql);
  }
  /**
   * @returns {number} Get manual height.
   */
  get height() {
    return M(this, Gl);
  }
  /**
   * @returns {number} Get manual width.
   */
  get width() {
    return M(this, zl);
  }
  /**
   * @param {HTMLElement|undefined|null} element - Set target element.
   */
  set element(e) {
    if (!M(this, xi))
      if (e == null || e instanceof HTMLElement)
        ye(this, ql, e);
      else
        throw new TypeError("'element' is not a HTMLElement, undefined, or null.");
  }
  /**
   * @param {number}   height - Set manual height.
   */
  set height(e) {
    if (!M(this, xi))
      if (e === void 0 || Number.isFinite(e))
        ye(this, Gl, e);
      else
        throw new TypeError("'height' is not a finite number or undefined.");
  }
  /**
   * @param {number}   width - Set manual width.
   */
  set width(e) {
    if (!M(this, xi))
      if (e === void 0 || Number.isFinite(e))
        ye(this, zl, e);
      else
        throw new TypeError("'width' is not a finite number or undefined.");
  }
  /**
   * Set manual width & height.
   *
   * @param {number}   width - New manual width.
   *
   * @param {number}   height - New manual height.
   */
  setDimension(e, t) {
    if (!M(this, xi)) {
      if (e === void 0 || Number.isFinite(e))
        ye(this, zl, e);
      else
        throw new TypeError("'width' is not a finite number or undefined.");
      if (t === void 0 || Number.isFinite(t))
        ye(this, Gl, t);
      else
        throw new TypeError("'height' is not a finite number or undefined.");
    }
  }
  /**
   * Get the left constraint based on any manual target values or the browser inner width.
   *
   * @param {number}   width - Target width.
   *
   * @returns {number} Calculated left constraint.
   */
  getLeft(e) {
    var s;
    return ((M(this, zl) ?? ((s = M(this, ql)) == null ? void 0 : s.offsetWidth) ?? globalThis.innerWidth) - e) / 2;
  }
  /**
   * Get the top constraint based on any manual target values or the browser inner height.
   *
   * @param {number}   height - Target height.
   *
   * @returns {number} Calculated top constraint.
   */
  getTop(e) {
    var s;
    return ((M(this, Gl) ?? ((s = M(this, ql)) == null ? void 0 : s.offsetHeight) ?? globalThis.innerHeight) - e) / 2;
  }
};
ql = new WeakMap(), Gl = new WeakMap(), xi = new WeakMap(), zl = new WeakMap(), f(I$, "Centered");
let Rd = I$;
const P$ = class P$ {
  constructor() {
    this.left = !1, this.top = !1, this.width = !1, this.height = !1, this.maxHeight = !1, this.maxWidth = !1, this.minHeight = !1, this.minWidth = !1, this.zIndex = !1, this.transform = !1, this.transformOrigin = !1;
  }
  hasChange() {
    return this.left || this.top || this.width || this.height || this.maxHeight || this.maxWidth || this.minHeight || this.minWidth || this.zIndex || this.transform || this.transformOrigin;
  }
  set(e) {
    this.left = e, this.top = e, this.width = e, this.height = e, this.maxHeight = e, this.maxWidth = e, this.minHeight = e, this.minWidth = e, this.zIndex = e, this.transform = e, this.transformOrigin = e;
  }
};
f(P$, "PositionChangeSet");
let t_ = P$;
const M$ = class M$ {
  constructor({
    height: e = null,
    left: t = null,
    maxHeight: s = null,
    maxWidth: n = null,
    minHeight: l = null,
    minWidth: r = null,
    rotateX: o = null,
    rotateY: a = null,
    rotateZ: c = null,
    scale: u = null,
    translateX: d = null,
    translateY: p = null,
    translateZ: m = null,
    top: g = null,
    transformOrigin: h = null,
    width: _ = null,
    zIndex: y = null
  } = {}) {
    this.height = e, this.left = t, this.maxHeight = s, this.maxWidth = n, this.minHeight = l, this.minWidth = r, this.rotateX = o, this.rotateY = a, this.rotateZ = c, this.scale = u, this.top = g, this.transformOrigin = h, this.translateX = d, this.translateY = p, this.translateZ = m, this.width = _, this.zIndex = y, Object.seal(this);
  }
  /**
   * Copies given data to this instance.
   *
   * @param {TJSPositionData}   data - Copy from this instance.
   *
   * @returns {TJSPositionData} This instance.
   */
  copy(e) {
    return this.height = e.height, this.left = e.left, this.maxHeight = e.maxHeight, this.maxWidth = e.maxWidth, this.minHeight = e.minHeight, this.minWidth = e.minWidth, this.rotateX = e.rotateX, this.rotateY = e.rotateY, this.rotateZ = e.rotateZ, this.scale = e.scale, this.top = e.top, this.transformOrigin = e.transformOrigin, this.translateX = e.translateX, this.translateY = e.translateY, this.translateZ = e.translateZ, this.width = e.width, this.zIndex = e.zIndex, this;
  }
};
f(M$, "TJSPositionData");
let Ac = M$;
var nu, sn, bs, iu;
const R$ = class R$ {
  constructor(e, t, s) {
    /** @type {import('./TJSPositionData').TJSPositionData} */
    Y(this, nu, void 0);
    /**
     * @type {Map<string, import('./').TJSPositionDataExtended>}
     */
    Y(this, sn, /* @__PURE__ */ new Map());
    /** @type {import('./').TJSPosition} */
    Y(this, bs, void 0);
    /** @type {import('./transform').TJSTransforms} */
    Y(this, iu, void 0);
    ye(this, bs, e), ye(this, nu, t), ye(this, iu, s);
  }
  /**
   * Returns any stored save state by name.
   *
   * @param {object}   options - Options
   *
   * @param {string}   options.name - Saved data set name.
   *
   * @returns {import('./').TJSPositionDataExtended} The saved data set.
   */
  get({ name: e }) {
    if (typeof e != "string")
      throw new TypeError("Position - getSave error: 'name' is not a string.");
    return M(this, sn).get(e);
  }
  /**
   * Returns any associated default data.
   *
   * @returns {import('./').TJSPositionDataExtended} Associated default data.
   */
  getDefault() {
    return M(this, sn).get("#defaultData");
  }
  /**
   * Removes and returns any position state by name.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - Name to remove and retrieve.
   *
   * @returns {import('./').TJSPositionDataExtended} Saved position data.
   */
  remove({ name: e }) {
    if (typeof e != "string")
      throw new TypeError("Position - remove: 'name' is not a string.");
    const t = M(this, sn).get(e);
    return M(this, sn).delete(e), t;
  }
  /**
   * Resets data to default values and invokes set.
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.keepZIndex=false] - When true keeps current z-index.
   *
   * @param {boolean}  [opts.invokeSet=true] - When true invokes set method.
   *
   * @returns {boolean} Operation successful.
   */
  reset({ keepZIndex: e = !1, invokeSet: t = !0 } = {}) {
    var r, o, a, c;
    const s = M(this, sn).get("#defaultData");
    if (!ke(s))
      return !1;
    M(this, bs).animate.isScheduled && M(this, bs).animate.cancel();
    const n = M(this, bs).zIndex, l = Object.assign({}, s);
    return e && (l.zIndex = n), M(this, iu).reset(l), (o = (r = M(this, bs).parent) == null ? void 0 : r.reactive) != null && o.minimized && ((c = (a = M(this, bs).parent) == null ? void 0 : a.maximize) == null || c.call(a, { animate: !1, duration: 0 })), t && setTimeout(() => M(this, bs).set(l), 0), !0;
  }
  /**
      * Restores a saved positional state returning the data. Several optional parameters are available
      * to control whether the restore action occurs silently (no store / inline styles updates), animates
  -   * to the stored data, or simply sets the stored data. Restoring via {@link AnimationAPI.to}
      * allows specification of the duration, easing, and interpolate functions along with configuring a Promise to be
      * returned if awaiting the end of the animation.
      *
      * @param {object}            params - Parameters
      *
      * @param {string}            params.name - Saved data set name.
      *
      * @param {boolean}           [params.remove=false] - Remove data set.
      *
      * @param {Iterable<string>}  [params.properties] - Specific properties to set / animate.
      *
      * @param {boolean}           [params.silent] - Set position data directly; no store or style updates.
      *
      * @param {boolean}           [params.async=false] - If animating return a Promise that resolves with any saved data.
      *
      * @param {boolean}           [params.animateTo=false] - Animate to restore data.
      *
      * @param {number}            [params.duration=0.1] - Duration in seconds.
      *
      * @param {Function}          [params.ease=linear] - Easing function.
      *
      * @param {Function}          [params.interpolate=lerp] - Interpolation function.
      *
      * @returns {import('./').TJSPositionDataExtended | Promise<import('./').TJSPositionDataExtended>} Saved position
      *          data.
      */
  restore({
    name: e,
    remove: t = !1,
    properties: s,
    silent: n = !1,
    async: l = !1,
    animateTo: r = !1,
    duration: o = 0.1,
    ease: a = ei,
    interpolate: c = Pl
  }) {
    if (typeof e != "string")
      throw new TypeError("Position - restore error: 'name' is not a string.");
    const u = M(this, sn).get(e);
    if (u) {
      t && M(this, sn).delete(e);
      let d = u;
      if (vt(s)) {
        d = {};
        for (const p of s)
          d[p] = u[p];
      }
      if (n) {
        for (const p in d)
          M(this, nu)[p] = d[p];
        return u;
      } else if (r) {
        if (d.transformOrigin !== M(this, bs).transformOrigin && (M(this, bs).transformOrigin = d.transformOrigin), l)
          return M(this, bs).animate.to(d, { duration: o, ease: a, interpolate: c }).finished.then(() => u);
        M(this, bs).animate.to(d, { duration: o, ease: a, interpolate: c });
      } else
        M(this, bs).set(d);
    }
    return u;
  }
  /**
   * Saves current position state with the opportunity to add extra data to the saved state.
   *
   * @param {object}   opts - Options.
   *
   * @param {string}   opts.name - name to index this saved data.
   *
   * @param {...*}     [opts.extra] - Extra data to add to saved data.
   *
   * @returns {import('./').TJSPositionData} Current position data
   */
  save({ name: e, ...t }) {
    if (typeof e != "string")
      throw new TypeError("Position - save error: 'name' is not a string.");
    const s = M(this, bs).get(t);
    return M(this, sn).set(e, s), s;
  }
  /**
   * Directly sets a position state.
   *
   * @param {object}   opts - Options.
   *
   * @param {string}   opts.name - name to index this saved data.
   *
   * @param {...*}     [opts.data] - TJSPosition data to set.
   */
  set({ name: e, ...t }) {
    if (typeof e != "string")
      throw new TypeError("Position - set error: 'name' is not a string.");
    M(this, sn).set(e, t);
  }
};
nu = new WeakMap(), sn = new WeakMap(), bs = new WeakMap(), iu = new WeakMap(), f(R$, "PositionStateAPI");
let s_ = R$;
const F$ = class F$ {
  constructor() {
    this.el = void 0, this.computed = void 0, this.marginLeft = void 0, this.marginTop = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.minHeight = void 0, this.minWidth = void 0, this.hasWillChange = !1, this.resizeObserved = {
      contentHeight: void 0,
      contentWidth: void 0,
      offsetHeight: void 0,
      offsetWidth: void 0
    };
    const e = It(this.resizeObserved);
    this.stores = {
      element: It(this.el),
      resizeContentHeight: dt(e, "contentHeight"),
      resizeContentWidth: dt(e, "contentWidth"),
      resizeObserved: e,
      resizeOffsetHeight: dt(e, "offsetHeight"),
      resizeOffsetWidth: dt(e, "offsetWidth")
    };
  }
  /**
   * Returns the cached offsetHeight from any attached `resizeObserver` action otherwise gets the offsetHeight from
   * the element directly. The more optimized path is using `resizeObserver` as getting it from the element
   * directly is more expensive and alters the execution order of an animation frame.
   *
   * @returns {number} The element offsetHeight.
   */
  get offsetHeight() {
    if (this.el instanceof HTMLElement)
      return this.resizeObserved.offsetHeight !== void 0 ? this.resizeObserved.offsetHeight : this.el.offsetHeight;
    throw new Error("StyleCache - get offsetHeight error: no element assigned.");
  }
  /**
   * Returns the cached offsetWidth from any attached `resizeObserver` action otherwise gets the offsetWidth from
   * the element directly. The more optimized path is using `resizeObserver` as getting it from the element
   * directly is more expensive and alters the execution order of an animation frame.
   *
   * @returns {number} The element offsetHeight.
   */
  get offsetWidth() {
    if (this.el instanceof HTMLElement)
      return this.resizeObserved.offsetWidth !== void 0 ? this.resizeObserved.offsetWidth : this.el.offsetWidth;
    throw new Error("StyleCache - get offsetWidth error: no element assigned.");
  }
  /**
   * @param {HTMLElement} el -
   *
   * @returns {boolean} Does element match cached element.
   */
  hasData(e) {
    return this.el === e;
  }
  /**
   * Resets the style cache.
   */
  reset() {
    this.el instanceof HTMLElement && this.el.isConnected && !this.hasWillChange && (this.el.style.willChange = null), this.el = void 0, this.computed = void 0, this.marginLeft = void 0, this.marginTop = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.minHeight = void 0, this.minWidth = void 0, this.hasWillChange = !1, this.resizeObserved.contentHeight = void 0, this.resizeObserved.contentWidth = void 0, this.resizeObserved.offsetHeight = void 0, this.resizeObserved.offsetWidth = void 0, this.stores.element.set(void 0);
  }
  /**
   * Updates the style cache with new data from the given element.
   *
   * @param {HTMLElement} el - An HTML element.
   */
  update(e) {
    this.el = e, this.computed = globalThis.getComputedStyle(e), this.marginLeft = ot.pixels(e.style.marginLeft) ?? ot.pixels(this.computed.marginLeft), this.marginTop = ot.pixels(e.style.marginTop) ?? ot.pixels(this.computed.marginTop), this.maxHeight = ot.pixels(e.style.maxHeight) ?? ot.pixels(this.computed.maxHeight), this.maxWidth = ot.pixels(e.style.maxWidth) ?? ot.pixels(this.computed.maxWidth), this.minHeight = ot.pixels(e.style.minHeight) ?? ot.pixels(this.computed.minHeight), this.minWidth = ot.pixels(e.style.minWidth) ?? ot.pixels(this.computed.minWidth);
    const t = e.style.willChange !== "" ? e.style.willChange : this.computed.willChange;
    this.hasWillChange = t !== "" && t !== "auto", this.stores.element.set(e);
  }
};
f(F$, "StyleCache");
let n_ = F$;
var xp, em, tm, sm;
const N$ = class N$ {
  constructor() {
    /**
     * Stores the calculated bounding rectangle.
     *
     * @type {DOMRect}
     */
    Y(this, xp, new DOMRect());
    /**
     * Stores the individual transformed corner points of the window in screen space clockwise from:
     * top left -> top right -> bottom right -> bottom left.
     *
     * @type {import('#runtime/math/gl-matrix').Vec3[]}
     */
    Y(this, em, [lt.create(), lt.create(), lt.create(), lt.create()]);
    /**
     * Stores the current gl-matrix Mat4 data.
     *
     * @type {import('#runtime/math/gl-matrix').Mat4}
     */
    Y(this, tm, He.create());
    /**
     * Stores the pre & post origin translations to apply to matrix transforms.
     *
     * @type {import('#runtime/math/gl-matrix').Mat4[]}
     */
    Y(this, sm, [He.create(), He.create()]);
    Object.seal(this);
  }
  /**
   * @returns {DOMRect} The bounding rectangle.
   */
  get boundingRect() {
    return M(this, xp);
  }
  /**
   * @returns {import('#runtime/math/gl-matrix').Vec3[]} The transformed corner points as Vec3 in screen space.
   */
  get corners() {
    return M(this, em);
  }
  /**
   * @returns {string} Returns the CSS style string for the transform matrix.
   */
  get css() {
    return `matrix3d(${this.mat4.join(",")})`;
  }
  /**
   * @returns {import('#runtime/math/gl-matrix').Mat4} The transform matrix.
   */
  get mat4() {
    return M(this, tm);
  }
  /**
   * @returns {import('#runtime/math/gl-matrix').Mat4[]} The pre / post translation matrices for origin translation.
   */
  get originTranslations() {
    return M(this, sm);
  }
};
xp = new WeakMap(), em = new WeakMap(), tm = new WeakMap(), sm = new WeakMap(), f(N$, "TJSTransformData");
let ua = N$;
const hi = [1, 1, 1], jt = [0, 0, 0], NO = He.create(), xt = He.create(), Gz = lt.create();
var Ot;
const j$ = class j$ {
  constructor() {
    /**
     * Stores the transform keys in the order added.
     *
     * @type {string[]}
     */
    Y(this, Ot, []);
    this._data = {};
  }
  /**
   * @returns {boolean} Whether there are active transforms in local data.
   */
  get isActive() {
    return M(this, Ot).length > 0;
  }
  /**
   * @returns {number|undefined} Any local rotateX data.
   */
  get rotateX() {
    return this._data.rotateX;
  }
  /**
   * @returns {number|undefined} Any local rotateY data.
   */
  get rotateY() {
    return this._data.rotateY;
  }
  /**
   * @returns {number|undefined} Any local rotateZ data.
   */
  get rotateZ() {
    return this._data.rotateZ;
  }
  /**
   * @returns {number|undefined} Any local rotateZ scale.
   */
  get scale() {
    return this._data.scale;
  }
  /**
   * @returns {number|undefined} Any local translateZ data.
   */
  get translateX() {
    return this._data.translateX;
  }
  /**
   * @returns {number|undefined} Any local translateZ data.
   */
  get translateY() {
    return this._data.translateY;
  }
  /**
   * @returns {number|undefined} Any local translateZ data.
   */
  get translateZ() {
    return this._data.translateZ;
  }
  /**
   * Sets the local rotateX data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set rotateX(e) {
    if (Number.isFinite(e))
      this._data.rotateX === void 0 && M(this, Ot).push("rotateX"), this._data.rotateX = e;
    else {
      if (this._data.rotateX !== void 0) {
        const t = M(this, Ot).findIndex((s) => s === "rotateX");
        t >= 0 && M(this, Ot).splice(t, 1);
      }
      delete this._data.rotateX;
    }
  }
  /**
   * Sets the local rotateY data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set rotateY(e) {
    if (Number.isFinite(e))
      this._data.rotateY === void 0 && M(this, Ot).push("rotateY"), this._data.rotateY = e;
    else {
      if (this._data.rotateY !== void 0) {
        const t = M(this, Ot).findIndex((s) => s === "rotateY");
        t >= 0 && M(this, Ot).splice(t, 1);
      }
      delete this._data.rotateY;
    }
  }
  /**
   * Sets the local rotateZ data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set rotateZ(e) {
    if (Number.isFinite(e))
      this._data.rotateZ === void 0 && M(this, Ot).push("rotateZ"), this._data.rotateZ = e;
    else {
      if (this._data.rotateZ !== void 0) {
        const t = M(this, Ot).findIndex((s) => s === "rotateZ");
        t >= 0 && M(this, Ot).splice(t, 1);
      }
      delete this._data.rotateZ;
    }
  }
  /**
   * Sets the local scale data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set scale(e) {
    if (Number.isFinite(e))
      this._data.scale === void 0 && M(this, Ot).push("scale"), this._data.scale = e;
    else {
      if (this._data.scale !== void 0) {
        const t = M(this, Ot).findIndex((s) => s === "scale");
        t >= 0 && M(this, Ot).splice(t, 1);
      }
      delete this._data.scale;
    }
  }
  /**
   * Sets the local translateX data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set translateX(e) {
    if (Number.isFinite(e))
      this._data.translateX === void 0 && M(this, Ot).push("translateX"), this._data.translateX = e;
    else {
      if (this._data.translateX !== void 0) {
        const t = M(this, Ot).findIndex((s) => s === "translateX");
        t >= 0 && M(this, Ot).splice(t, 1);
      }
      delete this._data.translateX;
    }
  }
  /**
   * Sets the local translateY data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set translateY(e) {
    if (Number.isFinite(e))
      this._data.translateY === void 0 && M(this, Ot).push("translateY"), this._data.translateY = e;
    else {
      if (this._data.translateY !== void 0) {
        const t = M(this, Ot).findIndex((s) => s === "translateY");
        t >= 0 && M(this, Ot).splice(t, 1);
      }
      delete this._data.translateY;
    }
  }
  /**
   * Sets the local translateZ data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set translateZ(e) {
    if (Number.isFinite(e))
      this._data.translateZ === void 0 && M(this, Ot).push("translateZ"), this._data.translateZ = e;
    else {
      if (this._data.translateZ !== void 0) {
        const t = M(this, Ot).findIndex((s) => s === "translateZ");
        t >= 0 && M(this, Ot).splice(t, 1);
      }
      delete this._data.translateZ;
    }
  }
  /**
   * Returns the matrix3d CSS transform for the given position / transform data.
   *
   * @param {object} [data] - Optional position data otherwise use local stored transform data.
   *
   * @returns {string} The CSS matrix3d string.
   */
  getCSS(e = this._data) {
    return `matrix3d(${this.getMat4(e, NO).join(",")})`;
  }
  /**
   * Returns the matrix3d CSS transform for the given position / transform data.
   *
   * @param {object} [data] - Optional position data otherwise use local stored transform data.
   *
   * @returns {string} The CSS matrix3d string.
   */
  getCSSOrtho(e = this._data) {
    return `matrix3d(${this.getMat4Ortho(e, NO).join(",")})`;
  }
  /**
   * Collects all data including a bounding rect, transform matrix, and points array of the given
   * {@link TJSPositionData} instance with the applied local transform data.
   *
   * @param {import('../').TJSPositionData} position - The position data to process.
   *
   * @param {TJSTransformData} [output] - Optional TJSTransformData output instance.
   *
   * @param {object} [validationData] - Optional validation data for adjustment parameters.
   *
   * @returns {TJSTransformData} The output TJSTransformData instance.
   */
  getData(e, t = new ua(), s = {}) {
    const n = s.width ?? 0, l = s.height ?? 0, r = s.offsetTop ?? s.marginTop ?? 0, o = s.offsetLeft ?? s.offsetLeft ?? 0;
    e.top += r, e.left += o;
    const a = Number.isFinite(e.width) ? e.width : n, c = Number.isFinite(e.height) ? e.height : l, u = t.corners;
    if (this.hasTransform(e)) {
      u[0][0] = u[0][1] = u[0][2] = 0, u[1][0] = a, u[1][1] = u[1][2] = 0, u[2][0] = a, u[2][1] = c, u[2][2] = 0, u[3][0] = 0, u[3][1] = c, u[3][2] = 0;
      const _ = this.getMat4(e, t.mat4), y = zz(e.transformOrigin, a, c, t.originTranslations);
      qz === e.transformOrigin ? (lt.transformMat4(u[0], u[0], _), lt.transformMat4(u[1], u[1], _), lt.transformMat4(u[2], u[2], _), lt.transformMat4(u[3], u[3], _)) : (lt.transformMat4(u[0], u[0], y[0]), lt.transformMat4(u[0], u[0], _), lt.transformMat4(u[0], u[0], y[1]), lt.transformMat4(u[1], u[1], y[0]), lt.transformMat4(u[1], u[1], _), lt.transformMat4(u[1], u[1], y[1]), lt.transformMat4(u[2], u[2], y[0]), lt.transformMat4(u[2], u[2], _), lt.transformMat4(u[2], u[2], y[1]), lt.transformMat4(u[3], u[3], y[0]), lt.transformMat4(u[3], u[3], _), lt.transformMat4(u[3], u[3], y[1])), u[0][0] = e.left + u[0][0], u[0][1] = e.top + u[0][1], u[1][0] = e.left + u[1][0], u[1][1] = e.top + u[1][1], u[2][0] = e.left + u[2][0], u[2][1] = e.top + u[2][1], u[3][0] = e.left + u[3][0], u[3][1] = e.top + u[3][1];
    } else
      u[0][0] = e.left, u[0][1] = e.top, u[1][0] = e.left + a, u[1][1] = e.top, u[2][0] = e.left + a, u[2][1] = e.top + c, u[3][0] = e.left, u[3][1] = e.top + c, He.identity(t.mat4);
    let d = Number.MIN_SAFE_INTEGER, p = Number.MIN_SAFE_INTEGER, m = Number.MAX_SAFE_INTEGER, g = Number.MAX_SAFE_INTEGER;
    for (let _ = 4; --_ >= 0; )
      u[_][0] > d && (d = u[_][0]), u[_][0] < m && (m = u[_][0]), u[_][1] > p && (p = u[_][1]), u[_][1] < g && (g = u[_][1]);
    const h = t.boundingRect;
    return h.x = m, h.y = g, h.width = d - m, h.height = p - g, e.top -= r, e.left -= o, t;
  }
  /**
   * Creates a transform matrix based on local data applied in order it was added.
   *
   * If no data object is provided then the source is the local transform data. If another data object is supplied
   * then the stored local transform order is applied then all remaining transform keys are applied. This allows the
   * construction of a transform matrix in advance of setting local data and is useful in collision detection.
   *
   * @param {object}   [data] - TJSPositionData instance or local transform data.
   *
   * @param {import('#runtime/math/gl-matrix').Mat4}  [output] - The output mat4 instance.
   *
   * @returns {import('#runtime/math/gl-matrix').Mat4} Transform matrix.
   */
  getMat4(e = this._data, t = He.create()) {
    const s = He.identity(t);
    let n = 0;
    const l = M(this, Ot);
    for (let r = 0; r < l.length; r++) {
      const o = l[r];
      switch (o) {
        case "rotateX":
          n |= Ns.rotateX, He.multiply(s, s, He.fromXRotation(xt, Js(e[o])));
          break;
        case "rotateY":
          n |= Ns.rotateY, He.multiply(s, s, He.fromYRotation(xt, Js(e[o])));
          break;
        case "rotateZ":
          n |= Ns.rotateZ, He.multiply(s, s, He.fromZRotation(xt, Js(e[o])));
          break;
        case "scale":
          n |= Ns.scale, hi[0] = hi[1] = e[o], He.multiply(s, s, He.fromScaling(xt, hi));
          break;
        case "translateX":
          n |= Ns.translateX, jt[0] = e.translateX, jt[1] = 0, jt[2] = 0, He.multiply(s, s, He.fromTranslation(xt, jt));
          break;
        case "translateY":
          n |= Ns.translateY, jt[0] = 0, jt[1] = e.translateY, jt[2] = 0, He.multiply(s, s, He.fromTranslation(xt, jt));
          break;
        case "translateZ":
          n |= Ns.translateZ, jt[0] = 0, jt[1] = 0, jt[2] = e.translateZ, He.multiply(s, s, He.fromTranslation(xt, jt));
          break;
      }
    }
    if (e !== this._data)
      for (let r = 0; r < Al.length; r++) {
        const o = Al[r];
        if (!(e[o] === null || (n & Ns[o]) > 0))
          switch (o) {
            case "rotateX":
              He.multiply(s, s, He.fromXRotation(xt, Js(e[o])));
              break;
            case "rotateY":
              He.multiply(s, s, He.fromYRotation(xt, Js(e[o])));
              break;
            case "rotateZ":
              He.multiply(s, s, He.fromZRotation(xt, Js(e[o])));
              break;
            case "scale":
              hi[0] = hi[1] = e[o], He.multiply(s, s, He.fromScaling(xt, hi));
              break;
            case "translateX":
              jt[0] = e[o], jt[1] = 0, jt[2] = 0, He.multiply(s, s, He.fromTranslation(xt, jt));
              break;
            case "translateY":
              jt[0] = 0, jt[1] = e[o], jt[2] = 0, He.multiply(s, s, He.fromTranslation(xt, jt));
              break;
            case "translateZ":
              jt[0] = 0, jt[1] = 0, jt[2] = e[o], He.multiply(s, s, He.fromTranslation(xt, jt));
              break;
          }
      }
    return s;
  }
  /**
   * Provides an orthographic enhancement to convert left / top positional data to a translate operation.
   *
   * This transform matrix takes into account that the remaining operations are , but adds any left / top attributes from passed in data to
   * translate X / Y.
   *
   * If no data object is provided then the source is the local transform data. If another data object is supplied
   * then the stored local transform order is applied then all remaining transform keys are applied. This allows the
   * construction of a transform matrix in advance of setting local data and is useful in collision detection.
   *
   * @param {object}   [data] - TJSPositionData instance or local transform data.
   *
   * @param {import('#runtime/math/gl-matrix').Mat4}  [output] - The output mat4 instance.
   *
   * @returns {import('#runtime/math/gl-matrix').Mat4} Transform matrix.
   */
  getMat4Ortho(e = this._data, t = He.create()) {
    const s = He.identity(t);
    if (jt[0] = (e.left ?? 0) + (e.translateX ?? 0), jt[1] = (e.top ?? 0) + (e.translateY ?? 0), jt[2] = e.translateZ ?? 0, He.multiply(s, s, He.fromTranslation(xt, jt)), e.scale !== null && (hi[0] = hi[1] = e.scale, He.multiply(s, s, He.fromScaling(xt, hi))), e.rotateX === null && e.rotateY === null && e.rotateZ === null)
      return s;
    let n = 0;
    const l = M(this, Ot);
    for (let r = 0; r < l.length; r++) {
      const o = l[r];
      switch (o) {
        case "rotateX":
          n |= Ns.rotateX, He.multiply(s, s, He.fromXRotation(xt, Js(e[o])));
          break;
        case "rotateY":
          n |= Ns.rotateY, He.multiply(s, s, He.fromYRotation(xt, Js(e[o])));
          break;
        case "rotateZ":
          n |= Ns.rotateZ, He.multiply(s, s, He.fromZRotation(xt, Js(e[o])));
          break;
      }
    }
    if (e !== this._data)
      for (let r = 0; r < Al.length; r++) {
        const o = Al[r];
        if (!(e[o] === null || (n & Ns[o]) > 0))
          switch (o) {
            case "rotateX":
              He.multiply(s, s, He.fromXRotation(xt, Js(e[o])));
              break;
            case "rotateY":
              He.multiply(s, s, He.fromYRotation(xt, Js(e[o])));
              break;
            case "rotateZ":
              He.multiply(s, s, He.fromZRotation(xt, Js(e[o])));
              break;
          }
      }
    return s;
  }
  /**
   * Tests an object if it contains transform keys and the values are finite numbers.
   *
   * @param {object} data - An object to test for transform data.
   *
   * @returns {boolean} Whether the given TJSPositionData has transforms.
   */
  hasTransform(e) {
    for (const t of Al)
      if (Number.isFinite(e[t]))
        return !0;
    return !1;
  }
  /**
   * Resets internal data from the given object containing valid transform keys.
   *
   * @param {object}   data - An object with transform data.
   */
  reset(e) {
    for (const t in e)
      if (Al.includes(t))
        if (Number.isFinite(e[t]))
          this._data[t] = e[t];
        else {
          const s = M(this, Ot).findIndex((n) => n === t);
          s >= 0 && M(this, Ot).splice(s, 1), delete this._data[t];
        }
  }
};
Ot = new WeakMap(), f(j$, "TJSTransforms");
let i_ = j$;
function zz(i, e, t, s) {
  const n = Gz;
  switch (i) {
    case "top left":
      n[0] = n[1] = 0, He.fromTranslation(s[0], n), He.fromTranslation(s[1], n);
      break;
    case "top center":
      n[0] = -e * 0.5, n[1] = 0, He.fromTranslation(s[0], n), n[0] = e * 0.5, He.fromTranslation(s[1], n);
      break;
    case "top right":
      n[0] = -e, n[1] = 0, He.fromTranslation(s[0], n), n[0] = e, He.fromTranslation(s[1], n);
      break;
    case "center left":
      n[0] = 0, n[1] = -t * 0.5, He.fromTranslation(s[0], n), n[1] = t * 0.5, He.fromTranslation(s[1], n);
      break;
    case null:
    case "center":
      n[0] = -e * 0.5, n[1] = -t * 0.5, He.fromTranslation(s[0], n), n[0] = e * 0.5, n[1] = t * 0.5, He.fromTranslation(s[1], n);
      break;
    case "center right":
      n[0] = -e, n[1] = -t * 0.5, He.fromTranslation(s[0], n), n[0] = e, n[1] = t * 0.5, He.fromTranslation(s[1], n);
      break;
    case "bottom left":
      n[0] = 0, n[1] = -t, He.fromTranslation(s[0], n), n[1] = t, He.fromTranslation(s[1], n);
      break;
    case "bottom center":
      n[0] = -e * 0.5, n[1] = -t, He.fromTranslation(s[0], n), n[0] = e * 0.5, n[1] = t, He.fromTranslation(s[1], n);
      break;
    case "bottom right":
      n[0] = -e, n[1] = -t, He.fromTranslation(s[0], n), n[0] = e, n[1] = t, He.fromTranslation(s[1], n);
      break;
    default:
      He.identity(s[0]), He.identity(s[1]);
      break;
  }
  return s;
}
f(zz, "s_GET_ORIGIN_TRANSLATION");
var lu, ts, qs;
const L$ = class L$ {
  /**
   * @returns {[AdapterValidators, import('../').ValidatorData[]]} Returns this and internal storage for validator
   *          adapter.
   */
  constructor() {
    /** @type {boolean} */
    Y(this, lu, !0);
    /**
     * @type {import('../').ValidatorData[]}
     */
    Y(this, ts, void 0);
    Y(this, qs, /* @__PURE__ */ new Map());
    return ye(this, ts, []), Object.seal(this), [this, M(this, ts)];
  }
  /**
   * @returns {boolean} Returns the enabled state.s
   */
  get enabled() {
    return M(this, lu);
  }
  /**
   * @returns {number} Returns the length of the validators array.
   */
  get length() {
    return M(this, ts).length;
  }
  /**
   * @param {boolean}  enabled - Sets enabled state.
   */
  set enabled(e) {
    if (typeof e != "boolean")
      throw new TypeError("'enabled' is not a boolean.");
    ye(this, lu, e);
  }
  /**
   * Provides an iterator for validators.
   *
   * @yields {import('../').ValidatorData}
   */
  *[Symbol.iterator]() {
    if (M(this, ts).length !== 0)
      for (const e of M(this, ts))
        yield { ...e };
  }
  /**
   * @param {...(import('../').ValidatorFn | import('../').ValidatorData)}   validators -
   */
  add(...e) {
    for (const t of e) {
      const s = typeof t;
      if (s !== "function" && s !== "object" || t === null)
        throw new TypeError("AdapterValidator error: 'validator' is not a function or object.");
      let n, l;
      switch (s) {
        case "function":
          n = {
            id: void 0,
            validator: t,
            weight: 1
          }, l = t.subscribe;
          break;
        case "object":
          if (typeof t.validator != "function")
            throw new TypeError("AdapterValidator error: 'validator' attribute is not a function.");
          if (t.weight !== void 0 && typeof t.weight != "number" || t.weight < 0 || t.weight > 1)
            throw new TypeError(
              "AdapterValidator error: 'weight' attribute is not a number between '0 - 1' inclusive."
            );
          n = {
            id: t.id !== void 0 ? t.id : void 0,
            validator: t.validator.bind(t),
            weight: t.weight || 1,
            instance: t
          }, l = t.validator.subscribe ?? t.subscribe;
          break;
      }
      const r = M(this, ts).findIndex((o) => n.weight < o.weight);
      if (r >= 0 ? M(this, ts).splice(r, 0, n) : M(this, ts).push(n), typeof l == "function") {
        const o = l();
        if (typeof o != "function")
          throw new TypeError(
            "AdapterValidator error: Filter has subscribe function, but no unsubscribe function is returned."
          );
        if (M(this, qs).has(n.validator))
          throw new Error(
            "AdapterValidator error: Filter added already has an unsubscribe function registered."
          );
        M(this, qs).set(n.validator, o);
      }
    }
  }
  clear() {
    M(this, ts).length = 0;
    for (const e of M(this, qs).values())
      e();
    M(this, qs).clear();
  }
  /**
   * @param {...(import('../').ValidatorFn | import('../').ValidatorData)}   validators -
   */
  remove(...e) {
    if (M(this, ts).length !== 0)
      for (const s of e) {
        const n = typeof s == "function" ? s : ke(s) ? s.validator : void 0;
        if (n) {
          for (let l = M(this, ts).length; --l >= 0; )
            if (M(this, ts)[l].validator === n) {
              M(this, ts).splice(l, 1);
              let r;
              typeof (r = M(this, qs).get(n)) == "function" && (r(), M(this, qs).delete(n));
            }
        }
      }
  }
  /**
   * Remove validators by the provided callback. The callback takes 3 parameters: `id`, `validator`, and `weight`.
   * Any truthy value returned will remove that validator.
   *
   * @param {function(*, import('../').ValidatorFn, number): boolean} callback - Callback function to evaluate each
   *        validator entry.
   */
  removeBy(e) {
    if (M(this, ts).length !== 0) {
      if (typeof e != "function")
        throw new TypeError("AdapterValidator error: 'callback' is not a function.");
      ye(this, ts, M(this, ts).filter((s) => {
        const n = e.call(e, { ...s });
        if (n) {
          let l;
          typeof (l = M(this, qs).get(s.validator)) == "function" && (l(), M(this, qs).delete(s.validator));
        }
        return !n;
      }));
    }
  }
  removeById(...e) {
    M(this, ts).length !== 0 && ye(this, ts, M(this, ts).filter((s) => {
      let n = !1;
      for (const l of e)
        n |= s.id === l;
      if (n) {
        let l;
        typeof (l = M(this, qs).get(s.validator)) == "function" && (l(), M(this, qs).delete(s.validator));
      }
      return !n;
    }));
  }
};
lu = new WeakMap(), ts = new WeakMap(), qs = new WeakMap(), f(L$, "AdapterValidators");
let l_ = L$;
var Hl, Ul, Eo, Vl, zn, Wl;
const B$ = class B$ {
  constructor({ constrain: e = !0, element: t, enabled: s = !0, lock: n = !1, width: l, height: r } = {}) {
    /**
     * When true constrains the min / max width or height to element.
     *
     * @type {boolean}
     */
    Y(this, Hl, void 0);
    /**
     * @type {HTMLElement}
     */
    Y(this, Ul, void 0);
    /**
     * When true the validator is active.
     *
     * @type {boolean}
     */
    Y(this, Eo, void 0);
    /**
     * Provides a manual setting of the element height. As things go `offsetHeight` causes a browser layout and is not
     * performance oriented. If manually set this height is used instead of `offsetHeight`.
     *
     * @type {number}
     */
    Y(this, Vl, void 0);
    /**
     * Set from an optional value in the constructor to lock accessors preventing modification.
     */
    Y(this, zn, void 0);
    /**
     * Provides a manual setting of the element width. As things go `offsetWidth` causes a browser layout and is not
     * performance oriented. If manually set this width is used instead of `offsetWidth`.
     *
     * @type {number}
     */
    Y(this, Wl, void 0);
    this.element = t, this.constrain = e, this.enabled = s, this.width = l, this.height = r, ye(this, zn, typeof n == "boolean" ? n : !1);
  }
  get constrain() {
    return M(this, Hl);
  }
  get element() {
    return M(this, Ul);
  }
  get enabled() {
    return M(this, Eo);
  }
  get height() {
    return M(this, Vl);
  }
  get width() {
    return M(this, Wl);
  }
  set constrain(e) {
    if (!M(this, zn)) {
      if (typeof e != "boolean")
        throw new TypeError("'constrain' is not a boolean.");
      ye(this, Hl, e);
    }
  }
  set element(e) {
    if (!M(this, zn))
      if (e == null || e instanceof HTMLElement)
        ye(this, Ul, e);
      else
        throw new TypeError("'element' is not a HTMLElement, undefined, or null.");
  }
  set enabled(e) {
    if (!M(this, zn)) {
      if (typeof e != "boolean")
        throw new TypeError("'enabled' is not a boolean.");
      ye(this, Eo, e);
    }
  }
  set height(e) {
    if (!M(this, zn))
      if (e === void 0 || Number.isFinite(e))
        ye(this, Vl, e);
      else
        throw new TypeError("'height' is not a finite number or undefined.");
  }
  set width(e) {
    if (!M(this, zn))
      if (e === void 0 || Number.isFinite(e))
        ye(this, Wl, e);
      else
        throw new TypeError("'width' is not a finite number or undefined.");
  }
  setDimension(e, t) {
    if (!M(this, zn)) {
      if (e === void 0 || Number.isFinite(e))
        ye(this, Wl, e);
      else
        throw new TypeError("'width' is not a finite number or undefined.");
      if (t === void 0 || Number.isFinite(t))
        ye(this, Vl, t);
      else
        throw new TypeError("'height' is not a finite number or undefined.");
    }
  }
  /**
   * Provides a validator that respects transforms in positional data constraining the position to within the target
   * elements bounds.
   *
   * @param {import('../').ValidationData}   valData - The associated validation data for position updates.
   *
   * @returns {import('../').TJSPositionData} Potentially adjusted position data.
   */
  validator(e) {
    var r, o;
    if (!M(this, Eo))
      return e.position;
    const t = M(this, Wl) ?? ((r = M(this, Ul)) == null ? void 0 : r.offsetWidth) ?? globalThis.innerWidth, s = M(this, Vl) ?? ((o = M(this, Ul)) == null ? void 0 : o.offsetHeight) ?? globalThis.innerHeight;
    if (typeof e.position.width == "number") {
      const a = e.maxWidth ?? (M(this, Hl) ? t : Number.MAX_SAFE_INTEGER);
      e.position.width = e.width = Yr(e.position.width, e.minWidth, a), e.width + e.position.left + e.marginLeft > t && (e.position.left = t - e.width - e.marginLeft);
    }
    if (typeof e.position.height == "number") {
      const a = e.maxHeight ?? (M(this, Hl) ? s : Number.MAX_SAFE_INTEGER);
      e.position.height = e.height = Yr(e.position.height, e.minHeight, a), e.height + e.position.top + e.marginTop > s && (e.position.top = s - e.height - e.marginTop);
    }
    const n = Math.max(t - e.width - e.marginLeft, 0);
    e.position.left = Math.round(Yr(e.position.left, 0, n));
    const l = Math.max(s - e.height - e.marginTop, 0);
    return e.position.top = Math.round(Yr(e.position.top, 0, l)), e.position;
  }
};
Hl = new WeakMap(), Ul = new WeakMap(), Eo = new WeakMap(), Vl = new WeakMap(), zn = new WeakMap(), Wl = new WeakMap(), f(B$, "BasicBounds");
let Fd = B$;
const Hz = new ua();
var Kl, Yl, So, Xl, Hn, Jl;
const q$ = class q$ {
  constructor({ constrain: e = !0, element: t, enabled: s = !0, lock: n = !1, width: l, height: r } = {}) {
    /**
     * When true constrains the min / max width or height to element.
     *
     * @type {boolean}
     */
    Y(this, Kl, void 0);
    /**
     * @type {HTMLElement}
     */
    Y(this, Yl, void 0);
    /**
     * When true the validator is active.
     *
     * @type {boolean}
     */
    Y(this, So, void 0);
    /**
     * Provides a manual setting of the element height. As things go `offsetHeight` causes a browser layout and is not
     * performance oriented. If manually set this height is used instead of `offsetHeight`.
     *
     * @type {number}
     */
    Y(this, Xl, void 0);
    /**
     * Set from an optional value in the constructor to lock accessors preventing modification.
     */
    Y(this, Hn, void 0);
    /**
     * Provides a manual setting of the element width. As things go `offsetWidth` causes a browser layout and is not
     * performance oriented. If manually set this width is used instead of `offsetWidth`.
     *
     * @type {number}
     */
    Y(this, Jl, void 0);
    this.element = t, this.constrain = e, this.enabled = s, this.width = l, this.height = r, ye(this, Hn, typeof n == "boolean" ? n : !1);
  }
  get constrain() {
    return M(this, Kl);
  }
  get element() {
    return M(this, Yl);
  }
  get enabled() {
    return M(this, So);
  }
  get height() {
    return M(this, Xl);
  }
  get width() {
    return M(this, Jl);
  }
  set constrain(e) {
    if (!M(this, Hn)) {
      if (typeof e != "boolean")
        throw new TypeError("'constrain' is not a boolean.");
      ye(this, Kl, e);
    }
  }
  set element(e) {
    if (!M(this, Hn))
      if (e == null || e instanceof HTMLElement)
        ye(this, Yl, e);
      else
        throw new TypeError("'element' is not a HTMLElement, undefined, or null.");
  }
  set enabled(e) {
    if (!M(this, Hn)) {
      if (typeof e != "boolean")
        throw new TypeError("'enabled' is not a boolean.");
      ye(this, So, e);
    }
  }
  set height(e) {
    if (!M(this, Hn))
      if (e === void 0 || Number.isFinite(e))
        ye(this, Xl, e);
      else
        throw new TypeError("'height' is not a finite number or undefined.");
  }
  set width(e) {
    if (!M(this, Hn))
      if (e === void 0 || Number.isFinite(e))
        ye(this, Jl, e);
      else
        throw new TypeError("'width' is not a finite number or undefined.");
  }
  setDimension(e, t) {
    if (!M(this, Hn)) {
      if (e === void 0 || Number.isFinite(e))
        ye(this, Jl, e);
      else
        throw new TypeError("'width' is not a finite number or undefined.");
      if (t === void 0 || Number.isFinite(t))
        ye(this, Xl, t);
      else
        throw new TypeError("'height' is not a finite number or undefined.");
    }
  }
  /**
   * Provides a validator that respects transforms in positional data constraining the position to within the target
   * elements bounds.
   *
   * @param {import('../').ValidationData}   valData - The associated validation data for position updates.
   *
   * @returns {import('../').TJSPositionData} Potentially adjusted position data.
   */
  validator(e) {
    var o, a;
    if (!M(this, So))
      return e.position;
    const t = M(this, Jl) ?? ((o = M(this, Yl)) == null ? void 0 : o.offsetWidth) ?? globalThis.innerWidth, s = M(this, Xl) ?? ((a = M(this, Yl)) == null ? void 0 : a.offsetHeight) ?? globalThis.innerHeight;
    if (typeof e.position.width == "number") {
      const c = e.maxWidth ?? (M(this, Kl) ? t : Number.MAX_SAFE_INTEGER);
      e.position.width = Yr(e.width, e.minWidth, c);
    }
    if (typeof e.position.height == "number") {
      const c = e.maxHeight ?? (M(this, Kl) ? s : Number.MAX_SAFE_INTEGER);
      e.position.height = Yr(e.height, e.minHeight, c);
    }
    const n = e.transforms.getData(e.position, Hz, e), l = n.boundingRect.x, r = n.boundingRect.y;
    return n.boundingRect.bottom + e.marginTop > s && (n.boundingRect.y += s - n.boundingRect.bottom - e.marginTop), n.boundingRect.right + e.marginLeft > t && (n.boundingRect.x += t - n.boundingRect.right - e.marginLeft), n.boundingRect.top - e.marginTop < 0 && (n.boundingRect.y += Math.abs(n.boundingRect.top - e.marginTop)), n.boundingRect.left - e.marginLeft < 0 && (n.boundingRect.x += Math.abs(n.boundingRect.left - e.marginLeft)), e.position.left -= l - n.boundingRect.x, e.position.top -= r - n.boundingRect.y, e.position;
  }
};
Kl = new WeakMap(), Yl = new WeakMap(), So = new WeakMap(), Xl = new WeakMap(), Hn = new WeakMap(), Jl = new WeakMap(), f(q$, "TransformBounds");
let Nd = q$;
const G$ = class G$ {
  constructor() {
    this.data = void 0, this.dataSubscribers = new Ac(), this.dimensionData = { width: 0, height: 0 }, this.changeSet = void 0, this.options = void 0, this.queued = !1, this.styleCache = void 0, this.transforms = void 0, this.transformData = new ua(), this.subscriptions = void 0, this.storeDimension = It(this.dimensionData), this.storeTransform = It(this.transformData, () => (this.options.transformSubscribed = !0, () => this.options.transformSubscribed = !1)), this.queued = !1, Object.seal(this.dimensionData);
  }
};
f(G$, "UpdateElementData");
let r_ = G$;
const Zr = class Zr {
  static get promise() {
    return this.updatePromise;
  }
  /**
   * Potentially adds the given element and internal updateData instance to the list.
   *
   * @param {HTMLElement}       el - An HTMLElement instance.
   *
   * @param {import('./UpdateElementData').UpdateElementData} updateData - An UpdateElementData instance.
   *
   * @returns {Promise<number>} The unified next frame update promise. Returns `currentTime`.
   */
  static add(e, t) {
    if (this.listCntr < this.list.length) {
      const s = this.list[this.listCntr];
      s[0] = e, s[1] = t;
    } else
      this.list.push([e, t]);
    return this.listCntr++, t.queued = !0, this.updatePromise || (this.updatePromise = this.wait()), this.updatePromise;
  }
  /**
   * Await on `nextAnimationFrame` and iterate over list map invoking callback functions.
   *
   * @returns {Promise<number>} The next frame Promise / currentTime from nextAnimationFrame.
   */
  static async wait() {
    const e = await Lz();
    this.updatePromise = void 0;
    for (let t = this.listCntr; --t >= 0; ) {
      const s = this.list[t], n = s[0], l = s[1];
      s[0] = void 0, s[1] = void 0, l.queued = !1, n.isConnected && (l.options.ortho ? LO(n, l) : jO(n, l), (l.options.calculateTransform || l.options.transformSubscribed) && BO(n, l), this.updateSubscribers(l));
    }
    return this.listCntr = 0, e;
  }
  /**
   * Potentially immediately updates the given element.
   *
   * @param {HTMLElement}       el - An HTMLElement instance.
   *
   * @param {import('./UpdateElementData').UpdateElementData} updateData - An UpdateElementData instance.
   */
  static immediate(e, t) {
    e.isConnected && (t.options.ortho ? LO(e, t) : jO(e, t), (t.options.calculateTransform || t.options.transformSubscribed) && BO(e, t), this.updateSubscribers(t));
  }
  /**
   * @param {import('./UpdateElementData').UpdateElementData} updateData - Data change set.
   */
  static updateSubscribers(e) {
    const t = e.data, s = e.changeSet;
    if (!s.hasChange())
      return;
    const n = e.dataSubscribers.copy(t), l = e.subscriptions;
    if (l.length > 0)
      for (let r = 0; r < l.length; r++)
        l[r](n);
    (s.width || s.height) && (e.dimensionData.width = t.width, e.dimensionData.height = t.height, e.storeDimension.set(e.dimensionData)), s.set(!1);
  }
};
f(Zr, "UpdateElementManager"), Ge(Zr, "list", []), Ge(Zr, "listCntr", 0), Ge(Zr, "updatePromise");
let sc = Zr;
function jO(i, e) {
  const t = e.changeSet, s = e.data;
  t.left && (i.style.left = `${s.left}px`), t.top && (i.style.top = `${s.top}px`), t.zIndex && (i.style.zIndex = typeof s.zIndex == "number" ? `${s.zIndex}` : null), t.width && (i.style.width = typeof s.width == "number" ? `${s.width}px` : s.width), t.height && (i.style.height = typeof s.height == "number" ? `${s.height}px` : s.height), t.transformOrigin && (i.style.transformOrigin = s.transformOrigin), t.transform && (i.style.transform = e.transforms.isActive ? e.transforms.getCSS() : null);
}
f(jO, "s_UPDATE_ELEMENT");
function LO(i, e) {
  const t = e.changeSet, s = e.data;
  t.zIndex && (i.style.zIndex = typeof s.zIndex == "number" ? `${s.zIndex}` : null), t.width && (i.style.width = typeof s.width == "number" ? `${s.width}px` : s.width), t.height && (i.style.height = typeof s.height == "number" ? `${s.height}px` : s.height), t.transformOrigin && (i.style.transformOrigin = s.transformOrigin), (t.left || t.top || t.transform) && (i.style.transform = e.transforms.getCSSOrtho(s));
}
f(LO, "s_UPDATE_ELEMENT_ORTHO");
function BO(i, e) {
  Ba.height = e.data.height !== "auto" ? e.data.height : e.styleCache.offsetHeight, Ba.width = e.data.width !== "auto" ? e.data.width : e.styleCache.offsetWidth, Ba.marginLeft = e.styleCache.marginLeft, Ba.marginTop = e.styleCache.marginTop, e.transforms.getData(e.data, e.transformData, Ba), e.storeTransform.set(e.transformData);
}
f(BO, "s_UPDATE_TRANSFORM");
const Ba = {
  height: void 0,
  width: void 0,
  marginLeft: void 0,
  marginTop: void 0
};
var nm, im, yt, lm, To, Gs, el, ru, Ut, Ds, Zl, tl, An, Co, sl, ou, Ql, rm, R7;
const Cl = class Cl {
  /**
   * @param {import('./').TJSPositionParent | import('./').TJSPositionOptionsAll}   [parent] - A
   *        potential parent element or object w/ `elementTarget` getter. May also be the TJSPositionOptions object
   *        w/ 1 argument.
   *
   * @param {import('./').TJSPositionOptionsAll}   [options] - Default values.
   */
  constructor(e, t) {
    /**
     * @param {import('./').TJSPositionDataExtended} opts -
     *
     * @param {number|null} opts.left -
     *
     * @param {number|null} opts.top -
     *
     * @param {number|null} opts.maxHeight -
     *
     * @param {number|null} opts.maxWidth -
     *
     * @param {number|null} opts.minHeight -
     *
     * @param {number|null} opts.minWidth -
     *
     * @param {number|'auto'|null} opts.width -
     *
     * @param {number|'auto'|null} opts.height -
     *
     * @param {number|null} opts.rotateX -
     *
     * @param {number|null} opts.rotateY -
     *
     * @param {number|null} opts.rotateZ -
     *
     * @param {number|null} opts.scale -
     *
     * @param {string} opts.transformOrigin -
     *
     * @param {number|null} opts.translateX -
     *
     * @param {number|null} opts.translateY -
     *
     * @param {number|null} opts.translateZ -
     *
     * @param {number|null} opts.zIndex -
     *
     * @param {number|null} opts.rotation - alias for rotateZ
     *
     * @param {*} opts.rest -
     *
     * @param {object} parent -
     *
     * @param {HTMLElement} el -
     *
     * @param {StyleCache} styleCache -
     *
     * @returns {null|TJSPositionData} Updated position data or null if validation fails.
     */
    Y(this, rm);
    /**
     * @type {TJSPositionData}
     */
    Y(this, yt, new Ac());
    /**
     * Provides the animation API.
     *
     * @type {AnimationAPI}
     */
    Y(this, lm, new Md(this, M(this, yt)));
    /**
     * Provides a way to turn on / off the position handling.
     *
     * @type {boolean}
     */
    Y(this, To, !0);
    /**
     * Stores ongoing options that are set in the constructor or by transform store subscription.
     *
     * @type {import('./').TJSPositionOptions}
     */
    Y(this, Gs, {
      calculateTransform: !1,
      initialHelper: void 0,
      ortho: !0,
      transformSubscribed: !1
    });
    /**
     * The associated parent for positional data tracking. Used in validators.
     *
     * @type {import('./').TJSPositionParent}
     */
    Y(this, el, void 0);
    /**
     * Stores the style attributes that changed on update.
     *
     * @type {PositionChangeSet}
     */
    Y(this, ru, new t_());
    /**
     * @type {import('./').TJSPositionStores}
     */
    Y(this, Ut, void 0);
    /**
     * Stores an instance of the computer styles for the target element.
     *
     * @type {StyleCache}
     */
    Y(this, Ds, void 0);
    /**
     * Stores the subscribers.
     *
     * @type {import('svelte/store').Subscriber<TJSPositionData>[]}
     */
    Y(this, Zl, []);
    /**
     * @type {TJSTransforms}
     */
    Y(this, tl, new i_());
    /**
     * @type {UpdateElementData}
     */
    Y(this, An, void 0);
    /**
     * Stores the UpdateElementManager wait promise.
     *
     * @type {Promise}
     */
    Y(this, Co, void 0);
    /**
     * @type {AdapterValidators}
     */
    Y(this, sl, void 0);
    /**
     * @type {import('./').ValidatorData[]}
     */
    Y(this, ou, void 0);
    /**
     * @type {PositionStateAPI}
     */
    Y(this, Ql, new s_(this, M(this, yt), M(this, tl)));
    d7(e) ? t = e : ye(this, el, e);
    const s = M(this, yt), n = M(this, tl);
    ye(this, Ds, new n_());
    const l = new r_();
    if (l.changeSet = M(this, ru), l.data = M(this, yt), l.options = M(this, Gs), l.styleCache = M(this, Ds), l.subscriptions = M(this, Zl), l.transforms = M(this, tl), ye(this, An, l), ke(t) && (typeof t.calculateTransform == "boolean" && (M(this, Gs).calculateTransform = t.calculateTransform), typeof t.ortho == "boolean" && (M(this, Gs).ortho = t.ortho), (Number.isFinite(t.height) || t.height === "auto" || t.height === "inherit" || t.height === null) && (s.height = l.dimensionData.height = typeof t.height == "number" ? Math.round(t.height) : t.height), (Number.isFinite(t.left) || t.left === null) && (s.left = typeof t.left == "number" ? Math.round(t.left) : t.left), (Number.isFinite(t.maxHeight) || t.maxHeight === null) && (s.maxHeight = typeof t.maxHeight == "number" ? Math.round(t.maxHeight) : t.maxHeight), (Number.isFinite(t.maxWidth) || t.maxWidth === null) && (s.maxWidth = typeof t.maxWidth == "number" ? Math.round(t.maxWidth) : t.maxWidth), (Number.isFinite(t.minHeight) || t.minHeight === null) && (s.minHeight = typeof t.minHeight == "number" ? Math.round(t.minHeight) : t.minHeight), (Number.isFinite(t.minWidth) || t.minWidth === null) && (s.minWidth = typeof t.minWidth == "number" ? Math.round(t.minWidth) : t.minWidth), (Number.isFinite(t.rotateX) || t.rotateX === null) && (n.rotateX = s.rotateX = t.rotateX), (Number.isFinite(t.rotateY) || t.rotateY === null) && (n.rotateY = s.rotateY = t.rotateY), (Number.isFinite(t.rotateZ) || t.rotateZ === null) && (n.rotateZ = s.rotateZ = t.rotateZ), (Number.isFinite(t.scale) || t.scale === null) && (n.scale = s.scale = t.scale), (Number.isFinite(t.top) || t.top === null) && (s.top = typeof t.top == "number" ? Math.round(t.top) : t.top), (typeof t.transformOrigin == "string" || t.transformOrigin === null) && (s.transformOrigin = Ur.includes(t.transformOrigin) ? t.transformOrigin : null), (Number.isFinite(t.translateX) || t.translateX === null) && (n.translateX = s.translateX = t.translateX), (Number.isFinite(t.translateY) || t.translateY === null) && (n.translateY = s.translateY = t.translateY), (Number.isFinite(t.translateZ) || t.translateZ === null) && (n.translateZ = s.translateZ = t.translateZ), (Number.isFinite(t.width) || t.width === "auto" || t.width === "inherit" || t.width === null) && (s.width = l.dimensionData.width = typeof t.width == "number" ? Math.round(t.width) : t.width), (Number.isFinite(t.zIndex) || t.zIndex === null) && (s.zIndex = typeof t.zIndex == "number" ? Math.round(t.zIndex) : t.zIndex)), ye(this, Ut, {
      // The main properties for manipulating TJSPosition.
      height: dt(this, "height"),
      left: dt(this, "left"),
      rotateX: dt(this, "rotateX"),
      rotateY: dt(this, "rotateY"),
      rotateZ: dt(this, "rotateZ"),
      scale: dt(this, "scale"),
      top: dt(this, "top"),
      transformOrigin: dt(this, "transformOrigin"),
      translateX: dt(this, "translateX"),
      translateY: dt(this, "translateY"),
      translateZ: dt(this, "translateZ"),
      width: dt(this, "width"),
      zIndex: dt(this, "zIndex"),
      // Stores that control validation when width / height is not `auto`.
      maxHeight: dt(this, "maxHeight"),
      maxWidth: dt(this, "maxWidth"),
      minHeight: dt(this, "minHeight"),
      minWidth: dt(this, "minWidth"),
      // Readable stores based on updates or from resize observer changes.
      dimension: { subscribe: l.storeDimension.subscribe },
      element: { subscribe: M(this, Ds).stores.element.subscribe },
      resizeContentHeight: { subscribe: M(this, Ds).stores.resizeContentHeight.subscribe },
      resizeContentWidth: { subscribe: M(this, Ds).stores.resizeContentWidth.subscribe },
      resizeOffsetHeight: { subscribe: M(this, Ds).stores.resizeOffsetHeight.subscribe },
      resizeOffsetWidth: { subscribe: M(this, Ds).stores.resizeOffsetWidth.subscribe },
      transform: { subscribe: l.storeTransform.subscribe },
      // Protected store that should only be set by resizeObserver action.
      resizeObserved: M(this, Ds).stores.resizeObserved
    }), tc(M(this, Ut).resizeObserved, (r) => {
      const o = M(this, el);
      (o instanceof HTMLElement ? o : o == null ? void 0 : o.elementTarget) instanceof HTMLElement && Number.isFinite(r == null ? void 0 : r.offsetWidth) && Number.isFinite(r == null ? void 0 : r.offsetHeight) && this.set(s);
    }), M(this, Ut).transformOrigin.values = Ur, [Lr(this, sl)._, Lr(this, ou)._] = new l_(), t != null && t.initial || t != null && t.positionInitial) {
      const r = t.initial ?? t.positionInitial;
      if (typeof (r == null ? void 0 : r.getLeft) != "function" || typeof (r == null ? void 0 : r.getTop) != "function")
        throw new Error(
          "'options.initial' position helper does not contain 'getLeft' and / or 'getTop' functions."
        );
      M(this, Gs).initialHelper = t.initial;
    }
    t != null && t.validator && (vt(t == null ? void 0 : t.validator) ? this.validators.add(...t.validator) : this.validators.add(t.validator));
  }
  /**
   * @returns {AnimationGroupAPI} Public Animation API.
   */
  static get Animate() {
    return e_;
  }
  /**
   * @returns {{browserCentered: Centered, Centered: Centered}} TJSPosition initial API.
   */
  static get Initial() {
    return M(this, nm);
  }
  /**
   * Returns TJSTransformData class / constructor.
   *
   * @returns {TJSTransformData} TJSTransformData class / constructor.
   */
  static get TransformData() {
    return ua;
  }
  /**
   * Returns default validators.
   *
   * Note: `basicWindow` and `BasicBounds` will eventually be removed.
   *
   * @returns {{TransformBounds: TransformBounds, BasicBounds: BasicBounds, basicWindow: BasicBounds, transformWindow: TransformBounds}}
   * Available validators.
   */
  static get Validators() {
    return M(this, im);
  }
  /**
   * Returns a duplicate of a given position instance copying any options and validators.
   *
   * // TODO: Consider more safety over options processing.
   *
   * @param {TJSPosition}          position - A position instance.
   *
   * @param {import('./').TJSPositionOptions}   options - TJSPosition options.
   *
   * @returns {TJSPosition} A duplicate position instance.
   */
  static duplicate(e, t) {
    if (!(e instanceof Cl))
      throw new TypeError("'position' is not an instance of Position.");
    const s = new Cl(t);
    return ye(s, Gs, Object.assign({}, M(e, Gs), t)), M(s, sl).add(...M(e, sl)), s.set(M(e, yt)), s;
  }
  /**
   * Returns the animation API.
   *
   * @returns {AnimationAPI} Animation API.
   */
  get animate() {
    return M(this, lm);
  }
  /**
   * Returns the dimension data for the readable store.
   *
   * @returns {{width: number | 'auto', height: number | 'auto'}} Dimension data.
   */
  get dimension() {
    return M(this, An).dimensionData;
  }
  /**
   * Returns the enabled state.
   *
   * @returns {boolean} Enabled state.
   */
  get enabled() {
    return M(this, To);
  }
  /**
   * Returns the current HTMLElement being positioned.
   *
   * @returns {HTMLElement|undefined} Current HTMLElement being positioned.
   */
  get element() {
    return M(this, Ds).el;
  }
  /**
   * Returns a promise that is resolved on the next element update with the time of the update.
   *
   * @returns {Promise<number>} Promise resolved on element update.
   */
  get elementUpdated() {
    return M(this, Co);
  }
  /**
   * Returns the associated {@link TJSPositionParent} instance.
   *
   * @returns {import('./').TJSPositionParent} The TJSPositionParent instance.
   */
  get parent() {
    return M(this, el);
  }
  /**
   * Returns the state API.
   *
   * @returns {import('./PositionStateAPI').PositionStateAPI} TJSPosition state API.
   */
  get state() {
    return M(this, Ql);
  }
  /**
   * Returns the derived writable stores for individual data variables.
   *
   * @returns {import('./').TJSPositionStores} Derived / writable stores.
   */
  get stores() {
    return M(this, Ut);
  }
  /**
   * Returns the transform data for the readable store.
   *
   * @returns {TJSTransformData} Transform Data.
   */
  get transform() {
    return M(this, An).transformData;
  }
  /**
   * Returns the validators.
   *
   * @returns {AdapterValidators} validators.
   */
  get validators() {
    return M(this, sl);
  }
  /**
   * Sets the enabled state.
   *
   * @param {boolean}  enabled - New enabled state.
   */
  set enabled(e) {
    if (typeof e != "boolean")
      throw new TypeError("'enabled' is not a boolean.");
    ye(this, To, e);
  }
  /**
   * Sets the associated {@link TJSPositionParent} instance. Resets the style cache and default data.
   *
   * @param {import('./').TJSPositionParent} parent - A TJSPositionParent instance.
   */
  set parent(e) {
    if (e !== void 0 && !(e instanceof HTMLElement) && !ke(e))
      throw new TypeError("'parent' is not an HTMLElement, object, or undefined.");
    ye(this, el, e), M(this, Ql).remove({ name: "#defaultData" }), M(this, Ds).reset(), e && this.set(M(this, yt));
  }
  // Data accessors ----------------------------------------------------------------------------------------------------
  /**
   * @returns {number|'auto'|'inherit'|null} height
   */
  get height() {
    return M(this, yt).height;
  }
  /**
   * @returns {number|null} left
   */
  get left() {
    return M(this, yt).left;
  }
  /**
   * @returns {number|null} maxHeight
   */
  get maxHeight() {
    return M(this, yt).maxHeight;
  }
  /**
   * @returns {number|null} maxWidth
   */
  get maxWidth() {
    return M(this, yt).maxWidth;
  }
  /**
   * @returns {number|null} minHeight
   */
  get minHeight() {
    return M(this, yt).minHeight;
  }
  /**
   * @returns {number|null} minWidth
   */
  get minWidth() {
    return M(this, yt).minWidth;
  }
  /**
   * @returns {number|null} rotateX
   */
  get rotateX() {
    return M(this, yt).rotateX;
  }
  /**
   * @returns {number|null} rotateY
   */
  get rotateY() {
    return M(this, yt).rotateY;
  }
  /**
   * @returns {number|null} rotateZ
   */
  get rotateZ() {
    return M(this, yt).rotateZ;
  }
  /**
   * @returns {number|null} alias for rotateZ
   */
  get rotation() {
    return M(this, yt).rotateZ;
  }
  /**
   * @returns {number|null} scale
   */
  get scale() {
    return M(this, yt).scale;
  }
  /**
   * @returns {number|null} top
   */
  get top() {
    return M(this, yt).top;
  }
  /**
   * @returns {import('./').TJSTransformOrigin} transformOrigin
   */
  get transformOrigin() {
    return M(this, yt).transformOrigin;
  }
  /**
   * @returns {number|null} translateX
   */
  get translateX() {
    return M(this, yt).translateX;
  }
  /**
   * @returns {number|null} translateY
   */
  get translateY() {
    return M(this, yt).translateY;
  }
  /**
   * @returns {number|null} translateZ
   */
  get translateZ() {
    return M(this, yt).translateZ;
  }
  /**
   * @returns {number|'auto'|'inherit'|null} width
   */
  get width() {
    return M(this, yt).width;
  }
  /**
   * @returns {number|null} z-index
   */
  get zIndex() {
    return M(this, yt).zIndex;
  }
  /**
   * @param {number|string|null} height -
   */
  set height(e) {
    M(this, Ut).height.set(e);
  }
  /**
   * @param {number|string|null} left -
   */
  set left(e) {
    M(this, Ut).left.set(e);
  }
  /**
   * @param {number|string|null} maxHeight -
   */
  set maxHeight(e) {
    M(this, Ut).maxHeight.set(e);
  }
  /**
   * @param {number|string|null} maxWidth -
   */
  set maxWidth(e) {
    M(this, Ut).maxWidth.set(e);
  }
  /**
   * @param {number|string|null} minHeight -
   */
  set minHeight(e) {
    M(this, Ut).minHeight.set(e);
  }
  /**
   * @param {number|string|null} minWidth -
   */
  set minWidth(e) {
    M(this, Ut).minWidth.set(e);
  }
  /**
   * @param {number|string|null} rotateX -
   */
  set rotateX(e) {
    M(this, Ut).rotateX.set(e);
  }
  /**
   * @param {number|string|null} rotateY -
   */
  set rotateY(e) {
    M(this, Ut).rotateY.set(e);
  }
  /**
   * @param {number|string|null} rotateZ -
   */
  set rotateZ(e) {
    M(this, Ut).rotateZ.set(e);
  }
  /**
   * @param {number|string|null} rotateZ - alias for rotateZ
   */
  set rotation(e) {
    M(this, Ut).rotateZ.set(e);
  }
  /**
   * @param {number|string|null} scale -
   */
  set scale(e) {
    M(this, Ut).scale.set(e);
  }
  /**
   * @param {number|string|null} top -
   */
  set top(e) {
    M(this, Ut).top.set(e);
  }
  /**
   * @param {import('./').TJSTransformOrigin} transformOrigin -
   */
  set transformOrigin(e) {
    Ur.includes(e) && M(this, Ut).transformOrigin.set(e);
  }
  /**
   * @param {number|string|null} translateX -
   */
  set translateX(e) {
    M(this, Ut).translateX.set(e);
  }
  /**
   * @param {number|string|null} translateY -
   */
  set translateY(e) {
    M(this, Ut).translateY.set(e);
  }
  /**
   * @param {number|string|null} translateZ -
   */
  set translateZ(e) {
    M(this, Ut).translateZ.set(e);
  }
  /**
   * @param {number|string|null} width -
   */
  set width(e) {
    M(this, Ut).width.set(e);
  }
  /**
   * @param {number|string|null} zIndex -
   */
  set zIndex(e) {
    M(this, Ut).zIndex.set(e);
  }
  /**
   * Assigns current position to object passed into method.
   *
   * @param {object|TJSPositionData}  [position] - Target to assign current position data.
   *
   * @param {import('./').TJSPositionGetOptions}   [options] - Defines options for specific keys and substituting null
   *        for numeric default values.
   *
   * @returns {TJSPositionData} Passed in object with current position data.
   */
  get(e = {}, t) {
    const s = t == null ? void 0 : t.keys, n = t == null ? void 0 : t.exclude, l = (t == null ? void 0 : t.numeric) ?? !1;
    if (vt(s)) {
      if (l)
        for (const r of s)
          e[r] = this[r] ?? P7[r];
      else
        for (const r of s)
          e[r] = this[r];
      if (vt(n))
        for (const r of n)
          delete e[r];
      return e;
    } else {
      const r = Object.assign(e, M(this, yt));
      if (vt(n))
        for (const o of n)
          delete r[o];
      return l && za(r), r;
    }
  }
  /**
   * @returns {TJSPositionData} Current position data.
   */
  toJSON() {
    return Object.assign({}, M(this, yt));
  }
  /**
   * All calculation and updates of position are implemented in {@link TJSPosition}. This allows position to be fully
   * reactive and in control of updating inline styles for the application.
   *
   * Note: the logic for updating position is improved and changes a few aspects from the default
   * {@link globalThis.Application.setPosition}. The gate on `popOut` is removed, so to ensure no positional
   * application occurs popOut applications can set `this.options.positionable` to false ensuring no positional inline
   * styles are applied.
   *
   * The initial set call on an application with a target element will always set width / height as this is
   * necessary for correct calculations.
   *
   * When a target element is present updated styles are applied after validation. To modify the behavior of set
   * implement one or more validator functions and add them from the application via
   * `this.position.validators.add(<Function>)`.
   *
   * Updates to any target element are decoupled from the underlying TJSPosition data. This method returns this instance
   * that you can then await on the target element inline style update by using {@link TJSPosition.elementUpdated}.
   *
   * @param {import('./').TJSPositionDataExtended} [position] - TJSPosition data to set.
   *
   * @returns {TJSPosition} This TJSPosition instance.
   */
  set(e = {}) {
    var u, d;
    if (!ke(e))
      throw new TypeError("Position - set error: 'position' is not an object.");
    const t = M(this, el);
    if (!M(this, To))
      return this;
    if (t !== void 0 && typeof ((u = t == null ? void 0 : t.options) == null ? void 0 : u.positionable) == "boolean" && !((d = t == null ? void 0 : t.options) != null && d.positionable))
      return this;
    const s = e.immediateElementUpdate === !0, n = M(this, yt), l = M(this, tl), r = t instanceof HTMLElement ? t : t == null ? void 0 : t.elementTarget, o = r instanceof HTMLElement && r.isConnected ? r : void 0, a = M(this, ru), c = M(this, Ds);
    if (o && (c.hasData(o) || (c.update(o), c.hasWillChange, a.set(!0), M(this, An).queued = !1), Vr(e, this), e = Z(this, rm, R7).call(this, e, t, o, c), e === null))
      return this;
    if (Number.isFinite(e.left) && (e.left = Math.round(e.left), n.left !== e.left && (n.left = e.left, a.left = !0)), Number.isFinite(e.top) && (e.top = Math.round(e.top), n.top !== e.top && (n.top = e.top, a.top = !0)), (Number.isFinite(e.maxHeight) || e.maxHeight === null) && (e.maxHeight = typeof e.maxHeight == "number" ? Math.round(e.maxHeight) : null, n.maxHeight !== e.maxHeight && (n.maxHeight = e.maxHeight, a.maxHeight = !0)), (Number.isFinite(e.maxWidth) || e.maxWidth === null) && (e.maxWidth = typeof e.maxWidth == "number" ? Math.round(e.maxWidth) : null, n.maxWidth !== e.maxWidth && (n.maxWidth = e.maxWidth, a.maxWidth = !0)), (Number.isFinite(e.minHeight) || e.minHeight === null) && (e.minHeight = typeof e.minHeight == "number" ? Math.round(e.minHeight) : null, n.minHeight !== e.minHeight && (n.minHeight = e.minHeight, a.minHeight = !0)), (Number.isFinite(e.minWidth) || e.minWidth === null) && (e.minWidth = typeof e.minWidth == "number" ? Math.round(e.minWidth) : null, n.minWidth !== e.minWidth && (n.minWidth = e.minWidth, a.minWidth = !0)), (Number.isFinite(e.rotateX) || e.rotateX === null) && n.rotateX !== e.rotateX && (n.rotateX = l.rotateX = e.rotateX, a.transform = !0), (Number.isFinite(e.rotateY) || e.rotateY === null) && n.rotateY !== e.rotateY && (n.rotateY = l.rotateY = e.rotateY, a.transform = !0), (Number.isFinite(e.rotateZ) || e.rotateZ === null) && n.rotateZ !== e.rotateZ && (n.rotateZ = l.rotateZ = e.rotateZ, a.transform = !0), (Number.isFinite(e.scale) || e.scale === null) && (e.scale = typeof e.scale == "number" ? Math.max(0, Math.min(e.scale, 1e3)) : null, n.scale !== e.scale && (n.scale = l.scale = e.scale, a.transform = !0)), (typeof e.transformOrigin == "string" && Ur.includes(
      e.transformOrigin
    ) || e.transformOrigin === null) && n.transformOrigin !== e.transformOrigin && (n.transformOrigin = e.transformOrigin, a.transformOrigin = !0), (Number.isFinite(e.translateX) || e.translateX === null) && n.translateX !== e.translateX && (n.translateX = l.translateX = e.translateX, a.transform = !0), (Number.isFinite(e.translateY) || e.translateY === null) && n.translateY !== e.translateY && (n.translateY = l.translateY = e.translateY, a.transform = !0), (Number.isFinite(e.translateZ) || e.translateZ === null) && n.translateZ !== e.translateZ && (n.translateZ = l.translateZ = e.translateZ, a.transform = !0), Number.isFinite(e.zIndex) && (e.zIndex = Math.round(e.zIndex), n.zIndex !== e.zIndex && (n.zIndex = e.zIndex, a.zIndex = !0)), (Number.isFinite(e.width) || e.width === "auto" || e.width === "inherit" || e.width === null) && (e.width = typeof e.width == "number" ? Math.round(e.width) : e.width, n.width !== e.width && (n.width = e.width, a.width = !0)), (Number.isFinite(e.height) || e.height === "auto" || e.height === "inherit" || e.height === null) && (e.height = typeof e.height == "number" ? Math.round(e.height) : e.height, n.height !== e.height && (n.height = e.height, a.height = !0)), o) {
      const p = M(this, Ql).getDefault();
      ke(p) || M(this, Ql).save({ name: "#defaultData", ...Object.assign({}, n) }), s ? (sc.immediate(o, M(this, An)), ye(this, Co, Promise.resolve(performance.now()))) : M(this, An).queued || ye(this, Co, sc.add(o, M(this, An)));
    } else
      sc.updateSubscribers(M(this, An));
    return this;
  }
  /**
   * @param {import('svelte/store').Subscriber<TJSPositionData>} handler - Callback function that is invoked on
   *        update / changes. Receives a copy of the TJSPositionData.
   *
   * @returns {import('svelte/store').Unsubscriber} Unsubscribe function.
   */
  subscribe(e) {
    return M(this, Zl).push(e), e(Object.assign({}, M(this, yt))), () => {
      const t = M(this, Zl).findIndex((s) => s === e);
      t >= 0 && M(this, Zl).splice(t, 1);
    };
  }
};
nm = new WeakMap(), im = new WeakMap(), yt = new WeakMap(), lm = new WeakMap(), To = new WeakMap(), Gs = new WeakMap(), el = new WeakMap(), ru = new WeakMap(), Ut = new WeakMap(), Ds = new WeakMap(), Zl = new WeakMap(), tl = new WeakMap(), An = new WeakMap(), Co = new WeakMap(), sl = new WeakMap(), ou = new WeakMap(), Ql = new WeakMap(), rm = new WeakSet(), R7 = /* @__PURE__ */ f(function({
  // Directly supported parameters
  left: e,
  top: t,
  maxWidth: s,
  maxHeight: n,
  minWidth: l,
  minHeight: r,
  width: o,
  height: a,
  rotateX: c,
  rotateY: u,
  rotateZ: d,
  scale: p,
  transformOrigin: m,
  translateX: g,
  translateY: h,
  translateZ: _,
  zIndex: y,
  // Aliased parameters
  rotation: k,
  ...v
} = {}, O, P, D) {
  var F, H, G;
  let I = Uz.copy(M(this, yt));
  if (P.style.width === "" || o !== void 0)
    if (o === "auto" || I.width === "auto" && o !== null)
      I.width = "auto", o = D.offsetWidth;
    else if (o === "inherit" || I.width === "inherit" && o !== null)
      I.width = "inherit", o = D.offsetWidth;
    else {
      const U = Number.isFinite(o) ? o : I.width;
      I.width = o = Number.isFinite(U) ? Math.round(U) : D.offsetWidth;
    }
  else
    o = Number.isFinite(I.width) ? I.width : D.offsetWidth;
  if (P.style.height === "" || a !== void 0)
    if (a === "auto" || I.height === "auto" && a !== null)
      I.height = "auto", a = D.offsetHeight;
    else if (a === "inherit" || I.height === "inherit" && a !== null)
      I.height = "inherit", a = D.offsetHeight;
    else {
      const U = Number.isFinite(a) ? a : I.height;
      I.height = a = Number.isFinite(U) ? Math.round(U) : D.offsetHeight;
    }
  else
    a = Number.isFinite(I.height) ? I.height : D.offsetHeight;
  Number.isFinite(e) ? I.left = e : Number.isFinite(I.left) || (I.left = typeof ((F = M(this, Gs).initialHelper) == null ? void 0 : F.getLeft) == "function" ? M(this, Gs).initialHelper.getLeft(o) : 0), Number.isFinite(t) ? I.top = t : Number.isFinite(I.top) || (I.top = typeof ((H = M(this, Gs).initialHelper) == null ? void 0 : H.getTop) == "function" ? M(this, Gs).initialHelper.getTop(a) : 0), (Number.isFinite(n) || n === null) && (I.maxHeight = Number.isFinite(n) ? Math.round(n) : null), (Number.isFinite(s) || s === null) && (I.maxWidth = Number.isFinite(s) ? Math.round(s) : null), (Number.isFinite(r) || r === null) && (I.minHeight = Number.isFinite(r) ? Math.round(r) : null), (Number.isFinite(l) || l === null) && (I.minWidth = Number.isFinite(l) ? Math.round(l) : null), (Number.isFinite(c) || c === null) && (I.rotateX = c), (Number.isFinite(u) || u === null) && (I.rotateY = u), d !== I.rotateZ && (Number.isFinite(d) || d === null) ? I.rotateZ = d : k !== I.rotateZ && (Number.isFinite(k) || k === null) && (I.rotateZ = k), (Number.isFinite(g) || g === null) && (I.translateX = g), (Number.isFinite(h) || h === null) && (I.translateY = h), (Number.isFinite(_) || _ === null) && (I.translateZ = _), (Number.isFinite(p) || p === null) && (I.scale = typeof p == "number" ? Math.max(0, Math.min(p, 1e3)) : null), (typeof m == "string" || m === null) && (I.transformOrigin = Ur.includes(m) ? m : null), (Number.isFinite(y) || y === null) && (I.zIndex = typeof y == "number" ? Math.round(y) : y);
  const B = M(this, ou);
  if (M(this, sl).enabled && B.length) {
    gs.parent = O, gs.el = P, gs.computed = D.computed, gs.transforms = M(this, tl), gs.height = a, gs.width = o, gs.marginLeft = D.marginLeft, gs.marginTop = D.marginTop, gs.maxHeight = D.maxHeight ?? I.maxHeight, gs.maxWidth = D.maxWidth ?? I.maxWidth;
    const U = ((G = O == null ? void 0 : O.reactive) == null ? void 0 : G.minimized) ?? !1;
    gs.minHeight = U ? I.minHeight ?? 0 : D.minHeight || (I.minHeight ?? 0), gs.minWidth = U ? I.minWidth ?? 0 : D.minWidth || (I.minWidth ?? 0);
    for (let q = 0; q < B.length; q++)
      if (gs.position = I, gs.rest = v, I = B[q].validator(gs), I === null)
        return null;
  }
  return I;
}, "#updatePosition"), f(Cl, "TJSPosition"), /**
 * @type {{browserCentered: Centered, Centered: Centered}}
 */
Y(Cl, nm, {
  browserCentered: new Rd({ lock: !0 }),
  Centered: Rd
}), /**
 * @type {{TransformBounds: TransformBounds, BasicBounds: BasicBounds, basicWindow: BasicBounds, transformWindow: TransformBounds}}
 */
Y(Cl, im, {
  basicWindow: new Fd({ lock: !0 }),
  BasicBounds: Fd,
  transformWindow: new Nd({ lock: !0 }),
  TransformBounds: Nd
});
let nc = Cl;
const Uz = new Ac(), gs = {
  position: void 0,
  parent: void 0,
  el: void 0,
  computed: void 0,
  transforms: void 0,
  height: void 0,
  width: void 0,
  marginLeft: void 0,
  marginTop: void 0,
  maxHeight: void 0,
  maxWidth: void 0,
  minHeight: void 0,
  minWidth: void 0,
  rest: void 0
};
Object.seal(gs);
function F7(i, {
  position: e,
  active: t = !0,
  button: s = 0,
  storeDragging: n = void 0,
  ease: l = !1,
  easeOptions: r = { duration: 0.1, ease: Zn },
  hasTargetClassList: o,
  ignoreTargetClassList: a
}) {
  if (o !== void 0 && !vt(o))
    throw new TypeError("'hasTargetClassList' is not iterable.");
  if (a !== void 0 && !vt(a))
    throw new TypeError("'ignoreTargetClassList' is not iterable.");
  const c = { left: 0, top: 0 };
  let u = null, d = {}, p = !1, m = e.animate.quickTo(["top", "left"], r);
  const g = {
    dragDown: ["pointerdown", y, !1],
    dragMove: ["pointermove", k, !1],
    dragUp: ["pointerup", v, !1]
  };
  function h() {
    i.addEventListener(...g.dragDown), i.classList.add("draggable");
  }
  f(h, "activateListeners");
  function _() {
    typeof (n == null ? void 0 : n.set) == "function" && n.set(!1), i.removeEventListener(...g.dragDown), i.removeEventListener(...g.dragMove), i.removeEventListener(...g.dragUp), i.classList.remove("draggable");
  }
  f(_, "removeListeners"), t && h();
  function y(O) {
    if (!(O.button !== s || !O.isPrimary) && e.enabled) {
      if (a !== void 0 && O.target instanceof HTMLElement) {
        for (const P of a)
          if (O.target.classList.contains(P))
            return;
      }
      if (o !== void 0 && O.target instanceof HTMLElement) {
        let P = !1;
        for (const D of o)
          if (O.target.classList.contains(D)) {
            P = !0;
            break;
          }
        if (!P)
          return;
      }
      O.preventDefault(), p = !1, u = e.get(), d = { x: O.clientX, y: O.clientY }, i.addEventListener(...g.dragMove), i.addEventListener(...g.dragUp), i.setPointerCapture(O.pointerId);
    }
  }
  f(y, "onDragPointerDown");
  function k(O) {
    if (!(O.buttons & 1)) {
      v(O);
      return;
    }
    if (O.button !== -1 || !O.isPrimary)
      return;
    O.preventDefault(), !p && typeof (n == null ? void 0 : n.set) == "function" && (p = !0, n.set(!0));
    const P = u.left + (O.clientX - d.x), D = u.top + (O.clientY - d.y);
    l ? m(D, P) : (c.left = P, c.top = D, e.set(c));
  }
  f(k, "onDragPointerChange");
  function v(O) {
    O.preventDefault(), p = !1, typeof (n == null ? void 0 : n.set) == "function" && n.set(!1), i.removeEventListener(...g.dragMove), i.removeEventListener(...g.dragUp);
  }
  return f(v, "onDragPointerUp"), {
    // The default of active being true won't automatically add listeners twice.
    update: (O) => {
      if (typeof O.active == "boolean" && (t = O.active, t ? h() : _()), typeof O.button == "number" && (s = O.button), O.position !== void 0 && O.position !== e && (e = O.position, m = e.animate.quickTo(["top", "left"], r)), typeof O.ease == "boolean" && (l = O.ease), ke(O.easeOptions) && (r = O.easeOptions, m.options(r)), O.hasTargetClassList !== void 0)
        if (vt(O.hasTargetClassList))
          o = O.hasTargetClassList;
        else
          throw new TypeError("'hasTargetClassList' is not iterable.");
      if (O.ignoreTargetClassList !== void 0)
        if (vt(O.ignoreTargetClassList))
          a = O.ignoreTargetClassList;
        else
          throw new TypeError("'ignoreTargetClassList' is not iterable.");
    },
    destroy: () => _()
  };
}
f(F7, "draggable");
var Oo, nn, xl, $i, El;
const z$ = class z$ {
  /**
   *
   * @param {object} [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.ease] -
   *
   * @param {object}   [opts.easeOptions] -
   */
  constructor({ ease: e, easeOptions: t } = {}) {
    Y(this, $i);
    Y(this, Oo, !1);
    /**
     * @type {{ duration: number, ease: (t: number) => number | string }}
     */
    Y(this, nn, { duration: 0.1, ease: Zn });
    /**
     * Stores the subscribers.
     *
     * @type {import('svelte/store').Subscriber<DraggableOptions>[]}
     */
    Y(this, xl, []);
    Object.defineProperty(this, "ease", {
      get: () => M(this, Oo),
      set: (s) => {
        if (typeof s != "boolean")
          throw new TypeError("'ease' is not a boolean.");
        ye(this, Oo, s), Z(this, $i, El).call(this);
      },
      enumerable: !0
    }), Object.defineProperty(this, "easeOptions", {
      get: () => M(this, nn),
      set: (s) => {
        if (!ke(s))
          throw new TypeError("'easeOptions' is not an object.");
        if (s.duration !== void 0) {
          if (!Number.isFinite(s.duration))
            throw new TypeError("'easeOptions.duration' is not a finite number.");
          if (s.duration < 0)
            throw new Error("'easeOptions.duration' is less than 0.");
          M(this, nn).duration = s.duration;
        }
        if (s.ease !== void 0) {
          if (typeof s.ease != "function" && typeof s.ease != "string")
            throw new TypeError("'easeOptions.ease' is not a function or string.");
          M(this, nn).ease = s.ease;
        }
        Z(this, $i, El).call(this);
      },
      enumerable: !0
    }), e !== void 0 && (this.ease = e), t !== void 0 && (this.easeOptions = t);
  }
  /**
   * @returns {number} Get ease duration
   */
  get easeDuration() {
    return M(this, nn).duration;
  }
  /**
   * @returns {string|Function} Get easing function value.
   */
  get easeValue() {
    return M(this, nn).ease;
  }
  /**
   * @param {number}   duration - Set ease duration.
   */
  set easeDuration(e) {
    if (!Number.isFinite(e))
      throw new TypeError("'duration' is not a finite number.");
    if (e < 0)
      throw new Error("'duration' is less than 0.");
    M(this, nn).duration = e, Z(this, $i, El).call(this);
  }
  /**
   * @param {string|Function} value - Get easing function value.
   */
  set easeValue(e) {
    if (typeof e != "function" && typeof e != "string")
      throw new TypeError("'value' is not a function or string.");
    M(this, nn).ease = e, Z(this, $i, El).call(this);
  }
  /**
   * Resets all options data to default values.
   */
  reset() {
    ye(this, Oo, !1), ye(this, nn, { duration: 0.1, ease: Zn }), Z(this, $i, El).call(this);
  }
  /**
   * Resets easing options to default values.
   */
  resetEase() {
    ye(this, nn, { duration: 0.1, ease: Zn }), Z(this, $i, El).call(this);
  }
  /**
   *
   * @param {import('svelte/store').Subscriber<DraggableOptions>} handler - Callback function that is invoked on
   *        update / changes. Receives the DraggableOptions object / instance.
   *
   * @returns {import('svelte/store').Unsubscriber} Unsubscribe function.
   */
  subscribe(e) {
    return M(this, xl).push(e), e(this), () => {
      const t = M(this, xl).findIndex((s) => s === e);
      t >= 0 && M(this, xl).splice(t, 1);
    };
  }
};
Oo = new WeakMap(), nn = new WeakMap(), xl = new WeakMap(), $i = new WeakSet(), El = /* @__PURE__ */ f(function() {
  const e = M(this, xl);
  if (e.length > 0)
    for (let t = 0; t < e.length; t++)
      e[t](this);
}, "#updateSubscribers"), f(z$, "DraggableOptions");
let o_ = z$;
F7.options = (i) => new o_(i);
var Ai, Ei;
const H$ = class H$ {
  /**
   * @param {T}   application - The application.
   */
  constructor(e) {
    /** @type {T} */
    Y(this, Ai, void 0);
    /** @type {Map<string, ApplicationStateData>} */
    Y(this, Ei, /* @__PURE__ */ new Map());
    ye(this, Ai, e), Object.seal(this);
  }
  /**
   * Returns current application state along with any extra data passed into method.
   *
   * @param {object} [extra] - Extra data to add to application state.
   *
   * @returns {ApplicationStateData} Passed in object with current application state.
   */
  get(e = {}) {
    var t, s, n, l, r, o, a;
    return Object.assign(e, {
      position: (s = (t = M(this, Ai)) == null ? void 0 : t.position) == null ? void 0 : s.get(),
      beforeMinimized: (l = (n = M(this, Ai)) == null ? void 0 : n.position) == null ? void 0 : l.state.get({ name: "#beforeMinimized" }),
      options: Object.assign({}, (r = M(this, Ai)) == null ? void 0 : r.options),
      ui: { minimized: (a = (o = M(this, Ai)) == null ? void 0 : o.reactive) == null ? void 0 : a.minimized }
    });
  }
  /**
   * Returns any stored save state by name.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - Saved data set name.
   *
   * @returns {ApplicationStateData} The saved data set.
   */
  getSave({ name: e }) {
    if (typeof e != "string")
      throw new TypeError("ApplicationState - getSave error: 'name' is not a string.");
    return M(this, Ei).get(e);
  }
  /**
   * Removes and returns any application state by name.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - Name to remove and retrieve.
   *
   * @returns {ApplicationStateData} Saved application data.
   */
  remove({ name: e }) {
    if (typeof e != "string")
      throw new TypeError("ApplicationState - remove: 'name' is not a string.");
    const t = M(this, Ei).get(e);
    return M(this, Ei).delete(e), t;
  }
  /**
   * Restores a saved application state returning the data. Several optional parameters are available
   * to control whether the restore action occurs silently (no store / inline styles updates), animates
   * to the stored data, or simply sets the stored data. Restoring via {@link AnimationAPI.to} allows
   * specification of the duration, easing, and interpolate functions along with configuring a Promise to be
   * returned if awaiting the end of the animation.
   *
   * @param {object}            params - Parameters
   *
   * @param {string}            params.name - Saved data set name.
   *
   * @param {boolean}           [params.remove=false] - Remove data set.
   *
   * @param {boolean}           [params.async=false] - If animating return a Promise that resolves with any saved data.
   *
   * @param {boolean}           [params.animateTo=false] - Animate to restore data.
   *
   * @param {number}            [params.duration=0.1] - Duration in seconds.
   *
   * @param {Function}          [params.ease=linear] - Easing function.
   *
   * @param {Function}          [params.interpolate=lerp] - Interpolation function.
   *
   * @returns {ApplicationStateData|Promise<ApplicationStateData>} Saved application data.
   */
  restore({
    name: e,
    remove: t = !1,
    async: s = !1,
    animateTo: n = !1,
    duration: l = 0.1,
    ease: r = ei,
    interpolate: o = Pl
  }) {
    if (typeof e != "string")
      throw new TypeError("ApplicationState - restore error: 'name' is not a string.");
    const a = M(this, Ei).get(e);
    if (a) {
      if (t && M(this, Ei).delete(e), s)
        return this.set(a, { async: s, animateTo: n, duration: l, ease: r, interpolate: o }).then(() => a);
      this.set(a, { async: s, animateTo: n, duration: l, ease: r, interpolate: o });
    }
    return a;
  }
  /**
   * Saves current application state with the opportunity to add extra data to the saved state.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - name to index this saved data.
   *
   * @param {...*}     [options.extra] - Extra data to add to saved data.
   *
   * @returns {ApplicationStateData} Current application data
   */
  save({ name: e, ...t }) {
    if (typeof e != "string")
      throw new TypeError("ApplicationState - save error: 'name' is not a string.");
    const s = this.get(t);
    return M(this, Ei).set(e, s), s;
  }
  /**
   * Restores a saved application state returning the data. Several optional parameters are available
   * to control whether the restore action occurs silently (no store / inline styles updates), animates
   * to the stored data, or simply sets the stored data. Restoring via {@link AnimationAPI.to} allows
   * specification of the duration, easing, and interpolate functions along with configuring a Promise to be
   * returned if awaiting the end of the animation.
   *
   * Note: If serializing application state any minimized apps will use the before minimized state on initial render
   * of the app as it is currently not possible to render apps with Foundry VTT core API in the minimized state.
   *
   * TODO: THIS METHOD NEEDS TO BE REFACTORED WHEN TRL IS MADE INTO A STANDALONE FRAMEWORK.
   *
   * @param {ApplicationStateData}   data - Saved data set name.
   *
   * @param {object}            [opts] - Optional parameters
   *
   * @param {boolean}           [opts.async=false] - If animating return a Promise that resolves with any saved data.
   *
   * @param {boolean}           [opts.animateTo=false] - Animate to restore data.
   *
   * @param {number}            [opts.duration=0.1] - Duration in seconds.
   *
   * @param {Function}          [opts.ease=linear] - Easing function.
   *
   * @param {Function}          [opts.interpolate=lerp] - Interpolation function.
   *
   * @returns {T | Promise<T>} When synchronous the application or Promise when animating resolving with application.
   */
  set(e, { async: t = !1, animateTo: s = !1, duration: n = 0.1, ease: l = ei, interpolate: r = Pl } = {}) {
    var c, u, d, p, m;
    if (!ke(e))
      throw new TypeError("ApplicationState - restore error: 'data' is not an object.");
    const o = M(this, Ai);
    if (!ke(e == null ? void 0 : e.position))
      return console.warn("ApplicationState.set warning: 'data.position' is not an object."), o;
    const a = o.rendered;
    if (s && !a)
      return console.warn("ApplicationState.set warning: Application is not rendered and 'animateTo' is true."), o;
    if (s) {
      if (e.position.transformOrigin !== o.position.transformOrigin && (o.position.transformOrigin = e.position.transformOrigin), ke(e == null ? void 0 : e.ui)) {
        const h = typeof ((c = e.ui) == null ? void 0 : c.minimized) == "boolean" ? e.ui.minimized : !1;
        (u = o == null ? void 0 : o.reactive) != null && u.minimized && !h && o.maximize({ animate: !1, duration: 0 });
      }
      const g = o.position.animate.to(
        e.position,
        { duration: n, ease: l, interpolate: r }
      ).finished.then((h) => {
        var _, y;
        if (h)
          return o;
        if (ke(e == null ? void 0 : e.options) && (o == null || o.reactive.mergeOptions(e.options)), ke(e == null ? void 0 : e.ui)) {
          const k = typeof ((_ = e.ui) == null ? void 0 : _.minimized) == "boolean" ? e.ui.minimized : !1;
          !((y = o == null ? void 0 : o.reactive) != null && y.minimized) && k && o.minimize({ animate: !1, duration: 0 });
        }
        return ke(e == null ? void 0 : e.beforeMinimized) && o.position.state.set({ name: "#beforeMinimized", ...e.beforeMinimized }), o;
      });
      if (t)
        return g;
    } else if (a) {
      if (ke(e == null ? void 0 : e.options) && (o == null || o.reactive.mergeOptions(e.options)), ke(e == null ? void 0 : e.ui)) {
        const g = typeof ((d = e.ui) == null ? void 0 : d.minimized) == "boolean" ? e.ui.minimized : !1;
        (p = o == null ? void 0 : o.reactive) != null && p.minimized && !g ? o.maximize({ animate: !1, duration: 0 }) : !((m = o == null ? void 0 : o.reactive) != null && m.minimized) && g && o.minimize({ animate: !1, duration: n });
      }
      ke(e == null ? void 0 : e.beforeMinimized) && o.position.state.set({ name: "#beforeMinimized", ...e.beforeMinimized }), o.position.set(e.position);
    } else {
      let g = e.position;
      ke(e.beforeMinimized) && (g = e.beforeMinimized, g.left = e.position.left, g.top = e.position.top), o.position.set(g);
    }
    return o;
  }
};
Ai = new WeakMap(), Ei = new WeakMap(), f(H$, "ApplicationState");
let a_ = H$;
var au, Is;
const U$ = class U$ {
  /**
   * Keep a direct reference to the SvelteData array in an associated {@link SvelteApplication}.
   *
   * @param {import('./types').MountedAppShell[] | null[]}  applicationShellHolder - A reference to the
   *        MountedAppShell array.
   *
   * @param {import('./types').SvelteData[]}  svelteData - A reference to the SvelteData array of mounted components.
   */
  constructor(e, t) {
    /** @type {import('./types').MountedAppShell[] | null[]} */
    Y(this, au, void 0);
    /** @type {import('./types').SvelteData[]} */
    Y(this, Is, void 0);
    ye(this, au, e), ye(this, Is, t);
  }
  /**
   * Returns any mounted {@link MountedAppShell}.
   *
   * @returns {import('./types').MountedAppShell | null} Any mounted application shell.
   */
  get applicationShell() {
    return M(this, au)[0];
  }
  /**
   * Returns the indexed Svelte component.
   *
   * @param {number}   index -
   *
   * @returns {object} The loaded Svelte component.
   */
  component(e) {
    const t = M(this, Is)[e];
    return (t == null ? void 0 : t.component) ?? void 0;
  }
  /**
   * Returns the Svelte component entries iterator.
   *
   * @returns {IterableIterator<[number, import('svelte').SvelteComponent]>} Svelte component entries iterator.
   * @yields
   */
  *componentEntries() {
    for (let e = 0; e < M(this, Is).length; e++)
      yield [e, M(this, Is)[e].component];
  }
  /**
   * Returns the Svelte component values iterator.
   *
   * @returns {IterableIterator<import('svelte').SvelteComponent>} Svelte component values iterator.
   * @yields
   */
  *componentValues() {
    for (let e = 0; e < M(this, Is).length; e++)
      yield M(this, Is)[e].component;
  }
  /**
   * Returns the indexed SvelteData entry.
   *
   * @param {number}   index - The index of SvelteData instance to retrieve.
   *
   * @returns {import('./types').SvelteData} The loaded Svelte config + component.
   */
  data(e) {
    return M(this, Is)[e];
  }
  /**
   * Returns the {@link SvelteData} instance for a given component.
   *
   * @param {import('svelte').SvelteComponent} component - Svelte component.
   *
   * @returns {import('./types').SvelteData} -  The loaded Svelte config + component.
   */
  dataByComponent(e) {
    for (const t of M(this, Is))
      if (t.component === e)
        return t;
  }
  /**
   * Returns the SvelteData entries iterator.
   *
   * @returns {IterableIterator<[number, import('./types').SvelteData]>} SvelteData entries iterator.
   */
  dataEntries() {
    return M(this, Is).entries();
  }
  /**
   * Returns the SvelteData values iterator.
   *
   * @returns {IterableIterator<import('./types').SvelteData>} SvelteData values iterator.
   */
  dataValues() {
    return M(this, Is).values();
  }
  /**
   * Returns the length of the mounted Svelte component list.
   *
   * @returns {number} Length of mounted Svelte component list.
   */
  get length() {
    return M(this, Is).length;
  }
};
au = new WeakMap(), Is = new WeakMap(), f(U$, "GetSvelteData");
let c_ = U$;
function Vz({ storage: i, serialize: e = JSON.stringify, deserialize: t = JSON.parse }) {
  function s(o) {
    return o.length < 2;
  }
  f(s, "isSimpleDeriver");
  function n(o, a, c) {
    return {
      subscribe: l(o, a, c).subscribe
    };
  }
  f(n, "storageReadable");
  function l(o, a, c) {
    function u(h) {
      return c(/* @__PURE__ */ f(function(y) {
        return i && i.setItem(o, e(y)), h(y);
      }, "wrap_set"), /* @__PURE__ */ f(function(y) {
        p(y(fn(d)));
      }, "wrap_update"));
    }
    if (f(u, "wrap_start"), i) {
      const h = i.getItem(o);
      try {
        h && (a = t(h));
      } catch {
      }
      i.setItem(o, e(a));
    }
    const d = It(a, c ? u : void 0);
    function p(h) {
      i && i.setItem(o, e(h)), d.set(h);
    }
    f(p, "set");
    function m(h) {
      p(h(fn(d)));
    }
    f(m, "update");
    function g(h, _) {
      return d.subscribe(h, _);
    }
    return f(g, "subscribe"), { set: p, update: m, subscribe: g };
  }
  f(l, "storageWritable");
  function r(o, a, c, u) {
    const d = !Array.isArray(a), p = d ? [a] : a;
    if (i && i.getItem(o))
      try {
        u = t(i.getItem(o));
      } catch {
      }
    return n(o, u, (m, g) => {
      let h = !1;
      const _ = [];
      let y = 0, k;
      const v = /* @__PURE__ */ f(() => {
        if (y)
          return;
        k == null || k();
        const P = d ? _[0] : _;
        if (s(c))
          m(c(P));
        else {
          const D = c(P, m, g);
          typeof D == "function" && (k = D);
        }
      }, "sync"), O = p.map((P, D) => P.subscribe((I) => {
        _[D] = I, y &= ~(1 << D), h && v();
      }, () => {
        y |= 1 << D;
      }));
      return h = !0, v(), /* @__PURE__ */ f(function() {
        O.forEach((D) => D()), k == null || k();
      }, "stop");
    });
  }
  return f(r, "storageDerived"), {
    readable: n,
    writable: l,
    derived: r,
    storage: i,
    serialize: e,
    deserialize: t
  };
}
f(Vz, "storeGenerator");
const Wz = Vz({ storage: globalThis == null ? void 0 : globalThis.sessionStorage });
var ln, er, cu, u_, om, N7, am, j7, Do, td;
const V$ = class V$ {
  /**
   * @param {import('./').StorageStores} storageStores - Provides a complete set of
   *        storage API store helper functions and the associated storage API instance and serializations strategy.
   */
  constructor(e) {
    /**
     * @param {string}   key - Storage key.
     *
     * @returns {(value: string, ...rest: any[]) => any} Deserialize function.
     */
    Y(this, cu);
    /**
     * @param {string}   key - Storage key.
     *
     * @returns {(value: any, ...rest: any[]) => string} Serialize function.
     */
    Y(this, om);
    /**
     * Creates a new store for the given key.
     *
     * @template T
     *
     * @param {string}   key - Key to lookup in stores map.
     *
     * @param {T}        [defaultValue] - A default value to set for the store.
     *
     * @param {import('./').StorageStores} [storageStores] - Additional store creation options.
     *
     * @returns {import('svelte/store').Writable<T>} The new store.
     */
    Y(this, am);
    /**
     * Gets a store from the `stores` Map or creates a new store for the key and a given default value.
     *
     * @template T
     *
     * @param {string}   key - Key to lookup in stores map.
     *
     * @param {T}        [defaultValue] - A default value to set for the store.
     *
     * @param {import('./').StorageStores} [storageStores] - Additional store creation options.
     *
     * @returns {import('svelte/store').Writable<T>} The store for the given key.
     */
    Y(this, Do);
    /** @type {import('./').StorageStores} */
    Y(this, ln, void 0);
    /**
     * @type {(Map<string, {
     *    store: import('svelte/store').Writable,
     *    deserialize?: (value: string, ...rest: any[]) => any,
     *    serialize?: (value: any, ...rest: any[]) => string
     * }>)}
     */
    Y(this, er, /* @__PURE__ */ new Map());
    ye(this, ln, e);
  }
  /**
   * Get value from the storage API.
   *
   * @param {string}   key - Key to lookup in storage API.
   *
   * @param {*}        [defaultValue] - A default value to return if key not present in session storage.
   *
   * @returns {*} Value from session storage or if not defined any default value provided.
   */
  getItem(e, t) {
    let s = t;
    const n = M(this, ln).storage.getItem(e);
    if (n !== null)
      try {
        s = Z(this, cu, u_).call(this, e)(n);
      } catch {
        s = t;
      }
    else if (t !== void 0)
      try {
        const l = Z(this, om, N7).call(this, e)(t);
        M(this, ln).storage.setItem(e, l);
      } catch {
      }
    return s;
  }
  /**
   * Returns the backing Svelte store for the given key; potentially sets a default value if the key
   * is not already set.
   *
   * @template T
   *
   * @param {string}   key - Key to lookup in storage API.
   *
   * @param {T}        [defaultValue] - A default value to return if key not present in session storage.
   *
   * @param {import('./').StorageStores} [storageStores] - Additional store creation options.
   *
   * @returns {import('svelte/store').Writable<T>} The Svelte store for this key.
   */
  getStore(e, t, s) {
    return Z(this, Do, td).call(this, e, t, s);
  }
  /**
   * Sets the value for the given key in storage API.
   *
   * @param {string}   key - Key to lookup in storage API.
   *
   * @param {*}        value - A value to set for this key.
   */
  setItem(e, t) {
    Z(this, Do, td).call(this, e).set(t);
  }
  /**
   * Convenience method to swap a boolean value stored in storage API.
   *
   * @param {string}   key - Key to lookup in storage API.
   *
   * @param {boolean}  [defaultValue] - A default value to return if key not present in session storage.
   *
   * @returns {boolean} The boolean swap for the given key.
   */
  swapItemBoolean(e, t) {
    const s = Z(this, Do, td).call(this, e, t);
    let n = !1;
    try {
      n = !!Z(this, cu, u_).call(this, e)(M(this, ln).storage.getItem(e));
    } catch {
    }
    const l = typeof n == "boolean" ? !n : !1;
    return s.set(l), l;
  }
};
ln = new WeakMap(), er = new WeakMap(), cu = new WeakSet(), u_ = /* @__PURE__ */ f(function(e) {
  var t;
  return ((t = M(this, er).get(e)) == null ? void 0 : t.deserialize) ?? M(this, ln).deserialize;
}, "#getDeserialize"), om = new WeakSet(), N7 = /* @__PURE__ */ f(function(e) {
  var t;
  return ((t = M(this, er).get(e)) == null ? void 0 : t.serialize) ?? M(this, ln).serialize;
}, "#getSerialize"), am = new WeakSet(), j7 = /* @__PURE__ */ f(function(e, t = void 0, s) {
  try {
    const l = M(this, ln).storage.getItem(e);
    l !== null && (t = ((s == null ? void 0 : s.deserialize) ?? M(this, ln).deserialize)(l));
  } catch {
  }
  return ((s == null ? void 0 : s.writable) ?? M(this, ln).writable)(e, t);
}, "#createStore"), Do = new WeakSet(), td = /* @__PURE__ */ f(function(e, t = void 0, s) {
  const n = M(this, er).get(e);
  if (n)
    return n.store;
  const l = Z(this, am, j7).call(this, e, t, s);
  return M(this, er).set(e, {
    store: l,
    deserialize: s == null ? void 0 : s.deserialize,
    serialize: s == null ? void 0 : s.serialize
  }), l;
}, "#getStore"), f(V$, "TJSWebStorage");
let jd = V$;
const W$ = class W$ extends jd {
  constructor() {
    super(Wz);
  }
};
f(W$, "TJSSessionStorage");
let f_ = W$;
var Dt, uu, fu, nl, tr, il, du, Io, ll, cm, L7, um, B7, fm, q7;
const K$ = class K$ {
  /**
   * @param {import('../SvelteApplication').SvelteApplication} application - The host Foundry application.
   */
  constructor(e) {
    /**
     * Initializes the Svelte stores and derived stores for the application options and UI state.
     *
     * While writable stores are created the update method is stored in private variables locally and derived Readable
     * stores are provided for essential options which are commonly used.
     *
     * These stores are injected into all Svelte components mounted under the `external` context: `storeAppOptions` and
     * `storeUIState`.
     */
    Y(this, cm);
    /**
     * Registers local store subscriptions for app options. `popOut` controls registering this app with `ui.windows`.
     *
     * @see SvelteApplication._injectHTML
     */
    Y(this, um);
    /**
     * Unsubscribes from any locally monitored stores.
     *
     * @see SvelteApplication.close
     */
    Y(this, fm);
    /**
     * @type {import('../SvelteApplication').SvelteApplication}
     */
    Y(this, Dt, void 0);
    /**
     * @type {boolean}
     */
    Y(this, uu, !1);
    /** @type {import('@typhonjs-fvtt/runtime/svelte/store/web-storage').TJSWebStorage} */
    Y(this, fu, void 0);
    /**
     * The Application option store which is injected into mounted Svelte component context under the `external` key.
     *
     * @type {import('./types').StoreAppOptions}
     */
    Y(this, nl, void 0);
    /**
     * Stores the update function for `#storeAppOptions`.
     *
     * @type {(this: void, updater: import('svelte/store').Updater<object>) => void}
     */
    Y(this, tr, void 0);
    /**
     * Stores the UI state data to make it accessible via getters.
     *
     * @type {object}
     */
    Y(this, il, void 0);
    /**
     * The UI option store which is injected into mounted Svelte component context under the `external` key.
     *
     * @type {import('./types').StoreUIOptions}
     */
    Y(this, du, void 0);
    /**
     * Stores the update function for `#storeUIState`.
     *
     * @type {(this: void, updater: import('svelte/store').Updater<object>) => void}
     */
    Y(this, Io, void 0);
    /**
     * Stores the unsubscribe functions from local store subscriptions.
     *
     * @type {import('svelte/store').Unsubscriber[]}
     */
    Y(this, ll, []);
    var s;
    ye(this, Dt, e);
    const t = (s = e == null ? void 0 : e.options) == null ? void 0 : s.sessionStorage;
    if (t !== void 0 && !(t instanceof jd))
      throw new TypeError("'options.sessionStorage' is not an instance of TJSWebStorage.");
    ye(this, fu, t !== void 0 ? t : new f_());
  }
  /**
   * Initializes reactive support. Package private for internal use.
   *
   * @returns {SvelteReactiveStores | undefined} Internal methods to interact with Svelte stores.
   * @package
   * @internal
   */
  initialize() {
    if (!M(this, uu))
      return ye(this, uu, !0), Z(this, cm, L7).call(this), {
        appOptionsUpdate: M(this, tr),
        uiStateUpdate: M(this, Io),
        subscribe: Z(this, um, B7).bind(this),
        unsubscribe: Z(this, fm, q7).bind(this)
      };
  }
  // Store getters -----------------------------------------------------------------------------------------------------
  /**
   * @returns {import('@typhonjs-fvtt/runtime/svelte/store/web-storage').TJSWebStorage} Returns TJSWebStorage (session) instance.
   */
  get sessionStorage() {
    return M(this, fu);
  }
  /**
   * Returns the store for app options.
   *
   * @returns {import('./types').StoreAppOptions} App options store.
   */
  get storeAppOptions() {
    return M(this, nl);
  }
  /**
   * Returns the store for UI options.
   *
   * @returns {import('./types').StoreUIOptions} UI options store.
   */
  get storeUIState() {
    return M(this, du);
  }
  // Only reactive getters ---------------------------------------------------------------------------------------------
  /**
   * Returns the current dragging UI state.
   *
   * @returns {boolean} Dragging UI state.
   */
  get dragging() {
    return M(this, il).dragging;
  }
  /**
   * Returns the current minimized UI state.
   *
   * @returns {boolean} Minimized UI state.
   */
  get minimized() {
    return M(this, il).minimized;
  }
  /**
   * Returns the current resizing UI state.
   *
   * @returns {boolean} Resizing UI state.
   */
  get resizing() {
    return M(this, il).resizing;
  }
  // Reactive getter / setters -----------------------------------------------------------------------------------------
  /**
   * Returns the draggable app option.
   *
   * @returns {boolean} Draggable app option.
   */
  get draggable() {
    var e, t;
    return (t = (e = M(this, Dt)) == null ? void 0 : e.options) == null ? void 0 : t.draggable;
  }
  /**
   * Returns the focusAuto app option.
   *
   * @returns {boolean} When true auto-management of app focus is enabled.
   */
  get focusAuto() {
    var e, t;
    return (t = (e = M(this, Dt)) == null ? void 0 : e.options) == null ? void 0 : t.focusAuto;
  }
  /**
   * Returns the focusKeep app option.
   *
   * @returns {boolean} When `focusAuto` and `focusKeep` is true; keeps internal focus.
   */
  get focusKeep() {
    var e, t;
    return (t = (e = M(this, Dt)) == null ? void 0 : e.options) == null ? void 0 : t.focusKeep;
  }
  /**
   * Returns the focusTrap app option.
   *
   * @returns {boolean} When true focus trapping / wrapping is enabled keeping focus inside app.
   */
  get focusTrap() {
    var e, t;
    return (t = (e = M(this, Dt)) == null ? void 0 : e.options) == null ? void 0 : t.focusTrap;
  }
  /**
   * Returns the headerButtonNoClose app option.
   *
   * @returns {boolean} Remove the close the button in header app option.
   */
  get headerButtonNoClose() {
    var e, t;
    return (t = (e = M(this, Dt)) == null ? void 0 : e.options) == null ? void 0 : t.headerButtonNoClose;
  }
  /**
   * Returns the headerButtonNoLabel app option.
   *
   * @returns {boolean} Remove the labels from buttons in header app option.
   */
  get headerButtonNoLabel() {
    var e, t;
    return (t = (e = M(this, Dt)) == null ? void 0 : e.options) == null ? void 0 : t.headerButtonNoLabel;
  }
  /**
   * Returns the headerIcon app option.
   *
   * @returns {string|void} URL for header app icon.
   */
  get headerIcon() {
    var e, t;
    return (t = (e = M(this, Dt)) == null ? void 0 : e.options) == null ? void 0 : t.headerIcon;
  }
  /**
   * Returns the headerNoTitleMinimized app option.
   *
   * @returns {boolean} When true removes the header title when minimized.
   */
  get headerNoTitleMinimized() {
    var e, t;
    return (t = (e = M(this, Dt)) == null ? void 0 : e.options) == null ? void 0 : t.headerNoTitleMinimized;
  }
  /**
   * Returns the minimizable app option.
   *
   * @returns {boolean} Minimizable app option.
   */
  get minimizable() {
    var e, t;
    return (t = (e = M(this, Dt)) == null ? void 0 : e.options) == null ? void 0 : t.minimizable;
  }
  /**
   * Returns the Foundry popOut state; {@link Application.popOut}
   *
   * @returns {boolean} Positionable app option.
   */
  get popOut() {
    return M(this, Dt).popOut;
  }
  /**
   * Returns the positionable app option; {@link SvelteApplicationOptions.positionable}
   *
   * @returns {boolean} Positionable app option.
   */
  get positionable() {
    var e, t;
    return (t = (e = M(this, Dt)) == null ? void 0 : e.options) == null ? void 0 : t.positionable;
  }
  /**
   * Returns the resizable option.
   *
   * @returns {boolean} Resizable app option.
   */
  get resizable() {
    var e, t;
    return (t = (e = M(this, Dt)) == null ? void 0 : e.options) == null ? void 0 : t.resizable;
  }
  /**
   * Returns the title accessor from the parent Application class; {@link Application.title}
   * TODO: Application v2; note that super.title localizes `this.options.title`; IMHO it shouldn't.
   *
   * @returns {string} Title.
   */
  get title() {
    return M(this, Dt).title;
  }
  /**
   * Sets `this.options.draggable` which is reactive for application shells.
   *
   * @param {boolean}  draggable - Sets the draggable option.
   */
  set draggable(e) {
    typeof e == "boolean" && this.setOptions("draggable", e);
  }
  /**
   * Sets `this.options.focusAuto` which is reactive for application shells.
   *
   * @param {boolean}  focusAuto - Sets the focusAuto option.
   */
  set focusAuto(e) {
    typeof e == "boolean" && this.setOptions("focusAuto", e);
  }
  /**
   * Sets `this.options.focusKeep` which is reactive for application shells.
   *
   * @param {boolean}  focusKeep - Sets the focusKeep option.
   */
  set focusKeep(e) {
    typeof e == "boolean" && this.setOptions("focusKeep", e);
  }
  /**
   * Sets `this.options.focusTrap` which is reactive for application shells.
   *
   * @param {boolean}  focusTrap - Sets the focusTrap option.
   */
  set focusTrap(e) {
    typeof e == "boolean" && this.setOptions("focusTrap", e);
  }
  /**
   * Sets `this.options.headerButtonNoClose` which is reactive for application shells.
   *
   * @param {boolean}  headerButtonNoClose - Sets the headerButtonNoClose option.
   */
  set headerButtonNoClose(e) {
    typeof e == "boolean" && this.setOptions("headerButtonNoClose", e);
  }
  /**
   * Sets `this.options.headerButtonNoLabel` which is reactive for application shells.
   *
   * @param {boolean}  headerButtonNoLabel - Sets the headerButtonNoLabel option.
   */
  set headerButtonNoLabel(e) {
    typeof e == "boolean" && this.setOptions("headerButtonNoLabel", e);
  }
  /**
   * Sets `this.options.headerIcon` which is reactive for application shells.
   *
   * @param {string | undefined}  headerIcon - Sets the headerButtonNoLabel option.
   */
  set headerIcon(e) {
    (e === void 0 || typeof e == "string") && this.setOptions("headerIcon", e);
  }
  /**
   * Sets `this.options.headerNoTitleMinimized` which is reactive for application shells.
   *
   * @param {boolean}  headerNoTitleMinimized - Sets the headerNoTitleMinimized option.
   */
  set headerNoTitleMinimized(e) {
    typeof e == "boolean" && this.setOptions("headerNoTitleMinimized", e);
  }
  /**
   * Sets `this.options.minimizable` which is reactive for application shells that are also pop out.
   *
   * @param {boolean}  minimizable - Sets the minimizable option.
   */
  set minimizable(e) {
    typeof e == "boolean" && this.setOptions("minimizable", e);
  }
  /**
   * Sets `this.options.popOut` which is reactive for application shells. This will add / remove this application
   * from `ui.windows`.
   *
   * @param {boolean}  popOut - Sets the popOut option.
   */
  set popOut(e) {
    typeof e == "boolean" && this.setOptions("popOut", e);
  }
  /**
   * Sets `this.options.positionable` enabling / disabling {@link SvelteApplication.position}.
   *
   * @param {boolean}  positionable - Sets the positionable option.
   */
  set positionable(e) {
    typeof e == "boolean" && this.setOptions("positionable", e);
  }
  /**
   * Sets `this.options.resizable` which is reactive for application shells.
   *
   * @param {boolean}  resizable - Sets the resizable option.
   */
  set resizable(e) {
    typeof e == "boolean" && this.setOptions("resizable", e);
  }
  /**
   * Sets `this.options.title` which is reactive for application shells.
   *
   * Note: Will set empty string if title is undefined or null.
   *
   * @param {string | undefined | null}   title - Application title; will be localized, so a translation key is fine.
   */
  set title(e) {
    typeof e == "string" ? this.setOptions("title", e) : e == null && this.setOptions("title", "");
  }
  // Reactive Options API -------------------------------------------------------------------------------------------
  /**
   * Provides a way to safely get this applications options given an accessor string which describes the
   * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries
   * to walk.
   *
   * // TODO DOCUMENT the accessor in more detail.
   *
   * @param {string}   accessor - The path / key to set. You can set multiple levels.
   *
   * @param {*}        [defaultValue] - A default value returned if the accessor is not found.
   *
   * @returns {*} Value at the accessor.
   */
  getOptions(e, t) {
    return _d(M(this, Dt).options, e, t);
  }
  /**
   * Provides a way to merge `options` into this applications options and update the appOptions store.
   *
   * @param {object}   options - The options object to merge with `this.options`.
   */
  mergeOptions(e) {
    M(this, tr).call(this, (t) => Ii(t, e));
  }
  /**
   * Provides a way to safely set this applications options given an accessor string which describes the
   * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries
   * to walk.
   *
   * Additionally if an application shell Svelte component is mounted and exports the `appOptions` property then
   * the application options is set to `appOptions` potentially updating the application shell / Svelte component.
   *
   * // TODO DOCUMENT the accessor in more detail.
   *
   * @param {string}   accessor - The path / key to set. You can set multiple levels.
   *
   * @param {any}      value - Value to set.
   */
  setOptions(e, t) {
    p7(M(this, Dt).options, e, t) && M(this, tr).call(this, () => M(this, Dt).options);
  }
  /**
   * Updates the UI Options store with the current header buttons. You may dynamically add / remove header buttons
   * if using an application shell Svelte component. In either overriding `_getHeaderButtons` or responding to the
   * Hooks fired return a new button array and the uiOptions store is updated and the application shell will render
   * the new buttons.
   *
   * Optionally you can set in the SvelteApplication app options {@link SvelteApplicationOptions.headerButtonNoClose}
   * to remove the close button and {@link SvelteApplicationOptions.headerButtonNoLabel} to true and labels will be
   * removed from the header buttons.
   *
   * @param {object} [opts] - Optional parameters (for internal use)
   *
   * @param {boolean} [opts.headerButtonNoClose] - The value for `headerButtonNoClose`.
   *
   * @param {boolean} [opts.headerButtonNoLabel] - The value for `headerButtonNoLabel`.
   */
  updateHeaderButtons({
    headerButtonNoClose: e = M(this, Dt).options.headerButtonNoClose,
    headerButtonNoLabel: t = M(this, Dt).options.headerButtonNoLabel
  } = {}) {
    let s = M(this, Dt)._getHeaderButtons();
    if (typeof e == "boolean" && e && (s = s.filter((n) => n.class !== "close")), typeof t == "boolean" && t)
      for (const n of s)
        n.label = void 0;
    M(this, Io).call(this, (n) => (n.headerButtons = s, n));
  }
};
Dt = new WeakMap(), uu = new WeakMap(), fu = new WeakMap(), nl = new WeakMap(), tr = new WeakMap(), il = new WeakMap(), du = new WeakMap(), Io = new WeakMap(), ll = new WeakMap(), cm = new WeakSet(), L7 = /* @__PURE__ */ f(function() {
  const e = It(M(this, Dt).options);
  ye(this, tr, e.update);
  const t = {
    subscribe: e.subscribe,
    draggable: dt(e, "draggable"),
    focusAuto: dt(e, "focusAuto"),
    focusKeep: dt(e, "focusKeep"),
    focusTrap: dt(e, "focusTrap"),
    headerButtonNoClose: dt(e, "headerButtonNoClose"),
    headerButtonNoLabel: dt(e, "headerButtonNoLabel"),
    headerIcon: dt(e, "headerIcon"),
    headerNoTitleMinimized: dt(e, "headerNoTitleMinimized"),
    minimizable: dt(e, "minimizable"),
    popOut: dt(e, "popOut"),
    positionable: dt(e, "positionable"),
    resizable: dt(e, "resizable"),
    title: dt(e, "title")
  };
  Object.freeze(t), ye(this, nl, t), ye(this, il, {
    dragging: !1,
    headerButtons: [],
    minimized: M(this, Dt)._minimized,
    resizing: !1
  });
  const s = It(M(this, il));
  ye(this, Io, s.update);
  const n = {
    subscribe: s.subscribe,
    dragging: dt(s, "dragging"),
    headerButtons: wc(s, (l, r) => r(l.headerButtons)),
    minimized: wc(s, (l, r) => r(l.minimized)),
    resizing: dt(s, "resizing")
  };
  Object.freeze(n), ye(this, du, n);
}, "#storesInitialize"), um = new WeakSet(), B7 = /* @__PURE__ */ f(function() {
  M(this, ll).push(tc(M(this, nl).headerButtonNoClose, (e) => {
    this.updateHeaderButtons({ headerButtonNoClose: e });
  })), M(this, ll).push(tc(M(this, nl).headerButtonNoLabel, (e) => {
    this.updateHeaderButtons({ headerButtonNoLabel: e });
  })), M(this, ll).push(tc(M(this, nl).popOut, (e) => {
    e && M(this, Dt).rendered ? globalThis.ui.windows[M(this, Dt).appId] = M(this, Dt) : delete globalThis.ui.windows[M(this, Dt).appId];
  }));
}, "#storesSubscribe"), fm = new WeakSet(), q7 = /* @__PURE__ */ f(function() {
  M(this, ll).forEach((e) => e()), ye(this, ll, []);
}, "#storesUnsubscribe"), f(K$, "SvelteReactive");
let d_ = K$;
const p_ = ["elementRoot"];
Object.freeze(p_);
function m_(i) {
  if (i == null)
    return !1;
  let e = !0, t = !0;
  for (const n of p_) {
    const l = Object.getOwnPropertyDescriptor(i, n);
    (l === void 0 || l.get === void 0 || l.set === void 0) && (e = !1);
  }
  const s = Object.getPrototypeOf(i);
  for (const n of p_) {
    const l = Object.getOwnPropertyDescriptor(s, n);
    (l === void 0 || l.get === void 0 || l.set === void 0) && (t = !1);
  }
  return e || t;
}
f(m_, "isApplicationShell");
function qO({ app: i, template: e, config: t, elementRootUpdate: s } = {}) {
  const n = ke(t.options) ? t.options : {};
  let l;
  if (t.target instanceof HTMLElement ? l = t.target : e instanceof HTMLElement && typeof t.target == "string" ? l = e.querySelector(t.target) : l = document.createDocumentFragment(), l === void 0)
    throw console.log(
      `%c[TRL] loadSvelteConfig error - could not find target selector, '${t.target}', for config:
`,
      "background: rgb(57,34,34)",
      t
    ), new Error();
  const r = t.class, o = C7({ ...t, target: l }, i), a = o.context.get("#external");
  a.application = i, a.elementRootUpdate = s, a.sessionStorage = i.reactive.sessionStorage;
  let c;
  ke(i._eventbus) && typeof i._eventbus.createProxy == "function" && (c = i._eventbus.createProxy(), a.eventbus = c), Object.seal(a), o.context.set("external", new Proxy({}, {
    get(m, g) {
      return console.warn("[TRL] Deprecation warning: Please change getContext('external') to getContext('#external')."), a[g];
    }
  }));
  const u = new r(o);
  o.eventbus = c;
  let d;
  if (m_(u) && (d = u.elementRoot), l instanceof DocumentFragment && l.firstElementChild)
    d === void 0 && (d = l.firstElementChild), e.append(l);
  else if (t.target instanceof HTMLElement && d === void 0) {
    if (t.target instanceof HTMLElement && typeof n.selectorElement != "string")
      throw console.log(
        `%c[TRL] loadSvelteConfig error - HTMLElement target with no 'selectorElement' defined.

Note: If configuring an application shell and directly targeting a HTMLElement did you bind an'elementRoot' and include '<svelte:options accessors={true}/>'?

Offending config:
`,
        "background: rgb(57,34,34)",
        t
      ), new Error();
    if (d = l.querySelector(n.selectorElement), d == null)
      throw console.log(
        `%c[TRL] loadSvelteConfig error - HTMLElement target with 'selectorElement', '${n.selectorElement}', not found for config:
`,
        "background: rgb(57,34,34)",
        t
      ), new Error();
  }
  const p = !(t.target instanceof HTMLElement);
  return { config: o, component: u, element: d, injectHTML: p };
}
f(qO, "loadSvelteConfig");
var Si;
const dm = class dm {
  /**
   * Adds a SvelteApplication to all visible apps tracked.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication} app - A SvelteApplication
   *
   * @package
   */
  static add(e) {
    M(this, Si).set(e.id, e);
  }
  /**
   * Removes a SvelteApplication from all visible apps tracked.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication} app - A SvelteApplication
   *
   * @package
   */
  static delete(e) {
    M(this, Si).delete(e.id);
  }
  /**
   * Gets a particular app by ID.
   *
   * @param {string}   key - App ID.
   *
   * @returns {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication} Associated app.
   */
  static get(e) {
    return M(this, Si).get(e);
  }
  /**
   * Returns whether an associated app by ID is being tracked.
   *
   * @param {string}   key - App ID.
   *
   * @returns {boolean} The given App ID is visible.
   */
  static has(e) {
    return M(this, Si).has(e);
  }
  /**
   * @returns {IterableIterator<string>} All visible app IDs.
   */
  static keys() {
    return M(this, Si).keys();
  }
  /**
   * @returns {IterableIterator<import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication>} All visible apps.
   */
  static values() {
    return M(this, Si).values();
  }
};
Si = new WeakMap(), f(dm, "TJSAppIndex"), /**
 * Stores all visible / rendered apps.
 *
 * @type {Map<string, import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication>}
 */
Y(dm, Si, /* @__PURE__ */ new Map());
let Ld = dm;
var sr, pu, ss, Ti, Po, Mo, nr, Ro, Un, pm, Ci, Fo, sd;
const cc = class cc extends Application {
  /**
   * @param {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplicationOptions} options - The options for the application.
   *
   * @inheritDoc
   */
  constructor(t = {}) {
    super(t);
    /**
     * This method is invoked by the `elementRootUpdate` callback that is added to the external context passed to
     * Svelte components. When invoked it updates the local element roots tracked by SvelteApplication.
     *
     * This method may also be invoked by HMR / hot module replacement via `svelte-hmr`.
     */
    Y(this, Fo);
    /**
     * Stores the first mounted component which follows the application shell contract.
     *
     * @type {import('./internal/state-svelte/types').MountedAppShell[]|null[]} Application shell.
     */
    Y(this, sr, [null]);
    /**
     * Stores and manages application state for saving / restoring / serializing.
     *
     * @type {ApplicationState<SvelteApplication>}
     */
    Y(this, pu, void 0);
    /**
     * Stores the target element which may not necessarily be the main element.
     *
     * @type {HTMLElement}
     */
    Y(this, ss, null);
    /**
     * Stores the content element which is set for application shells.
     *
     * @type {HTMLElement}
     */
    Y(this, Ti, null);
    /**
     * Stores initial z-index from `_renderOuter` to set to target element / Svelte component.
     *
     * @type {number}
     */
    Y(this, Po, 95);
    /**
     * Stores on mount state which is checked in _render to trigger onSvelteMount callback.
     *
     * @type {boolean}
     */
    Y(this, Mo, !1);
    /**
     * The position store.
     *
     * @type {TJSPosition}
     */
    Y(this, nr, void 0);
    /**
     * Contains the Svelte stores and reactive accessors.
     *
     * @type {SvelteReactive}
     */
    Y(this, Ro, void 0);
    /**
     * Stores SvelteData entries with instantiated Svelte components.
     *
     * @type {import('./internal/state-svelte/types').SvelteData[]}
     */
    Y(this, Un, []);
    /**
     * Provides a helper class that combines multiple methods for interacting with the mounted components tracked in
     * #svelteData.
     *
     * @type {GetSvelteData}
     */
    Y(this, pm, new c_(M(this, sr), M(this, Un)));
    /**
     * Contains methods to interact with the Svelte stores.
     *
     * @type {import('./internal/state-reactive/SvelteReactive').SvelteReactiveStores}
     */
    Y(this, Ci, void 0);
    ye(this, pu, new a_(this)), ye(this, nr, new nc(this, {
      ...this.position,
      ...this.options,
      initial: this.options.positionInitial,
      ortho: this.options.positionOrtho,
      validator: this.options.positionValidator
    })), delete this.position, Object.defineProperty(this, "position", {
      get: () => M(this, nr),
      set: (s) => {
        ke(s) && M(this, nr).set(s);
      }
    }), ye(this, Ro, new d_(this)), ye(this, Ci, M(this, Ro).initialize());
  }
  /**
   * Specifies the default options that SvelteApplication supports.
   *
   * @returns {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplicationOptions} options - Application options.
   * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
   *
   * @internal
   */
  static get defaultOptions() {
    return Ii(super.defaultOptions, {
      defaultCloseAnimation: !0,
      // If false the default slide close animation is not run.
      draggable: !0,
      // If true then application shells are draggable.
      focusAuto: !0,
      // When true auto-management of app focus is enabled.
      focusKeep: !1,
      // When `focusAuto` and `focusKeep` is true; keeps internal focus.
      focusSource: void 0,
      // Stores any A11yFocusSource data that is applied when app is closed.
      focusTrap: !0,
      // When true focus trapping / wrapping is enabled keeping focus inside app.
      headerButtonNoClose: !1,
      // If true then the close header button is removed.
      headerButtonNoLabel: !1,
      // If true then header button labels are removed for application shells.
      headerIcon: void 0,
      // Sets a header icon given an image URL.
      headerNoTitleMinimized: !1,
      // If true then header title is hidden when application is minimized.
      minHeight: MIN_WINDOW_HEIGHT,
      // Assigned to position. Number specifying minimum window height.
      minWidth: MIN_WINDOW_WIDTH,
      // Assigned to position. Number specifying minimum window width.
      positionable: !0,
      // If false then `position.set` does not take effect.
      positionInitial: nc.Initial.browserCentered,
      // A helper for initial position placement.
      positionOrtho: !0,
      // When true TJSPosition is optimized for orthographic use.
      positionValidator: nc.Validators.transformWindow,
      // A function providing the default validator.
      sessionStorage: void 0,
      // An instance of TJSWebStorage (session) to share across SvelteApplications.
      svelte: void 0,
      // A Svelte configuration object.
      transformOrigin: "top left"
      // By default, 'top / left' respects rotation when minimizing.
    });
  }
  /**
   * Returns the content element if an application shell is mounted.
   *
   * @returns {HTMLElement} Content element.
   */
  get elementContent() {
    return M(this, Ti);
  }
  /**
   * Returns the target element or main element if no target defined.
   *
   * @returns {HTMLElement} Target element.
   */
  get elementTarget() {
    return M(this, ss);
  }
  /**
   * Returns the reactive accessors & Svelte stores for SvelteApplication.
   *
   * @returns {import('./internal/state-reactive/types').SvelteReactive} The reactive accessors & Svelte stores.
   */
  get reactive() {
    return M(this, Ro);
  }
  /**
   * Returns the application state manager.
   *
   * @returns {import('./internal/state-app/types').ApplicationState<SvelteApplication>} The application state manager.
   */
  get state() {
    return M(this, pu);
  }
  /**
   * Returns the Svelte helper class w/ various methods to access mounted Svelte components.
   *
   * @returns {import('./internal/state-svelte/types').GetSvelteData} GetSvelteData
   */
  get svelte() {
    return M(this, pm);
  }
  /**
   * In this case of when a template is defined in app options `html` references the inner HTML / template. However,
   * to activate classic v1 tabs for a Svelte component the element target is passed as an array simulating JQuery as
   * the element is retrieved immediately and the core listeners use standard DOM queries.
   *
   * @protected
   * @ignore
   * @internal
   */
  _activateCoreListeners(t) {
    var s;
    super._activateCoreListeners(typeof this.options.template == "string" ? t : [this.popOut ? (s = M(this, ss)) == null ? void 0 : s.firstChild : M(this, ss)]);
  }
  /**
   * Provide an override to set this application as the active window regardless of z-index. Changes behaviour from
   * Foundry core. This is important / used for instance in dialog key handling for left / right button selection.
   *
   * @param {object} [opts] - Optional parameters.
   *
   * @param {boolean} [opts.force=false] - Force bring to top; will increment z-index by popOut order.
   *
   * @ignore
   * @internal
   */
  bringToTop({ force: t = !1 } = {}) {
    (t || this.popOut) && super.bringToTop(), document.activeElement !== document.body && !this.elementTarget.contains(document.activeElement) && (document.activeElement instanceof HTMLElement && document.activeElement.blur(), document.body.focus()), globalThis.ui.activeWindow = this;
  }
  /**
   * Note: This method is fully overridden and duplicated as Svelte components need to be destroyed manually and the
   * best visual result is to destroy them after the default slide up animation occurs, but before the element
   * is removed from the DOM.
   *
   * If you destroy the Svelte components before the slide up animation the Svelte elements are removed immediately
   * from the DOM. The purpose of overriding ensures the slide up animation is always completed before
   * the Svelte components are destroyed and then the element is removed from the DOM.
   *
   * Close the application and un-register references to it within UI mappings.
   * This function returns a Promise which resolves once the window closing animation concludes
   *
   * @param {object}   [options] - Optional parameters.
   *
   * @param {boolean}  [options.force] - Force close regardless of render state.
   *
   * @returns {Promise<void>}    A Promise which resolves once the application is closed.
   *
   * @ignore
   * @internal
   */
  async close(t = {}) {
    const s = Application.RENDER_STATES;
    if (!t.force && ![s.RENDERED, s.ERROR].includes(this._state))
      return;
    M(this, Ci).unsubscribe(), this._state = s.CLOSING;
    const n = M(this, ss);
    if (!n)
      return this._state = s.CLOSED;
    const l = n.querySelector(".window-content");
    if (l) {
      l.style.overflow = "hidden";
      for (let a = l.children.length; --a >= 0; )
        l.children[a].style.overflow = "hidden";
    }
    for (const a of this.constructor._getInheritanceChain())
      Hooks.call(`close${a.name}`, this, $(n));
    if (typeof this.options.defaultCloseAnimation == "boolean" ? this.options.defaultCloseAnimation : !0) {
      n.style.minHeight = "0";
      const { paddingBottom: a, paddingTop: c } = globalThis.getComputedStyle(n);
      await n.animate([
        { maxHeight: `${n.clientHeight}px`, paddingTop: c, paddingBottom: a },
        { maxHeight: 0, paddingTop: 0, paddingBottom: 0 }
      ], { duration: 250, easing: "ease-in", fill: "forwards" }).finished;
    }
    const o = [];
    for (const a of M(this, Un)) {
      o.push(Mz(a.component));
      const c = a.config.eventbus;
      ke(c) && typeof c.off == "function" && (c.off(), a.config.eventbus = void 0);
    }
    await Promise.all(o), Ld.delete(this), M(this, Un).length = 0, n.remove(), this.position.state.restore({
      name: "#beforeMinimized",
      properties: ["width", "height"],
      silent: !0,
      remove: !0
    }), M(this, sr)[0] = null, this._element = null, ye(this, Ti, null), ye(this, ss, null), delete globalThis.ui.windows[this.appId], this._minimized = !1, this._scrollPositions = null, this._state = s.CLOSED, ye(this, Mo, !1), M(this, Ci).uiStateUpdate((a) => Ii(a, { minimized: this._minimized })), dn.applyFocusSource(this.options.focusSource), delete this.options.focusSource;
  }
  /**
   * Inject the Svelte components defined in `this.options.svelte`. The Svelte component can attach to the existing
   * pop-out of Application or provide no template and render into a document fragment which is then attached to the
   * DOM.
   *
   * @protected
   * @ignore
   * @internal
   */
  _injectHTML(t) {
    var r, o, a, c;
    if (this.popOut && t.length === 0 && vt(this.options.svelte))
      throw new Error(
        "SvelteApplication - _injectHTML - A popout app with no template can only support one Svelte component."
      );
    this.reactive.updateHeaderButtons();
    const s = /* @__PURE__ */ f(() => {
      let u = 0;
      return (d) => d != null && u++ > 0 ? (Z(this, Fo, sd).call(this), !0) : !1;
    }, "elementRootUpdate");
    if (vt(this.options.svelte))
      for (const u of this.options.svelte) {
        const d = qO({
          app: this,
          template: t[0],
          config: u,
          elementRootUpdate: s
        });
        if (m_(d.component)) {
          if (this.svelte.applicationShell !== null)
            throw new Error(
              `SvelteApplication - _injectHTML - An application shell is already mounted; offending config:
                    ${JSON.stringify(u)}`
            );
          M(this, sr)[0] = d.component, PO(d.component) && Array.isArray((o = (r = d.component) == null ? void 0 : r.$$) == null ? void 0 : o.on_hmr) && d.component.$$.on_hmr.push(() => () => Z(this, Fo, sd).call(this));
        }
        M(this, Un).push(d);
      }
    else if (ke(this.options.svelte)) {
      const u = qO({
        app: this,
        template: t[0],
        config: this.options.svelte,
        elementRootUpdate: s
      });
      if (m_(u.component)) {
        if (this.svelte.applicationShell !== null)
          throw new Error(
            `SvelteApplication - _injectHTML - An application shell is already mounted; offending config:
                 ${JSON.stringify(this.options.svelte)}`
          );
        M(this, sr)[0] = u.component, PO(u.component) && Array.isArray((c = (a = u.component) == null ? void 0 : a.$$) == null ? void 0 : c.on_hmr) && u.component.$$.on_hmr.push(() => () => Z(this, Fo, sd).call(this));
      }
      M(this, Un).push(u);
    }
    const n = t.length && t[0] instanceof DocumentFragment;
    let l = !0;
    for (const u of M(this, Un))
      if (!u.injectHTML) {
        l = !1;
        break;
      }
    if (l && super._injectHTML(t), this.svelte.applicationShell !== null)
      this._element = $(this.svelte.applicationShell.elementRoot), ye(this, Ti, Lf(this.svelte.applicationShell, "elementContent") ? this.svelte.applicationShell.elementContent : null), ye(this, ss, Lf(this.svelte.applicationShell, "elementTarget") ? this.svelte.applicationShell.elementTarget : null);
    else if (n) {
      for (const u of M(this, Un))
        if (u.element instanceof HTMLElement) {
          this._element = $(u.element);
          break;
        }
    }
    if (M(this, ss) === null && ye(this, ss, typeof this.options.selectorTarget == "string" ? this._element[0].querySelector(this.options.selectorTarget) : this._element[0]), M(this, ss) === null || M(this, ss) === void 0)
      throw new Error(`SvelteApplication - _injectHTML: Target element '${this.options.selectorTarget}' not found.`);
    typeof this.options.positionable == "boolean" && this.options.positionable && (M(this, ss).style.zIndex = typeof this.options.zIndex == "number" ? this.options.zIndex : M(this, Po) ?? 95), M(this, Ci).subscribe();
  }
  /**
   * Provides a mechanism to update the UI options store for maximized.
   *
   * Note: the sanity check is duplicated from {@link Application.maximize} the store is updated _before_
   * performing the rest of animations. This allows application shells to remove / show any resize handlers
   * correctly. Extra constraint data is stored in a saved position state in {@link SvelteApplication.minimize}
   * to animate the content area.
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.animate=true] - When true perform default maximizing animation.
   *
   * @param {number}   [opts.duration=0.1] - Controls content area animation duration in seconds.
   */
  async maximize({ animate: t = !0, duration: s = 0.1 } = {}) {
    var u, d;
    if (!this.popOut || [!1, null].includes(this._minimized))
      return;
    this._minimized = null;
    const n = s * 1e3, l = this.elementTarget, r = l.querySelector(".window-header"), o = l.querySelector(".window-content"), a = this.position.state.get({ name: "#beforeMinimized" });
    t && await this.position.state.restore({
      name: "#beforeMinimized",
      async: !0,
      animateTo: !0,
      properties: ["width"],
      duration: 0.1
    }), l.classList.remove("minimized");
    for (let p = r.children.length; --p >= 0; )
      r.children[p].style.display = null;
    o.style.display = null;
    let c;
    t ? { constraints: c } = this.position.state.restore({
      name: "#beforeMinimized",
      animateTo: !0,
      properties: ["height"],
      remove: !0,
      duration: s
    }) : { constraints: c } = this.position.state.remove({ name: "#beforeMinimized" }), await o.animate([
      { maxHeight: 0, paddingTop: 0, paddingBottom: 0, offset: 0 },
      { ...c, offset: 1 },
      { maxHeight: "100%", offset: 1 }
    ], { duration: n, fill: "forwards" }).finished, this.position.set({
      minHeight: a.minHeight ?? ((u = this.options) == null ? void 0 : u.minHeight) ?? MIN_WINDOW_HEIGHT,
      minWidth: a.minWidth ?? ((d = this.options) == null ? void 0 : d.minWidth) ?? MIN_WINDOW_WIDTH
    }), l.style.minWidth = null, l.style.minHeight = null, this._minimized = !1, setTimeout(() => {
      o.style.overflow = null;
      for (let p = o.children.length; --p >= 0; )
        o.children[p].style.overflow = null;
    }, 50), M(this, Ci).uiStateUpdate((p) => Ii(p, { minimized: !1 }));
  }
  /**
   * Provides a mechanism to update the UI options store for minimized.
   *
   * Note: the sanity check is duplicated from {@link Application.minimize} the store is updated _before_
   * performing the rest of animations. This allows application shells to remove / show any resize handlers
   * correctly. Extra constraint data is stored in a saved position state in {@link SvelteApplication.minimize}
   * to animate the content area.
   *
   * @param {object}   [opts] - Optional parameters
   *
   * @param {boolean}  [opts.animate=true] - When true perform default minimizing animation.
   *
   * @param {number}   [opts.duration=0.1] - Controls content area animation duration in seconds.
   */
  async minimize({ animate: t = !0, duration: s = 0.1 } = {}) {
    if (!this.rendered || !this.popOut || [!0, null].includes(this._minimized))
      return;
    M(this, Ci).uiStateUpdate((h) => Ii(h, { minimized: !0 })), this._minimized = null;
    const n = s * 1e3, l = this.elementTarget, r = l.querySelector(".window-header"), o = l.querySelector(".window-content"), a = this.position.minWidth, c = this.position.minHeight;
    if (this.position.set({ minWidth: 100, minHeight: 30 }), l.style.minWidth = "100px", l.style.minHeight = "30px", o) {
      o.style.overflow = "hidden";
      for (let h = o.children.length; --h >= 0; )
        o.children[h].style.overflow = "hidden";
    }
    const { paddingBottom: u, paddingTop: d } = globalThis.getComputedStyle(o), p = {
      maxHeight: `${o.clientHeight}px`,
      paddingTop: d,
      paddingBottom: u
    };
    t ? o.animate([
      p,
      { maxHeight: 0, paddingTop: 0, paddingBottom: 0 }
    ], { duration: n, fill: "forwards" }).finished.then(() => o.style.display = "none") : setTimeout(() => o.style.display = "none", n);
    const m = this.position.state.save({ name: "#beforeMinimized", constraints: p });
    m.minWidth = a, m.minHeight = c;
    const g = r.offsetHeight;
    this.position.minHeight = g, t && await this.position.animate.to({ height: g }, { duration: s }).finished;
    for (let h = r.children.length; --h >= 0; ) {
      const _ = r.children[h].className;
      if (!(_.includes("window-title") || _.includes("close"))) {
        if (_.includes("keep-minimized")) {
          r.children[h].style.display = "block";
          continue;
        }
        r.children[h].style.display = "none";
      }
    }
    t && await this.position.animate.to({ width: MIN_WINDOW_WIDTH }, { duration: 0.1 }).finished, l.classList.add("minimized"), this._minimized = !0;
  }
  /**
   * Provides a callback after all Svelte components are initialized.
   *
   * @param {import('./internal/state-svelte/types').MountedAppShell} [mountedAppShell] - The mounted app shell
   *        elements.
   */
  onSvelteMount(t) {
  }
  // eslint-disable-line no-unused-vars
  /**
   * Provides a callback after the main application shell is remounted. This may occur during HMR / hot module
   * replacement or directly invoked from the `elementRootUpdate` callback passed to the application shell component
   * context.
   *
   * @param {import('./internal/state-svelte/types').MountedAppShell} [mountedAppShell] - The mounted app shell
   *        elements.
   */
  onSvelteRemount(t) {
  }
  // eslint-disable-line no-unused-vars
  /**
   * Override replacing HTML as Svelte components control the rendering process. Only potentially change the outer
   * application frame / title for pop-out applications.
   *
   * @protected
   * @ignore
   * @internal
   */
  _replaceHTML(t, s) {
    t.length && this.reactive.updateHeaderButtons();
  }
  /**
   * Provides an override verifying that a new Application being rendered for the first time doesn't have a
   * corresponding DOM element already loaded. This is a check that only occurs when `this._state` is
   * `Application.RENDER_STATES.NONE`. It is useful in particular when SvelteApplication has a static ID
   * explicitly set in `this.options.id` and long intro / outro transitions are assigned. If a new application
   * sharing this static ID attempts to open / render for the first time while an existing DOM element sharing
   * this static ID exists then the initial render is cancelled below rather than crashing later in the render
   * cycle {@link TJSPosition.set}.
   *
   * @protected
   * @ignore
   * @internal
   */
  async _render(t = !1, s = {}) {
    if (ke(s == null ? void 0 : s.focusSource) && (this.options.focusSource = s.focusSource), this._state === Application.RENDER_STATES.NONE && document.querySelector(`#${this.id}`) instanceof HTMLElement) {
      console.warn(`SvelteApplication - _render: A DOM element already exists for CSS ID '${this.id}'. Cancelling initial render for new application with appId '${this.appId}'.`);
      return;
    }
    await super._render(t, s), ![Application.RENDER_STATES.CLOSING, Application.RENDER_STATES.RENDERING].includes(this._state) && (!t && this._state <= Application.RENDER_STATES.NONE || (this._minimized || M(this, nr).set(s), M(this, Mo) || (Ld.add(this), this.onSvelteMount({ element: this._element[0], elementContent: M(this, Ti), elementTarget: M(this, ss) }), ye(this, Mo, !0))));
  }
  /**
   * Render the inner application content. Only render a template if one is defined otherwise provide an empty
   * JQuery element per the core Foundry API.
   *
   * @protected
   * @ignore
   * @internal
   */
  async _renderInner(t) {
    const s = typeof this.template == "string" ? await renderTemplate(this.template, t) : document.createDocumentFragment();
    return $(s);
  }
  /**
   * Stores the initial z-index set in `_renderOuter` which is used in `_injectHTML` to set the target element
   * z-index after the Svelte component is mounted.
   *
   * @protected
   * @ignore
   * @internal
   */
  async _renderOuter() {
    const t = await super._renderOuter();
    return ye(this, Po, t[0].style.zIndex), t;
  }
  /**
   * All calculation and updates of position are implemented in {@link TJSPosition.set}. This allows position to be fully
   * reactive and in control of updating inline styles for the application.
   *
   * This method remains for backward compatibility with Foundry. If you have a custom override quite likely you need
   * to update to using the {@link TJSPosition.validators} functionality.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/store/position').TJSPositionDataExtended}   [position] - TJSPosition data.
   *
   * @returns {TJSPosition} The updated position object for the application containing the new values.
   * @ignore
   */
  setPosition(t) {
    return this.position.set(t);
  }
};
sr = new WeakMap(), pu = new WeakMap(), ss = new WeakMap(), Ti = new WeakMap(), Po = new WeakMap(), Mo = new WeakMap(), nr = new WeakMap(), Ro = new WeakMap(), Un = new WeakMap(), pm = new WeakMap(), Ci = new WeakMap(), Fo = new WeakSet(), sd = /* @__PURE__ */ f(function() {
  var s;
  const t = this.svelte.applicationShell;
  t !== null && (this._element = $(t.elementRoot), ye(this, Ti, Lf(t, "elementContent") ? t.elementContent : null), ye(this, ss, Lf(t, "elementTarget") ? t.elementTarget : null), M(this, ss) === null && ye(this, ss, typeof this.options.selectorTarget == "string" ? this._element[0].querySelector(this.options.selectorTarget) : this._element[0]), typeof this.options.positionable == "boolean" && this.options.positionable && (M(this, ss).style.zIndex = typeof this.options.zIndex == "number" ? this.options.zIndex : M(this, Po) ?? 95, Ab(cc.prototype, this, "bringToTop").call(this), this.position.set(this.position.get())), Ab(cc.prototype, this, "_activateCoreListeners").call(this, [this.popOut ? (s = M(this, ss)) == null ? void 0 : s.firstChild : M(this, ss)]), this.onSvelteRemount({ element: this._element[0], elementContent: M(this, Ti), elementTarget: M(this, ss) }));
}, "#updateApplicationShell"), f(cc, "SvelteApplication");
let _s = cc;
const Kz = new Pd({ docKey: "#__trl-root-styles", version: 1 });
function h_(i, e) {
  return Xr.add(i, e), {
    /**
     * @param {ResizeObserverTarget} newTarget - An object or function to update with observed width & height changes.
     */
    update: (t) => {
      Xr.remove(i, e), e = t, Xr.add(i, e);
    },
    destroy: () => {
      Xr.remove(i, e);
    }
  };
}
f(h_, "resizeObserver");
h_.updateCache = function(i) {
  if (!(i instanceof HTMLElement))
    throw new TypeError("resizeObserverUpdate error: 'el' is not an HTMLElement.");
  const e = Tl.get(i);
  if (Array.isArray(e)) {
    const t = globalThis.getComputedStyle(i), s = ot.pixels(i.style.borderBottom) ?? ot.pixels(t.borderBottom) ?? 0, n = ot.pixels(i.style.borderLeft) ?? ot.pixels(t.borderLeft) ?? 0, l = ot.pixels(i.style.borderRight) ?? ot.pixels(t.borderRight) ?? 0, r = ot.pixels(i.style.borderTop) ?? ot.pixels(t.borderTop) ?? 0, o = ot.pixels(i.style.paddingBottom) ?? ot.pixels(t.paddingBottom) ?? 0, a = ot.pixels(i.style.paddingLeft) ?? ot.pixels(t.paddingLeft) ?? 0, c = ot.pixels(i.style.paddingRight) ?? ot.pixels(t.paddingRight) ?? 0, u = ot.pixels(i.style.paddingTop) ?? ot.pixels(t.paddingTop) ?? 0, d = n + l + a + c, p = r + s + u + o;
    for (const m of e)
      m.styles.additionalWidth = d, m.styles.additionalHeight = p, H5(m, m.contentWidth, m.contentHeight);
  }
};
const Tl = /* @__PURE__ */ new Map(), Y$ = class Y$ {
  /**
   * Add an HTMLElement and ResizeObserverTarget instance for monitoring. Create cached style attributes for the
   * given element include border & padding dimensions for offset width / height calculations.
   *
   * @param {HTMLElement}    el - The element to observe.
   *
   * @param {ResizeObserverTarget} target - A target that contains one of several mechanisms for updating resize data.
   */
  static add(e, t) {
    const s = Yz(t);
    if (s === 0)
      throw new Error("'target' does not match supported ResizeObserverManager update mechanisms.");
    const n = globalThis.getComputedStyle(e), l = ot.pixels(e.style.borderBottom) ?? ot.pixels(n.borderBottom) ?? 0, r = ot.pixels(e.style.borderLeft) ?? ot.pixels(n.borderLeft) ?? 0, o = ot.pixels(e.style.borderRight) ?? ot.pixels(n.borderRight) ?? 0, a = ot.pixels(e.style.borderTop) ?? ot.pixels(n.borderTop) ?? 0, c = ot.pixels(e.style.paddingBottom) ?? ot.pixels(n.paddingBottom) ?? 0, u = ot.pixels(e.style.paddingLeft) ?? ot.pixels(n.paddingLeft) ?? 0, d = ot.pixels(e.style.paddingRight) ?? ot.pixels(n.paddingRight) ?? 0, p = ot.pixels(e.style.paddingTop) ?? ot.pixels(n.paddingTop) ?? 0, m = {
      updateType: s,
      target: t,
      // Stores most recent contentRect.width and contentRect.height values from ResizeObserver.
      contentWidth: 0,
      contentHeight: 0,
      // Convenience data for total border & padding for offset width & height calculations.
      styles: {
        additionalWidth: r + o + u + d,
        additionalHeight: a + l + p + c
      }
    };
    Tl.has(e) ? Tl.get(e).push(m) : Tl.set(e, [m]), GO.observe(e);
  }
  /**
   * Removes all targets from monitoring when just an element is provided otherwise removes a specific target
   * from the monitoring map. If no more targets remain then the element is removed from monitoring.
   *
   * @param {HTMLElement}          el - Element to remove from monitoring.
   *
   * @param {ResizeObserverTarget} [target] - A specific target to remove from monitoring.
   */
  static remove(e, t = void 0) {
    const s = Tl.get(e);
    if (Array.isArray(s)) {
      const n = s.findIndex((l) => l.target === t);
      n >= 0 && (H5(s[n], void 0, void 0), s.splice(n, 1)), s.length === 0 && (Tl.delete(e), GO.unobserve(e));
    }
  }
};
f(Y$, "ResizeObserverManager");
let Xr = Y$;
const $s = {
  none: 0,
  attribute: 1,
  function: 2,
  resizeObserved: 3,
  setContentBounds: 4,
  setDimension: 5,
  storeObject: 6,
  storesObject: 7
}, GO = new ResizeObserver((i) => {
  for (const e of i) {
    const t = Tl.get(e == null ? void 0 : e.target);
    if (Array.isArray(t)) {
      const s = e.contentRect.width, n = e.contentRect.height;
      for (const l of t)
        H5(l, s, n);
    }
  }
});
function Yz(i) {
  if ((i == null ? void 0 : i.resizeObserved) instanceof Function)
    return $s.resizeObserved;
  if ((i == null ? void 0 : i.setDimension) instanceof Function)
    return $s.setDimension;
  if ((i == null ? void 0 : i.setContentBounds) instanceof Function)
    return $s.setContentBounds;
  const e = typeof i;
  if (e !== null && (e === "object" || e === "function")) {
    if (DO(i.resizeObserved))
      return $s.storeObject;
    const t = i == null ? void 0 : i.stores;
    if ((ke(t) || typeof t == "function") && DO(t.resizeObserved))
      return $s.storesObject;
  }
  return e !== null && e === "object" ? $s.attribute : e === "function" ? $s.function : $s.none;
}
f(Yz, "s_GET_UPDATE_TYPE");
function H5(i, e, t) {
  var o, a, c;
  const s = i.styles;
  i.contentWidth = e, i.contentHeight = t;
  const n = Number.isFinite(e) ? e + s.additionalWidth : void 0, l = Number.isFinite(t) ? t + s.additionalHeight : void 0, r = i.target;
  switch (i.updateType) {
    case $s.attribute:
      r.contentWidth = e, r.contentHeight = t, r.offsetWidth = n, r.offsetHeight = l;
      break;
    case $s.function:
      r == null || r(n, l, e, t);
      break;
    case $s.resizeObserved:
      (o = r.resizeObserved) == null || o.call(r, n, l, e, t);
      break;
    case $s.setContentBounds:
      (a = r.setContentBounds) == null || a.call(r, e, t);
      break;
    case $s.setDimension:
      (c = r.setDimension) == null || c.call(r, n, l);
      break;
    case $s.storeObject:
      r.resizeObserved.update((u) => (u.contentHeight = t, u.contentWidth = e, u.offsetHeight = l, u.offsetWidth = n, u));
      break;
    case $s.storesObject:
      r.stores.resizeObserved.update((u) => (u.contentHeight = t, u.contentWidth = e, u.offsetHeight = l, u.offsetWidth = n, u));
      break;
  }
}
f(H5, "s_UPDATE_SUBSCRIBER");
function Rs(i, e) {
  function t() {
    if (ke(e))
      for (const s of Object.keys(e))
        i.style.setProperty(`${s}`, e[s]);
  }
  return f(t, "setProperties"), t(), {
    /**
     * @param {Record<string, string>}  newProperties - Key / value object of properties to set.
     */
    update: (s) => {
      e = s, t();
    }
  };
}
f(Rs, "applyStyles");
function fa(i, { delay: e = 0, duration: t = 400, easing: s = ei } = {}) {
  const n = +getComputedStyle(i).opacity;
  return {
    delay: e,
    duration: t,
    easing: s,
    css: (l) => `opacity: ${l * n}`
  };
}
f(fa, "fade");
function Ec(i, { delay: e = 0, duration: t = 400, easing: s = Zn, axis: n = "y" } = {}) {
  const l = getComputedStyle(i), r = +l.opacity, o = n === "y" ? "height" : "width", a = parseFloat(l[o]), c = n === "y" ? ["top", "bottom"] : ["left", "right"], u = c.map(
    (y) => `${y[0].toUpperCase()}${y.slice(1)}`
  ), d = parseFloat(l[`padding${u[0]}`]), p = parseFloat(l[`padding${u[1]}`]), m = parseFloat(l[`margin${u[0]}`]), g = parseFloat(l[`margin${u[1]}`]), h = parseFloat(
    l[`border${u[0]}Width`]
  ), _ = parseFloat(
    l[`border${u[1]}Width`]
  );
  return {
    delay: e,
    duration: t,
    easing: s,
    css: (y) => `overflow: hidden;opacity: ${Math.min(y * 20, 1) * r};${o}: ${y * a}px;padding-${c[0]}: ${y * d}px;padding-${c[1]}: ${y * p}px;margin-${c[0]}: ${y * m}px;margin-${c[1]}: ${y * g}px;border-${c[0]}-width: ${y * h}px;border-${c[1]}-width: ${y * _}px;`
  };
}
f(Ec, "slide");
function Xz(i, e) {
  const t = e.easingFade || e.easing || ei, s = e.easingSlide || e.easing || ei, n = fa(i), l = Ec(i);
  return {
    delay: e.delay || 0,
    duration: e.duration || 500,
    easing: ei,
    css: (r) => {
      const o = t(r), a = s(r);
      return `${l.css(a, 1 - a)}; ${n.css(o, 1 - o)}`;
    }
  };
}
f(Xz, "slideFade");
var mm, hm;
const uc = class uc {
  /**
   * @returns {() => undefined} Default empty transition.
   */
  static get default() {
    return M(this, hm);
  }
  /**
   * @returns {{}} Default empty options.
   */
  static get options() {
    return M(this, mm);
  }
};
mm = new WeakMap(), hm = new WeakMap(), f(uc, "TJSDefaultTransition"), Y(uc, mm, {}), Y(uc, hm, /* @__PURE__ */ f(() => {
}, "#default"));
let Xt = uc;
function Jz(i) {
  let e, t, s, n, l, r, o;
  const a = (
    /*#slots*/
    i[20].default
  ), c = Pt(
    a,
    i,
    /*$$scope*/
    i[19],
    null
  );
  return {
    c() {
      e = E("div"), c && c.c(), b(e, "class", "tjs-glass-pane-background svelte-hqedxf"), z(
        e,
        "background",
        /*background*/
        i[5]
      );
    },
    m(u, d) {
      T(u, e, d), c && c.m(e, null), i[23](e), l = !0, r || (o = At(t = Rs.call(
        null,
        e,
        /*styles*/
        i[7]
      )), r = !0);
    },
    p(u, d) {
      i = u, c && c.p && (!l || d & /*$$scope*/
      524288) && Rt(
        c,
        a,
        i,
        /*$$scope*/
        i[19],
        l ? Mt(
          a,
          /*$$scope*/
          i[19],
          d,
          null
        ) : Ft(
          /*$$scope*/
          i[19]
        ),
        null
      ), t && $t(t.update) && d & /*styles*/
      128 && t.update.call(
        null,
        /*styles*/
        i[7]
      ), d & /*background*/
      32 && z(
        e,
        "background",
        /*background*/
        i[5]
      );
    },
    i(u) {
      l || (w(c, u), is(() => {
        l && (n && n.end(1), s = sb(
          e,
          /*inTransition*/
          i[1],
          /*inTransitionOptions*/
          i[3]
        ), s.start());
      }), l = !0);
    },
    o(u) {
      C(c, u), s && s.invalidate(), n = nb(
        e,
        /*outTransition*/
        i[2],
        /*outTransitionOptions*/
        i[4]
      ), l = !1;
    },
    d(u) {
      u && S(e), c && c.d(u), i[23](null), u && n && n.end(), r = !1, o();
    }
  };
}
f(Jz, "create_else_block$I");
function Zz(i) {
  let e, t, s, n, l, r, o, a, c;
  const u = (
    /*#slots*/
    i[20].default
  ), d = Pt(
    u,
    i,
    /*$$scope*/
    i[19],
    null
  );
  return {
    c() {
      e = E("div"), l = R(), r = E("div"), d && d.c(), b(e, "class", "tjs-glass-pane-background svelte-hqedxf"), z(
        e,
        "background",
        /*background*/
        i[5]
      ), b(r, "class", "tjs-glass-pane-container svelte-hqedxf");
    },
    m(p, m) {
      T(p, e, m), i[21](e), T(p, l, m), T(p, r, m), d && d.m(r, null), i[22](r), o = !0, a || (c = At(t = Rs.call(
        null,
        e,
        /*styles*/
        i[7]
      )), a = !0);
    },
    p(p, m) {
      i = p, t && $t(t.update) && m & /*styles*/
      128 && t.update.call(
        null,
        /*styles*/
        i[7]
      ), m & /*background*/
      32 && z(
        e,
        "background",
        /*background*/
        i[5]
      ), d && d.p && (!o || m & /*$$scope*/
      524288) && Rt(
        d,
        u,
        i,
        /*$$scope*/
        i[19],
        o ? Mt(
          u,
          /*$$scope*/
          i[19],
          m,
          null
        ) : Ft(
          /*$$scope*/
          i[19]
        ),
        null
      );
    },
    i(p) {
      o || (is(() => {
        o && (n && n.end(1), s = sb(
          e,
          /*inTransition*/
          i[1],
          /*inTransitionOptions*/
          i[3]
        ), s.start());
      }), w(d, p), o = !0);
    },
    o(p) {
      s && s.invalidate(), n = nb(
        e,
        /*outTransition*/
        i[2],
        /*outTransitionOptions*/
        i[4]
      ), C(d, p), o = !1;
    },
    d(p) {
      p && (S(e), S(l), S(r)), i[21](null), p && n && n.end(), d && d.d(p), i[22](null), a = !1, c();
    }
  };
}
f(Zz, "create_if_block$2v");
function Qz(i) {
  let e, t, s, n, l, r;
  const o = [Zz, Jz], a = [];
  function c(u, d) {
    return (
      /*slotSeparate*/
      u[0] ? 0 : 1
    );
  }
  return f(c, "select_block_type"), t = c(i), s = a[t] = o[t](i), {
    c() {
      e = E("div"), s.c(), b(
        e,
        "id",
        /*id*/
        i[6]
      ), b(e, "class", "tjs-glass-pane svelte-hqedxf"), z(
        e,
        "z-index",
        /*zIndex*/
        i[8]
      );
    },
    m(u, d) {
      T(u, e, d), a[t].m(e, null), i[24](e), n = !0, l || (r = [
        V(
          window,
          "contextmenu",
          /*swallow*/
          i[12],
          !0
        ),
        V(
          window,
          "dblclick",
          /*swallow*/
          i[12],
          !0
        ),
        V(
          window,
          "keydown",
          /*swallow*/
          i[12],
          !0
        ),
        V(
          window,
          "keyup",
          /*swallow*/
          i[12],
          !0
        ),
        V(
          window,
          "mousedown",
          /*swallow*/
          i[12],
          !0
        ),
        V(
          window,
          "mousemove",
          /*swallow*/
          i[12],
          !0
        ),
        V(
          window,
          "mouseup",
          /*swallow*/
          i[12],
          !0
        ),
        V(
          window,
          "pointerdown",
          /*swallow*/
          i[12],
          !0
        ),
        V(
          window,
          "pointermove",
          /*swallow*/
          i[12],
          !0
        ),
        V(
          window,
          "pointerup",
          /*swallow*/
          i[12],
          !0
        ),
        V(
          window,
          "touchend",
          /*swallow*/
          i[12],
          !0
        ),
        V(
          window,
          "touchmove",
          /*swallow*/
          i[12],
          !0
        ),
        V(
          window,
          "touchstart",
          /*swallow*/
          i[12],
          !0
        ),
        V(
          window,
          "wheel",
          /*swallow*/
          i[12],
          !0
        )
      ], l = !0);
    },
    p(u, [d]) {
      let p = t;
      t = c(u), t === p ? a[t].p(u, d) : (ce(), C(a[p], 1, 1, () => {
        a[p] = null;
      }), ue(), s = a[t], s ? s.p(u, d) : (s = a[t] = o[t](u), s.c()), w(s, 1), s.m(e, null)), (!n || d & /*id*/
      64) && b(
        e,
        "id",
        /*id*/
        u[6]
      ), d & /*zIndex*/
      256 && z(
        e,
        "z-index",
        /*zIndex*/
        u[8]
      );
    },
    i(u) {
      n || (w(s), n = !0);
    },
    o(u) {
      C(s), n = !1;
    },
    d(u) {
      u && S(e), a[t].d(), i[24](null), l = !1, Ne(r);
    }
  };
}
f(Qz, "create_fragment$4A");
function xz(i, e, t) {
  let { $$slots: s = {}, $$scope: n } = e, { background: l = "#50505080" } = e, { captureInput: r = !0 } = e, { closeOnInput: o = void 0 } = e, { id: a = void 0 } = e, { slotSeparate: c = void 0 } = e, { styles: u = void 0 } = e, { zIndex: d = Number.MAX_SAFE_INTEGER } = e;
  const p = it();
  let m, g, h, { transition: _ = void 0 } = e, { inTransition: y = void 0 } = e, { outTransition: k = void 0 } = e, { transitionOptions: v = void 0 } = e, { inTransitionOptions: O = Xt.options } = e, { outTransitionOptions: P = Xt.options } = e, D, I;
  function B(q) {
    const W = q.target;
    W !== h && W !== m && W !== g && h.contains(W) || (r && (q.preventDefault(), q.stopImmediatePropagation()), (q == null ? void 0 : q.type) === "pointerdown" && o && p("close:glasspane"));
  }
  f(B, "swallow");
  function F(q) {
    st[q ? "unshift" : "push"](() => {
      m = q, t(9, m);
    });
  }
  f(F, "div0_binding");
  function H(q) {
    st[q ? "unshift" : "push"](() => {
      g = q, t(10, g);
    });
  }
  f(H, "div1_binding");
  function G(q) {
    st[q ? "unshift" : "push"](() => {
      m = q, t(9, m);
    });
  }
  f(G, "div_binding");
  function U(q) {
    st[q ? "unshift" : "push"](() => {
      h = q, t(11, h);
    });
  }
  return f(U, "div_binding_1"), i.$$set = (q) => {
    "background" in q && t(5, l = q.background), "captureInput" in q && t(13, r = q.captureInput), "closeOnInput" in q && t(14, o = q.closeOnInput), "id" in q && t(6, a = q.id), "slotSeparate" in q && t(0, c = q.slotSeparate), "styles" in q && t(7, u = q.styles), "zIndex" in q && t(8, d = q.zIndex), "transition" in q && t(15, _ = q.transition), "inTransition" in q && t(1, y = q.inTransition), "outTransition" in q && t(2, k = q.outTransition), "transitionOptions" in q && t(16, v = q.transitionOptions), "inTransitionOptions" in q && t(3, O = q.inTransitionOptions), "outTransitionOptions" in q && t(4, P = q.outTransitionOptions), "$$scope" in q && t(19, n = q.$$scope);
  }, i.$$.update = () => {
    if (i.$$.dirty & /*slotSeparate*/
    1 && t(0, c = typeof c == "boolean" ? c : !1), i.$$.dirty & /*oldTransition, transition*/
    163840 && D !== _) {
      const q = typeof _ == "function" ? _ : void 0;
      t(1, y = q), t(2, k = q), t(17, D = q);
    }
    if (i.$$.dirty & /*oldTransitionOptions, transitionOptions*/
    327680 && I !== v) {
      const q = v !== Xt.options && ke(v) ? v : Xt.options;
      t(3, O = q), t(4, P = q), t(18, I = q);
    }
    i.$$.dirty & /*inTransition*/
    2 && typeof y != "function" && t(1, y = void 0), i.$$.dirty & /*outTransition*/
    4 && typeof k != "function" && t(2, k = void 0), i.$$.dirty & /*inTransitionOptions*/
    8 && (ke(O) || t(3, O = Xt.options)), i.$$.dirty & /*outTransitionOptions*/
    16 && (ke(P) || t(4, P = Xt.options));
  }, [
    c,
    y,
    k,
    O,
    P,
    l,
    a,
    u,
    d,
    m,
    g,
    h,
    B,
    r,
    o,
    _,
    v,
    D,
    I,
    n,
    s,
    F,
    H,
    G,
    U
  ];
}
f(xz, "instance$4r");
const X$ = class X$ extends ie {
  constructor(e) {
    super(), le(this, e, xz, Qz, ne, {
      background: 5,
      captureInput: 13,
      closeOnInput: 14,
      id: 6,
      slotSeparate: 0,
      styles: 7,
      zIndex: 8,
      transition: 15,
      inTransition: 1,
      outTransition: 2,
      transitionOptions: 16,
      inTransitionOptions: 3,
      outTransitionOptions: 4
    });
  }
};
f(X$, "TJSGlassPane");
let g_ = X$;
const eH = g_;
var No;
const J$ = class J$ {
  constructor() {
    /** @type {InternalAppStores} */
    Y(this, No, void 0);
    ye(this, No, {
      elementContent: It(void 0),
      elementRoot: It(void 0)
    }), Object.freeze(M(this, No)), Object.seal(this);
  }
  /**
   * @returns {InternalAppStores} The internal context stores for elementContent / elementRoot
   */
  get stores() {
    return M(this, No);
  }
};
No = new WeakMap(), f(J$, "AppShellContextInternal");
let b_ = J$;
function zO(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = x(
        /*label*/
        i[3]
      ), b(e, "class", "svelte-166l8wd"), Q(
        e,
        "has-icon",
        /*icon*/
        i[4] !== void 0
      );
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n & /*label*/
      8 && _e(
        t,
        /*label*/
        s[3]
      ), n & /*icon*/
      16 && Q(
        e,
        "has-icon",
        /*icon*/
        s[4] !== void 0
      );
    },
    d(s) {
      s && S(e);
    }
  };
}
f(zO, "create_if_block$2u");
function tH(i) {
  let e, t, s, n, l, r, o, a = (
    /*label*/
    i[3] && zO(i)
  );
  return {
    c() {
      e = E("a"), t = new As(!1), s = $e(), a && a.c(), t.a = s, b(e, "class", n = "header-button " + /*button*/
      i[0].class + " svelte-166l8wd"), b(
        e,
        "aria-label",
        /*label*/
        i[3]
      ), b(e, "tabindex", "0"), b(e, "role", "button"), Q(
        e,
        "keep-minimized",
        /*keepMinimized*/
        i[2]
      );
    },
    m(c, u) {
      T(c, e, u), t.m(
        /*icon*/
        i[4],
        e
      ), A(e, s), a && a.m(e, null), r || (o = [
        V(e, "click", We(tt(
          /*onClick*/
          i[5]
        ))),
        V(e, "contextmenu", We(tt(
          /*onContextMenu*/
          i[6]
        ))),
        V(
          e,
          "keydown",
          /*onKeydown*/
          i[7]
        ),
        V(
          e,
          "keyup",
          /*onKeyup*/
          i[8]
        ),
        At(l = Rs.call(
          null,
          e,
          /*styles*/
          i[1]
        ))
      ], r = !0);
    },
    p(c, [u]) {
      u & /*icon*/
      16 && t.p(
        /*icon*/
        c[4]
      ), /*label*/
      c[3] ? a ? a.p(c, u) : (a = zO(c), a.c(), a.m(e, null)) : a && (a.d(1), a = null), u & /*button*/
      1 && n !== (n = "header-button " + /*button*/
      c[0].class + " svelte-166l8wd") && b(e, "class", n), u & /*label*/
      8 && b(
        e,
        "aria-label",
        /*label*/
        c[3]
      ), l && $t(l.update) && u & /*styles*/
      2 && l.update.call(
        null,
        /*styles*/
        c[1]
      ), u & /*button, keepMinimized*/
      5 && Q(
        e,
        "keep-minimized",
        /*keepMinimized*/
        c[2]
      );
    },
    i: ee,
    o: ee,
    d(c) {
      c && S(e), a && a.d(), r = !1, Ne(o);
    }
  };
}
f(tH, "create_fragment$4z");
const sH = /^\s*<.*>$/;
function nH(i, e, t) {
  let s, n, l, r, o, a, { button: c = void 0 } = e;
  function u(g) {
    const h = (c == null ? void 0 : c.onPress) ?? (c == null ? void 0 : c.onclick);
    typeof h == "function" && (h.call(c, g), t(0, c));
  }
  f(u, "onClick");
  function d(g) {
    const h = c == null ? void 0 : c.onContextMenu;
    typeof h == "function" && (h.call(c, g), t(0, c));
  }
  f(d, "onContextMenu");
  function p(g) {
    g.code === o && (g.preventDefault(), g.stopPropagation());
  }
  f(p, "onKeydown");
  function m(g) {
    if (g.code === o) {
      const h = c.onPress ?? c.onclick;
      typeof h == "function" && (h.call(c, g), t(0, c)), g.preventDefault(), g.stopPropagation();
    }
  }
  return f(m, "onKeyup"), i.$$set = (g) => {
    "button" in g && t(0, c = g.button);
  }, i.$$.update = () => {
    i.$$.dirty & /*button*/
    1 && t(9, s = ke(c) && typeof c.title == "string" ? K(c.title) : ""), i.$$.dirty & /*button, title*/
    513 && t(4, n = ke(c) && typeof c.icon != "string" ? void 0 : sH.test(c.icon) ? c.icon : `<i class="${c.icon}" title="${s}"></i>`), i.$$.dirty & /*button*/
    1 && t(3, l = ke(c) && typeof c.label == "string" ? K(c.label) : void 0), i.$$.dirty & /*button*/
    1 && t(2, r = ke(c) && typeof c.keepMinimized == "boolean" ? c.keepMinimized : !1), i.$$.dirty & /*button*/
    1 && (o = ke(c) && typeof c.keyCode == "string" ? c.keyCode : "Enter"), i.$$.dirty & /*button*/
    1 && t(1, a = ke(c) && ke(c.styles) ? c.styles : void 0);
  }, [
    c,
    a,
    r,
    l,
    n,
    u,
    d,
    p,
    m,
    s
  ];
}
f(nH, "instance$4q");
const Z$ = class Z$ extends ie {
  constructor(e) {
    super(), le(this, e, nH, tH, ne, { button: 0 });
  }
  get button() {
    return this.$$.ctx[0];
  }
  set button(e) {
    this.$$set({ button: e }), Ke();
  }
};
f(Z$, "TJSHeaderButton");
let __ = Z$;
const iH = __;
function HO(i, e, t) {
  const s = i.slice();
  return s[31] = e[t], s;
}
f(HO, "get_each_context$1L");
function UO(i, e, t) {
  const s = i.slice();
  return s[31] = e[t], s;
}
f(UO, "get_each_context_1$o");
function VO(i) {
  let e, t;
  return {
    c() {
      e = E("img"), b(e, "class", "tjs-app-icon keep-minimized svelte-1wviwl9"), ze(e.src, t = /*$storeHeaderIcon*/
      i[6]) || b(e, "src", t), b(e, "alt", "icon");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n[0] & /*$storeHeaderIcon*/
      64 && !ze(e.src, t = /*$storeHeaderIcon*/
      s[6]) && b(e, "src", t);
    },
    d(s) {
      s && S(e);
    }
  };
}
f(VO, "create_if_block$2t");
function WO(i) {
  let e, t, s;
  const n = [
    /*button*/
    i[31].props
  ];
  var l = (
    /*button*/
    i[31].class
  );
  function r(o, a) {
    let c = {};
    for (let u = 0; u < n.length; u += 1)
      c = fs(c, n[u]);
    return a !== void 0 && a[0] & /*buttonsLeft*/
    2 && (c = fs(c, hs(n, [Es(
      /*button*/
      o[31].props
    )]))), { props: c };
  }
  return f(r, "switch_props"), l && (e = nt(l, r(i))), {
    c() {
      e && L(e.$$.fragment), t = $e();
    },
    m(o, a) {
      e && N(e, o, a), T(o, t, a), s = !0;
    },
    p(o, a) {
      if (a[0] & /*buttonsLeft*/
      2 && l !== (l = /*button*/
      o[31].class)) {
        if (e) {
          ce();
          const c = e;
          C(c.$$.fragment, 1, 0, () => {
            j(c, 1);
          }), ue();
        }
        l ? (e = nt(l, r(o, a)), L(e.$$.fragment), w(e.$$.fragment, 1), N(e, t.parentNode, t)) : e = null;
      } else if (l) {
        const c = a[0] & /*buttonsLeft*/
        2 ? hs(n, [Es(
          /*button*/
          o[31].props
        )]) : {};
        e.$set(c);
      }
    },
    i(o) {
      s || (e && w(e.$$.fragment, o), s = !0);
    },
    o(o) {
      e && C(e.$$.fragment, o), s = !1;
    },
    d(o) {
      o && S(t), e && j(e, o);
    }
  };
}
f(WO, "create_each_block_1$o");
function KO(i) {
  let e, t, s;
  const n = [
    /*button*/
    i[31].props
  ];
  var l = (
    /*button*/
    i[31].class
  );
  function r(o, a) {
    let c = {};
    for (let u = 0; u < n.length; u += 1)
      c = fs(c, n[u]);
    return a !== void 0 && a[0] & /*buttonsRight*/
    4 && (c = fs(c, hs(n, [Es(
      /*button*/
      o[31].props
    )]))), { props: c };
  }
  return f(r, "switch_props"), l && (e = nt(l, r(i))), {
    c() {
      e && L(e.$$.fragment), t = $e();
    },
    m(o, a) {
      e && N(e, o, a), T(o, t, a), s = !0;
    },
    p(o, a) {
      if (a[0] & /*buttonsRight*/
      4 && l !== (l = /*button*/
      o[31].class)) {
        if (e) {
          ce();
          const c = e;
          C(c.$$.fragment, 1, 0, () => {
            j(c, 1);
          }), ue();
        }
        l ? (e = nt(l, r(o, a)), L(e.$$.fragment), w(e.$$.fragment, 1), N(e, t.parentNode, t)) : e = null;
      } else if (l) {
        const c = a[0] & /*buttonsRight*/
        4 ? hs(n, [Es(
          /*button*/
          o[31].props
        )]) : {};
        e.$set(c);
      }
    },
    i(o) {
      s || (e && w(e.$$.fragment, o), s = !0);
    },
    o(o) {
      e && C(e.$$.fragment, o), s = !1;
    },
    d(o) {
      o && S(t), e && j(e, o);
    }
  };
}
f(KO, "create_each_block$1L");
function YO(i) {
  let e, t, s, n = K(
    /*$storeTitle*/
    i[7]
  ) + "", l, r, o, a, c, u, d, p, m, g, h = typeof /*$storeHeaderIcon*/
  i[6] == "string" && VO(i), _ = oe(
    /*buttonsLeft*/
    i[1]
  ), y = [];
  for (let D = 0; D < _.length; D += 1)
    y[D] = WO(UO(i, _, D));
  const k = /* @__PURE__ */ f((D) => C(y[D], 1, 1, () => {
    y[D] = null;
  }), "out");
  let v = oe(
    /*buttonsRight*/
    i[2]
  ), O = [];
  for (let D = 0; D < v.length; D += 1)
    O[D] = KO(HO(i, v, D));
  const P = /* @__PURE__ */ f((D) => C(O[D], 1, 1, () => {
    O[D] = null;
  }), "out_1");
  return {
    c() {
      e = E("header"), h && h.c(), t = R(), s = E("h4"), l = x(n), r = R();
      for (let D = 0; D < y.length; D += 1)
        y[D].c();
      o = R(), a = E("span"), c = R();
      for (let D = 0; D < O.length; D += 1)
        O[D].c();
      b(s, "class", "window-title svelte-1wviwl9"), z(
        s,
        "display",
        /*displayHeaderTitle*/
        i[4]
      ), b(a, "class", "tjs-window-header-spacer keep-minimized svelte-1wviwl9"), b(e, "class", "window-header flexrow svelte-1wviwl9");
    },
    m(D, I) {
      T(D, e, I), h && h.m(e, null), A(e, t), A(e, s), A(s, l), A(e, r);
      for (let B = 0; B < y.length; B += 1)
        y[B] && y[B].m(e, null);
      A(e, o), A(e, a), A(e, c);
      for (let B = 0; B < O.length; B += 1)
        O[B] && O[B].m(e, null);
      p = !0, m || (g = [
        At(u = /*draggable*/
        i[0].call(
          null,
          e,
          /*dragOptions*/
          i[3]
        )),
        At(d = /*minimizable*/
        i[18].call(
          null,
          e,
          /*$storeMinimizable*/
          i[5]
        )),
        V(
          e,
          "pointerdown",
          /*onPointerdown*/
          i[19]
        )
      ], m = !0);
    },
    p(D, I) {
      if (typeof /*$storeHeaderIcon*/
      D[6] == "string" ? h ? h.p(D, I) : (h = VO(D), h.c(), h.m(e, t)) : h && (h.d(1), h = null), (!p || I[0] & /*$storeTitle*/
      128) && n !== (n = K(
        /*$storeTitle*/
        D[7]
      ) + "") && _e(l, n), I[0] & /*displayHeaderTitle*/
      16 && z(
        s,
        "display",
        /*displayHeaderTitle*/
        D[4]
      ), I[0] & /*buttonsLeft*/
      2) {
        _ = oe(
          /*buttonsLeft*/
          D[1]
        );
        let B;
        for (B = 0; B < _.length; B += 1) {
          const F = UO(D, _, B);
          y[B] ? (y[B].p(F, I), w(y[B], 1)) : (y[B] = WO(F), y[B].c(), w(y[B], 1), y[B].m(e, o));
        }
        for (ce(), B = _.length; B < y.length; B += 1)
          k(B);
        ue();
      }
      if (I[0] & /*buttonsRight*/
      4) {
        v = oe(
          /*buttonsRight*/
          D[2]
        );
        let B;
        for (B = 0; B < v.length; B += 1) {
          const F = HO(D, v, B);
          O[B] ? (O[B].p(F, I), w(O[B], 1)) : (O[B] = KO(F), O[B].c(), w(O[B], 1), O[B].m(e, null));
        }
        for (ce(), B = v.length; B < O.length; B += 1)
          P(B);
        ue();
      }
      u && $t(u.update) && I[0] & /*dragOptions*/
      8 && u.update.call(
        null,
        /*dragOptions*/
        D[3]
      ), d && $t(d.update) && I[0] & /*$storeMinimizable*/
      32 && d.update.call(
        null,
        /*$storeMinimizable*/
        D[5]
      );
    },
    i(D) {
      if (!p) {
        for (let I = 0; I < _.length; I += 1)
          w(y[I]);
        for (let I = 0; I < v.length; I += 1)
          w(O[I]);
        p = !0;
      }
    },
    o(D) {
      y = y.filter(Boolean);
      for (let I = 0; I < y.length; I += 1)
        C(y[I]);
      O = O.filter(Boolean);
      for (let I = 0; I < O.length; I += 1)
        C(O[I]);
      p = !1;
    },
    d(D) {
      D && S(e), h && h.d(), Le(y, D), Le(O, D), m = !1, Ne(g);
    }
  };
}
f(YO, "create_key_block$5");
function lH(i) {
  let e = (
    /*draggable*/
    i[0]
  ), t, s, n = YO(i);
  return {
    c() {
      n.c(), t = $e();
    },
    m(l, r) {
      n.m(l, r), T(l, t, r), s = !0;
    },
    p(l, r) {
      r[0] & /*draggable*/
      1 && ne(e, e = /*draggable*/
      l[0]) ? (ce(), C(n, 1, 1, ee), ue(), n = YO(l), n.c(), w(n, 1), n.m(t.parentNode, t)) : n.p(l, r);
    },
    i(l) {
      s || (w(n), s = !0);
    },
    o(l) {
      C(n), s = !1;
    },
    d(l) {
      l && S(t), n.d(l);
    }
  };
}
f(lH, "create_fragment$4y");
function rH(i, e, t) {
  let s, n, l, r, o, a, c, u, d, p, { draggable: m = void 0 } = e, { draggableOptions: g = void 0 } = e;
  const { application: h } = fe("#external"), { focusAuto: _, focusKeep: y } = h.reactive.storeAppOptions;
  pe(i, _, (re) => t(26, n = re)), pe(i, y, (re) => t(25, s = re));
  const { elementRoot: k } = fe("#internal").stores;
  pe(i, k, (re) => t(27, l = re));
  const v = h.reactive.storeAppOptions.title;
  pe(i, v, (re) => t(7, p = re));
  const O = h.reactive.storeAppOptions.draggable;
  pe(i, O, (re) => t(24, c = re));
  const P = h.reactive.storeUIState.dragging, D = h.reactive.storeUIState.headerButtons;
  pe(i, D, (re) => t(21, r = re));
  const I = h.reactive.storeAppOptions.headerIcon;
  pe(i, I, (re) => t(6, d = re));
  const B = h.reactive.storeAppOptions.headerNoTitleMinimized;
  pe(i, B, (re) => t(23, a = re));
  const F = h.reactive.storeAppOptions.minimizable;
  pe(i, F, (re) => t(5, u = re));
  const H = h.reactive.storeUIState.minimized;
  pe(i, H, (re) => t(22, o = re));
  const G = Object.freeze(["tjs-app-icon", "tjs-window-header-spacer", "window-header", "window-title"]);
  let U, q, W, X;
  function te(re, ae) {
    const be = /* @__PURE__ */ f((me) => {
      (me.target.classList.contains("window-title") || me.target.classList.contains("window-header") || me.target.classList.contains("keep-minimized")) && h._onToggleMinimize(me);
    }, "callback");
    function we() {
      re.addEventListener("dblclick", be);
    }
    f(we, "activateListeners");
    function ve() {
      re.removeEventListener("dblclick", be);
    }
    return f(ve, "removeListeners"), ae && we(), {
      update: (me) => {
        me ? we() : ve();
      },
      destroy: () => ve()
    };
  }
  f(te, "minimizable");
  function J(re) {
    const ae = l;
    n && ae instanceof HTMLElement && (ae != null && ae.isConnected) && (s ? document.activeElement instanceof HTMLElement && !ae.contains(document.activeElement) ? ae.focus() : re.preventDefault() : ae.focus());
  }
  return f(J, "onPointerdown"), i.$$set = (re) => {
    "draggable" in re && t(0, m = re.draggable), "draggableOptions" in re && t(20, g = re.draggableOptions);
  }, i.$$.update = () => {
    if (i.$$.dirty[0] & /*draggable*/
    1 && t(0, m = typeof m == "function" ? m : F7), i.$$.dirty[0] & /*draggableOptions, $storeDraggable*/
    17825792 && t(3, U = Object.assign(
      {},
      {
        ease: !0,
        easeOptions: { duration: 0.08, ease: Zn }
      },
      ke(g) ? g : {},
      {
        position: h.position,
        active: c,
        storeDragging: P,
        hasTargetClassList: G
      }
    )), i.$$.dirty[0] & /*$storeHeaderNoTitleMinimized, $storeMinimized*/
    12582912 && t(4, q = a && o ? "none" : null), i.$$.dirty[0] & /*$storeHeaderButtons, buttonsLeft, buttonsRight*/
    2097158) {
      t(1, W = []), t(2, X = []);
      for (const re of r)
        (typeof (re == null ? void 0 : re.alignLeft) == "boolean" && (re != null && re.alignLeft) ? W : X).push(ti(re) ? { class: re, props: {} } : {
          class: iH,
          props: { button: re }
        });
    }
  }, [
    m,
    W,
    X,
    U,
    q,
    u,
    d,
    p,
    _,
    y,
    k,
    v,
    O,
    D,
    I,
    B,
    F,
    H,
    te,
    J,
    g,
    r,
    o,
    a,
    c
  ];
}
f(rH, "instance$4p");
const Q$ = class Q$ extends ie {
  constructor(e) {
    super(), le(this, e, rH, lH, ne, { draggable: 0, draggableOptions: 20 }, null, [-1, -1]);
  }
};
f(Q$, "TJSApplicationHeader");
let y_ = Q$;
const G7 = y_;
function oH(i) {
  let e, t, s;
  return {
    c() {
      e = E("div"), b(e, "class", "tjs-focus-wrap svelte-kjcljd"), b(e, "tabindex", "0");
    },
    m(n, l) {
      T(n, e, l), i[4](e), t || (s = V(
        e,
        "focus",
        /*onFocus*/
        i[1]
      ), t = !0);
    },
    p: ee,
    i: ee,
    o: ee,
    d(n) {
      n && S(e), i[4](null), t = !1, s();
    }
  };
}
f(oH, "create_fragment$4x");
function aH(i, e, t) {
  let { elementRoot: s = void 0 } = e, { enabled: n = !0 } = e, l, r;
  function o() {
    if (n && s instanceof HTMLElement) {
      const c = dn.getFirstFocusableElement(s, l);
      c instanceof HTMLElement && c !== r ? c.focus() : s.focus();
    }
  }
  f(o, "onFocus");
  function a(c) {
    st[c ? "unshift" : "push"](() => {
      r = c, t(0, r);
    });
  }
  return f(a, "div_binding"), i.$$set = (c) => {
    "elementRoot" in c && t(2, s = c.elementRoot), "enabled" in c && t(3, n = c.enabled);
  }, i.$$.update = () => {
    i.$$.dirty & /*wrapEl*/
    1 && r && (l = /* @__PURE__ */ new Set([r]));
  }, [r, o, s, n, a];
}
f(aH, "instance$4o");
const x$ = class x$ extends ie {
  constructor(e) {
    super(), le(this, e, aH, oH, ne, { elementRoot: 2, enabled: 3 });
  }
};
f(x$, "TJSFocusWrap");
let v_ = x$;
const U5 = v_;
function cH(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("div"), e.innerHTML = '<i class="fas fa-arrows-alt-h svelte-14lnpz8"></i>', b(e, "class", "window-resizable-handle svelte-14lnpz8");
    },
    m(l, r) {
      T(l, e, r), i[10](e), s || (n = At(t = /*resizable*/
      i[6].call(null, e, {
        active: (
          /*$storeResizable*/
          i[1]
        ),
        storeResizing: (
          /*storeResizing*/
          i[5]
        )
      })), s = !0);
    },
    p(l, [r]) {
      t && $t(t.update) && r & /*$storeResizable*/
      2 && t.update.call(null, {
        active: (
          /*$storeResizable*/
          l[1]
        ),
        storeResizing: (
          /*storeResizing*/
          l[5]
        )
      });
    },
    i: ee,
    o: ee,
    d(l) {
      l && S(e), i[10](null), s = !1, n();
    }
  };
}
f(cH, "create_fragment$4w");
function uH(i, e, t) {
  let s, n, l, { isResizable: r = !1 } = e;
  const o = fe("#external").application, a = fe("#internal").stores.elementRoot;
  pe(i, a, (h) => t(8, s = h));
  const c = o.reactive.storeAppOptions.resizable;
  pe(i, c, (h) => t(1, l = h));
  const u = o.reactive.storeUIState.minimized;
  pe(i, u, (h) => t(9, n = h));
  const d = o.reactive.storeUIState.resizing;
  let p;
  function m(h, { active: _ = !0, storeResizing: y = void 0 } = {}) {
    let k = null, v = {}, O = !1;
    const P = {
      resizeDown: ["pointerdown", (G) => B(G), !1],
      resizeMove: ["pointermove", (G) => F(G), !1],
      resizeUp: ["pointerup", (G) => H(G), !1]
    };
    function D() {
      h.addEventListener(...P.resizeDown), t(7, r = !0), h.style.display = "block";
    }
    f(D, "activateListeners");
    function I() {
      typeof (y == null ? void 0 : y.set) == "function" && y.set(!1), h.removeEventListener(...P.resizeDown), h.removeEventListener(...P.resizeMove), h.removeEventListener(...P.resizeUp), h.style.display = "none", t(7, r = !1);
    }
    f(I, "removeListeners"), _ ? D() : h.style.display = "none";
    function B(G) {
      G.preventDefault(), O = !1, k = o.position.get(), k.height === "auto" && (k.height = s.clientHeight), k.width === "auto" && (k.width = s.clientWidth), v = { x: G.clientX, y: G.clientY }, h.addEventListener(...P.resizeMove), h.addEventListener(...P.resizeUp), h.setPointerCapture(G.pointerId);
    }
    f(B, "onResizePointerDown");
    function F(G) {
      G.preventDefault(), !O && typeof (y == null ? void 0 : y.set) == "function" && (O = !0, y.set(!0)), o.position.set({
        width: k.width + (G.clientX - v.x),
        height: k.height + (G.clientY - v.y)
      });
    }
    f(F, "onResizePointerMove");
    function H(G) {
      var U;
      O = !1, typeof (y == null ? void 0 : y.set) == "function" && y.set(!1), G.preventDefault(), h.removeEventListener(...P.resizeMove), h.removeEventListener(...P.resizeUp), (U = o == null ? void 0 : o._onResize) == null || U.call(o, G);
    }
    return f(H, "onResizePointerUp"), {
      update: ({ active: G }) => {
        G ? D() : I();
      },
      destroy: () => I()
    };
  }
  f(m, "resizable");
  function g(h) {
    st[h ? "unshift" : "push"](() => {
      p = h, t(0, p), t(7, r), t(9, n), t(8, s);
    });
  }
  return f(g, "div_binding"), i.$$set = (h) => {
    "isResizable" in h && t(7, r = h.isResizable);
  }, i.$$.update = () => {
    if (i.$$.dirty & /*elementResize, isResizable, $storeMinimized, $storeElementRoot*/
    897 && p) {
      t(0, p.style.display = r && !n ? "block" : "none", p);
      const h = s;
      h && h.classList[r ? "add" : "remove"]("resizable");
    }
  }, [
    p,
    l,
    a,
    c,
    u,
    d,
    m,
    r,
    s,
    n,
    g
  ];
}
f(uH, "instance$4n");
const eA = class eA extends ie {
  constructor(e) {
    super(), le(this, e, uH, cH, ne, { isResizable: 7 });
  }
};
f(eA, "ResizableHandle");
let k_ = eA;
const z7 = k_;
function fH(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _;
  t = new G7({
    props: {
      draggable: (
        /*draggable*/
        i[6]
      ),
      draggableOptions: (
        /*draggableOptions*/
        i[7]
      )
    }
  });
  const y = (
    /*#slots*/
    i[36].default
  ), k = Pt(
    y,
    i,
    /*$$scope*/
    i[35],
    null
  );
  return o = new z7({}), c = new U5({
    props: {
      elementRoot: (
        /*elementRoot*/
        i[1]
      ),
      enabled: (
        /*focusWrapEnabled*/
        i[11]
      )
    }
  }), {
    c() {
      e = E("div"), L(t.$$.fragment), s = R(), n = E("section"), k && k.c(), r = R(), L(o.$$.fragment), a = R(), L(c.$$.fragment), b(n, "class", "window-content svelte-oz81f7"), b(n, "tabindex", "-1"), b(e, "id", u = /*application*/
      i[10].id), b(e, "class", d = "app window-app " + /*application*/
      i[10].options.classes.join(" ") + " svelte-oz81f7"), b(e, "data-appid", p = /*application*/
      i[10].appId), b(e, "role", "application"), b(e, "tabindex", "-1");
    },
    m(v, O) {
      T(v, e, O), N(t, e, null), A(e, s), A(e, n), k && k.m(n, null), i[39](n), A(e, r), N(o, e, null), A(e, a), N(c, e, null), i[40](e), g = !0, h || (_ = [
        V(
          n,
          "pointerdown",
          /*onPointerdownContent*/
          i[21]
        ),
        At(l = Rs.call(
          null,
          n,
          /*stylesContent*/
          i[9]
        )),
        At(
          /*contentResizeObserver*/
          i[13].call(
            null,
            n,
            /*resizeObservedContent*/
            i[22]
          )
        ),
        V(e, "close:popup", We(tt(
          /*onClosePopup*/
          i[18]
        ))),
        V(
          e,
          "keydown",
          /*onKeydown*/
          i[19],
          !0
        ),
        V(
          e,
          "pointerdown",
          /*onPointerdownApp*/
          i[20]
        ),
        At(m = Rs.call(
          null,
          e,
          /*stylesApp*/
          i[8]
        )),
        At(
          /*appResizeObserver*/
          i[12].call(
            null,
            e,
            /*resizeObservedApp*/
            i[23]
          )
        )
      ], h = !0);
    },
    p(v, O) {
      const P = {};
      O[0] & /*draggable*/
      64 && (P.draggable = /*draggable*/
      v[6]), O[0] & /*draggableOptions*/
      128 && (P.draggableOptions = /*draggableOptions*/
      v[7]), t.$set(P), k && k.p && (!g || O[1] & /*$$scope*/
      16) && Rt(
        k,
        y,
        v,
        /*$$scope*/
        v[35],
        g ? Mt(
          y,
          /*$$scope*/
          v[35],
          O,
          null
        ) : Ft(
          /*$$scope*/
          v[35]
        ),
        null
      ), l && $t(l.update) && O[0] & /*stylesContent*/
      512 && l.update.call(
        null,
        /*stylesContent*/
        v[9]
      );
      const D = {};
      O[0] & /*elementRoot*/
      2 && (D.elementRoot = /*elementRoot*/
      v[1]), O[0] & /*focusWrapEnabled*/
      2048 && (D.enabled = /*focusWrapEnabled*/
      v[11]), c.$set(D), (!g || O[0] & /*application*/
      1024 && u !== (u = /*application*/
      v[10].id)) && b(e, "id", u), (!g || O[0] & /*application*/
      1024 && d !== (d = "app window-app " + /*application*/
      v[10].options.classes.join(" ") + " svelte-oz81f7")) && b(e, "class", d), (!g || O[0] & /*application*/
      1024 && p !== (p = /*application*/
      v[10].appId)) && b(e, "data-appid", p), m && $t(m.update) && O[0] & /*stylesApp*/
      256 && m.update.call(
        null,
        /*stylesApp*/
        v[8]
      );
    },
    i(v) {
      g || (w(t.$$.fragment, v), w(k, v), w(o.$$.fragment, v), w(c.$$.fragment, v), g = !0);
    },
    o(v) {
      C(t.$$.fragment, v), C(k, v), C(o.$$.fragment, v), C(c.$$.fragment, v), g = !1;
    },
    d(v) {
      v && S(e), j(t), k && k.d(v), i[39](null), j(o), j(c), i[40](null), h = !1, Ne(_);
    }
  };
}
f(fH, "create_else_block$H");
function dH(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k;
  t = new G7({
    props: {
      draggable: (
        /*draggable*/
        i[6]
      ),
      draggableOptions: (
        /*draggableOptions*/
        i[7]
      )
    }
  });
  const v = (
    /*#slots*/
    i[36].default
  ), O = Pt(
    v,
    i,
    /*$$scope*/
    i[35],
    null
  );
  return o = new z7({}), c = new U5({
    props: { elementRoot: (
      /*elementRoot*/
      i[1]
    ) }
  }), {
    c() {
      e = E("div"), L(t.$$.fragment), s = R(), n = E("section"), O && O.c(), r = R(), L(o.$$.fragment), a = R(), L(c.$$.fragment), b(n, "class", "window-content svelte-oz81f7"), b(n, "tabindex", "-1"), b(e, "id", u = /*application*/
      i[10].id), b(e, "class", d = "app window-app " + /*application*/
      i[10].options.classes.join(" ") + " svelte-oz81f7"), b(e, "data-appid", p = /*application*/
      i[10].appId), b(e, "role", "application"), b(e, "tabindex", "-1");
    },
    m(P, D) {
      T(P, e, D), N(t, e, null), A(e, s), A(e, n), O && O.m(n, null), i[37](n), A(e, r), N(o, e, null), A(e, a), N(c, e, null), i[38](e), _ = !0, y || (k = [
        V(
          n,
          "pointerdown",
          /*onPointerdownContent*/
          i[21]
        ),
        At(l = Rs.call(
          null,
          n,
          /*stylesContent*/
          i[9]
        )),
        At(
          /*contentResizeObserver*/
          i[13].call(
            null,
            n,
            /*resizeObservedContent*/
            i[22]
          )
        ),
        V(e, "close:popup", We(tt(
          /*onClosePopup*/
          i[18]
        ))),
        V(
          e,
          "keydown",
          /*onKeydown*/
          i[19],
          !0
        ),
        V(
          e,
          "pointerdown",
          /*onPointerdownApp*/
          i[20]
        ),
        At(m = Rs.call(
          null,
          e,
          /*stylesApp*/
          i[8]
        )),
        At(
          /*appResizeObserver*/
          i[12].call(
            null,
            e,
            /*resizeObservedApp*/
            i[23]
          )
        )
      ], y = !0);
    },
    p(P, D) {
      i = P;
      const I = {};
      D[0] & /*draggable*/
      64 && (I.draggable = /*draggable*/
      i[6]), D[0] & /*draggableOptions*/
      128 && (I.draggableOptions = /*draggableOptions*/
      i[7]), t.$set(I), O && O.p && (!_ || D[1] & /*$$scope*/
      16) && Rt(
        O,
        v,
        i,
        /*$$scope*/
        i[35],
        _ ? Mt(
          v,
          /*$$scope*/
          i[35],
          D,
          null
        ) : Ft(
          /*$$scope*/
          i[35]
        ),
        null
      ), l && $t(l.update) && D[0] & /*stylesContent*/
      512 && l.update.call(
        null,
        /*stylesContent*/
        i[9]
      );
      const B = {};
      D[0] & /*elementRoot*/
      2 && (B.elementRoot = /*elementRoot*/
      i[1]), c.$set(B), (!_ || D[0] & /*application*/
      1024 && u !== (u = /*application*/
      i[10].id)) && b(e, "id", u), (!_ || D[0] & /*application*/
      1024 && d !== (d = "app window-app " + /*application*/
      i[10].options.classes.join(" ") + " svelte-oz81f7")) && b(e, "class", d), (!_ || D[0] & /*application*/
      1024 && p !== (p = /*application*/
      i[10].appId)) && b(e, "data-appid", p), m && $t(m.update) && D[0] & /*stylesApp*/
      256 && m.update.call(
        null,
        /*stylesApp*/
        i[8]
      );
    },
    i(P) {
      _ || (w(t.$$.fragment, P), w(O, P), w(o.$$.fragment, P), w(c.$$.fragment, P), is(() => {
        _ && (h && h.end(1), g = sb(
          e,
          /*inTransition*/
          i[2],
          /*inTransitionOptions*/
          i[4]
        ), g.start());
      }), _ = !0);
    },
    o(P) {
      C(t.$$.fragment, P), C(O, P), C(o.$$.fragment, P), C(c.$$.fragment, P), g && g.invalidate(), h = nb(
        e,
        /*outTransition*/
        i[3],
        /*outTransitionOptions*/
        i[5]
      ), _ = !1;
    },
    d(P) {
      P && S(e), j(t), O && O.d(P), i[37](null), j(o), j(c), i[38](null), P && h && h.end(), y = !1, Ne(k);
    }
  };
}
f(dH, "create_if_block$2s");
function pH(i) {
  let e, t, s, n;
  const l = [dH, fH], r = [];
  function o(a, c) {
    return (
      /*inTransition*/
      a[2] !== Xt.default || /*outTransition*/
      a[3] !== Xt.default ? 0 : 1
    );
  }
  return f(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let u = e;
      e = o(a), e === u ? r[e].p(a, c) : (ce(), C(r[u], 1, 1, () => {
        r[u] = null;
      }), ue(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), r[e].d(a);
    }
  };
}
f(pH, "create_fragment$4v");
function mH(i, e, t) {
  let s, n, l, r, { $$slots: o = {}, $$scope: a } = e, { elementContent: c = void 0 } = e, { elementRoot: u = void 0 } = e, { draggable: d = void 0 } = e, { draggableOptions: p = void 0 } = e, { stylesApp: m = void 0 } = e, { stylesContent: g = void 0 } = e, { appOffsetHeight: h = !1 } = e, { appOffsetWidth: _ = !1 } = e;
  const y = h || _ ? h_ : () => null;
  let { contentOffsetHeight: k = !1 } = e, { contentOffsetWidth: v = !1 } = e;
  const O = k || v ? h_ : () => null, P = new b_(), D = { ignoreClasses: ["tjs-focus-wrap"] };
  et("#internal", P);
  const { application: I } = fe("#external"), { focusAuto: B, focusKeep: F, focusTrap: H } = I.reactive.storeAppOptions;
  pe(i, B, (Te) => t(32, n = Te)), pe(i, F, (Te) => t(41, s = Te)), pe(i, H, (Te) => t(34, r = Te));
  const { minimized: G } = I.reactive.storeUIState;
  pe(i, G, (Te) => t(33, l = Te));
  let U, { transition: q = Xt.default } = e, { inTransition: W = Xt.default } = e, { outTransition: X = Xt.default } = e, { transitionOptions: te = void 0 } = e, { inTransitionOptions: J = Xt.options } = e, { outTransitionOptions: re = Xt.options } = e, ae = Xt.default, be;
  Sr(() => u.focus());
  function we(Te) {
    var Ce;
    if (!n)
      return;
    const Ee = (Ce = Te == null ? void 0 : Te.detail) == null ? void 0 : Ce.target;
    if (!(Ee instanceof HTMLElement) || dn.isFocusable(Ee))
      return;
    const Be = u.contains(Ee);
    Ee === u ? u.focus() : Ee === c ? c.focus() : Be && (c.contains(Ee) ? c.focus() : u.focus());
  }
  f(we, "onClosePopup");
  function ve(Te) {
    var Ee, Be, Ce, Re, Oe, Je;
    if ((Te.target === u || Te.target === c) && KeyboardManager && ((Ce = (Be = KeyboardManager == null ? void 0 : KeyboardManager._getMatchingActions) == null ? void 0 : Be.call(KeyboardManager, (Ee = KeyboardManager == null ? void 0 : KeyboardManager.getKeyboardEventContext) == null ? void 0 : Ee.call(KeyboardManager, Te))) != null && Ce.length)) {
      (Re = Te.target) == null || Re.blur();
      return;
    }
    if (U && Te.shiftKey && Te.code === "Tab") {
      const Xe = dn.getFocusableElements(u, D), Gt = Xe.length > 0 ? Xe[0] : void 0, zt = Xe.length > 0 ? Xe[Xe.length - 1] : void 0;
      (u === document.activeElement || Gt === document.activeElement) && (zt instanceof HTMLElement && Gt !== zt && zt.focus(), Te.preventDefault(), Te.stopPropagation());
    }
    typeof ((Oe = I == null ? void 0 : I.options) == null ? void 0 : Oe.popOut) == "boolean" && I.options.popOut && I !== ((Je = globalThis.ui) == null ? void 0 : Je.activeWindow) && I.bringToTop.call(I);
  }
  f(ve, "onKeydown");
  function me() {
    var Te, Ee;
    typeof ((Te = I == null ? void 0 : I.options) == null ? void 0 : Te.popOut) == "boolean" && I.options.popOut && I !== ((Ee = globalThis.ui) == null ? void 0 : Ee.activeWindow) && I.bringToTop.call(I);
  }
  f(me, "onPointerdownApp");
  function he(Te) {
    !dn.isFocusable(Te.target) && n && (s ? document.activeElement instanceof HTMLElement && !u.contains(document.activeElement) ? c.focus() : Te.preventDefault() : c.focus());
  }
  f(he, "onPointerdownContent");
  function Ae(Te, Ee) {
    t(27, v = Te), t(26, k = Ee);
  }
  f(Ae, "resizeObservedContent");
  function Fe(Te, Ee, Be, Ce) {
    I.position.stores.resizeObserved.update((Re) => (Re.contentWidth = Be, Re.contentHeight = Ce, Re.offsetWidth = Te, Re.offsetHeight = Ee, Re)), t(24, h = Ee), t(25, _ = Te);
  }
  f(Fe, "resizeObservedApp");
  function Ve(Te) {
    st[Te ? "unshift" : "push"](() => {
      c = Te, t(0, c);
    });
  }
  f(Ve, "section_binding");
  function je(Te) {
    st[Te ? "unshift" : "push"](() => {
      u = Te, t(1, u);
    });
  }
  f(je, "div_binding");
  function Pe(Te) {
    st[Te ? "unshift" : "push"](() => {
      c = Te, t(0, c);
    });
  }
  f(Pe, "section_binding_1");
  function rt(Te) {
    st[Te ? "unshift" : "push"](() => {
      u = Te, t(1, u);
    });
  }
  return f(rt, "div_binding_1"), i.$$set = (Te) => {
    "elementContent" in Te && t(0, c = Te.elementContent), "elementRoot" in Te && t(1, u = Te.elementRoot), "draggable" in Te && t(6, d = Te.draggable), "draggableOptions" in Te && t(7, p = Te.draggableOptions), "stylesApp" in Te && t(8, m = Te.stylesApp), "stylesContent" in Te && t(9, g = Te.stylesContent), "appOffsetHeight" in Te && t(24, h = Te.appOffsetHeight), "appOffsetWidth" in Te && t(25, _ = Te.appOffsetWidth), "contentOffsetHeight" in Te && t(26, k = Te.contentOffsetHeight), "contentOffsetWidth" in Te && t(27, v = Te.contentOffsetWidth), "transition" in Te && t(28, q = Te.transition), "inTransition" in Te && t(2, W = Te.inTransition), "outTransition" in Te && t(3, X = Te.outTransition), "transitionOptions" in Te && t(29, te = Te.transitionOptions), "inTransitionOptions" in Te && t(4, J = Te.inTransitionOptions), "outTransitionOptions" in Te && t(5, re = Te.outTransitionOptions), "$$scope" in Te && t(35, a = Te.$$scope);
  }, i.$$.update = () => {
    var Te;
    if (i.$$.dirty[0] & /*elementContent*/
    1 && c != null && fe("#internal").stores.elementContent.set(c), i.$$.dirty[0] & /*elementRoot*/
    2 && u != null && fe("#internal").stores.elementRoot.set(u), i.$$.dirty[1] & /*$focusAuto, $focusTrap, $minimized*/
    14 && t(11, U = n && r && !l), i.$$.dirty[0] & /*oldTransition, transition*/
    1342177280 && ae !== q) {
      const Ee = typeof q == "function" ? q : Xt.default;
      t(2, W = Ee), t(3, X = Ee), t(30, ae = Ee);
    }
    if (i.$$.dirty[0] & /*transitionOptions*/
    536870912 | i.$$.dirty[1] & /*oldTransitionOptions*/
    1 && be !== te) {
      const Ee = te !== Xt.options && ke(te) ? te : Xt.options;
      t(4, J = Ee), t(5, re = Ee), t(31, be = Ee);
    }
    if (i.$$.dirty[0] & /*inTransition*/
    4 && typeof W != "function" && t(2, W = Xt.default), i.$$.dirty[0] & /*outTransition, application*/
    1032) {
      typeof X != "function" && t(3, X = Xt.default);
      const Ee = (Te = I == null ? void 0 : I.options) == null ? void 0 : Te.defaultCloseAnimation;
      typeof Ee == "boolean" && Ee && X !== Xt.default && t(10, I.options.defaultCloseAnimation = !1, I);
    }
    i.$$.dirty[0] & /*inTransitionOptions*/
    16 && (ke(J) || t(4, J = Xt.options)), i.$$.dirty[0] & /*outTransitionOptions*/
    32 && (ke(re) || t(5, re = Xt.options));
  }, [
    c,
    u,
    W,
    X,
    J,
    re,
    d,
    p,
    m,
    g,
    I,
    U,
    y,
    O,
    B,
    F,
    H,
    G,
    we,
    ve,
    me,
    he,
    Ae,
    Fe,
    h,
    _,
    k,
    v,
    q,
    te,
    ae,
    be,
    n,
    l,
    r,
    a,
    o,
    Ve,
    je,
    Pe,
    rt
  ];
}
f(mH, "instance$4m");
const tA = class tA extends ie {
  constructor(e) {
    super(), le(
      this,
      e,
      mH,
      pH,
      ne,
      {
        elementContent: 0,
        elementRoot: 1,
        draggable: 6,
        draggableOptions: 7,
        stylesApp: 8,
        stylesContent: 9,
        appOffsetHeight: 24,
        appOffsetWidth: 25,
        contentOffsetHeight: 26,
        contentOffsetWidth: 27,
        transition: 28,
        inTransition: 2,
        outTransition: 3,
        transitionOptions: 29,
        inTransitionOptions: 4,
        outTransitionOptions: 5
      },
      null,
      [-1, -1]
    );
  }
  get elementContent() {
    return this.$$.ctx[0];
  }
  set elementContent(e) {
    this.$$set({ elementContent: e }), Ke();
  }
  get elementRoot() {
    return this.$$.ctx[1];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Ke();
  }
  get draggable() {
    return this.$$.ctx[6];
  }
  set draggable(e) {
    this.$$set({ draggable: e }), Ke();
  }
  get draggableOptions() {
    return this.$$.ctx[7];
  }
  set draggableOptions(e) {
    this.$$set({ draggableOptions: e }), Ke();
  }
  get stylesApp() {
    return this.$$.ctx[8];
  }
  set stylesApp(e) {
    this.$$set({ stylesApp: e }), Ke();
  }
  get stylesContent() {
    return this.$$.ctx[9];
  }
  set stylesContent(e) {
    this.$$set({ stylesContent: e }), Ke();
  }
  get appOffsetHeight() {
    return this.$$.ctx[24];
  }
  set appOffsetHeight(e) {
    this.$$set({ appOffsetHeight: e }), Ke();
  }
  get appOffsetWidth() {
    return this.$$.ctx[25];
  }
  set appOffsetWidth(e) {
    this.$$set({ appOffsetWidth: e }), Ke();
  }
  get contentOffsetHeight() {
    return this.$$.ctx[26];
  }
  set contentOffsetHeight(e) {
    this.$$set({ contentOffsetHeight: e }), Ke();
  }
  get contentOffsetWidth() {
    return this.$$.ctx[27];
  }
  set contentOffsetWidth(e) {
    this.$$set({ contentOffsetWidth: e }), Ke();
  }
  get transition() {
    return this.$$.ctx[28];
  }
  set transition(e) {
    this.$$set({ transition: e }), Ke();
  }
  get inTransition() {
    return this.$$.ctx[2];
  }
  set inTransition(e) {
    this.$$set({ inTransition: e }), Ke();
  }
  get outTransition() {
    return this.$$.ctx[3];
  }
  set outTransition(e) {
    this.$$set({ outTransition: e }), Ke();
  }
  get transitionOptions() {
    return this.$$.ctx[29];
  }
  set transitionOptions(e) {
    this.$$set({ transitionOptions: e }), Ke();
  }
  get inTransitionOptions() {
    return this.$$.ctx[4];
  }
  set inTransitionOptions(e) {
    this.$$set({ inTransitionOptions: e }), Ke();
  }
  get outTransitionOptions() {
    return this.$$.ctx[5];
  }
  set outTransitionOptions(e) {
    this.$$set({ outTransitionOptions: e }), Ke();
  }
};
f(tA, "ApplicationShell");
let w_ = tA;
const Ss = w_;
function XO(i, e, t) {
  const s = i.slice();
  return s[26] = e[t], s;
}
f(XO, "get_each_context$1K");
function hH(i) {
  let e, t, s;
  const n = [
    /*dialogProps*/
    i[7]
  ];
  var l = (
    /*dialogClass*/
    i[6]
  );
  function r(o, a) {
    let c = {};
    for (let u = 0; u < n.length; u += 1)
      c = fs(c, n[u]);
    return a !== void 0 && a & /*dialogProps*/
    128 && (c = fs(c, hs(n, [Es(
      /*dialogProps*/
      o[7]
    )]))), { props: c };
  }
  return f(r, "switch_props"), l && (e = nt(l, r(i)), i[16](e)), {
    c() {
      e && L(e.$$.fragment), t = $e();
    },
    m(o, a) {
      e && N(e, o, a), T(o, t, a), s = !0;
    },
    p(o, a) {
      if (a & /*dialogClass*/
      64 && l !== (l = /*dialogClass*/
      o[6])) {
        if (e) {
          ce();
          const c = e;
          C(c.$$.fragment, 1, 0, () => {
            j(c, 1);
          }), ue();
        }
        l ? (e = nt(l, r(o, a)), o[16](e), L(e.$$.fragment), w(e.$$.fragment, 1), N(e, t.parentNode, t)) : e = null;
      } else if (l) {
        const c = a & /*dialogProps*/
        128 ? hs(n, [Es(
          /*dialogProps*/
          o[7]
        )]) : {};
        e.$set(c);
      }
    },
    i(o) {
      s || (e && w(e.$$.fragment, o), s = !0);
    },
    o(o) {
      e && C(e.$$.fragment, o), s = !1;
    },
    d(o) {
      o && S(t), i[16](null), e && j(e, o);
    }
  };
}
f(hH, "create_if_block_3$D");
function gH(i) {
  let e, t;
  return {
    c() {
      e = new As(!1), t = $e(), e.a = t;
    },
    m(s, n) {
      e.m(
        /*content*/
        i[3],
        s,
        n
      ), T(s, t, n);
    },
    p(s, n) {
      n & /*content*/
      8 && e.p(
        /*content*/
        s[3]
      );
    },
    i: ee,
    o: ee,
    d(s) {
      s && (S(t), e.d());
    }
  };
}
f(gH, "create_if_block_2$_");
function JO(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n = oe(
    /*buttons*/
    i[1]
  );
  const l = /* @__PURE__ */ f((r) => (
    /*button*/
    r[26].id
  ), "get_key");
  for (let r = 0; r < n.length; r += 1) {
    let o = XO(i, n, r), a = l(o);
    s.set(a, t[r] = QO(a, o));
  }
  return {
    c() {
      e = E("div");
      for (let r = 0; r < t.length; r += 1)
        t[r].c();
      b(e, "class", "dialog-buttons tjs-dialog-buttons svelte-1ez4adq");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < t.length; a += 1)
        t[a] && t[a].m(e, null);
      i[20](e);
    },
    p(r, o) {
      o & /*buttons, onClick, currentButtonId*/
      530 && (n = oe(
        /*buttons*/
        r[1]
      ), t = kt(t, o, l, 1, r, n, s, e, vs, QO, null, XO));
    },
    d(r) {
      r && S(e);
      for (let o = 0; o < t.length; o += 1)
        t[o].d();
      i[20](null);
    }
  };
}
f(JO, "create_if_block$2r");
function ZO(i) {
  let e, t = (
    /*button*/
    i[26].icon + ""
  ), s;
  return {
    c() {
      e = new As(!1), s = $e(), e.a = s;
    },
    m(n, l) {
      e.m(t, n, l), T(n, s, l);
    },
    p(n, l) {
      l & /*buttons*/
      2 && t !== (t = /*button*/
      n[26].icon + "") && e.p(t);
    },
    d(n) {
      n && (S(s), e.d());
    }
  };
}
f(ZO, "create_if_block_1$1z");
function QO(i, e) {
  let t, s, n = (
    /*button*/
    e[26].label + ""
  ), l, r, o, a, c, u, d, p, m = (
    /*button*/
    e[26].icon && ZO(e)
  );
  function g() {
    return (
      /*click_handler*/
      e[18](
        /*button*/
        e[26]
      )
    );
  }
  f(g, "click_handler");
  function h() {
    return (
      /*focus_handler*/
      e[19](
        /*button*/
        e[26]
      )
    );
  }
  return f(h, "focus_handler"), {
    key: i,
    first: null,
    c() {
      t = E("button"), s = E("span"), m && m.c(), l = x(n), o = R(), b(s, "title", r = /*button*/
      e[26].title), b(t, "class", a = "dialog-button tjs-dialog-button " + /*button*/
      e[26].id + " svelte-1ez4adq"), t.disabled = c = /*button*/
      e[26].disabled, this.first = t;
    },
    m(_, y) {
      T(_, t, y), A(t, s), m && m.m(s, null), A(s, l), A(t, o), d || (p = [
        V(t, "click", We(tt(g))),
        V(t, "focus", h),
        At(u = Rs.call(
          null,
          t,
          /*button*/
          e[26].styles
        ))
      ], d = !0);
    },
    p(_, y) {
      e = _, /*button*/
      e[26].icon ? m ? m.p(e, y) : (m = ZO(e), m.c(), m.m(s, l)) : m && (m.d(1), m = null), y & /*buttons*/
      2 && n !== (n = /*button*/
      e[26].label + "") && _e(l, n), y & /*buttons*/
      2 && r !== (r = /*button*/
      e[26].title) && b(s, "title", r), y & /*buttons*/
      2 && a !== (a = "dialog-button tjs-dialog-button " + /*button*/
      e[26].id + " svelte-1ez4adq") && b(t, "class", a), y & /*buttons*/
      2 && c !== (c = /*button*/
      e[26].disabled) && (t.disabled = c), u && $t(u.update) && y & /*buttons*/
      2 && u.update.call(
        null,
        /*button*/
        e[26].styles
      );
    },
    d(_) {
      _ && S(t), m && m.d(), d = !1, Ne(p);
    }
  };
}
f(QO, "create_each_block$1K");
function bH(i) {
  let e, t, s, n, l, r;
  const o = [gH, hH], a = [];
  function c(d, p) {
    return typeof /*content*/
    d[3] == "string" ? 0 : (
      /*dialogClass*/
      d[6] ? 1 : -1
    );
  }
  f(c, "select_block_type"), ~(s = c(i)) && (n = a[s] = o[s](i));
  let u = (
    /*buttons*/
    i[1].length && JO(i)
  );
  return {
    c() {
      e = E("main"), t = E("div"), n && n.c(), l = R(), u && u.c(), b(t, "class", "dialog-content");
    },
    m(d, p) {
      T(d, e, p), A(e, t), ~s && a[s].m(t, null), i[17](t), A(e, l), u && u.m(e, null), r = !0;
    },
    p(d, [p]) {
      let m = s;
      s = c(d), s === m ? ~s && a[s].p(d, p) : (n && (ce(), C(a[m], 1, 1, () => {
        a[m] = null;
      }), ue()), ~s ? (n = a[s], n ? n.p(d, p) : (n = a[s] = o[s](d), n.c()), w(n, 1), n.m(t, null)) : n = null), /*buttons*/
      d[1].length ? u ? u.p(d, p) : (u = JO(d), u.c(), u.m(e, null)) : u && (u.d(1), u = null);
    },
    i(d) {
      r || (w(n), r = !0);
    },
    o(d) {
      C(n), r = !1;
    },
    d(d) {
      d && S(e), ~s && a[s].d(), i[17](null), u && u.d();
    }
  };
}
f(bH, "create_fragment$4u");
const _H = /^\s*<.*>$/;
function yH(i, e, t) {
  let s, n, l, r, { data: o = void 0 } = e, { preventDefault: a = !1 } = e, { stopPropagation: c = !1 } = e, { dialogComponent: u = void 0 } = e, d, p, m, g, h, _ = {}, { elementRoot: y } = fe("#internal").stores;
  pe(i, y, (q) => t(15, r = q));
  let { application: k } = fe("#external"), v = fe("#managedPromise"), O = o.default;
  Nt(() => {
    const q = r;
    q instanceof HTMLElement && (q.removeEventListener("keydown", D), q.removeEventListener("keyup", I));
  }), Sr(() => {
    if (n) {
      const q = dn.getFirstFocusableElement(p);
      q instanceof HTMLElement && setTimeout(() => q.focus(), 0);
    }
  });
  function P(q) {
    try {
      let W;
      const X = q == null ? void 0 : q.onPress;
      switch (typeof X) {
        case "function":
          W = X(k);
          break;
        case "string":
          u !== void 0 && typeof u[X] == "function" ? W = u[X](k) : u === void 0 ? console.warn("[TRL] TJSDialog warning: 'onPress' defined as a string with no associated content Svelte component.") : typeof (u == null ? void 0 : u[X]) != "function" && console.warn(`[TRL] TJSDialog warning: The content Svelte component does not contain an associated function '${X}'. Did you remember to add '<svelte:options accessors={true} />' and export the function?`);
          break;
      }
      q.autoClose && s && (l && W === void 0 && (W = q.id), v.resolve(W));
    } catch (W) {
      if ((typeof o.notifyError == "boolean" ? o.notifyError : !0) && globalThis.ui.notifications.error(W, { console: !1 }), !v.reject(W))
        throw W;
    } finally {
      q.autoClose && s && k.close();
    }
  }
  f(P, "onClick");
  function D(q) {
    switch (q.code) {
      case "ArrowLeft":
      case "ArrowRight":
      case "Enter":
        q.stopPropagation();
        break;
      case "Tab":
        q.stopPropagation(), setTimeout(
          () => {
            const W = document.activeElement;
            if (W instanceof HTMLElement && m instanceof HTMLElement && m.contains(W))
              for (let X = 0; X < W.classList.length; X++) {
                const te = W.classList.item(X);
                if (te !== "dialog-button" && te !== "default" && typeof o.buttons[te] !== void 0) {
                  t(4, O = te);
                  break;
                }
              }
          },
          0
        );
        break;
      default:
        a && q.preventDefault(), c && q.stopPropagation();
        break;
    }
  }
  f(D, "onKeydown");
  function I(q) {
    switch (q.code) {
      case "ArrowLeft": {
        q.preventDefault(), q.stopPropagation();
        const W = document.activeElement;
        if (m instanceof HTMLElement) {
          if (W instanceof HTMLElement && m.contains(W)) {
            const te = d.findIndex((J) => J.id === O);
            d.length && te > 0 && t(4, O = d[te - 1].id);
          }
          const X = m.querySelector(`.${O}`);
          X instanceof HTMLElement && X.focus();
        }
        break;
      }
      case "ArrowRight": {
        q.preventDefault(), q.stopPropagation();
        const W = document.activeElement;
        if (m instanceof HTMLElement) {
          if (W instanceof HTMLElement && (m.contains(W) || O === void 0)) {
            const te = d.findIndex((J) => J.id === O);
            d.length && te < d.length - 1 && t(4, O = d[te + 1].id);
          }
          const X = m.querySelector(`.${O}`);
          X instanceof HTMLElement && X.focus();
        }
        break;
      }
      case "Enter":
        q.preventDefault(), q.stopPropagation();
        break;
      default:
        a && q.preventDefault(), c && q.stopPropagation();
        break;
    }
  }
  f(I, "onKeyup");
  function B(q) {
    st[q ? "unshift" : "push"](() => {
      u = q, t(0, u);
    });
  }
  f(B, "switch_instance_binding");
  function F(q) {
    st[q ? "unshift" : "push"](() => {
      p = q, t(5, p);
    });
  }
  f(F, "div_binding");
  const H = /* @__PURE__ */ f((q) => P(q), "click_handler"), G = /* @__PURE__ */ f((q) => t(4, O = q.id), "focus_handler");
  function U(q) {
    st[q ? "unshift" : "push"](() => {
      m = q, t(2, m);
    });
  }
  return f(U, "div_binding_1"), i.$$set = (q) => {
    "data" in q && t(10, o = q.data), "preventDefault" in q && t(11, a = q.preventDefault), "stopPropagation" in q && t(12, c = q.stopPropagation), "dialogComponent" in q && t(0, u = q.dialogComponent);
  }, i.$$.update = () => {
    var q, W;
    if (i.$$.dirty & /*$elementRoot*/
    32768 && r) {
      const X = r;
      X instanceof HTMLElement && (X.addEventListener("keydown", D), X.addEventListener("keyup", I));
    }
    if (i.$$.dirty & /*data*/
    1024 && t(13, s = typeof o.autoClose == "boolean" ? o.autoClose : !0), i.$$.dirty & /*data*/
    1024 && t(14, n = typeof o.focusFirst == "boolean" ? o.focusFirst : !1), i.$$.dirty & /*data*/
    1024 && t(1, d = ke(o.buttons) ? Object.keys(o.buttons).reduce(
      (X, te) => {
        const J = o.buttons[te], re = typeof J.icon != "string" ? void 0 : _H.test(J.icon) ? J.icon : `<i class="${J.icon}"></i>`, ae = typeof J.autoClose == "boolean" ? J.autoClose : !0, be = typeof J.disabled == "boolean" ? J.disabled : !1, we = typeof J.label == "string" ? `${re !== void 0 ? " " : ""}${K(J.label)}` : "", ve = typeof J.title == "string" ? K(J.title) : void 0;
        return (typeof J.condition == "function" ? J.condition.call(J) : J.condition ?? !0) && X.push({
          ...J,
          id: te,
          autoClose: ae,
          icon: re,
          label: we,
          title: ve,
          disabled: be
        }), X;
      },
      []
    ) : []), i.$$.dirty & /*buttons, currentButtonId*/
    18 && (d.find((X) => X.id === O) || t(4, O = void 0)), i.$$.dirty & /*focusFirst, buttonsEl, currentButtonId*/
    16404 && !n && m instanceof HTMLElement) {
      const X = m.querySelector(`.${O}`);
      X instanceof HTMLElement && X.focus();
    }
    if (i.$$.dirty & /*data*/
    1024 && (l = typeof o.resolveId == "boolean" ? o.resolveId : !1), i.$$.dirty & /*content, data*/
    1032 && g !== o.content) {
      t(
        3,
        g = o.content
      );
      try {
        if (ti(g))
          t(6, h = g), t(7, _ = {});
        else if (ke(g)) {
          const X = C7(g, k);
          t(6, h = X.class), t(7, _ = X.props ?? {});
          const te = (W = (q = X == null ? void 0 : X.context) == null ? void 0 : q.get("external")) == null ? void 0 : W.children;
          Array.isArray(te) && t(7, _.children = te, _);
        } else
          t(6, h = void 0), t(7, _ = {});
      } catch (X) {
        t(6, h = void 0), t(7, _ = {}), t(3, g = X.message), console.error(X);
      }
    }
  }, [
    u,
    d,
    m,
    g,
    O,
    p,
    h,
    _,
    y,
    P,
    o,
    a,
    c,
    s,
    n,
    r,
    B,
    F,
    H,
    G,
    U
  ];
}
f(yH, "instance$4l");
const sA = class sA extends ie {
  constructor(e) {
    super(), le(this, e, yH, bH, ne, {
      data: 10,
      preventDefault: 11,
      stopPropagation: 12,
      dialogComponent: 0
    });
  }
};
f(sA, "DialogContent");
let $_ = sA;
const H7 = $_;
function vH(i) {
  let e, t, s, n;
  const l = [
    /*appProps*/
    i[6],
    { appOffsetHeight: !0 }
  ];
  function r(c) {
    i[15](c);
  }
  f(r, "applicationshell_elementRoot_binding_1");
  function o(c) {
    i[16](c);
  }
  f(o, "applicationshell_elementContent_binding_1");
  let a = {
    $$slots: { default: [wH] },
    $$scope: { ctx: i }
  };
  for (let c = 0; c < l.length; c += 1)
    a = fs(a, l[c]);
  return (
    /*elementRoot*/
    i[0] !== void 0 && (a.elementRoot = /*elementRoot*/
    i[0]), /*elementContent*/
    i[1] !== void 0 && (a.elementContent = /*elementContent*/
    i[1]), e = new Ss({ props: a }), st.push(() => mt(e, "elementRoot", r)), st.push(() => mt(e, "elementContent", o)), {
      c() {
        L(e.$$.fragment);
      },
      m(c, u) {
        N(e, c, u), n = !0;
      },
      p(c, u) {
        const d = u & /*appProps*/
        64 ? hs(l, [
          Es(
            /*appProps*/
            c[6]
          ),
          l[1]
        ]) : {};
        u & /*$$scope, data, dialogComponent*/
        4194316 && (d.$$scope = { dirty: u, ctx: c }), !t && u & /*elementRoot*/
        1 && (t = !0, d.elementRoot = /*elementRoot*/
        c[0], _t(() => t = !1)), !s && u & /*elementContent*/
        2 && (s = !0, d.elementContent = /*elementContent*/
        c[1], _t(() => s = !1)), e.$set(d);
      },
      i(c) {
        n || (w(e.$$.fragment, c), n = !0);
      },
      o(c) {
        C(e.$$.fragment, c), n = !1;
      },
      d(c) {
        j(e, c);
      }
    }
  );
}
f(vH, "create_else_block$G");
function kH(i) {
  let e, t;
  const s = [
    {
      id: `${/*application*/
      i[4].id}-glasspane`
    },
    /*modalProps*/
    i[7],
    { zIndex: (
      /*zIndex*/
      i[8]
    ) }
  ];
  let n = {
    $$slots: { default: [AH] },
    $$scope: { ctx: i }
  };
  for (let l = 0; l < s.length; l += 1)
    n = fs(n, s[l]);
  return e = new eH({ props: n }), e.$on(
    "close:glasspane",
    /*close_glasspane_handler*/
    i[13]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), t = !0;
    },
    p(l, r) {
      const o = r & /*application, modalProps, zIndex*/
      400 ? hs(s, [
        r & /*application*/
        16 && {
          id: `${/*application*/
          l[4].id}-glasspane`
        },
        r & /*modalProps*/
        128 && Es(
          /*modalProps*/
          l[7]
        ),
        r & /*zIndex*/
        256 && { zIndex: (
          /*zIndex*/
          l[8]
        ) }
      ]) : {};
      r & /*$$scope, appProps, elementRoot, elementContent, data, dialogComponent*/
      4194383 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
    },
    i(l) {
      t || (w(e.$$.fragment, l), t = !0);
    },
    o(l) {
      C(e.$$.fragment, l), t = !1;
    },
    d(l) {
      j(e, l);
    }
  };
}
f(kH, "create_if_block$2q");
function wH(i) {
  let e, t, s;
  function n(r) {
    i[14](r);
  }
  f(n, "dialogcontent_dialogComponent_binding_1");
  let l = { data: (
    /*data*/
    i[3]
  ) };
  return (
    /*dialogComponent*/
    i[2] !== void 0 && (l.dialogComponent = /*dialogComponent*/
    i[2]), e = new H7({ props: l }), st.push(() => mt(e, "dialogComponent", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, o) {
        const a = {};
        o & /*data*/
        8 && (a.data = /*data*/
        r[3]), !t && o & /*dialogComponent*/
        4 && (t = !0, a.dialogComponent = /*dialogComponent*/
        r[2], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(wH, "create_default_slot_2$13");
function $H(i) {
  let e, t, s;
  function n(r) {
    i[10](r);
  }
  f(n, "dialogcontent_dialogComponent_binding");
  let l = {
    data: (
      /*data*/
      i[3]
    ),
    stopPropagation: !0
  };
  return (
    /*dialogComponent*/
    i[2] !== void 0 && (l.dialogComponent = /*dialogComponent*/
    i[2]), e = new H7({ props: l }), st.push(() => mt(e, "dialogComponent", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, o) {
        const a = {};
        o & /*data*/
        8 && (a.data = /*data*/
        r[3]), !t && o & /*dialogComponent*/
        4 && (t = !0, a.dialogComponent = /*dialogComponent*/
        r[2], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f($H, "create_default_slot_1$1v");
function AH(i) {
  let e, t, s, n;
  const l = [
    /*appProps*/
    i[6],
    { appOffsetHeight: !0 }
  ];
  function r(c) {
    i[11](c);
  }
  f(r, "applicationshell_elementRoot_binding");
  function o(c) {
    i[12](c);
  }
  f(o, "applicationshell_elementContent_binding");
  let a = {
    $$slots: { default: [$H] },
    $$scope: { ctx: i }
  };
  for (let c = 0; c < l.length; c += 1)
    a = fs(a, l[c]);
  return (
    /*elementRoot*/
    i[0] !== void 0 && (a.elementRoot = /*elementRoot*/
    i[0]), /*elementContent*/
    i[1] !== void 0 && (a.elementContent = /*elementContent*/
    i[1]), e = new Ss({ props: a }), st.push(() => mt(e, "elementRoot", r)), st.push(() => mt(e, "elementContent", o)), {
      c() {
        L(e.$$.fragment);
      },
      m(c, u) {
        N(e, c, u), n = !0;
      },
      p(c, u) {
        const d = u & /*appProps*/
        64 ? hs(l, [
          Es(
            /*appProps*/
            c[6]
          ),
          l[1]
        ]) : {};
        u & /*$$scope, data, dialogComponent*/
        4194316 && (d.$$scope = { dirty: u, ctx: c }), !t && u & /*elementRoot*/
        1 && (t = !0, d.elementRoot = /*elementRoot*/
        c[0], _t(() => t = !1)), !s && u & /*elementContent*/
        2 && (s = !0, d.elementContent = /*elementContent*/
        c[1], _t(() => s = !1)), e.$set(d);
      },
      i(c) {
        n || (w(e.$$.fragment, c), n = !0);
      },
      o(c) {
        C(e.$$.fragment, c), n = !1;
      },
      d(c) {
        j(e, c);
      }
    }
  );
}
f(AH, "create_default_slot$2t");
function EH(i) {
  let e, t, s, n;
  const l = [kH, vH], r = [];
  function o(a, c) {
    return (
      /*modal*/
      a[5] ? 0 : 1
    );
  }
  return f(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, [c]) {
      let u = e;
      e = o(a), e === u ? r[e].p(a, c) : (ce(), C(r[u], 1, 1, () => {
        r[u] = null;
      }), ue(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), r[e].d(a);
    }
  };
}
f(EH, "create_fragment$4t");
const SH = "#50505080";
function TH(i, e, t) {
  let { elementContent: s = void 0 } = e, { elementRoot: n = void 0 } = e, { data: l = {} } = e, { dialogComponent: r = void 0 } = e, { managedPromise: o = void 0 } = e;
  const a = fe("#external").application, c = It({});
  et("#managedPromise", o), et("#dialogOptions", c);
  const u = fa, d = { duration: 200 };
  let p;
  const m = {
    // Stores any transition functions.
    transition: void 0,
    inTransition: void 0,
    outTransition: void 0,
    // Stores properties to set for options for any transitions.
    transitionOptions: void 0,
    inTransitionOptions: void 0,
    outTransitionOptions: void 0,
    // Stores any style overrides for application shell.
    stylesApp: void 0,
    stylesContent: void 0
  }, g = {
    // Background CSS style string.
    background: void 0,
    slotSeparate: void 0,
    styles: void 0,
    // Close modal on glasspane input.
    closeOnInput: void 0,
    // Stores any transition functions.
    transition: void 0,
    inTransition: void 0,
    outTransition: void 0,
    // Stores properties to set for options for any transitions.
    transitionOptions: void 0,
    inTransitionOptions: void 0,
    outTransitionOptions: void 0
  };
  let h;
  p === void 0 && (p = typeof (l == null ? void 0 : l.modal) == "boolean" ? l.modal : !1), p ? (Nt(() => window.removeEventListener("keydown", y, { capture: !0 })), Sr(() => window.addEventListener("keydown", y, { capture: !0 }))) : (Nt(() => document.removeEventListener("keydown", _)), Sr(() => document.addEventListener("keydown", _)));
  function _(F) {
    F.code === "Escape" && (F.preventDefault(), F.stopPropagation(), a.close());
  }
  f(_, "onKeydown");
  function y(F) {
    F.code === "Escape" && (F.preventDefault(), F.stopImmediatePropagation(), a.close());
  }
  f(y, "onKeydownModal");
  function k(F) {
    r = F, t(2, r);
  }
  f(k, "dialogcontent_dialogComponent_binding");
  function v(F) {
    n = F, t(0, n);
  }
  f(v, "applicationshell_elementRoot_binding");
  function O(F) {
    s = F, t(1, s);
  }
  f(O, "applicationshell_elementContent_binding");
  const P = /* @__PURE__ */ f(() => a.close(), "close_glasspane_handler");
  function D(F) {
    r = F, t(2, r);
  }
  f(D, "dialogcontent_dialogComponent_binding_1");
  function I(F) {
    n = F, t(0, n);
  }
  f(I, "applicationshell_elementRoot_binding_1");
  function B(F) {
    s = F, t(1, s);
  }
  return f(B, "applicationshell_elementContent_binding_1"), i.$$set = (F) => {
    "elementContent" in F && t(1, s = F.elementContent), "elementRoot" in F && t(0, n = F.elementRoot), "data" in F && t(3, l = F.data), "dialogComponent" in F && t(2, r = F.dialogComponent), "managedPromise" in F && t(9, o = F.managedPromise);
  }, i.$$.update = () => {
    var F, H, G, U, q, W, X, te, J;
    if (i.$$.dirty & /*elementRoot, modal*/
    33 && n instanceof HTMLElement && (n.setAttribute("role", "dialog"), p && n.setAttribute("aria-modal", "true")), i.$$.dirty & /*data, modal, zIndex, application*/
    312 && ke(l)) {
      c.set(Wr(l));
      const re = Number.isInteger(l.zIndex) || l.zIndex === null ? l.zIndex : p ? Number.MAX_SAFE_INTEGER : Number.MAX_SAFE_INTEGER - 1;
      h !== re && t(8, h = re);
      const ae = typeof l.draggable == "boolean" ? l.draggable : void 0;
      ae !== void 0 && a.reactive.draggable !== ae && t(4, a.reactive.draggable = ae, a);
      const be = typeof l.focusAuto == "boolean" ? l.focusAuto : void 0;
      be !== void 0 && a.reactive.focusAuto !== be && t(4, a.reactive.focusAuto = be, a);
      const we = typeof l.focusKeep == "boolean" ? l.focusKeep : void 0;
      we !== void 0 && a.reactive.focusKeep !== we && t(4, a.reactive.focusKeep = we, a);
      const ve = typeof l.focusTrap == "boolean" ? l.focusTrap : void 0;
      ve !== void 0 && a.reactive.focusTrap !== ve && t(4, a.reactive.focusTrap = ve, a);
      const me = typeof l.minimizable == "boolean" ? l.minimizable : void 0;
      me !== void 0 && a.reactive.minimizable !== me && t(4, a.reactive.minimizable = me, a);
      const he = typeof l.resizable == "boolean" ? l.resizable : void 0;
      he !== void 0 && a.reactive.resizable !== he && t(4, a.reactive.resizable = he, a);
      const Ae = l.title ?? "Dialog";
      Ae !== ((F = a == null ? void 0 : a.options) == null ? void 0 : F.title) && t(4, a.reactive.title = Ae, a), a.position.zIndex !== h && t(4, a.position.zIndex = h, a);
    }
    if (i.$$.dirty & /*data, appProps*/
    72 && ke(l == null ? void 0 : l.transition)) {
      const re = l.transition;
      (re == null ? void 0 : re.transition) !== m.transition && t(6, m.transition = re.transition, m), (re == null ? void 0 : re.inTransition) !== m.inTransition && t(6, m.inTransition = re.inTransition, m), (re == null ? void 0 : re.outTransition) !== m.outTransition && t(6, m.outTransition = re.outTransition, m), (re == null ? void 0 : re.transitionOptions) !== m.transitionOptions && t(6, m.transitionOptions = re.transitionOptions, m), (re == null ? void 0 : re.inTransitionOptions) !== m.inTransitionOptions && t(6, m.inTransitionOptions = re.inTransitionOptions, m), (re == null ? void 0 : re.outTransitionOptions) !== m.outTransitionOptions && t(6, m.outTransitionOptions = re.outTransitionOptions, m);
    }
    if (i.$$.dirty & /*data, modalProps*/
    136) {
      const re = typeof ((H = l == null ? void 0 : l.modalOptions) == null ? void 0 : H.background) == "string" ? l.modalOptions.background : SH;
      re !== g.background && t(7, g.background = re, g);
    }
    if (i.$$.dirty & /*data, modalProps*/
    136) {
      const re = typeof ((G = l == null ? void 0 : l.modalOptions) == null ? void 0 : G.slotSeparate) == "boolean" ? l.modalOptions.slotSeparate : void 0;
      re !== g.slotSeparate && t(7, g.slotSeparate = re, g);
    }
    if (i.$$.dirty & /*data, modalProps*/
    136) {
      const re = ke((U = l == null ? void 0 : l.modalOptions) == null ? void 0 : U.styles) ? l.modalOptions.styles : void 0;
      re !== g.styles && t(7, g.styles = re, g);
    }
    if (i.$$.dirty & /*data, modalProps*/
    136) {
      const re = typeof ((q = l == null ? void 0 : l.modalOptions) == null ? void 0 : q.closeOnInput) == "boolean" ? l.modalOptions.closeOnInput : void 0;
      re !== g.closeOnInput && t(7, g.closeOnInput = re, g);
    }
    if (i.$$.dirty & /*data, modalProps*/
    136)
      if (ke((W = l == null ? void 0 : l.modalOptions) == null ? void 0 : W.transition)) {
        const re = l.modalOptions.transition;
        (re == null ? void 0 : re.transition) !== g.transition && t(
          7,
          g.transition = typeof (re == null ? void 0 : re.transition) == "function" ? re.transition : u,
          g
        ), (re == null ? void 0 : re.inTransition) !== g.inTransition && t(7, g.inTransition = re.inTransition, g), (re == null ? void 0 : re.outTransition) !== g.outTransition && t(7, g.outTransition = re.outTransition, g), (re == null ? void 0 : re.transitionOptions) !== g.transitionOptions && t(
          7,
          g.transitionOptions = ke(re == null ? void 0 : re.transitionOptions) ? re.transitionOptions : d,
          g
        ), (re == null ? void 0 : re.inTransitionOptions) !== g.inTransitionOptions && t(7, g.inTransitionOptions = re.inTransitionOptions, g), (re == null ? void 0 : re.outTransitionOptions) !== g.outTransitionOptions && t(7, g.outTransitionOptions = re.outTransitionOptions, g);
      } else {
        const re = typeof ((te = (X = l == null ? void 0 : l.modalOptions) == null ? void 0 : X.transition) == null ? void 0 : te.transition) == "function" ? l.modalOptions.transition.transition : u;
        re !== g.transition && t(7, g.transition = re, g);
        const ae = ke((J = l == null ? void 0 : l.modalOptions) == null ? void 0 : J.transitionOptions) ? l.modalOptions.transitionOptions : d;
        ae !== g.transitionOptions && t(7, g.transitionOptions = ae, g);
      }
  }, [
    n,
    s,
    r,
    l,
    a,
    p,
    m,
    g,
    h,
    o,
    k,
    v,
    O,
    P,
    D,
    I,
    B
  ];
}
f(TH, "instance$4k");
const nA = class nA extends ie {
  constructor(e) {
    super(), le(this, e, TH, EH, ne, {
      elementContent: 1,
      elementRoot: 0,
      data: 3,
      dialogComponent: 2,
      managedPromise: 9
    });
  }
  get elementContent() {
    return this.$$.ctx[1];
  }
  set elementContent(e) {
    this.$$set({ elementContent: e }), Ke();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Ke();
  }
  get data() {
    return this.$$.ctx[3];
  }
  set data(e) {
    this.$$set({ data: e }), Ke();
  }
  get dialogComponent() {
    return this.$$.ctx[2];
  }
  set dialogComponent(e) {
    this.$$set({ dialogComponent: e }), Ke();
  }
  get managedPromise() {
    return this.$$.ctx[9];
  }
  set managedPromise(e) {
    this.$$set({ managedPromise: e }), Ke();
  }
};
f(nA, "DialogShell");
let A_ = nA;
const CH = A_;
Kz.setProperties({
  // Anchor text shadow / header buttons
  "--tjs-default-text-shadow-focus-hover": "0 0 8px var(--color-shadow-primary)",
  // TJSApplicationShell app background.
  "--tjs-app-background": `url("${globalThis.foundry.utils.getRoute("/ui/denim075.png")}")`
}, !1);
var En, ft;
const Rn = class Rn {
  constructor() {
    /** @type {{ isProcessing?: boolean, promise?: Promise, reject: Function, resolve: Function }} */
    Y(this, ft, void 0);
  }
  /**
   * @returns {boolean} Whether global logging is enabled.
   */
  static get logging() {
    return M(this, En);
  }
  /**
   * @returns {boolean} Whether there is an active managed Promise.
   */
  get isActive() {
    return M(this, ft) !== void 0;
  }
  /**
   * @returns {boolean} Whether there is an active managed Promise and resolution is currently being processed.
   */
  get isProcessing() {
    return M(this, ft) !== void 0 ? M(this, ft).isProcessing : !1;
  }
  /**
   * Sets global logging enabled state.
   *
   * @param {boolean}  logging - New logging enabled state.
   */
  static set logging(e) {
    if (typeof e != "boolean")
      throw new TypeError("[TRL] ManagedPromise.logging error: 'logging' is not a boolean.");
    ye(this, En, e);
  }
  // ----------------------------------------------------------------------------------------------------------------
  /**
   * Resolves any current Promise with undefined and creates a new current Promise.
   *
   * @template T
   *
   * @param {object} opts - Options.
   *
   * @param {boolean}  [opts.reuse=false] - When true if there is an existing live Promise it is returned immediately.
   *
   * @returns {Promise<T>} The new current managed Promise.
   */
  create({ reuse: e = !1 } = {}) {
    if (typeof e != "boolean")
      throw new TypeError("[TRL] ManagedPromise.create error: 'reuse' is not a boolean.");
    if (e && M(this, ft) !== void 0 && M(this, ft).promise instanceof Promise)
      return M(Rn, En) && console.warn("[TRL] ManagedPromise.create info: Reusing / returning existing managed Promise."), M(this, ft).promise;
    M(this, ft) !== void 0 && (M(Rn, En) && console.warn(
      "[TRL] ManagedPromise.create info: Creating a new Promise and resolving existing immediately."
    ), M(this, ft).resolve(void 0), ye(this, ft, void 0));
    const t = new Promise((s, n) => {
      ye(this, ft, {
        isProcessing: !1,
        reject: n,
        resolve: s
      });
    });
    return M(this, ft).promise = t, t;
  }
  /**
   * Gets the current Promise if any.
   *
   * @returns {Promise<any>} Current Promise.
   */
  get() {
    return M(this, ft) ? M(this, ft).promise : void 0;
  }
  /**
   * Rejects the current Promise if applicable.
   *
   * @param {*}  [result] - Result to reject.
   *
   * @returns {boolean} Was the promise rejected.
   */
  reject(e = void 0) {
    return M(this, ft) !== void 0 && M(this, ft).isProcessing ? (M(Rn, En) && console.warn("[TRL] ManagedPromise.reject info: Currently processing promise."), !0) : M(this, ft) !== void 0 ? (M(this, ft).isProcessing = !0, e instanceof Promise ? e.then((t) => {
      M(this, ft).reject(t), ye(this, ft, void 0);
    }).catch((t) => {
      M(this, ft).reject(t), ye(this, ft, void 0);
    }) : (M(this, ft).reject(e), ye(this, ft, void 0)), !0) : (M(Rn, En) && console.warn("[TRL] ManagedPromise.reject warning: No current managed Promise to reject."), !1);
  }
  /**
   * Resolves the current Promise if applicable.
   *
   * @param {*}  [result] - Result to resolve.
   *
   * @returns {boolean} Was the promise resolved.
   */
  resolve(e = void 0) {
    return M(this, ft) !== void 0 && M(this, ft).isProcessing ? (M(Rn, En) && console.warn("[TRL] ManagedPromise.resolve info: Currently processing promise."), !0) : M(this, ft) !== void 0 ? (e instanceof Promise ? (M(this, ft).isProcessing = !0, e.then((t) => {
      M(this, ft).resolve(t), ye(this, ft, void 0);
    }).catch((t) => {
      M(this, ft).reject(t), ye(this, ft, void 0);
    })) : (M(this, ft).resolve(e), ye(this, ft, void 0)), !0) : (M(Rn, En) && console.warn("[TRL] ManagedPromise.resolve warning: No current managed Promise to resolve."), !1);
  }
};
En = new WeakMap(), ft = new WeakMap(), f(Rn, "ManagedPromise"), /** @type {boolean} */
Y(Rn, En, !1);
let E_ = Rn;
var mu, ct, Zt, ns;
const iA = class iA {
  /**
   * @param {import('../../index.js').SvelteApplication} application - The host Foundry application.
   */
  constructor(e) {
    /**
     * Updates the data in the Svelte dialog component.
     */
    Y(this, Zt);
    /**
     * @type {import('../../index.js').SvelteApplication}
     */
    Y(this, mu, void 0);
    /**
     * Stores the dialog options data.
     *
     * @type {import('./types').TJSDialogOptions}
     */
    Y(this, ct, {});
    ye(this, mu, e);
  }
  /**
   * @returns {Record<string, import('./types').TJSDialogButtonData>} The dialog button configuration.
   */
  get buttons() {
    return M(this, ct).buttons;
  }
  /**
   * Set the dialog button configuration.
   *
   * @param {string} buttons - New dialog button configuration.
   */
  set buttons(e) {
    M(this, ct).buttons = e, Z(this, Zt, ns).call(this);
  }
  /**
   * @returns {import('@typhonjs-fvtt/runtime/svelte/util').TJSSvelteConfig | string} The Svelte configuration object or HTML string
   *          content.
   */
  get content() {
    return M(this, ct).content;
  }
  /**
   * Set the Svelte configuration object or HTML string content.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/util').TJSSvelteConfig | string} content - New Svelte configuration object or
   *        HTML string content.
   */
  set content(e) {
    M(this, ct).content = e, Z(this, Zt, ns).call(this);
  }
  /**
   * @returns {string} The default button ID to focus initially.
   */
  get default() {
    return M(this, ct).default;
  }
  /**
   * Set the default button ID to focus initially.
   *
   * @param {string} newDefault - New default button ID to focus initially.
   */
  set default(e) {
    M(this, ct).default = e, Z(this, Zt, ns).call(this);
  }
  /**
   * @returns {boolean} The dialog draggable state; draggable when true.
   */
  get draggable() {
    return M(this, ct).draggable;
  }
  /**
   * Set the dialog state; draggable when true.
   *
   * @param {boolean} draggable - New dialog draggable state; draggable when true.
   */
  set draggable(e) {
    M(this, ct).draggable = e, Z(this, Zt, ns).call(this);
  }
  /**
   * @returns {boolean} When true auto-management of app focus is enabled.
   */
  get focusAuto() {
    return M(this, ct).focusAuto;
  }
  /**
   * Set the dialog auto-management of app focus.
   *
   * @param {boolean} focusAuto - New dialog auto-management of app focus.
   */
  set focusAuto(e) {
    M(this, ct).focusAuto = e, Z(this, Zt, ns).call(this);
  }
  /**
   * @returns {boolean} When true the first focusable element that isn't a button is focused.
   */
  get focusFirst() {
    return M(this, ct).focusFirst;
  }
  /**
   * Set the dialog first focusable element state.
   *
   * @param {boolean} focusFirst - New dialog first focusable element state.
   */
  set focusFirst(e) {
    M(this, ct).focusFirst = e, Z(this, Zt, ns).call(this);
  }
  /**
   * @returns {boolean} When `focusAuto` and `focusKeep` is true; keeps internal focus.
   */
  get focusKeep() {
    return M(this, ct).focusKeep;
  }
  /**
   * Set the dialog `focusKeep` state. When `focusAuto` and `focusKeep` is true; keeps internal focus.
   *
   * @param {boolean} focusKeep - New dialog `focusKeep` state.
   */
  set focusKeep(e) {
    M(this, ct).focusKeep = e, Z(this, Zt, ns).call(this);
  }
  /**
   * @returns {boolean} When true the dialog is minimizable.
   */
  get minimizable() {
    return M(this, ct).minimizable;
  }
  /**
   * Set the dialog `minimizable` state. When true the dialog is minimizable.
   *
   * @param {boolean} minimizable - New dialog `minimizable` state.
   */
  set minimizable(e) {
    M(this, ct).minimizable = e, Z(this, Zt, ns).call(this);
  }
  /**
   * @returns {boolean} When true a modal dialog is displayed.
   */
  get modal() {
    return M(this, ct).modal;
  }
  /**
   * Set the dialog `modal` state. When true a modal dialog is displayed.
   *
   * @param {boolean} modal - New dialog `modal` state.
   */
  set modal(e) {
    M(this, ct).modal = e, Z(this, Zt, ns).call(this);
  }
  /**
   * @returns {import('./types').TJSDialogModalOptions} Additional options for modal dialog display.
   */
  get modalOptions() {
    return M(this, ct).modalOptions;
  }
  /**
   * Set additional options for modal dialog display.
   *
   * @param {import('./types').TJSDialogModalOptions} modalOptions - New additional options for modal dialog display.
   */
  set modalOptions(e) {
    M(this, ct).modalOptions = e, Z(this, Zt, ns).call(this);
  }
  /**
   * @returns {boolean} When true and an error is raised in dialog callback functions post a UI error notification.
   */
  get notifyError() {
    return M(this, ct).notifyError;
  }
  /**
   * Set the dialog `notifyError` state. When true and an error is raised in dialog callback functions post a UI error
   * notification.
   *
   * @param {boolean} notifyError - New dialog `notifyError` state.
   */
  set notifyError(e) {
    M(this, ct).notifyError = e, Z(this, Zt, ns).call(this);
  }
  /**
   * @returns {string | ((application: import('../../index.js').TJSDialog) => any)} Callback invoked when dialog is
   *          closed; no button option selected. When defined as a string any matching function by name exported from
   *          content Svelte component is invoked.
   */
  get onClose() {
    return M(this, ct).onClose;
  }
  /**
   * Set callback invoked when dialog is closed; no button option selected. When defined as a string any matching
   * function by name exported from content Svelte component is invoked..
   *
   * @param {string | ((application: import('../../index.js').TJSDialog) => any)} onClose - New dialog `onClose` state.
   */
  set onClose(e) {
    M(this, ct).onClose = e, Z(this, Zt, ns).call(this);
  }
  /**
   * @returns {boolean} Dialog `rejectClose` state. When true and a Promise has been created by {@link TJSDialog.wait}
   *          and the Promise is not in the process of being resolved or rejected on close of the dialog any `onClose`
   *          function is invoked and any result that is undefined will cause the Promise to then be rejected..
   */
  get rejectClose() {
    return M(this, ct).rejectClose;
  }
  /**
   * Set the dialog `rejectClose` state.
   *
   * @param {boolean} rejectClose - New dialog `rejectClose` state.
   */
  set rejectClose(e) {
    M(this, ct).rejectClose = e, Z(this, Zt, ns).call(this);
  }
  /**
   * @returns {boolean} When true the dialog is resizable.
   */
  get resizable() {
    return M(this, ct).resizable;
  }
  /**
   * Set the dialog `resizable` state. When true the dialog is resizable.
   *
   * @param {boolean} resizable - New dialog `resizable` state.
   */
  set resizable(e) {
    M(this, ct).resizable = e, Z(this, Zt, ns).call(this);
  }
  /**
   * @returns {boolean} When true and resolving any Promises and there are undefined results from any button callbacks
   *          the button ID is resolved.
   */
  get resolveId() {
    return M(this, ct).resolveId;
  }
  /**
   * Set the dialog `resolveId` state. When true and resolving any Promises and there are undefined results from any
   * button callbacks the button ID is resolved.
   *
   * @param {boolean} resolveId - New dialog `resolveId` state.
   */
  set resolveId(e) {
    M(this, ct).resolveId = e, Z(this, Zt, ns).call(this);
  }
  /**
   * @returns {string} The dialog window title.
   */
  get title() {
    return M(this, ct).title;
  }
  /**
   * Set the dialog window title.
   *
   * @param {string} title - New dialog window title.
   */
  set title(e) {
    M(this, ct).title = e, Z(this, Zt, ns).call(this);
  }
  /**
   * @returns {import('./types').TJSDialogTransitionOptions} Transition options for the dialog.
   */
  get transition() {
    return M(this, ct).transition;
  }
  /**
   * Set transition options for the dialog.
   *
   * @param {import('./types').TJSDialogTransitionOptions} transition - New transition options for the dialog.
   */
  set transition(e) {
    M(this, ct).transition = e, Z(this, Zt, ns).call(this);
  }
  /**
   * @returns {number | null} A specific z-index for the dialog. Pass null for the dialog to act like other
   *          applications in regard bringing to top when activated.
   */
  get zIndex() {
    return M(this, ct).zIndex;
  }
  /**
   * Set specific z-index for the dialog.
   *
   * @param {number | null} zIndex - New z-index for the dialog.
   */
  set zIndex(e) {
    M(this, ct).zIndex = e, Z(this, Zt, ns).call(this);
  }
  /**
   * Provides a way to safely get this dialogs data given an accessor string which describes the
   * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries
   * to walk.
   *
   * @param {string}   accessor - The path / key to set. You can set multiple levels.
   *
   * @param {any}      [defaultValue] - A default value returned if the accessor is not found.
   *
   * @returns {any} Value at the accessor.
   */
  get(e, t) {
    return _d(M(this, ct), e, t);
  }
  /**
   * @param {import('./types').TJSDialogOptions} data - Merge provided data object into Dialog data.
   */
  merge(e) {
    Ii(M(this, ct), e), Z(this, Zt, ns).call(this);
  }
  /**
   * Sets the dialog data; this is reactive.
   *
   * @param {import('./types').TJSDialogOptions}   data - Dialog data.
   */
  replace(e) {
    if (!ke(e))
      throw new TypeError("TJSDialogData replace error: 'data' is not an object'.");
    ye(this, ct, {}), this.merge(e);
  }
  /**
   * Provides a way to safely set this dialogs data given an accessor string which describes the
   * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries
   * to walk.
   *
   * Automatically the dialog data will be updated in the associated DialogShell Svelte component.
   *
   * @param {string}   accessor - The path / key to set. You can set multiple levels.
   *
   * @param {any}      value - Value to set.
   *
   * @returns {boolean} True if successful.
   */
  set(e, t) {
    const s = p7(M(this, ct), e, t);
    return s && Z(this, Zt, ns).call(this), s;
  }
};
mu = new WeakMap(), ct = new WeakMap(), Zt = new WeakSet(), ns = /* @__PURE__ */ f(function() {
  const e = M(this, mu).svelte.component(0);
  e != null && e.data && (e.data = M(this, ct));
}, "#updateComponent"), f(iA, "TJSDialogData");
let S_ = iA;
var rn, on, ir, Ha;
const fc = class fc extends _s {
  /**
   * @param {import('./internal/state-dialog/types').TJSDialogOptions}           data - Dialog options.
   *
   * @param {import('./').SvelteApplicationOptions}   [options] - SvelteApplication options.
   */
  constructor(t, s = {}) {
    super(s);
    /** @type {TJSDialogData} */
    Y(this, rn, void 0);
    /** @type {ManagedPromise} */
    Y(this, on, void 0);
    ye(this, on, new E_()), ye(this, rn, new S_(this)), M(this, rn).replace(t), Object.defineProperty(this.svelte, "dialogComponent", {
      get: () => {
        var n, l;
        return (l = (n = this.svelte) == null ? void 0 : n.applicationShell) == null ? void 0 : l.dialogComponent;
      }
    });
  }
  /**
   * Default options for TJSDialog. Provides a default width and setting `height` to `auto` to always display dialog
   * content even if it changes. The default `DialogShell` / `svelte` options should not be changed and instead mount
   * the dialog content component by supplying a Svelte configuration object to dialog data `content` field.
   *
   * @returns {import('./').SvelteApplicationOptions} Default options
   */
  static get defaultOptions() {
    return Ii(super.defaultOptions, {
      classes: ["dialog", "tjs-dialog"],
      width: 400,
      height: "auto",
      svelte: {
        class: CH,
        intro: !0,
        target: document.body,
        props: function() {
          return {
            data: M(this, rn),
            managedPromise: M(this, on)
          };
        }
      }
    });
  }
  /**
   * Returns the dialog data.
   *
   * @returns {import('./internal/state-dialog/types').TJSDialogData} Dialog data.
   */
  get data() {
    return M(this, rn);
  }
  /**
   * @returns {import('@typhonjs-fvtt/runtime/util/async').ManagedPromise} Returns the managed promise.
   */
  get managedPromise() {
    return M(this, on);
  }
  /**
   * Close the dialog and un-register references to it within UI mappings.
   * This function returns a Promise which resolves once the window closing animation concludes.
   *
   * @param {object}   [options] - Optional parameters.
   *
   * @param {boolean}  [options.force] - Force close regardless of render state.
   *
   * @returns {Promise<void>} A Promise which resolves once the application is closed with the callback value or
   *                          `true`.
   */
  async close(t) {
    var s;
    try {
      if (M(this, on).isActive && !M(this, on).isProcessing) {
        const n = Z(s = fc, ir, Ha).call(s, M(this, rn).onClose, this, null);
        (typeof M(this, rn).rejectClose == "boolean" ? M(this, rn).rejectClose : !1) && n === null ? M(this, on).reject(new Error("TJSDialog was closed without a choice being made.")) : M(this, on).resolve(n);
      }
    } catch (n) {
      if ((typeof M(this, rn).notifyError == "boolean" ? M(this, rn).notifyError : !0) && globalThis.ui.notifications.error(n, { console: !1 }), !M(this, on).reject(n))
        throw n;
    } finally {
      await super.close(t);
    }
  }
  /**
   * Brings to top or renders this dialog returning a Promise that is resolved any button pressed or when the dialog
   * is closed.
   *
   * Creates an anonymous data defined TJSDialog returning a Promise that can be awaited upon for the user to make a
   * choice.
   *
   * Note: `null` is returned if the dialog is closed without a user making a choice.
   *
   * @template T
   *
   * @param {object}   [options] - Options.
   *
   * @param {boolean}  [options.reuse=false] - When true if there is an existing managed Promise this allows multiple
   *        sources to await on the same result.
   *
   * @returns {Promise<T>} A promise for dialog resolution.
   */
  async wait(t) {
    return this.rendered ? this.bringToTop() : this.render(!0, { focus: !0 }), M(this, on).create(t);
  }
  // ---------------------------------------------------------------------------------------------------------------
  /**
   * A helper factory method to create simple confirmation dialog windows which consist of simple yes / no prompts.
   * If you require more flexibility, a custom TJSDialog instance is preferred. The default focused button is 'yes'.
   * You can change the default focused button by setting `default` to `yes` or `no`.
   *
   * @template T
   *
   * @param {import('./internal/state-dialog/types').TJSDialogOptions & {
   *    onYes?: string|((application: TJSDialog) => any),
   *    onNo?: string|((application: TJSDialog) => any)
   * }} [data] - Confirm dialog options.
   *
   * @param {string|((application: TJSDialog) => any)} [data.onYes] - Callback function upon `yes`; may be an async
   *        function. When defined as a string any matching function by name exported from content Svelte component is
   *        invoked.
   *
   * @param {string|((application: TJSDialog) => any)} [data.onNo] - Callback function upon `no`; may be an async
   *        function. When defined as a string any matching function by name exported from content Svelte component is
   *        invoked.
   *
   * @param {import('./').SvelteApplicationOptions}  [options]  SvelteApplication options passed to the TJSDialog
   *        constructor.
   *
   * @returns {Promise<T>} A promise which resolves with result of yes / no callbacks or true / false.
   *
   * @example
   * const result = await TJSDialog.confirm({
   *  title: 'A Yes or No Question',
   *  content: '<p>Choose wisely.</p>',
   *  onYes: () => 'YES Result'
   *  onNo: () => 'NO Result'
   * });
   *
   * // Logs 'YES result', 'NO Result', or null if the user closed the dialog without making a selection.
   * console.log(result);
   */
  static async confirm({ onYes: t, onNo: s, ...n } = {}, l = {}) {
    const r = Ii({
      yes: {
        icon: "fas fa-check",
        label: "Yes"
      },
      no: {
        icon: "fas fa-times",
        label: "No"
      }
    }, n.buttons ?? {});
    return this.wait({
      ...n,
      buttons: Ii(r, {
        yes: {
          onPress: (o) => Z(this, ir, Ha).call(this, t, o, !0)
        },
        no: {
          onPress: (o) => Z(this, ir, Ha).call(this, s, o, !1)
        }
      }),
      default: n.default ?? "yes"
    }, l);
  }
  /**
   * A helper factory method to display a basic "prompt" style TJSDialog with a single button.
   *
   * @template T
   *
   * @param {import('./internal/state-dialog/types').TJSDialogOptions & {
   *    onOk?: string|((application: TJSDialog) => any),
   *    label?: string,
   *    icon?: string
   * }} [data] - Prompt dialog options that includes any TJSDialog options along with the following optional fields:
   *
   * @param {string|((application: TJSDialog) => any)} [data.onOk] - Callback function upon `ok`; may be an async
   *        function. When defined as a string any matching function by name exported from content Svelte component is
   *        invoked.
   *
   * @param {string}   [data.label] - The OK prompt button text.
   *
   * @param {string}   [data.icon="fas fa-check"] - Set another icon besides `fas fa-check` for button.
   *
   * @param {import('./').SvelteApplicationOptions}  [options]  SvelteApplication options passed to the TJSDialog
   *        constructor.
   *
   * @returns {Promise<T>} The returned value from the provided callback function or `true` if the button
   *          is pressed.
   *
   * @example
   * const result = await TJSDialog.prompt({
   *  title: 'Are you OK?',
   *  content: '<p>Are you OK?.</p>',
   *  label: 'Feeling Fine!'
   *  onOk: () => 'OK'
   * });
   *
   * // Logs 'OK' or null if the user closed the dialog without making a selection.
   * console.log(result);
   */
  static async prompt({ onOk: t, label: s, icon: n = "fas fa-check", ...l } = {}, r = {}) {
    return this.wait({
      ...l,
      buttons: {
        ok: {
          icon: n,
          label: s,
          onPress: (o) => Z(this, ir, Ha).call(this, t, o, !0)
        }
      },
      default: "ok"
    }, r);
  }
  /**
   * Creates an anonymous data defined TJSDialog returning a Promise that can be awaited upon for the user to make a
   * choice.
   *
   * Note: By default `null` is returned if the dialog is closed without a user making a choice.
   *
   * @template T
   *
   * @param {import('./internal/state-dialog/types').TJSDialogOptions}  data - Dialog data passed to the TJSDialog constructor.
   *
   * @param {import('./').SvelteApplicationOptions}  [options]  SvelteApplication options passed to the TJSDialog
   *        constructor.
   *
   * @returns {Promise<T>} A Promise that resolves to the chosen result.
   */
  static async wait(t, s = {}) {
    if (!ke(t))
      throw new TypeError("TJSDialog.wait error: 'data' is not an object'.");
    return new this({ ...t }, s).wait();
  }
};
rn = new WeakMap(), on = new WeakMap(), ir = new WeakSet(), Ha = /* @__PURE__ */ f(function(t, s, n = void 0) {
  var r;
  let l = n;
  switch (typeof t) {
    case "function":
      l = t(s);
      break;
    case "string": {
      const o = (r = s == null ? void 0 : s.svelte) == null ? void 0 : r.dialogComponent;
      o !== void 0 && typeof (o == null ? void 0 : o[t]) == "function" ? l = o == null ? void 0 : o[t](s) : o === void 0 ? console.warn("[TRL] TJSDialog warning: 'onPress' defined as a string with no associated content Svelte component.") : typeof (o == null ? void 0 : o[t]) != "function" && console.warn(`[TRL] TJSDialog warning: The content Svelte component does not contain an associated function '${t}'. Did you remember to add '<svelte:options accessors={true} />' and export the function?`);
      break;
    }
  }
  return l;
}, "#invokeFn"), /**
 * A helper method to invoke a callback function directly or lookup an exported function with the same name from any
 * content Svelte component to invoke. This is used internally to apply default values for `confirm` and `prompt`.
 *
 * @param {string|((application: TJSDialog) => any)} callback - Callback function to invoke; may be an async
 *        function. When defined as a string any matching function by name exported from content Svelte component is
 *        invoked.
 *
 * @param {TJSDialog} application - TJSDialog instance passed to callback.
 *
 * @param {*} [defaultResult] - An optional default result to return; undefined if not specified.
 *
 * @returns {*} Result.
 *
 * @internal
 */
Y(fc, ir), f(fc, "TJSDialog");
let Fs = fc;
var hu, lr, zs, rr, jo, gm, U7, bm, V7, _m, W7;
const lA = class lA {
  /**
   * @param {import('./').TJSGameSettings}   settings -
   */
  constructor(e) {
    /**
     * Destroy callback. Checks for any `requiresReload` parameter in each setting comparing against initial value
     * when `settings` is created and current value. If there is a difference then show a modal dialog asking the user
     * if they want to reload for those settings to take effect.
     *
     * @param {import('./types').TJSSettingsUIData}   settings - The UI data object initiated w/ `create`.
     */
    Y(this, gm);
    /**
     * @param {import('./types').TJSSettingsCreateOptions} [options] - Optional parameters.
     *
     * @returns {import('./types').TJSSettingsUIData} Parsed UI settings data.
     */
    Y(this, bm);
    Y(this, _m);
    /** @type {import('./types').TJSSettingsCustomSection[]} */
    Y(this, hu, []);
    /** @type {import('./').TJSGameSettings} */
    Y(this, lr, void 0);
    /** @type {boolean} */
    Y(this, zs, !1);
    /** @type {Function} */
    Y(this, rr, void 0);
    /** @type {{showSettings: import('svelte/store').Readable<boolean>}} */
    Y(this, jo, void 0);
    ye(this, lr, e);
    const t = It(M(this, zs));
    ye(this, rr, t.set), ye(this, jo, {
      showSettings: { subscribe: t.subscribe }
    }), Object.freeze(M(this, jo));
  }
  /**
   * @returns {boolean} Current `showSettings` state.
   */
  get showSettings() {
    return M(this, zs);
  }
  /**
   * @returns {{ showSettings: import('svelte/store').Readable<boolean> }} Returns the managed stores.
   */
  get stores() {
    return M(this, jo);
  }
  /**
   * Sets current `showSettings` state.
   *
   * @param {boolean}  showSettings - New `showSettings` state.
   */
  set showSettings(e) {
    ye(this, zs, e), M(this, rr).call(this, M(this, zs));
  }
  /**
   * Adds a custom section / folder defined by the provided TJSSettingsCustomSection options object.
   *
   * @param {import('./types').TJSSettingsCustomSection} options - The configuration object for the custom section.
   */
  addSection(e) {
    if (!ke(e))
      throw new TypeError("'options' is not an object.");
    if (!ti(e.class))
      throw new TypeError("'options.class' is not a Svelte component.");
    if (e.props !== void 0 && !ke(e.props))
      throw new TypeError("'options.props' is not an object.");
    if (e.folder !== void 0) {
      const t = e.folder;
      if (typeof t != "string" && !ke(t))
        throw new TypeError("'options.folder' is not a string or object.");
      if (ke(t)) {
        if (typeof t.label != "string")
          throw new TypeError("'options.folder.label' is not a string.");
        if (t.summaryEnd !== void 0) {
          if (!ke(t.summaryEnd))
            throw new TypeError("'options.folder.summaryEnd' is not an object.");
          if (!ti(t.summaryEnd.class))
            throw new TypeError("'options.folder.summaryEnd.class' is not a Svelte component.");
          if (t.summaryEnd.props !== void 0 && !ke(t.summaryEnd.props))
            throw new TypeError("'options.folder.summaryEnd.props' is not an object.");
        }
        if (t.styles !== void 0 && !ke(t.styles))
          throw new TypeError("'options.folder.styles' is not an object.");
      }
    }
    if (e.styles !== void 0 && !ke(e.styles))
      throw new TypeError("'options.styles' is not an object.");
    M(this, hu).push(e);
  }
  /**
   * Creates the UISettingsData object by parsing stored settings in
   *
   * @param {import('./types').TJSSettingsCreateOptions} [options] - Optional parameters.
   *
   * @returns {import('./types').TJSSettingsUIData} Parsed UI settings data.
   */
  create(e) {
    const t = Z(this, bm, V7).call(this, e);
    return {
      ...t,
      destroy: /* @__PURE__ */ f(() => Z(this, gm, U7).call(this, t), "destroy")
    };
  }
  /**
   * Convenience method to swap `showSettings`.
   *
   * @returns {boolean} New `showSettings` state.
   */
  swapShowSettings() {
    return ye(this, zs, !M(this, zs)), M(this, rr).call(this, M(this, zs)), M(this, zs);
  }
};
hu = new WeakMap(), lr = new WeakMap(), zs = new WeakMap(), rr = new WeakMap(), jo = new WeakMap(), gm = new WeakSet(), U7 = /* @__PURE__ */ f(function(e) {
  let t = !1, s = !1;
  if (Array.isArray(e.topLevel))
    for (const n of e.topLevel)
      globalThis.game.settings.get(n.namespace, n.key) !== n.initialValue && (t || (t = n.scope === "client" && n.requiresReload), s || (s = n.scope === "world" && n.requiresReload));
  if (Array.isArray(e.folders)) {
    for (const n of e.folders)
      if (Array.isArray(n.settings))
        for (const l of n.settings)
          globalThis.game.settings.get(l.namespace, l.key) !== l.initialValue && (t || (t = l.scope === "client" && l.requiresReload), s || (s = l.scope === "world" && l.requiresReload));
  }
  (t || s) && Z(this, _m, W7).call(this, { world: s }), ye(this, zs, !1), M(this, rr).call(this, M(this, zs));
}, "#destroy"), bm = new WeakSet(), V7 = /* @__PURE__ */ f(function({ efx: e = "ripple", storage: t } = {}) {
  const s = M(this, lr).namespace;
  t && typeof s != "string" && console.warn(
    "TJSGameSettings warning: 'options.storage' defined, but 'namespace' not defined in TJSGameSettings."
  );
  const n = t && typeof s == "string", l = [], r = globalThis.game.user.can("SETTINGS_MODIFY");
  for (const p of M(this, lr)) {
    if (!p.config || !r && p.scope !== "client")
      continue;
    let m;
    ke(p.choices) && (m = Object.entries(p.choices).map((D) => ({ value: D[0], label: K(D[1]) })));
    let g;
    if (ke(p.range)) {
      if (g = {}, typeof p.range.min != "number")
        throw new TypeError("Setting 'range.min' is not a number.");
      if (typeof p.range.max != "number")
        throw new TypeError("Setting 'range.max' is not a number.");
      if (p.range.step !== void 0 && typeof p.range.step != "number")
        throw new TypeError("Setting 'range.step' is not a number.");
      g.min = p.range.min, g.max = p.range.max, g.step = p.range.step ? p.range.step : 1;
    }
    const h = p.type instanceof Function ? p.type.name : "String";
    let _;
    h === "String" && (_ = p.filePicker === !0 ? "any" : p.filePicker);
    let y;
    _ && (y = {
      icon: "fas fa-file-import fa-fw",
      efx: e === "ripple" ? Pz() : void 0,
      title: "FILES.BrowseTooltip",
      styles: { "margin-left": "0.25em" }
    });
    const k = M(this, lr).getStore(p.key);
    let v, O = "text";
    p.type === Boolean ? O = "checkbox" : m !== void 0 ? (O = "select", v = {
      store: k,
      efx: e === "ripple" ? IO() : void 0,
      type: O,
      options: m
    }) : p.type === Number && (O = ke(p.range) ? "range" : "number");
    let P;
    (O === "text" || O === "number") && (P = {
      store: k,
      efx: e === "ripple" ? IO() : void 0,
      type: O
    }), l.push({
      id: `${p.namespace}.${p.key}`,
      namespace: p.namespace,
      folder: p.folder,
      key: p.key,
      name: K(p.name),
      hint: K(p.hint),
      type: h,
      componentType: O,
      filePicker: _,
      range: g,
      store: k,
      initialValue: globalThis.game.settings.get(p.namespace, p.key),
      scope: p.scope,
      requiresReload: typeof p.requiresReload == "boolean" ? p.requiresReload : !1,
      buttonData: y,
      inputData: P,
      selectData: v
    });
  }
  const o = n ? t.getStore(`${s}-settings-scrollbar`) : It(0), a = [], c = {};
  for (const p of l)
    if (typeof p.folder == "string") {
      const m = K(p.folder);
      Array.isArray(c[m]) || (c[m] = []), c[m].push(p);
    } else
      a.push(p);
  const u = Object.entries(c).map((p) => ({
    label: p[0],
    store: n ? t.getStore(`${s}-settings-folder-${p[0]}`) : void 0,
    settings: p[1]
  })), d = [];
  for (const p of M(this, hu)) {
    const m = {
      class: p.class,
      props: p.props,
      styles: p.styles
    };
    if (typeof p.folder == "string") {
      const g = K(p.folder);
      m.folder = {
        label: g,
        store: n ? t.getStore(`${s}-settings-folder-${g}`) : void 0
      };
    } else if (ke(p.folder)) {
      const g = K(p.folder.label);
      m.folder = {
        label: g,
        store: n ? t.getStore(`${s}-settings-folder-${g}`) : void 0,
        summaryEnd: p.folder.summaryEnd,
        styles: p.folder.styles
      };
    }
    d.push(m);
  }
  return {
    storeScrollbar: o,
    topLevel: a,
    folders: u,
    sections: d
  };
}, "#parseSettings"), _m = new WeakSet(), W7 = /* @__PURE__ */ f(async function({ world: e = !1 } = {}) {
  let t = K("SETTINGS.ReloadPromptTitle"), s = K("SETTINGS.ReloadPromptBody");
  t = t !== "SETTINGS.ReloadPromptTitle" ? t : "Reload Application?", s = s !== "SETTINGS.ReloadPromptBody" ? s : "Some of the changed settings require a reload of the application to take effect. Would you like to reload now?", await Fs.confirm({
    modal: !0,
    draggable: !1,
    title: t,
    content: `<p>${s}</p>`
  }) && (e && globalThis.game.user.isGM && globalThis.game.socket.emit("reload"), window.location.reload());
}, "#reloadConfirm"), f(lA, "UIControl");
let T_ = lA;
var gu, bu, rl, _u, ym, K7, or, Ua;
const dc = class dc {
  /**
   * Creates the TJSGameSettings instance.
   *
   * @param {string}   namespace - The namespace for all settings.
   */
  constructor(e) {
    /**
     * Gets a store from the `stores` Map or creates a new store for the key.
     *
     * @param {string}   key - Key to lookup in stores map.
     *
     * @param {string}   [initialValue] - An initial value to set to new stores.
     *
     * @returns {import('svelte/store').Writable} The store for the given key.
     */
    Y(this, or);
    /** @type {string} */
    Y(this, gu, void 0);
    /** @type {GameSettingData[]} */
    Y(this, bu, []);
    /**
     * @type {Map<string, import('svelte/store').Writable>}
     */
    Y(this, rl, /* @__PURE__ */ new Map());
    /** @type {import('./types').UIControl} */
    Y(this, _u, void 0);
    if (typeof e != "string")
      throw new TypeError("'namespace' is not a string.");
    ye(this, gu, e), ye(this, _u, new T_(this));
  }
  /**
   * Provides an iterator / generator to return stored settings data.
   *
   * @returns {IterableIterator<GameSettingData>} An iterator of all game setting data.
   * @yields {GameSettingData}
   */
  *[Symbol.iterator]() {
    for (const e of M(this, bu))
      yield e;
  }
  /**
   * @returns {string} Returns namespace set in constructor.
   */
  get namespace() {
    return M(this, gu);
  }
  /**
   * @returns {import('./types').UIControl} The associated UIControl.
   */
  get uiControl() {
    return M(this, _u);
  }
  /**
   * Returns a readable Game Settings store for the associated key.
   *
   * @param {string}   key - Game setting key.
   *
   * @returns {import('svelte/store').Readable | undefined} The associated store for the given game setting key.
   */
  getReadableStore(e) {
    if (!M(this, rl).has(e)) {
      console.warn(`TJSGameSettings - getReadableStore: '${e}' is not a registered setting.`);
      return;
    }
    return { subscribe: Z(this, or, Ua).call(this, e).subscribe };
  }
  /**
   * Returns a writable Game Settings store for the associated key.
   *
   * @param {string}   key - Game setting key.
   *
   * @returns {import('svelte/store').Writable | undefined} The associated store for the given game setting key.
   */
  getStore(e) {
    return this.getWritableStore(e);
  }
  /**
   * Returns a writable Game Settings store for the associated key.
   *
   * @param {string}   key - Game setting key.
   *
   * @returns {import('svelte/store').Writable | undefined} The associated store for the given game setting key.
   */
  getWritableStore(e) {
    if (!M(this, rl).has(e)) {
      console.warn(`TJSGameSettings - getWritableStore: '${e}' is not a registered setting.`);
      return;
    }
    return Z(this, or, Ua).call(this, e);
  }
  /**
   * Registers a setting with TJSGameSettings and Foundry core.
   *
   * Note: The specific store subscription handler assigned to the passed in store or store created for the setting
   * internally is returned from this function. In some cases when setting up custom stores particularly of object
   * types with several child property stores (`propertyStore`) it is necessary to only update the setting store and
   * not all subscribers to the custom store as the `propertyStore` instances are also subscribers to the custom store.
   *
   * This allows the custom store in the `set` implementation to mainly only trigger the TJSGameSettings subscriber
   * handler on updates and not all the connected `propertyStore` instances.
   *
   * @param {GameSetting} setting - A GameSetting instance to set to Foundry game settings.
   *
   * @param {boolean}     coreConfig - When false this overrides the `setting.options.config` parameter when
   *                                   registering the setting with Foundry. This allows the settings to be displayed
   *                                   in the app itself, but removed from the standard Foundry configuration location.
   *
   * @returns {Function} The specific store subscription handler assigned to the passed in store.
   */
  register(e, t = !0) {
    if (!ke(e))
      throw new TypeError("TJSGameSettings - register: setting is not an object.");
    if (!ke(e.options))
      throw new TypeError("TJSGameSettings - register: 'setting.options' attribute is not an object.");
    if (typeof t != "boolean")
      throw new TypeError("TJSGameSettings - register: 'coreConfig' is not an boolean.");
    if (e.store !== void 0 && !pl(e.store))
      throw new TypeError(
        "TJSGameSettings - register: 'setting.store' attribute is not a writable store."
      );
    const s = e.namespace, n = e.key, l = e.folder, r = t ? e.options.config : !1;
    if (typeof s != "string")
      throw new TypeError("TJSGameSettings - register: 'namespace' attribute is not a string.");
    if (typeof n != "string")
      throw new TypeError("TJSGameSettings - register: 'key' attribute is not a string.");
    if (l !== void 0 && typeof l != "string")
      throw new TypeError("TJSGameSettings - register: 'folder' attribute is not a string.");
    const o = e.store, a = e.options, c = [];
    let u = !1;
    if (c.push((g) => {
      const h = Z(this, or, Ua).call(this, n);
      h && !u && (u = !0, h.set(g), u = !1);
    }), vt(a == null ? void 0 : a.onChange))
      for (const g of a.onChange)
        typeof g == "function" && c.push(g);
    else
      typeof a.onChange == "function" && c.push(a.onChange);
    const d = /* @__PURE__ */ f((g) => {
      for (const h of c)
        h(g);
    }, "onChange");
    globalThis.game.settings.register(s, n, { ...a, config: r, onChange: d });
    const p = o || Z(this, or, Ua).call(this, n, globalThis.game.settings.get(s, n));
    o && (M(this, rl).set(n, p), o.set(globalThis.game.settings.get(s, n)));
    const m = /* @__PURE__ */ f(async (g) => {
      !u && globalThis.game.settings.get(s, n) !== g && (u = !0, await globalThis.game.settings.set(s, n, g)), u = !1;
    }, "storeHandler");
    return tc(p, m), M(this, bu).push({
      namespace: s,
      key: n,
      folder: l,
      ...a
    }), m;
  }
  /**
   * Registers multiple settings.
   *
   * Please refer to the note in {@link TJSGameSettings.register} about the returned object of store subscriber handler
   * functions.
   *
   * @param {Iterable<GameSetting>} settings - An iterable list of game setting configurations to register.
   *
   * @param {boolean}     coreConfig - When false this overrides the `setting.options.config` parameter when
   *                                   registering the setting with Foundry. This allows the settings to be displayed
   *                                   in the app itself, but removed from the standard Foundry configuration location.
   *
   * @returns { {[key: string]: Function} } An object containing all TJSGameSetting store subscriber handlers for each
   *          setting `key` added.
   */
  registerAll(e, t) {
    const s = {};
    if (!vt(e))
      throw new TypeError("TJSGameSettings - registerAll: settings is not iterable.");
    for (const n of e) {
      if (!ke(n))
        throw new TypeError("TJSGameSettings - registerAll: entry in settings is not an object.");
      if (typeof n.namespace != "string")
        throw new TypeError("TJSGameSettings - registerAll: entry in settings missing 'namespace' attribute.");
      if (typeof n.key != "string")
        throw new TypeError("TJSGameSettings - registerAll: entry in settings missing 'key' attribute.");
      if (!ke(n.options))
        throw new TypeError("TJSGameSettings - registerAll: entry in settings missing 'options' attribute.");
      s[n.key] = this.register(n, t);
    }
    return s;
  }
};
gu = new WeakMap(), bu = new WeakMap(), rl = new WeakMap(), _u = new WeakMap(), ym = new WeakSet(), K7 = /* @__PURE__ */ f(function(e) {
  return It(e);
}, "#createStore"), or = new WeakSet(), Ua = /* @__PURE__ */ f(function(e, t) {
  var n;
  let s = M(this, rl).get(e);
  return s === void 0 && (s = Z(n = dc, ym, K7).call(n, t), M(this, rl).set(e, s)), s;
}, "#getStore"), /**
 * Creates a new writable for the given key.
 *
 * @param {*}  initialValue - An initial value to set to new stores.
 *
 * @returns {import('svelte/store').Writable} The new writable.
 */
Y(dc, ym), f(dc, "TJSGameSettings");
let C_ = dc;
const vm = class vm {
  constructor(e = !1) {
    this.version = this.constructor.version, this.requiresFlush = !1;
  }
  /**
   *
   * @param {Object} actorData
   * @returns {Promise<void>}
   */
  async updateActor(e) {
  }
  /**
   *
   * @param {*} itemData
   * @param {*} actorData
   * @returns {Promise<void>}
   */
  async preUpdateItem(e, t) {
  }
  /**
   *
   * @param {*} itemData
   * @returns {Promise<void>}
   */
  async updateItem(e, t) {
  }
  /**
   *
   * @param {*} macroData
   * @returns {Promise<void>}
   */
  async updateMacro(e) {
  }
  /**
   *
   * @param {*} tokenData
   * @returns {Promise<void>}
   */
  async updateToken(e, t, s) {
  }
  /**
   *
   * @param {*} userData
   * @returns {Promise<void>}
   */
  async updateUser(e) {
  }
  /**
   *
   * @returns {Promise<void>}
   */
  async migrate() {
  }
};
f(vm, "MigrationBase"), Ge(vm, "version");
let ls = vm;
var Lo, nd;
const Ol = class Ol {
  /**
   *
   * @param {Array<MigrationBase>} migrations
   */
  constructor(e) {
    /**
     *
     * @param {Object} schema
     * @param {MigrationBase} latestMigration
     */
    Y(this, Lo);
    this.migrations = e.sort((t, s) => t.version - s.version);
  }
  /**
   *
   * @param {Number} currentVersion
   * @returns {Boolean}
   */
  needsMigration(e) {
    return e < Ol.LATEST_SCHEMA_VERSION;
  }
  /**
   *
   * @param {Array<Object>} original
   * @param {Array<Object>} updated
   */
  diffCollection(e, t) {
    const s = {
      inserted: [],
      deleted: [],
      updated: []
    }, n = /* @__PURE__ */ new Map();
    return e.forEach((l) => n.set(l._id, l)), t.forEach((l) => {
      const r = n.get(l._id);
      r ? (JSON.stringify(r) !== JSON.stringify(l) && s.updated.push(l), n.delete(l._id)) : s.inserted.push(l);
    }), n.forEach((l) => s.deleted.push(l._id)), s;
  }
  /**
   *
   * @param {Object} actor
   * @param {Array<MigrationBase>} migrations
   * @returns {Object}
   */
  async getUpdatedActor(e, t) {
    var n, l, r, o, a, c;
    const s = foundry.utils.deepClone(e);
    for (const u of t)
      try {
        await ((n = u == null ? void 0 : u.updateActor) == null ? void 0 : n.call(u, s));
        for (const d of s.items)
          try {
            await ((l = u == null ? void 0 : u.preUpdateItem) == null ? void 0 : l.call(u, d, s)), await ((r = u == null ? void 0 : u.updateItem) == null ? void 0 : r.call(u, d, s));
          } catch (p) {
            console.error(p);
          }
        for (const d of s.effects)
          try {
            await ((o = u == null ? void 0 : u.updateEffect) == null ? void 0 : o.call(u, d, s));
          } catch (p) {
            console.error(p);
          }
      } catch (d) {
        console.error(d);
      }
    if ("game" in globalThis) {
      const u = t.slice(-1)[0];
      (a = s.system).schemaVersion ?? (a.schemaVersion = { version: null, lastMigration: null }), Z(this, Lo, nd).call(this, s.system.schemaVersion, u);
      for (const d of s.items)
        (c = d.system).schemaVersion ?? (c.schemaVersion = { version: null, lastMigration: null }), Z(this, Lo, nd).call(this, d.system.schemaVersion, u);
    }
    return s;
  }
  /**
   *
   * @param {Object} item
   * @param {Array<MigrationBase>} migrations
   * @returns {Object}
   */
  async getUpdatedItem(e, t) {
    var n, l, r, o;
    const s = foundry.utils.deepClone(e);
    try {
      for (const a of t) {
        await ((n = a == null ? void 0 : a.preUpdateItem) == null ? void 0 : n.call(a, s)), await ((l = a == null ? void 0 : a.updateItem) == null ? void 0 : l.call(a, s));
        for (const c of s.effects)
          try {
            await ((r = a == null ? void 0 : a.updateEffect) == null ? void 0 : r.call(a, c, s));
          } catch (u) {
            console.error(u);
          }
      }
    } catch (a) {
      console.error(a);
    }
    return t.length > 0 && Z(this, Lo, nd).call(this, (o = s.system) == null ? void 0 : o.schemaVersion, t.slice(-1)[0]), s;
  }
  /**
   *
   * @param {Object} macro
   * @param {Array<MigrationBase>} migrations
   * @returns {Object}
   */
  async getUpdatedMacro(e, t) {
    var n;
    const s = foundry.utils.deepClone(e);
    for (const l of t)
      try {
        await ((n = l == null ? void 0 : l.updateMacro) == null ? void 0 : n.call(l, s));
      } catch (r) {
        console.error(r);
      }
    return s;
  }
  /**
   * @param {Object} journal
   * @param {Array<MigrationBase>} migrations
   * @returns {Object}
   */
  async getUpdatedJournalEntry(e, t) {
    var n;
    const s = deepClone(e);
    for (const l of t)
      try {
        await ((n = l.updateJournalEntry) == null ? void 0 : n.call(l, s));
      } catch (r) {
        console.error(r);
      }
    return s;
  }
  /**
   *
   * @param {Object} token
   * @param {Array<MigrationBase>} migrations
   * @returns {Object}
   */
  async getUpdatedToken(e, t) {
    var n;
    const s = e.toObject();
    for (const l of t)
      try {
        await ((n = l == null ? void 0 : l.updateToken) == null ? void 0 : n.call(l, s, e.actor, e.scene));
      } catch (r) {
        console.error(r);
      }
    return s;
  }
  /**
   *
   * @param {*} user
   * @param {Array<MigrationBase>} migrations
   * @returns {Object}
   */
  async getUpdatedUser(e, t) {
    var n;
    const s = foundry.utils.deepClone(e);
    for (const l of t)
      try {
        await ((n = l == null ? void 0 : l.updateUser) == null ? void 0 : n.call(l, s));
      } catch (r) {
        console.error(r);
      }
    return s;
  }
};
Lo = new WeakSet(), nd = /* @__PURE__ */ f(function(e = {}, t = null) {
  if (!("game" in globalThis && t))
    return;
  const s = typeof (e == null ? void 0 : e.version) == "number" ? e.version : null;
  e.version = t == null ? void 0 : t.version, e.lastMigration = {
    version: {
      schema: s,
      foundry: game.version,
      system: game.system.version
    }
  };
}, "#updateSchemaRecord"), f(Ol, "MigrationRunnerBase"), Ge(Ol, "LATEST_SCHEMA_VERSION", 0.019), Ge(Ol, "MIN_SAFE_VERSION", 0), Ge(Ol, "RECOMMENDED_SAFE_VERSION", 0);
let wr = Ol;
var ar;
const rA = class rA {
  constructor({ max: e, label: t }) {
    Y(this, ar, 0);
    this.label = t ?? "", this.max = e, ye(this, ar, 0);
  }
  advance({ by: e = 1, label: t = this.label }) {
    if (M(this, ar) === this.max)
      return;
    ye(this, ar, M(this, ar) + Math.abs(e));
    const s = Math.floor(M(this, ar) / this.max * 100);
    SceneNavigation.displayProgressBar({ label: t, pct: s });
  }
  close({ label: e = "" } = {}) {
    SceneNavigation.displayProgressBar({ label: e, pct: 100 });
  }
};
ar = new WeakMap(), f(rA, "Progress");
let Bd = rA;
var Bo, id, km, Y7, cr, Va, qo, ld, wm, X7, $m, J7, Am, Z7, Em, Q7;
const pc = class pc extends wr {
  constructor() {
    super(...arguments);
    /**
    * Migrate actor or item documents in batches of 50
     * @param {*} collection
     * @param {Array<MigrationBase>} migrations
     * @param {Progress} progress
     * @returns {Promise<void>}
     */
    Y(this, Bo);
    /**
     * Migrate adventure documents
     * @param {*} collection
     * @param {Array<MigrationBase>} migrations
     * @returns {Promise<void>}
     */
    Y(this, km);
    /**
     *
     * @param {Array<MigrationBase>} migrations
     * @param {Object} actor
     * @param {Promise<Object>} options
     */
    Y(this, cr);
    /**
     *
     * @param {Array<MigrationBase>} migrations
     * @param {Object} item
     * @param {Promise<Object>} options
     */
    // eslint-disable-next-line no-unused-vars, @typescript-eslint/no-unused-vars
    Y(this, qo);
    /**
     * @param {Object} journal
     * @param {Array<MigrationBase>} migrations
     * @param {Progress} progress
     */
    Y(this, wm);
    /**
     *
     * @param {Object} macro
     * @param {Array<MigrationBase>} migrations
     */
    Y(this, $m);
    /**
     *
     * @param {Object} token
     * @param {Array<MigrationBase>} migrations
     */
    Y(this, Am);
    /**
     *
     * @param {Object} user
     * @param {Array<MigrationBase>} migrations
     */
    Y(this, Em);
  }
  /**
   * @override
   * @returns {Boolean}
   * */
  needsMigration() {
    return super.needsMigration(game.settings.get("a5e", "worldSchemaVersion"));
  }
  /**
   * Ensure that an actor or item reflects the current data schema before it is created
   * @param {Object} document
   * @param {Array<MigrationBase>} migrations
   * @returns {Promise<void>}
   */
  static async ensureSchemaVersion(t, s) {
    if (s.length === 0)
      return;
    const n = this.LATEST_SCHEMA_VERSION;
    if (Number(t.schemaVersion) || n > 0) {
      const l = new this(s), r = t._source, o = await (async () => {
        try {
          return "items" in r ? await l.getUpdatedActor(r, l.migrations) : await l.getUpdatedItem(r, l.migrations);
        } catch {
          return null;
        }
      })();
      o && t.updateSource(o);
    }
    if (t.updateSource({ "system.schemaVersion.version": n }), "items" in t && "token" in t)
      for (const l of t.items)
        l.updateSource({ "system.schemaVersion.version": n });
  }
  async runDocumentMigration(t, s) {
    var r;
    if ((((r = t.system.schemaVersion) == null ? void 0 : r.version) ?? t.system.schema.version ?? 0) >= pc.LATEST_SCHEMA_VERSION || !["Actor", "Item"].includes(t.documentName))
      return !1;
    const l = "items" in t ? await Z(this, cr, Va).call(this, s, t) : await Z(this, qo, ld).call(this, s, t);
    return await t.update(l), !0;
  }
  /**
   *
   * @param {Object} compendium
   * @returns {Promise<void>}
   */
  async runCompendiumMigration(t, s = !1) {
    if (!["Adventure", "Actor", "Item"].includes(t.documentName))
      return;
    const n = new Bd({
      label: K("A5E.migration.compendium.running"),
      max: t.index.size
    }), l = await t.getDocuments();
    let r;
    s ? r = 0 : t.documentName === "Adventure" ? r = Math.min(
      wr.LATEST_SCHEMA_VERSION,
      ...l.flatMap((c) => {
        const u = [...c.items].map((p) => {
          var m, g;
          return (g = (m = p.system) == null ? void 0 : m.schema) == null ? void 0 : g.version;
        }).filter((p) => !!p), d = [...c.items].map((p) => {
          var m, g;
          return (g = (m = p.system) == null ? void 0 : m.schema) == null ? void 0 : g.version;
        }).filter((p) => !!p);
        return [...u, ...d];
      })
    ) : r = Math.min(
      wr.LATEST_SCHEMA_VERSION,
      ...l.map((c) => {
        var u, d;
        return ((d = (u = c.system) == null ? void 0 : u.schema) == null ? void 0 : d.version) ?? 0;
      }).filter((c) => !!c)
    ), console.log(`A5E | Lowest Schema Version: ${r}`);
    const o = this.migrations.filter((c) => c.version > r), a = t.locked;
    a && await t.configure({ locked: !1 }), t.documentName === "Adventure" ? await Z(this, km, Y7).call(this, t, o) : await Z(this, Bo, id).call(this, t, o, n), a && await t.configure({ locked: !0 }), n.close();
  }
  /**
   *
   * @param {Array<migrations>} migrations
   * @returns {Promise<void>}
   */
  async runMigrations(t) {
    var l, r;
    if (t.length === 0)
      return;
    console.info(`A5E | Found ${t.length} migrations`);
    const s = new Bd({
      label: K("A5E.migration.running"),
      max: Math.floor(
        game.actors.size + game.items.size + game.journal.size + game.scenes.map((o) => o.tokens.contents).flat().filter((o) => {
          var a;
          return (a = o.actor) == null ? void 0 : a.isToken;
        }).length
      )
    });
    console.info(`A5E | Migrating ${game.actors.size} actors.`), await Z(this, Bo, id).call(this, game.actors, t, s), console.info(`A5E | Migrating ${game.items.size} items.`), await Z(this, Bo, id).call(this, game.items, t, s);
    for (const o of game.journal)
      await Z(this, wm, X7).call(this, o, t, s);
    const n = [];
    game.macros.forEach((o) => n.push(Z(this, $m, J7).call(this, o, t))), game.users.forEach((o) => n.push(Z(this, Em, Q7).call(this, o, t))), console.info(`A5E | Migrating ${n.length} macros & users.`), t.forEach((o) => {
      o.migrate && n.push(o.migrate());
    }), await Promise.allSettled(n), console.info(`A5E | Migrating ${game.scenes.size} scenes.`);
    for (const o of game.scenes) {
      console.info(`A5E | Migrating ${o.tokens.size} tokens in ${o.id}.`);
      for (const a of o.tokens) {
        const { actor: c } = a;
        if (!c || !!!await Z(this, Am, Z7).call(this, a, t))
          continue;
        const d = (l = a.delta) == null ? void 0 : l.source, p = !!d && ((r = d.flags) == null ? void 0 : r.a5e) || ((d ?? {}).items ?? []).length > 0 || Object.keys((d == null ? void 0 : d.system) ?? {}).length > 0;
        if (c.isToken && p) {
          const m = await Z(this, cr, Va).call(this, t, c);
          if (m)
            try {
              await c.update(m, { noHook: !0 });
            } catch (g) {
              console.warn(g);
            }
          s.advance();
        }
      }
    }
    s.close();
    for (const o of game.packs)
      o.metadata.packageType === "world" && ["Actor", "Item"].includes(o.documentName) && (ui.notifications.info(K("A5E.migration.compendium.starting", { packName: o.metadata.label })), console.info(`A5E | Migrating ${o.index.size} documents in ${o.metadata.id}.`), await this.runCompendiumMigration(o, s), ui.notifications.info(K("A5E.migration.compendium.finished", { packName: o.metadata.label })));
  }
  /**
   *
   * @param {Boolean} force
   * @returns {Promise<void>}
   */
  async runMigration(t = !1) {
    const s = {
      latest: pc.LATEST_SCHEMA_VERSION,
      current: game.settings.get("a5e", "worldSchemaVersion")
    }, n = game.system.version;
    ui.notifications.info(K("A5E.migration.starting", { version: n }), {
      permanent: !0
    });
    const l = t ? this.migrations : this.migrations.filter((o) => s.current < o.version), r = [[]];
    for (const o of l)
      r[r.length - 1].push(o), o.requiresFlush && r.push([]);
    for (const o of r)
      o.length > 0 && await this.runMigrations(o);
    ui.notifications.info(K("A5E.migration.finished", { version: n }), {
      permanent: !0
    }), await game.settings.set("a5e", "worldSchemaVersion", s.latest), await game.settings.set("a5e", "systemMigrationVersion", game.system.version);
  }
};
Bo = new WeakSet(), id = /* @__PURE__ */ f(async function(t, s, n) {
  const { documentClass: l } = t, r = "metadata" in t ? t.metadata.id : null, o = [];
  for (const a of t.contents) {
    if (o.length === 50)
      try {
        await l.updateDocuments(o, { noHook: !0, pack: r });
      } catch (u) {
        console.error(u);
      } finally {
        n == null || n.advance({ by: o.length }), o.length = 0;
      }
    const c = "items" in a ? await Z(this, cr, Va).call(this, s, a, { pack: r }) : await Z(this, qo, ld).call(this, s, a, { pack: r });
    c && o.push(c);
  }
  if (o.length > 0)
    try {
      await l.updateDocuments(o, { noHook: !0, pack: r });
    } catch (a) {
      n == null || n.advance({ by: o.length }), console.warn(a);
    }
}, "#migrateDocuments"), km = new WeakSet(), Y7 = /* @__PURE__ */ f(async function(t, s) {
  const n = "metadata" in t ? t.metadata.id : null;
  for (const l of t.contents) {
    const r = [], o = [...l.actors], a = [...l.items];
    for (const c of o) {
      const u = await Z(this, cr, Va).call(this, s, c, { pack: n, isAdventure: !0 });
      u && r.push(u);
    }
    try {
      await l.update({ actors: r }, { noHook: !0, pack: n });
    } catch (c) {
      console.warn(c);
    }
    r.length = 0;
    for (const c of a) {
      const u = await Z(this, qo, ld).call(this, s, c, { pack: n });
      u && r.push(u);
    }
    try {
      await l.update({ items: r }, { noHook: !0, pack: n });
    } catch (c) {
      console.warn(c);
    }
  }
}, "#migrateAdventureDocuments"), cr = new WeakSet(), Va = /* @__PURE__ */ f(async function(t, s, n = {}) {
  const { isAdventure: l, pack: r } = n, o = s._source ?? s.toObject(), a = await (() => {
    try {
      return this.getUpdatedActor(o, t);
    } catch (h) {
      return h instanceof Error && console.error(`Error thrown while migrating ${s.uuid}: ${h.message}`), null;
    }
  })();
  if (!a)
    return null;
  const c = [...o.items], u = [...a.items], d = this.diffCollection(c, u);
  if (d.deleted.length > 0)
    try {
      const h = d.deleted.filter((_) => s.items.some((y) => y.id === _));
      await s.deleteEmbeddedDocuments("Item", h, { noHook: !0, pack: r });
    } catch (h) {
      console.warn(h);
    }
  if (d.inserted.length > 0)
    try {
      await s.createEmbeddedDocuments("Item", d.inserted, { noHook: !0, pack: r });
    } catch (h) {
      console.warn(h);
    }
  a.items = s.isToken || l ? u : d.updated;
  const p = [...o.effects], m = [...a.effects], g = this.diffCollection(p, m);
  if (g.deleted.length > 0)
    try {
      const h = g.deleted.filter((_) => s.effects.some((y) => y.id === _));
      await s.deleteEmbeddedDocuments("ActiveEffect", h, { noHook: !0, pack: r });
    } catch (h) {
      console.warn(h);
    }
  if (g.inserted.length > 0)
    try {
      await s.createEmbeddedDocuments("ActiveEffect", g.inserted, { noHook: !0, pack: r });
    } catch (h) {
      console.warn(h);
    }
  return a.effects = s.isToken || l ? m : g.updated, a;
}, "#migrateActor"), qo = new WeakSet(), ld = /* @__PURE__ */ f(async function(t, s, n = {}) {
  const { isAdventure: l, pack: r } = n, o = s._source ?? s.toObject(), a = await (() => {
    try {
      return this.getUpdatedItem(o, t);
    } catch (p) {
      return p instanceof Error && console.error(`Error thrown while migrating ${s.uuid}: ${p.message}`), null;
    }
  })();
  if (!a)
    return null;
  const c = [...o.effects], u = [...a.effects], d = this.diffCollection(c, u);
  if (d.deleted.length > 0)
    try {
      const p = d.deleted.filter((m) => s.effects.some((g) => g.id === m));
      await s.deleteEmbeddedDocuments("ActiveEffect", p, { noHook: !0, pack: r });
    } catch (p) {
      console.warn(p);
    }
  if (d.inserted.length > 0)
    try {
      await s.createEmbeddedDocuments("ActiveEffect", d.inserted, { noHook: !0, pack: r });
    } catch (p) {
      console.warn(p);
    }
  return a.effects = l ? u : d.updated, a;
}, "#migrateItem"), wm = new WeakSet(), X7 = /* @__PURE__ */ f(async function(t, s, n) {
  if (s.some((l) => !!l.updateJournalEntry)) {
    try {
      const l = await this.getUpdatedJournalEntry(t.toObject(), s), r = diffObject(t.toObject(), l);
      Object.keys(r).length > 0 && await t.update(r, { noHook: !0 });
    } catch (l) {
      console.warn(l);
    }
    n.advance();
  }
}, "#migrateWorldJournalEntry"), $m = new WeakSet(), J7 = /* @__PURE__ */ f(async function(t, s) {
  if (s.some((n) => !!n.updateMacro))
    try {
      const n = await this.getUpdatedMacro(t.toObject(), s), l = foundry.utils.diffObject(t.toObject(), n);
      Object.keys(l).length > 0 && await t.update(l, { noHook: !0 });
    } catch (n) {
      console.warn(n);
    }
}, "#migrateWorldMacro"), Am = new WeakSet(), Z7 = /* @__PURE__ */ f(async function(t, s) {
  if (!s.some((n) => !!n.updateToken))
    return t.toObject();
  try {
    const n = await this.getUpdatedToken(t, s), l = diffObject(t.toObject(), n);
    if (Object.keys(l).length > 0)
      try {
        await t.update(l, { noHook: !0 });
      } catch (r) {
        console.warn(r);
      }
    return n;
  } catch (n) {
    return console.error(n), null;
  }
}, "#migrateSceneToken"), Em = new WeakSet(), Q7 = /* @__PURE__ */ f(async function(t, s) {
  if (s.some((n) => !!n.updateUser))
    try {
      const n = t.toObject(), l = await this.getUpdatedUser(n, s), r = diffObject(t.toObject(), l);
      Object.keys(r).length > 0 && await t.update(r, { noHook: !0 });
    } catch (n) {
      console.error(n);
    }
}, "#migrateUser"), f(pc, "MigrationRunner");
let Dn = pc;
function OH(i) {
  i.ACTIVE_EFFECT_MODES = {
    CUSTOM: 0,
    MULTIPLY: 1,
    ADD: 2,
    SUBTRACT: 3,
    DOWNGRADE: 4,
    UPGRADE: 5,
    OVERRIDE: 6,
    CONDITIONAL: 7
  }, i.activeEffectTypes = {
    onUse: "A5E.effects.types.plural.onUse",
    ongoing: "A5E.effects.types.plural.ongoing",
    inactive: "A5E.effects.types.plural.inactive",
    passive: "A5E.effects.types.plural.passive",
    temporary: "A5E.effects.types.plural.temporary"
  }, i.conditionIconsDefault = {
    blinded: "icons/svg/blind.svg",
    bloodied: "icons/svg/blood.svg",
    charmed: "systems/a5e/assets/icons/charmed.svg",
    concentration: "systems/a5e/assets/icons/concentration.svg",
    confused: "systems/a5e/assets/icons/confused.svg",
    deafened: "icons/svg/deaf.svg",
    dead: "icons/svg/skull.svg",
    doomed: "systems/a5e/assets/icons/doomed.svg",
    encumbered: "systems/a5e/assets/icons/encumbered.svg",
    fatigue: "systems/a5e/assets/icons/fatigue.svg",
    frightened: "icons/svg/terror.svg",
    grappled: "systems/a5e/assets/icons/grappled.svg",
    incapacitated: "systems/a5e/assets/icons/incapacitated.svg",
    invisible: "icons/svg/invisible.svg",
    paralyzed: "icons/svg/paralysis.svg",
    petrified: "systems/a5e/assets/icons/petrified.svg",
    poisoned: "icons/svg/poison.svg",
    prone: "icons/svg/falling.svg",
    rattled: "systems/a5e/assets/icons/rattled.svg",
    restrained: "icons/svg/net.svg",
    slowed: "systems/a5e/assets/icons/slowed.svg",
    strife: "systems/a5e/assets/icons/strife.svg",
    stunned: "icons/svg/daze.svg",
    unconscious: "icons/svg/unconscious.svg"
  }, Array.from({ length: 10 }, (e, t) => i.conditionIconsDefault[`generic${t + 1}`] = `systems/a5e/assets/icons/circle${t + 1}.svg`), i.actionActiveEffectTypes = {
    onUse: "A5E.effects.types.singular.onUse"
  }, i.actionActiveEffectTypesPlural = {
    onUse: "A5E.effects.types.plural.onUse"
  }, i.itemActiveEffectTypes = {
    passive: "A5E.effects.types.singular.passive"
  }, i.itemActiveEffectTypesPlural = {
    passive: "A5E.effects.types.plural.passive"
  }, i.effectDurationTypes = {
    seconds: "A5E.effects.durationTypes.plural.seconds",
    rounds: "A5E.effects.durationTypes.plural.roundsAndTurns"
  }, i.effectDurationUnits = {
    seconds: "A5E.effects.durationUnits.plural.seconds",
    minutes: "A5E.effects.durationUnits.plural.minutes",
    hours: "A5E.effects.durationUnits.plural.hours"
  }, i.EXPANDED_EFFECTS = /* @__PURE__ */ new Set([
    "system.attributes.spellDC",
    "flags.a5e.effects.movement.allDistances",
    "flags.a5e.effects.movement.allUnits",
    "flags.a5e.effects.senses.allSenses",
    "flags.a5e.effects.senses.allUnits"
  ]);
}
f(OH, "registerActiveEffectConfig");
function DH(i) {
  i.bonusTypes = {
    abilities: "A5E.Ability",
    attacks: "A5E.Attack",
    damage: "A5E.Damage",
    exertion: "A5E.Exertion",
    healing: "A5E.Healing",
    hitPoint: "A5E.HitPoints",
    initiative: "A5E.Initiative",
    movement: "A5E.Movement",
    senses: "A5E.Senses",
    skills: "A5E.Skill"
  }, i.bonusDialogKeys = {
    abilities: "abilityBonus",
    attacks: "attackBonus",
    damage: "damageBonus",
    exertion: "exertionBonus",
    healing: "healingBonus",
    hitPoint: "hitPointsBonus",
    initiative: "initiativeBonus",
    movement: "movementBonus",
    senses: "sensesBonus",
    skills: "skillBonus"
  }, i.bonusLabels = {
    abilities: {
      addButton: "A5E.bonuses.labels.abilities.addButton",
      sectionHeader: "A5E.bonuses.labels.abilities.sectionHeader",
      defaultName: "A5E.bonuses.labels.abilities.defaultName",
      dialogName: "A5E.bonuses.labels.abilities.dialogName"
    },
    attacks: {
      addButton: "A5E.bonuses.labels.attack.addButton",
      sectionHeader: "A5E.bonuses.labels.attack.sectionHeader",
      defaultName: "A5E.bonuses.labels.attack.defaultName",
      dialogName: "A5E.bonuses.labels.attacks.dialogName"
    },
    damage: {
      addButton: "A5E.bonuses.labels.damage.addButton",
      sectionHeader: "A5E.bonuses.labels.damage.sectionHeader",
      defaultName: "A5E.bonuses.labels.damage.defaultName",
      dialogName: "A5E.bonuses.labels.damage.dialogName"
    },
    exertion: {
      addButton: "A5E.bonuses.labels.exertion.addButton",
      sectionHeader: "A5E.bonuses.labels.exertion.sectionHeader",
      defaultName: "A5E.bonuses.labels.exertion.defaultName",
      dialogName: "A5E.bonuses.labels.exertion.dialogName"
    },
    healing: {
      addButton: "A5E.bonuses.labels.healing.addButton",
      sectionHeader: "A5E.bonuses.labels.healing.sectionHeader",
      defaultName: "A5E.bonuses.labels.healing.defaultName",
      dialogName: "A5E.bonuses.labels.healing.dialogName"
    },
    hitPoint: {
      addButton: "A5E.bonuses.labels.hitPoint.addButton",
      sectionHeader: "A5E.bonuses.labels.hitPoint.sectionHeader",
      defaultName: "A5E.bonuses.labels.hitPoint.defaultName",
      dialogName: "A5E.bonuses.labels.hitPoint.dialogName"
    },
    initiative: {
      addButton: "A5E.bonuses.labels.initiative.addButton",
      sectionHeader: "A5E.bonuses.labels.initiative.sectionHeader",
      defaultName: "A5E.bonuses.labels.initiative.defaultName",
      dialogName: "A5E.bonuses.labels.initiative.dialogName"
    },
    movement: {
      addButton: "A5E.bonuses.labels.movement.addButton",
      sectionHeader: "A5E.bonuses.labels.movement.sectionHeader",
      defaultName: "A5E.bonuses.labels.movement.defaultName",
      dialogName: "A5E.bonuses.labels.movement.dialogName"
    },
    senses: {
      addButton: "A5E.bonuses.labels.senses.addButton",
      sectionHeader: "A5E.bonuses.labels.senses.sectionHeader",
      defaultName: "A5E.bonuses.labels.senses.defaultName",
      dialogName: "A5E.bonuses.labels.senses.dialogName"
    },
    skills: {
      addButton: "A5E.bonuses.labels.skills.addButton",
      sectionHeader: "A5E.bonuses.labels.skills.sectionHeader",
      defaultName: "A5E.bonuses.labels.skills.defaultName",
      dialogName: "A5E.bonuses.labels.skills.dialogName"
    }
  };
}
f(DH, "registerBonusesConfig");
function IH(i) {
  i.classSpellLists = {
    artificer: "A5E.characterClasses.artificer",
    bard: "A5E.characterClasses.bard",
    cleric: "A5E.characterClasses.cleric",
    druid: "A5E.characterClasses.druid",
    elementalistAir: "A5E.characterClasses.elementalistAir",
    elementalistEarth: "A5E.characterClasses.elementalistEarth",
    elementalistFire: "A5E.characterClasses.elementalistFire",
    elementalistWater: "A5E.characterClasses.elementalistWater",
    herald: "A5E.characterClasses.herald",
    sorcerer: "A5E.characterClasses.sorcerer",
    warlock: "A5E.characterClasses.warlock",
    wielder: "A5E.characterClasses.wielder",
    witch: "A5E.characterClasses.witch",
    wizard: "A5E.characterClasses.wizard"
  }, i.characterClasses = {
    adept: "A5E.characterClasses.adept",
    artificer: "A5E.characterClasses.artificer",
    bard: "A5E.characterClasses.bard",
    berserker: "A5E.characterClasses.berserker",
    cleric: "A5E.characterClasses.cleric",
    druid: "A5E.characterClasses.druid",
    elementalist: "A5E.characterClasses.elementalist",
    esper: "A5E.characterClasses.esper",
    fighter: "A5E.characterClasses.fighter",
    herald: "A5E.characterClasses.herald",
    marshal: "A5E.characterClasses.marshal",
    ranger: "A5E.characterClasses.ranger",
    rogue: "A5E.characterClasses.rogue",
    savant: "A5E.characterClasses.savant",
    scholar: "A5E.characterClasses.scholar",
    sorcerer: "A5E.characterClasses.sorcerer",
    warlock: "A5E.characterClasses.warlock",
    wielder: "A5E.characterClasses.wielder",
    witch: "A5E.characterClasses.witch",
    wizard: "A5E.characterClasses.wizard"
  };
}
f(IH, "registerCharacterClassesConfig");
function PH(i) {
  i.configurableConsumers = /* @__PURE__ */ new Set([
    "actionUses",
    "itemUses",
    "hitDice",
    "spell"
  ]), i.resourceConsumerConfig = {
    exertion: { path: "attributes.exertion.current", label: "A5E.Exertion", type: "value" },
    hp: { path: "attributes.hp.value", label: "A5E.HitPoints", type: "value" },
    inspiration: { path: "attributes.inspiration", label: "A5E.Inspiration", type: "boolean" },
    primaryResource: { path: "resources.primary.value", label: "A5E.ResourcesPrimary", type: "value" },
    secondaryResource: { path: "resources.secondary.value", label: "A5E.ResourcesSecondary", type: "value" },
    tertiaryResource: { path: "resources.tertiary.value", label: "A5E.ResourcesTertiary", type: "value" },
    quaternaryResource: { path: "resources.quaternary.value", label: "A5E.ResourcesQuaternary", type: "value" }
  }, i.spellConsumerModes = {
    variable: "A5E.ConsumerSpellModeVariable",
    pointsOnly: "A5E.ConsumerSpellModePointsOnly",
    slotsOnly: "A5E.ConsumerSpellModeSlotsOnly"
  };
}
f(PH, "registerConsumerConfig");
function MH(i) {
  i.abilityBonusContexts = {
    base: "A5E.contexts.base",
    check: "A5E.contexts.check",
    save: "A5E.contexts.save"
  }, i.damageBonusContexts = {
    meleeWeaponAttack: "A5E.damageBonuses.contexts.meleeWeaponAttacks",
    meleeSpellAttack: "A5E.damageBonuses.contexts.meleeSpellAttacks",
    rangedWeaponAttack: "A5E.damageBonuses.contexts.rangedWeaponAttacks",
    rangedSpellAttack: "A5E.damageBonuses.contexts.rangedSpellAttacks"
  }, i.damageBonusSummariesByContext = {
    all: "A5E.damageBonuses.summaries.contexts.all",
    meleeWeaponAttack: "A5E.damageBonuses.summaries.contexts.meleeWeaponAttacks",
    meleeSpellAttack: "A5E.damageBonuses.summaries.contexts.meleeSpellAttacks",
    rangedWeaponAttack: "A5E.damageBonuses.summaries.contexts.rangedWeaponAttacks",
    rangedSpellAttack: "A5E.damageBonuses.summaries.contexts.rangedSpellAttacks",
    spellAttacks: "A5E.damageBonuses.summaries.contexts.spellAttacks",
    weaponAttacks: "A5E.damageBonuses.summaries.contexts.weaponAttacks"
  }, i.healingBonusContexts = {
    healing: "A5E.healingBonuses.contexts.healing",
    temporaryHealing: "A5E.healingBonuses.contexts.temporaryHealing"
  }, i.healingBonusSummariesByContext = {
    healing: "A5E.healingBonuses.summaries.contexts.healing",
    temporaryHealing: "A5E.healingBonuses.summaries.contexts.temporaryHealing"
  }, i.skillBonusContexts = {
    check: "A5E.contexts.check",
    passive: "A5E.contexts.passive"
  };
}
f(MH, "registerContextsConfig");
function O_(i) {
  try {
    return JSON.parse(i);
  } catch {
    return i;
  }
}
f(O_, "parseOrString");
function RH(i) {
  let e;
  try {
    e = JSON.parse(i), e = e instanceof Array ? e : [e];
  } catch {
    e = [i];
  }
  return e;
}
f(RH, "castArray");
function FH(i) {
  let e;
  try {
    e = JSON.parse(i), e = e instanceof Object ? e : {};
  } catch {
    e = {};
  }
  return e;
}
f(FH, "castObject");
function NH(i) {
  let e;
  try {
    e = O_(i), e = e instanceof Set ? e : new Set(e);
  } catch {
    e = /* @__PURE__ */ new Set([i]);
  }
  return e;
}
f(NH, "castSet");
function x7(i, e) {
  if (e === "Array")
    return RH(i);
  if (e === "Object")
    return FH(i);
  if (e === "Set")
    return NH(i);
  if (e === "boolean")
    return !!O_(i);
  if (e === "number") {
    const t = Number.fromString(i);
    return Number.isNaN(t) ? 0 : t;
  }
  return e === "string" ? String(i) : O_(i);
}
f(x7, "castType");
const jH = {
  "==": (i, e) => i === e,
  "!=": (i, e) => i !== e,
  ">=": (i, e) => i >= e,
  "<=": (i, e) => i <= e,
  ">": (i, e) => i > e,
  "<": (i, e) => i < e
};
function LH(i, e, t, s, n) {
  if (!i && i !== 0)
    return i;
  const l = jH[e];
  return l(i, t) ? s : n;
}
f(LH, "evaluateConditional");
function BH(i, e) {
  var o, a, c;
  const t = game.model.Actor[i.type] ?? {}, s = foundry.utils.getProperty(i, e) ?? null, n = ((c = (a = (o = game.a5e.activeEffects.options[i.type]) == null ? void 0 : o.allOptions) == null ? void 0 : a[e]) == null ? void 0 : c.sampleValue) ?? foundry.utils.getProperty(t, e) ?? null;
  if (s == null)
    return n;
  if (!n && n !== 0)
    return s;
  const l = foundry.utils.getType(s), r = foundry.utils.getType(n);
  if (l === r)
    return s;
  try {
    return x7(s, r);
  } catch {
    return console.error(
      `Actor [${i.id}] | Unable to parse active effect change for ${e}: "${s}"`
    ), null;
  }
}
f(BH, "getCorrectedTypeValueFromKey");
function D_(i, e) {
  return `(${Roll._splitParentheses(i).map((n) => {
    let l = [];
    (typeof n == "string" || n instanceof ParentheticalTerm) && (l = Roll.parse(n.term ?? n, e).map((o) => o instanceof DiceTerm ? new NumericTerm({ number: 0 }) : o));
    const r = Roll.getFormula(l);
    if ((typeof n == "string" || n instanceof ParentheticalTerm) && l.every(
      (o) => !(o instanceof ParentheticalTerm || o instanceof MathTerm || o instanceof DiceTerm)
    ))
      return r;
    if (l.find((o) => o instanceof ParentheticalTerm) || l.find((o) => o instanceof MathTerm))
      return D_(r);
    if (!n.isDeterministic)
      return "0";
    if (n instanceof MathTerm) {
      const o = n.terms.join(", ");
      return `${n.fn}(${o})`;
    }
    return r;
  }).join(" ")})`;
}
f(D_, "zeroDiceTerms");
function at(i, e = {}) {
  if (!i)
    return null;
  const t = D_(i.toString() || "0", e), s = new Roll(t, e);
  if (!Roll.validate(s.formula))
    throw Error("Invalid roll formula");
  const n = s.roll({ async: !1 }), l = s.dice.reduce((r, o) => r + o.total, 0);
  return n.total - l;
}
f(at, "getDeterministicBonus");
var Sm, e9, yu, I_, Tm, t9, Cm, s9, Om, n9, Go, rd, Dm, i9;
const Dl = class Dl extends ActiveEffect {
  constructor() {
    super(...arguments);
    /**
     * Returns the new value that should be applied to the actor.
     * @param {*} current
     * @param {*} change
     */
    Y(this, Sm);
    Y(this, yu);
    Y(this, Tm);
    Y(this, Cm);
    /**
     *
     * @param {import("../actor/actor").default| import("../item").default} document
     * @param {*} change
     * @param {*} delta
     */
    Y(this, Om);
    /**
     * Updates the canvas perception and lights if token effect has changed.
     * @param {Object} data
     */
    Y(this, Go);
    Y(this, Dm);
  }
  // -------------------------------------------------------
  //  Getters
  // -------------------------------------------------------
  /**
   * Convenience access to the ActiveEffect's icon field
   * @returns {String}
   */
  get img() {
    return this.icon || Dl.FALLBACK_ICON;
  }
  /**
   * @returns {Boolean}
   */
  get isSuppressed() {
    var s, n, l;
    if (this.disabled || !["Actor", "ActorDelta", "Token"].includes(this.parent.documentName))
      return !0;
    if (((n = (s = this.flags) == null ? void 0 : s.a5e) == null ? void 0 : n.transferType) === "onUse")
      return !1;
    const { parentItem: t } = this;
    return !t || (t == null ? void 0 : t.type) !== "object" ? !1 : ((l = t == null ? void 0 : t.system) == null ? void 0 : l.equippedState) !== CONFIG.A5E.EQUIPPED_STATES.EQUIPPED;
  }
  get parentItem() {
    var n, l;
    if (!(this.parent instanceof Actor))
      return null;
    const t = /Item\.([a-zA-Z0-9]+)/, s = (l = (n = this.origin) == null ? void 0 : n.match(t)) == null ? void 0 : l[1];
    return s ? this.parent.items.get(s) : null;
  }
  get isLocked() {
    var s, n, l;
    if (!["Actor", "ActorDelta", "Token"].includes(this.parent.documentName))
      return !0;
    if (((n = (s = this.flags) == null ? void 0 : s.a5e) == null ? void 0 : n.transferType) === "onUse")
      return !1;
    const { parentItem: t } = this;
    return !t || (t == null ? void 0 : t.type) !== "object" ? !1 : ((l = t == null ? void 0 : t.system) == null ? void 0 : l.equippedState) !== CONFIG.A5E.EQUIPPED_STATES.EQUIPPED;
  }
  // -------------------------------------------------------
  //  Class Methods
  // -------------------------------------------------------
  /**
   * @inheritdoc
   */
  apply(t, s, n = "applyAEs") {
    if (this.isSuppressed)
      return null;
    const l = foundry.utils.deepClone(s);
    if (l.key = l.key.replace("@token.", ""), n === "applyAEs") {
      const d = foundry.utils.deepClone(l.value).replace("@original", "");
      if (Roll.replaceFormulaData(
        d,
        t.getRollData(),
        { missing: null }
      ).includes("null"))
        return null;
    }
    const r = BH(t, l.key) ?? null;
    l.mode !== CONFIG.A5E.ACTIVE_EFFECT_MODES.CUSTOM && (l.value = l.value.replace("@original", r));
    const o = foundry.utils.getType(r), a = x7(
      Z(this, Om, n9).call(this, t, l),
      o
    ), c = Z(this, Sm, e9).call(this, t, r, l, a), u = { [l.key]: c };
    return foundry.utils.mergeObject(t, u), u;
  }
  // -------------------------------------------------------
  //  CRUD Methods
  // -------------------------------------------------------
  _onCreate(t, s, n) {
    var l;
    super._onCreate(t, s, n), Z(this, Go, rd).call(this), ((l = this.parent) == null ? void 0 : l.documentName) !== "Item" && Z(this, Dm, i9).call(this, t, n);
  }
  _preUpdate(t, s, n) {
    this._preUpdateParentEffect(t, s, n), this._preUpdateStatusEffects(t, s, n);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _preUpdateParentEffect(t, s, n) {
    var a, c, u;
    if (!(((a = this.parent) == null ? void 0 : a.parent) instanceof Actor))
      return;
    const l = this.parent.parent;
    if (((u = (c = this.flags) == null ? void 0 : c.a5e) == null ? void 0 : u.transferType) !== "passive")
      return;
    const r = l.effects.contents.find((d) => this.equals(d));
    if (!r)
      return;
    const o = foundry.utils.deepClone(t);
    delete o._id, r.update(o);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _preUpdateStatusEffects(t, s, n) {
    const l = t.changes ?? [], r = /* @__PURE__ */ new Set();
    l.forEach((o) => {
      if (o.key !== "flags.a5e.effects.statusConditions")
        return;
      let a;
      try {
        if (a = JSON.parse(o.value), !Array.isArray(a))
          return;
      } catch {
        return;
      }
      a.forEach((c) => {
        const u = CONFIG.statusEffects.find((d) => d.id === c);
        u && r.add(u.id);
      });
    }), r.size && (t.statuses = Array.from(r));
  }
  _onUpdate(t, s, n) {
    var r;
    if (super._onUpdate(t, s, n), Z(this, Go, rd).call(this), !(((r = this.parent) == null ? void 0 : r.parent) instanceof Actor))
      return;
    const l = this.parent.parent;
    l.effectPhases = null, l.reset();
  }
  _onDelete(t, s) {
    var n;
    super._onDelete(t, s), Z(this, Go, rd).call(this), ((n = this.parent) == null ? void 0 : n.documentName) === "Actor" && (this.parent.effectPhases = null, this.parent.reset());
  }
  async duplicateEffect() {
    const t = this.parent, s = foundry.utils.duplicate(this);
    s.name = `${K(s.name)} (Copy)`, t && t.createEmbeddedDocuments("ActiveEffect", [s]);
  }
  // -------------------------------------------------------
  //  Custom API
  // -------------------------------------------------------
  async toggleActiveState() {
    await this.update({ disabled: !this.disabled });
  }
  /**
  * Transfer effect to another document
  */
  transferEffect(t) {
    ["Actor", "ActorDelta", "Token"].includes(t.documentName) || ui.notifications.error(`Document of type ${t.documentName} is not supported by this operation.`);
    const s = foundry.utils.deepClone(this);
    s.origin = this.parent.uuid;
    const n = t.documentName === "Token" ? t.actor.effects.contents : t.effects.contents;
    for (const l of n)
      if (this.equals(l)) {
        l.update({ disabled: !1 });
        return;
      }
    t.createEmbeddedDocuments("ActiveEffect", [s]);
  }
  equals(t) {
    var l, r, o, a, c, u, d, p;
    const s = foundry.utils.deepClone(this.toObject()), n = foundry.utils.deepClone(t.toObject());
    return delete s._id, delete n._id, delete s.disabled, delete n.disabled, delete s.duration, delete n.duration, (r = (l = s.flags) == null ? void 0 : l.a5e) == null || delete r.sort, (a = (o = n.flags) == null ? void 0 : o.a5e) == null || delete a.sort, (u = (c = s.flags) == null ? void 0 : c.a5e) == null || delete u.actionId, (p = (d = n.flags) == null ? void 0 : d.a5e) == null || delete p.actionId, s.changes.forEach((m) => delete m.priority), n.changes.forEach((m) => delete m.priority), foundry.utils.objectsEqual(s, n);
  }
  // -------------------------------------------------------
  //  Static Methods
  // -------------------------------------------------------
  static generateExpandedEffects(t) {
    const s = [], n = [];
    t.forEach(({ change: l, effect: r }) => {
      var o, a;
      CONFIG.A5E.EXPANDED_EFFECTS.has(l.key) && (l.key === "flags.a5e.effects.movement.allDistances" && Object.keys(CONFIG.A5E.movement).forEach((u) => {
        const d = foundry.utils.deepClone(l);
        d.key = `system.attributes.movement.${u}.distance`, s.push({ effect: r, change: d }), n.push(l.key);
      }), l.key === "flags.a5e.effects.movements.allUnits" && Object.keys(CONFIG.A5E.movement).forEach((u) => {
        const d = foundry.utils.deepClone(l);
        d.key = `system.attributes.movement.${u}.unit`, s.push({ effect: r, change: d }), n.push(l.key);
      }), l.key === "flags.a5e.effects.senses.allSenses" && Object.keys(CONFIG.A5E.senses).forEach((u) => {
        const d = foundry.utils.deepClone(l);
        d.key = `system.attributes.senses.${u}.value`, s.push({ effect: r, change: d }), n.push(l.key);
      }), l.key === "flags.a5e.effects.senses.allUnits" && Object.keys(CONFIG.A5E.senses).forEach((u) => {
        const d = foundry.utils.deepClone(l);
        d.key = `system.attributes.senses.${u}.unit`, s.push({ effect: r, change: d }), n.push(l.key);
      }), l.key === "system.attributes.spellDC" && Object.keys(((a = (o = r.parent) == null ? void 0 : o.system) == null ? void 0 : a.spellBooks) ?? {}).forEach((u) => {
        const d = foundry.utils.deepClone(l);
        d.key = `system.spellBooks.${u}.stats.dc`, s.push({ effect: r, change: d });
      }));
    }), n.forEach((l) => {
      const r = t.findIndex((o) => o.change.key === l);
      r !== -1 && t.splice(r, 1);
    }), t.push(...s);
  }
  /**
   *
   * @param {} document
   * @param {Array<ActiveEffectA5e>} effects
   * @param {() => boolean} predicate
   */
  static applyEffects(t, s, n, l, r = () => !0) {
    var c;
    const o = {}, a = s.flatMap((u) => u.disabled || u.isSuppressed ? [] : (t.documentName !== "Token" && u.statuses.forEach((d) => t.statuses.add(d)), u._source.changes.filter(r).map((d) => {
      const p = (d.priority ?? 0) * d.mode;
      return d.priority = p ?? d.mode * 10, { effect: u, change: d };
    })));
    this.generateExpandedEffects(a), n === "afterDerived" && a.push(...((c = t.effectPhases) == null ? void 0 : c[n]) ?? []), a.sort((u, d) => (u.change.priority ?? 0) - (d.change.priority ?? 0)), a.forEach((u) => {
      var p, m, g;
      if (!((p = u.change) != null && p.key))
        return;
      let d;
      if (t.documentName === "Token" && n === "afterDerived")
        d = u.effect.apply(t, u.change, n), Object.assign(o, d);
      else {
        if (d = u.effect.apply(t, u.change, n), d === null && !u.effect.isSuppressed) {
          if (!l) {
            ui.notifications.error(K("A5E.notifications.effects.invalidChange"));
            return;
          }
          let h = ((m = t.effectPhases[l]) == null ? void 0 : m.findIndex((_) => _.effect._id === u.effect._id && _.change.key === u.change.key)) ?? -1;
          if (h === -1 && t.effectPhases[l].push(u), n === "afterDerived")
            return;
          h = ((g = t.effectPhases[n]) == null ? void 0 : g.findIndex((_) => _.effect._id === u.effect._id && _.change.key === u.change.key)) ?? -1, h !== -1 && t.effectPhases[n].splice(h, 1);
        }
        Object.assign(o, d);
      }
    }), t.overrides = foundry.utils.expandObject({
      ...foundry.utils.flattenObject(t.overrides),
      ...o
    });
  }
  /**
   * Creates a new default active effect on an actor or an item
   * @param {import("../actor/actor").default| import("../item").default} parentDocument
   * @returns
   */
  static createDefaultEffect(t) {
    const s = {
      name: K("A5E.effects.new"),
      icon: this.FALLBACK_ICON,
      flags: { a5e: { sort: 0 } }
    };
    return super.create(s, { parent: t });
  }
};
Sm = new WeakSet(), e9 = /* @__PURE__ */ f(function(t, s, n, l) {
  const r = CONFIG.A5E.ACTIVE_EFFECT_MODES, { mode: o } = n;
  if (o === r.ADD)
    return Z(this, yu, I_).call(this, s, l);
  if (o === r.MULTIPLY)
    return typeof l == "number" && (typeof s == "number" || s === void 0) ? Math.trunc((s ?? 0) * l) : s;
  if ([r.SUBTRACT, r.REMOVE].includes(o)) {
    const a = (typeof s == "number" || s === void 0) && typeof l == "number" ? -1 * l : l;
    return Z(this, yu, I_).call(this, s, a, !0);
  }
  return o === r.DOWNGRADE ? typeof l == "number" && (typeof s == "number" || s === void 0) ? Math.min(s ?? 0, l) : s : o === r.UPGRADE ? typeof l == "number" && (typeof s == "number" || s === void 0) ? Math.max(s ?? 0, l) : s : o === r.OVERRIDE ? l : o === r.CUSTOM ? Z(this, Tm, t9).call(this, s, l, n) : o === r.CONDITIONAL ? Z(this, Cm, s9).call(this, t, s, n) : s;
}, "#getNewValue"), yu = new WeakSet(), I_ = /* @__PURE__ */ f(function(t, s, n = !1) {
  const l = typeof s == "number" && (typeof t == "number" || [void 0, null].includes(t)), r = Array.isArray(t) && s instanceof Array, o = t instanceof Set && s instanceof Set;
  return l ? (t ?? 0) + s : r ? n ? t.filter((a) => !s.includes(a)) : [.../* @__PURE__ */ new Set([...t, ...s])] : o ? n ? t.difference(s) : t.union(s) : t.length ? n ? `${t} - ${s}` : `${t} + ${s}` : s;
}, "#addOrSubtractValues"), Tm = new WeakSet(), t9 = /* @__PURE__ */ f(function(t, s, n) {
  if (!n.key.startsWith("flags.a5e.effects"))
    return null;
  let l = "";
  switch (s = s || "", n.key) {
    case "flags.a5e.effects.damageResistances.all":
    case "flags.a5e.effects.damageVulnerabilities.all":
    case "flags.a5e.effects.damageImmunities.all":
      l = `system.traits.${n.key.split(".").at(-2)}`, s = Object.keys(CONFIG.A5E.damageTypes);
      break;
    case "flags.a5e.effects.conditionImmunities.all":
      l = `system.traits.${n.key.split(".").at(-2)}`, s = Object.keys(CONFIG.A5E.conditions);
      break;
    default:
      if (n.key.startsWith("flags.a5e.effects.bonuses")) {
        l = `system.bonuses.${n.key.split(".").at(-1)}.${foundry.utils.randomID()}`;
        break;
      }
      break;
  }
  return n.key = l, s;
}, "#applyCustom"), Cm = new WeakSet(), s9 = /* @__PURE__ */ f(function(t, s, n) {
  let l;
  try {
    if (l = JSON.parse(n.value), typeof l != "object")
      return s;
  } catch {
    return s;
  }
  let r = `${l.positiveValue}`, o = `${l.negativeValue}`;
  const a = at(l.comparisonValue ?? "0", t.getRollData()), c = l.comparisonOperator ?? "==";
  return r = at(r ?? "0", t.getRollData()), o = at(o ?? "0", t.getRollData()), LH(s, c, a, r, o);
}, "#applyConditional"), Om = new WeakSet(), n9 = /* @__PURE__ */ f(function(t, s) {
  var r, o;
  const n = t.documentName === "Actor", l = t.documentName === "Item";
  try {
    if (n)
      return typeof game.a5e.activeEffects.options[t.type].allOptions[s.key].sampleValue != "number" ? s.value : at(
        s.value ?? 0,
        t.getRollData()
      ) ?? s.value;
    if (l && ((r = t.parent) == null ? void 0 : r.documentName) === "Actor")
      return at(
        s.value ?? 0,
        (o = t.parent) == null ? void 0 : o.getRollData()
      ) ?? s.value;
  } catch {
    return s.value;
  }
  return s.value;
}, "#convertToDeterministicBonus"), Go = new WeakSet(), rd = /* @__PURE__ */ f(function() {
  var n, l;
  if (((n = this.parent) == null ? void 0 : n.documentName) !== "Actor")
    return;
  const t = ((l = this.changes) == null ? void 0 : l.map((r) => r.key)) ?? [];
  if (!t.some((r) => r.startsWith("@token")))
    return;
  if (foundry.utils.getProperty(this.parent, "prototypeToken.actorLink") ?? !0) {
    const r = this.parent.getActiveTokens().map((o) => o.document);
    if (!r.length)
      return;
    r.forEach((o) => {
      var a;
      o == null || o.reset(), (a = o == null ? void 0 : o.object) == null || a.draw();
    });
  } else {
    if (!this.parent.token)
      return;
    this.parent.token.reset(), this.parent.token.object.draw();
  }
  const s = t.some((r) => r.startsWith("@token.light"));
  s && canvas.perception.update({ initializeLighting: s }, !0);
}, "#updateCanvas"), Dm = new WeakSet(), i9 = /* @__PURE__ */ f(function(t, s) {
  var o, a;
  if (game.user.id !== s)
    return;
  const n = t.statuses ?? [], l = /* @__PURE__ */ new Set();
  if (n.forEach((c) => {
    const u = CONFIG.statusEffects.find((d) => d.id === c);
    u && l.add(...(u == null ? void 0 : u.statuses) ?? []);
  }), !l.size)
    return;
  const r = (a = (o = this.parent) == null ? void 0 : o.getActiveTokens()) == null ? void 0 : a[0];
  r && l.forEach((c) => {
    var d, p, m;
    if ((p = (d = this.parent) == null ? void 0 : d.statuses) != null && p.has(c))
      return;
    const u = CONFIG.statusEffects.find((g) => g.id === c);
    u && ((m = t.statuses) != null && m[0] && foundry.utils.setProperty(u, "flags.a5e.source", t.statuses[0]), r.document.toggleActiveEffect(u, { active: !0 }));
  });
}, "#addSubConditions"), f(Dl, "ActiveEffectA5e"), // -------------------------------------------------------
//  Static Properties
// -------------------------------------------------------
Ge(Dl, "FALLBACK_ICON", "icons/svg/aura.svg"), Ge(Dl, "PHASES", ["applyAEs", "afterDerived"]), Ge(Dl, "ITEM_TYPES", ["passive", "onUse"]);
let da = Dl;
const gi = class gi extends foundry.abstract.TypeDataModel {
  /**
   * The field names of the base templates used for construction.
   * @type {Set<string>}
   * @private
   */
  static get _schemaTemplateFields() {
    const e = Object.freeze(
      new Set(this._schemaTemplates.map((t) => t.schema.keys()).flat())
    );
    return Object.defineProperty(this, "_schemaTemplateFields", {
      value: e,
      writable: !1,
      configurable: !1
    }), e;
  }
  get metadata() {
    return gi.metadata;
  }
  static defineSchema() {
    const e = {};
    for (const t of this._schemaTemplates) {
      if (!t.defineSchema)
        throw new Error(`Invalid a5e template mixin ${t} defined on class ${this.constructor}`);
      this.mergeSchema(e, t.defineSchema());
    }
    return e;
  }
  static mergeSchema(e, t) {
    const { fields: s } = foundry.data;
    for (const n of Object.keys(t)) {
      if (!(n in e) || e[n].constructor !== t[n].constructor) {
        e[n] = t[n];
        continue;
      }
      const l = foundry.utils.mergeObject(e[n].options, t[n].options), r = t[n].constructor;
      if (r === s.SchemaField) {
        const o = this.mergeSchema(e[n].fields, t[n].fields);
        Object.values(o).forEach((a) => {
          a.parent = void 0;
        }), e[n] = new s.SchemaField(o, l);
      } else if (r === s.ArrayField || r === s.SetField) {
        const o = foundry.utils.mergeObject(
          e[n].element.options,
          t[n].element.options
        ), a = (t[n].element || e[n].element).constructor;
        e[n] = new t[n].constructor(new a(o), l);
      } else
        e[n] = new t[n].constructor(l);
    }
    return e;
  }
  static mergeData(e) {
    var t;
    for (const s of this._schemaTemplates)
      (t = s.migrateData) == null || t.call(s, e);
    return super.migrateData(e);
  }
  // static cleanData(source: Record<string, any>, options: Record<string, any> = {}) {
  //   this._cleanData(source, options);
  //   return super.cleanData(source, options);
  // }
  // static _cleanData(source: Record<string, any>, options: Record<string, any> = {}) {
  //   for (const template of this._schemaTemplates) {
  //     template._cleanData?.(source, options);
  //   }
  // }
  // eslint-disable-next-line generator-star-spacing
  static *_initializationOrder() {
    for (const e of this._schemaTemplates)
      for (const t of e._initializationOrder())
        t[1] = this.schema.get(t[0]), yield t;
    for (const e of this.schema.entries())
      this._schemaTemplateFields.has(e[0]) || (yield e);
  }
  // static validateJoint(data: Record<string, any>) {
  //   this._validateJoint(data);
  //   return super.validateJoint(data);
  // }
  // static _validateJoint(data) {
  //   for (const template of this._schemaTemplates) {
  //     template._validateJoint(data);
  //   }
  // }
  // static migrateData(source: Record<string, any>) {
  //   this._migrateData(source);
  //   return super.migrateData(source);
  // }
  // static _migrateData(source: Record<string, any>) {
  //   for (const template of this._schemaTemplates) {
  //     template._migrateData(source);
  //   }
  // }
  // static shimData(data: Record<string, any>, options: Record<string, any>) {
  //   this._shimData(data, options);
  //   return super.shimData(data, options);
  // }
  // static _shimData(data: Record<string, any>, options: Record<string, any>) {
  //   for (const template of this._schemaTemplates) {
  //     template._shimData(data, options);
  //   }
  // }
  static mixin(...e) {
    var s;
    const t = (s = class extends gi {
    }, f(s, "Base"), s);
    Object.defineProperty(t, "_schemaTemplates", {
      value: Object.seal([...this._schemaTemplates, ...e]),
      writable: !1,
      configurable: !1
    });
    for (const n of e) {
      for (const [l, r] of Object.entries(Object.getOwnPropertyDescriptors(n)))
        this._immiscible.has(l) || Object.defineProperty(t.prototype, l, r);
      for (const [l, r] of Object.entries(
        Object.getOwnPropertyDescriptors(n.prototype)
      ))
        ["constructor"].includes(l) || Object.defineProperty(t.prototype, l, r);
    }
    return t;
  }
  // @ts-ignore
  _cleanType(e, t = {}) {
    t.source = t.source ?? e;
    for (const [s, n] of this.entries())
      !(s in e) && t.partial || (e[s] = n.clean(e[s], t), e[s] === void 0 && delete e[s]);
    return e;
  }
};
f(gi, "A5EDataModel"), Ge(gi, "_documentType"), Ge(gi, "_schemaTemplates", []), Ge(gi, "_immiscible", /* @__PURE__ */ new Set([
  "length",
  "mixed",
  "name",
  "prototype",
  "cleanData",
  "_cleanData",
  "_initializationOrder",
  "validateJoint",
  "_validateJoint",
  "migrateData",
  "_migrateData",
  "shimData",
  "_shimData",
  "defineSchema"
])), Ge(gi, "metadata", Object.freeze({
  systemFlagsModel: null
}));
let ys = gi;
const oA = class oA extends ys {
  constructor(e, t = {}) {
    super(e, t);
  }
  static defineSchema() {
    const { fields: e } = foundry.data;
    return {
      // TODO: v12 - Update to UUIDField in v12
      itemUuid: new e.StringField({ required: !0, initial: "" }),
      // itemUuid: new fields.DocumentUUIDField({ required: true, initial: '' }),
      grantId: new e.DocumentIdField({ required: !0, initial: "" }),
      grantType: new e.StringField({ required: !0, initial: "" }),
      level: new e.NumberField({
        nullable: !1,
        initial: 1,
        integer: !0,
        min: 1
      })
    };
  }
};
f(oA, "ActorBaseGrant");
let mn = oA;
const aA = class aA extends mn {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new e.StringField({ required: !0, initial: "bonus" }),
      bonusId: new e.StringField({ required: !0, initial: "" }),
      type: new e.StringField({ required: !0, initial: "" })
    });
  }
};
f(aA, "ActorBonusGrant");
let P_ = aA;
const cA = class cA extends mn {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new e.StringField({ required: !0, initial: "feature" }),
      documentIds: new e.ArrayField(
        new e.StringField({ required: !0, initial: "" }),
        { required: !0, initial: [] }
      )
    });
  }
};
f(cA, "ActorFeatureGrant");
let M_ = cA;
const uA = class uA extends mn {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new e.StringField({ required: !0, initial: "item" }),
      documentIds: new e.ArrayField(
        new e.StringField({ required: !0, initial: "" }),
        { required: !0, initial: [] }
      )
    });
  }
};
f(uA, "ActorItemGrant");
let R_ = uA;
const fA = class fA extends mn {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new e.StringField({ required: !0, initial: "exertion" }),
      exertionData: new e.SchemaField({
        exertionType: new e.StringField({ required: !0, initial: "" }),
        bonusId: new e.StringField({ required: !1, initial: "" }),
        poolType: new e.StringField({ required: !0, initial: "" })
      }),
      type: new e.StringField({ required: !0, initial: "" })
    });
  }
};
f(fA, "ActorExertionGrant");
let F_ = fA;
const dA = class dA extends mn {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new e.StringField({ required: !0, initial: "expertiseDice" }),
      expertiseDiceData: new e.SchemaField({
        keys: new e.ArrayField(
          new e.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        total: new e.NumberField({ nullable: !1, initial: 0, integer: !0 }),
        expertiseCount: new e.NumberField({ nullable: !1, initial: 1, integer: !0 }),
        expertiseType: new e.StringField({ required: !0, initial: "" })
      })
    });
  }
};
f(dA, "ActorExpertiseDiceGrant");
let N_ = dA;
const pA = class pA extends mn {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new e.StringField({ required: !0, initial: "proficiency" }),
      proficiencyData: new e.SchemaField({
        keys: new e.ArrayField(
          new e.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        total: new e.NumberField({ nullable: !1, initial: 0, integer: !0 }),
        proficiencyType: new e.StringField({ required: !0, initial: "" })
      })
    });
  }
};
f(pA, "ActorProficiencyGrant");
let j_ = pA;
const mA = class mA extends mn {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new e.StringField({ required: !0, initial: "rollOverride" }),
      rollOverrideData: new e.SchemaField({
        keys: new e.ArrayField(
          new e.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        total: new e.NumberField({ nullable: !1, initial: 0, integer: !0 }),
        rollOverrideType: new e.StringField({ required: !1, initial: "abilityCheck" }),
        rollMode: new e.NumberField({ nullable: !1, initial: 0 })
      })
    });
  }
};
f(mA, "ActorRollOverrideGrant");
let L_ = mA;
const hA = class hA extends mn {
  defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new e.StringField({ required: !0, initial: "skillSpecialty" }),
      specialtyData: new e.SchemaField({
        specialties: new e.ArrayField(
          new e.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        total: new e.NumberField({ nullable: !1, initial: 0, integer: !0 }),
        skill: new e.StringField({ required: !0, initial: "" })
      })
    });
  }
};
f(hA, "ActorSkillSpecialtyGrant");
let B_ = hA;
const gA = class gA extends mn {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new e.StringField({ required: !0, initial: "trait" }),
      traitData: new e.SchemaField({
        traits: new e.ArrayField(
          new e.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        total: new e.NumberField({ nullable: !1, initial: 0, integer: !0 }),
        traitType: new e.StringField({ required: !0, initial: "" })
      })
    });
  }
};
f(gA, "ActorTraitGrant");
let q_ = gA;
const vn = {
  base: mn,
  bonus: P_,
  feature: M_,
  item: R_,
  exertion: F_,
  expertiseDice: N_,
  proficiency: j_,
  rollOverride: L_,
  skillSpecialty: B_,
  trait: q_
};
var vu, G_;
const bA = class bA extends Fs {
  constructor(t, s, n = {}, l = {}) {
    super({
      title: t,
      content: {
        class: s,
        props: { ...n }
      },
      zIndex: null
    }, {
      classes: ["a5e-sheet"],
      width: l.width ?? 420,
      height: l.height ?? "auto",
      resizable: l.resizable ?? !1
    });
    Y(this, vu);
    this.data.content.props.dialog = this, this.promise = new Promise((r) => {
      this.resolve = r;
    });
  }
  /** @inheritdoc */
  close(t) {
    return Z(this, vu, G_).call(this, null), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    return Z(this, vu, G_).call(this, t), super.close();
  }
};
vu = new WeakSet(), G_ = /* @__PURE__ */ f(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), f(bA, "GenericDialog");
let pa = bA;
function l9(i, e, t) {
  const s = {}, n = /* @__PURE__ */ new Map();
  return e.forEach(({ id: l, grant: r }) => {
    const o = t.get(l);
    if (r.grantType === "feature") {
      const a = r.getApplyData(i, o), u = ((o == null ? void 0 : o.uuids) ?? r.features.base.map(({ uuid: d }) => d) ?? []).map((d) => ({ uuid: d, type: "feature" }));
      n.set(l, u), foundry.utils.mergeObject(s, a ?? {});
      return;
    }
    if (r.grantType === "item") {
      const a = r.getApplyData(i, o), c = (o == null ? void 0 : o.uuids) ?? r.items.base.map(({ uuid: p }) => p) ?? [], d = [...r.items.base, ...r.items.options].reduce((p, { uuid: m, quantityOverride: g }) => (c.includes(m) && p.push({ uuid: m, type: "object", quantity: g }), p), []);
      n.set(l, d), foundry.utils.mergeObject(s, a ?? {});
      return;
    }
    o ? foundry.utils.mergeObject(s, r.getApplyData(i, o)) : foundry.utils.mergeObject(s, r.getApplyData(i));
  }), { updateData: s, documentData: n };
}
f(l9, "prepareApplyData");
function xO(i, e, t) {
  const s = i.slice();
  return s[7] = e[t].classes, s[8] = e[t].display, s[9] = e[t].handler, s[10] = e[t].label, s[11] = e[t].tooltip, s;
}
f(xO, "get_each_context$1J");
function eD(i) {
  let e, t, s = K(
    /*heading*/
    i[1]
  ) + "", n, l, r = (
    /*buttons*/
    i[0].length && tD(i)
  );
  return {
    c() {
      e = E("header"), t = E("h3"), n = x(s), l = R(), r && r.c(), b(t, "class", "a5e-field-wrapper__heading"), b(e, "class", "a5e-field-wrapper__header");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(t, n), A(e, l), r && r.m(e, null);
    },
    p(o, a) {
      a & /*heading*/
      2 && s !== (s = K(
        /*heading*/
        o[1]
      ) + "") && _e(n, s), /*buttons*/
      o[0].length ? r ? r.p(o, a) : (r = tD(o), r.c(), r.m(e, null)) : r && (r.d(1), r = null);
    },
    d(o) {
      o && S(e), r && r.d();
    }
  };
}
f(eD, "create_if_block_2$Z");
function tD(i) {
  let e, t = oe(
    /*buttons*/
    i[0]
  ), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = nD(xO(i, t, n));
  return {
    c() {
      e = E("div");
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      b(e, "class", "a5e-field-wrapper__header-button-wrapper");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l & /*buttons*/
      1) {
        t = oe(
          /*buttons*/
          n[0]
        );
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = xO(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = nD(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && S(e), Le(s, n);
    }
  };
}
f(tD, "create_if_block_3$C");
function sD(i) {
  let e, t = K(
    /*label*/
    i[10] ?? ""
  ) + "", s, n, l, r, o, a;
  return {
    c() {
      e = E("button"), s = x(t), n = R(), b(e, "class", l = `a5e-field-wrapper__header-button ${/*classes*/
      i[7]}`), b(e, "data-tooltip", r = /*tooltip*/
      i[11]), b(e, "data-tooltip-direction", "UP");
    },
    m(c, u) {
      T(c, e, u), A(e, s), A(e, n), o || (a = V(e, "click", We(tt(function() {
        $t(
          /*handler*/
          i[9]
        ) && i[9].apply(this, arguments);
      }))), o = !0);
    },
    p(c, u) {
      i = c, u & /*buttons*/
      1 && t !== (t = K(
        /*label*/
        i[10] ?? ""
      ) + "") && _e(s, t), u & /*buttons*/
      1 && l !== (l = `a5e-field-wrapper__header-button ${/*classes*/
      i[7]}`) && b(e, "class", l), u & /*buttons*/
      1 && r !== (r = /*tooltip*/
      i[11]) && b(e, "data-tooltip", r);
    },
    d(c) {
      c && S(e), o = !1, a();
    }
  };
}
f(sD, "create_if_block_4$t");
function nD(i) {
  let e, t = (
    /*display*/
    (i[8] ?? !0) && sD(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*display*/
      s[8] ?? !0 ? t ? t.p(s, n) : (t = sD(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && S(e), t && t.d(s);
    }
  };
}
f(nD, "create_each_block$1J");
function iD(i) {
  let e, t = K(
    /*hint*/
    i[2]
  ) + "", s;
  return {
    c() {
      e = E("small"), s = x(t), b(e, "class", "a5e-field-wrapper__hint");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*hint*/
      4 && t !== (t = K(
        /*hint*/
        n[2]
      ) + "") && _e(s, t);
    },
    d(n) {
      n && S(e);
    }
  };
}
f(iD, "create_if_block_1$1y");
function lD(i) {
  let e, t, s, n = K(
    /*warning*/
    i[4]
  ) + "", l;
  return {
    c() {
      e = E("small"), t = E("i"), s = R(), l = x(n), b(t, "class", "fa-solid fa-circle-exclamation"), b(e, "class", "a5e-field-wrapper__warning");
    },
    m(r, o) {
      T(r, e, o), A(e, t), A(e, s), A(e, l);
    },
    p(r, o) {
      o & /*warning*/
      16 && n !== (n = K(
        /*warning*/
        r[4]
      ) + "") && _e(l, n);
    },
    d(r) {
      r && S(e);
    }
  };
}
f(lD, "create_if_block$2p");
function qH(i) {
  let e, t, s, n, l, r = (
    /*heading*/
    i[1] && eD(i)
  );
  const o = (
    /*#slots*/
    i[6].default
  ), a = Pt(
    o,
    i,
    /*$$scope*/
    i[5],
    null
  );
  let c = (
    /*hint*/
    i[2] && iD(i)
  ), u = (
    /*showWarning*/
    i[3] && lD(i)
  );
  return {
    c() {
      e = E("section"), r && r.c(), t = R(), a && a.c(), s = R(), c && c.c(), n = R(), u && u.c(), b(e, "class", "a5e-field-wrapper");
    },
    m(d, p) {
      T(d, e, p), r && r.m(e, null), A(e, t), a && a.m(e, null), A(e, s), c && c.m(e, null), A(e, n), u && u.m(e, null), l = !0;
    },
    p(d, [p]) {
      /*heading*/
      d[1] ? r ? r.p(d, p) : (r = eD(d), r.c(), r.m(e, t)) : r && (r.d(1), r = null), a && a.p && (!l || p & /*$$scope*/
      32) && Rt(
        a,
        o,
        d,
        /*$$scope*/
        d[5],
        l ? Mt(
          o,
          /*$$scope*/
          d[5],
          p,
          null
        ) : Ft(
          /*$$scope*/
          d[5]
        ),
        null
      ), /*hint*/
      d[2] ? c ? c.p(d, p) : (c = iD(d), c.c(), c.m(e, n)) : c && (c.d(1), c = null), /*showWarning*/
      d[3] ? u ? u.p(d, p) : (u = lD(d), u.c(), u.m(e, null)) : u && (u.d(1), u = null);
    },
    i(d) {
      l || (w(a, d), l = !0);
    },
    o(d) {
      C(a, d), l = !1;
    },
    d(d) {
      d && S(e), r && r.d(), a && a.d(d), c && c.d(), u && u.d();
    }
  };
}
f(qH, "create_fragment$4s");
function GH(i, e, t) {
  let { $$slots: s = {}, $$scope: n } = e, { buttons: l = [] } = e, { heading: r = "" } = e, { hint: o = "" } = e, { showWarning: a = !1 } = e, { warning: c = "" } = e;
  return i.$$set = (u) => {
    "buttons" in u && t(0, l = u.buttons), "heading" in u && t(1, r = u.heading), "hint" in u && t(2, o = u.hint), "showWarning" in u && t(3, a = u.showWarning), "warning" in u && t(4, c = u.warning), "$$scope" in u && t(5, n = u.$$scope);
  }, [l, r, o, a, c, n, s];
}
f(GH, "instance$4j");
const _A = class _A extends ie {
  constructor(e) {
    super(), le(this, e, GH, qH, ne, {
      buttons: 0,
      heading: 1,
      hint: 2,
      showWarning: 3,
      warning: 4
    });
  }
};
f(_A, "FieldWrapper");
let de = _A;
function zH(i) {
  let e, t, s = K(
    /*label*/
    i[1]
  ) + "", n, l, r;
  return {
    c() {
      e = E("li"), t = E("button"), n = x(s), b(t, "class", "tag svelte-1gr8phr"), b(
        t,
        "style",
        /*style*/
        i[6]
      ), t.disabled = /*disabled*/
      i[0], t.value = /*value*/
      i[5], b(
        t,
        "data-tooltip",
        /*tooltipText*/
        i[4]
      ), b(
        t,
        "data-tooltip-direction",
        /*tooltipDirection*/
        i[3]
      ), Q(
        t,
        "tag--tight",
        /*tight*/
        i[2]
      );
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(t, n), l || (r = [
        V(t, "click", tt(
          /*click_handler*/
          i[14]
        )),
        V(t, "auxclick", tt(
          /*auxclick_handler*/
          i[15]
        ))
      ], l = !0);
    },
    p(o, [a]) {
      a & /*label*/
      2 && s !== (s = K(
        /*label*/
        o[1]
      ) + "") && _e(n, s), a & /*style*/
      64 && b(
        t,
        "style",
        /*style*/
        o[6]
      ), a & /*disabled*/
      1 && (t.disabled = /*disabled*/
      o[0]), a & /*value*/
      32 && (t.value = /*value*/
      o[5]), a & /*tooltipText*/
      16 && b(
        t,
        "data-tooltip",
        /*tooltipText*/
        o[4]
      ), a & /*tooltipDirection*/
      8 && b(
        t,
        "data-tooltip-direction",
        /*tooltipDirection*/
        o[3]
      ), a & /*tight*/
      4 && Q(
        t,
        "tag--tight",
        /*tight*/
        o[2]
      );
    },
    i: ee,
    o: ee,
    d(o) {
      o && S(e), l = !1, Ne(r);
    }
  };
}
f(zH, "create_fragment$4r");
function HH(i, e, t, s) {
  return i ? "green" : s ? "disabled" : e ? "red" : t ? "orange" : "default";
}
f(HH, "getColor");
function UH(i, e, t) {
  let s, n, l, { active: r = !1 } = e, { disabled: o = !1 } = e, { optionStyles: a = "" } = e, { orange: c = !1 } = e, { red: u = !1 } = e, { label: d = "" } = e, { tight: p = !1 } = e, { tooltipDirection: m = "UP" } = e, { tooltipText: g = "" } = e, { value: h = "" } = e;
  function _(O) {
    return O === "red" ? `
                --tag-font-color: hsl(0, 58%, 100%);
                --tag-background-color: hsl(0, 58%, 35%);
                --tag-border-color: hsl(0, 58%, 28%);
                --tag-hover-background-color: hsl(0, 58%, 35%);
                --tag-hover-font-color: var(--color-hover, hsl(0, 58%, 100%));
            ` : O === "orange" ? `
                --tag-font-color: hsl(36, 58%, 100%);
                --tag-background-color: hsl(36, 58%, 35%);
                --tag-border-color: hsl(36, 58%, 28%);
                --tag-hover-background-color: hsl(36, 58%, 35%);
                --tag-hover-font-color: var(--color-hover, hsl(36, 58%, 100%));
            ` : O === "green" ? `
                --tag-font-color: hsl(190, 21%, 100%);
                --tag-background-color: hsl(190, 21%, 33%);
                --tag-border-color: hsl(190, 21%, 28%);
                --tag-hover-background-color: hsl(190, 21%, 33%);
                --tag-hover-font-color: var(--color-hover, hsl(190, 21%, 100%));
            ` : O === "disabled" ? `
                --tag-font-color: hsl(0, 0%, 100%);
                --tag-background-color: hsl(0, 0%, 67%);
                --tag-border-color: hsl(0, 0%, 60%);
                --tag-hover-background-color: hsl(0, 0%, 67%);
                --tag-hover-font-color: var(--color-hover, hsl(0, 0%, 100%));
            ` : `
            --tag-font-color: inherit;
            --tag-background-color: transparent;
            --tag-border-color: #706b55;
            --tag-hover-background-color: #d8d4c6;
            --tag-hover-font-color: var(--color-hover, inherit);
        `;
  }
  f(_, "getColorData");
  const y = it(), k = /* @__PURE__ */ f(() => y("tagToggle", h), "click_handler"), v = /* @__PURE__ */ f(() => y("tagToggleAux", h), "auxclick_handler");
  return i.$$set = (O) => {
    "active" in O && t(8, r = O.active), "disabled" in O && t(0, o = O.disabled), "optionStyles" in O && t(9, a = O.optionStyles), "orange" in O && t(10, c = O.orange), "red" in O && t(11, u = O.red), "label" in O && t(1, d = O.label), "tight" in O && t(2, p = O.tight), "tooltipDirection" in O && t(3, m = O.tooltipDirection), "tooltipText" in O && t(4, g = O.tooltipText), "value" in O && t(5, h = O.value);
  }, i.$$.update = () => {
    i.$$.dirty & /*active, red, orange, disabled*/
    3329 && t(13, s = HH(r, u, c, o)), i.$$.dirty & /*color*/
    8192 && t(12, n = _(s)), i.$$.dirty & /*colorStyles, optionStyles*/
    4608 && t(6, l = `${n} ${a}`);
  }, [
    o,
    d,
    p,
    m,
    g,
    h,
    l,
    y,
    r,
    a,
    c,
    u,
    n,
    s,
    k,
    v
  ];
}
f(UH, "instance$4i");
const yA = class yA extends ie {
  constructor(e) {
    super(), le(this, e, UH, zH, ne, {
      active: 8,
      disabled: 0,
      optionStyles: 9,
      orange: 10,
      red: 11,
      label: 1,
      tight: 2,
      tooltipDirection: 3,
      tooltipText: 4,
      value: 5
    });
  }
};
f(yA, "Tag");
let Cr = yA;
function Sc(i, e) {
  if (!Array.isArray(i) || !Array.isArray(e))
    return !1;
  const t = Array.from(i).sort(), s = Array.from(e).sort();
  return t.length === s.length && t.every((n, l) => n === s[l]);
}
f(Sc, "arraysAreEqual");
function rD(i, e, t) {
  const s = i.slice();
  return s[20] = e[t][0], s[21] = e[t][1], s;
}
f(rD, "get_each_context$1I");
function oD(i) {
  var s, n, l;
  let e, t;
  return e = new Cr({
    props: {
      active: (
        /*selected*/
        i[0].includes(
          /*value*/
          i[20]
        )
      ),
      label: (
        /*label*/
        i[21]
      ),
      optionStyles: (
        /*optionStyles*/
        i[7]
      ),
      value: (
        /*value*/
        i[20]
      ),
      red: (
        /*red*/
        (s = i[9]) == null ? void 0 : s.includes(
          /*value*/
          i[20]
        )
      ),
      orange: (
        /*orange*/
        (n = i[8]) == null ? void 0 : n.includes(
          /*value*/
          i[20]
        )
      ),
      disabled: (
        /*disabledOptions*/
        i[2].includes(
          /*value*/
          i[20]
        ) || /*disabled*/
        i[1] && !/*selected*/
        i[0].includes(
          /*value*/
          i[20]
        )
      ),
      tooltipText: (
        /*tooltipData*/
        ((l = i[11]) == null ? void 0 : l[
          /*value*/
          i[20]
        ]) ?? ""
      )
    }
  }), e.$on(
    "tagToggle",
    /*tagToggle_handler*/
    i[16]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(r, o) {
      N(e, r, o), t = !0;
    },
    p(r, o) {
      var c, u, d;
      const a = {};
      o & /*selected, options*/
      65 && (a.active = /*selected*/
      r[0].includes(
        /*value*/
        r[20]
      )), o & /*options*/
      64 && (a.label = /*label*/
      r[21]), o & /*optionStyles*/
      128 && (a.optionStyles = /*optionStyles*/
      r[7]), o & /*options*/
      64 && (a.value = /*value*/
      r[20]), o & /*red, options*/
      576 && (a.red = /*red*/
      (c = r[9]) == null ? void 0 : c.includes(
        /*value*/
        r[20]
      )), o & /*orange, options*/
      320 && (a.orange = /*orange*/
      (u = r[8]) == null ? void 0 : u.includes(
        /*value*/
        r[20]
      )), o & /*disabledOptions, options, disabled, selected*/
      71 && (a.disabled = /*disabledOptions*/
      r[2].includes(
        /*value*/
        r[20]
      ) || /*disabled*/
      r[1] && !/*selected*/
      r[0].includes(
        /*value*/
        r[20]
      )), o & /*tooltipData, options*/
      2112 && (a.tooltipText = /*tooltipData*/
      ((d = r[11]) == null ? void 0 : d[
        /*value*/
        r[20]
      ]) ?? ""), e.$set(a);
    },
    i(r) {
      t || (w(e.$$.fragment, r), t = !0);
    },
    o(r) {
      C(e.$$.fragment, r), t = !1;
    },
    d(r) {
      j(e, r);
    }
  };
}
f(oD, "create_each_block$1I");
function VH(i) {
  let e, t, s, n = oe(
    /*options*/
    i[6]
  ), l = [];
  for (let o = 0; o < n.length; o += 1)
    l[o] = oD(rD(i, n, o));
  const r = /* @__PURE__ */ f((o) => C(l[o], 1, 1, () => {
    l[o] = null;
  }), "out");
  return {
    c() {
      e = E("ul");
      for (let o = 0; o < l.length; o += 1)
        l[o].c();
      b(e, "class", t = "u-flex u-flex-wrap u-gap-sm u-list-style-none u-m-0 u-p-0 u-text-xs u-w-full " + /*listClasses*/
      i[5]);
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < l.length; c += 1)
        l[c] && l[c].m(e, null);
      s = !0;
    },
    p(o, a) {
      if (a & /*selected, options, optionStyles, red, orange, disabledOptions, disabled, tooltipData, updateSelection*/
      11207) {
        n = oe(
          /*options*/
          o[6]
        );
        let c;
        for (c = 0; c < n.length; c += 1) {
          const u = rD(o, n, c);
          l[c] ? (l[c].p(u, a), w(l[c], 1)) : (l[c] = oD(u), l[c].c(), w(l[c], 1), l[c].m(e, null));
        }
        for (ce(), c = n.length; c < l.length; c += 1)
          r(c);
        ue();
      }
      (!s || a & /*listClasses*/
      32 && t !== (t = "u-flex u-flex-wrap u-gap-sm u-list-style-none u-m-0 u-p-0 u-text-xs u-w-full " + /*listClasses*/
      o[5])) && b(e, "class", t);
    },
    i(o) {
      if (!s) {
        for (let a = 0; a < n.length; a += 1)
          w(l[a]);
        s = !0;
      }
    },
    o(o) {
      l = l.filter(Boolean);
      for (let a = 0; a < l.length; a += 1)
        C(l[a]);
      s = !1;
    },
    d(o) {
      o && S(e), Le(l, o);
    }
  };
}
f(VH, "create_default_slot$2s");
function WH(i) {
  let e, t, s;
  return e = new de({
    props: {
      buttons: (
        /*buttons*/
        i[14]
      ),
      heading: (
        /*heading*/
        i[3]
      ),
      hint: (
        /*hint*/
        i[4]
      ),
      showWarning: (
        /*showWarning*/
        i[10]
      ),
      warning: (
        /*warning*/
        i[12]
      ),
      $$slots: { default: [VH] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-header-item-justification", "flex-start"), z(t, "--a5e-field-wrapper-header-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*heading*/
      8 && (r.heading = /*heading*/
      n[3]), l & /*hint*/
      16 && (r.hint = /*hint*/
      n[4]), l & /*showWarning*/
      1024 && (r.showWarning = /*showWarning*/
      n[10]), l & /*warning*/
      4096 && (r.warning = /*warning*/
      n[12]), l & /*$$scope, listClasses, options, selected, optionStyles, red, orange, disabledOptions, disabled, tooltipData*/
      16780263 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(WH, "create_fragment$4q");
function KH(i, e, t) {
  let { disabled: s = !1 } = e, { disabledOptions: n = [] } = e, { heading: l = "" } = e, { hint: r = "" } = e, { listClasses: o = "" } = e, { options: a = [] } = e, { optionStyles: c = "" } = e, { orange: u = [] } = e, { red: d = [] } = e, { selected: p = [] } = e, { showToggleAllButton: m = !1 } = e, { showWarning: g = !1 } = e, { tooltipData: h = {} } = e, { warning: _ = "" } = e;
  function y() {
    return m ? [
      {
        classes: "u-text-xs",
        label: "+ Toggle All",
        handler: v
      }
    ] : [];
  }
  f(y, "getButtons");
  function k(I) {
    const B = new Set(p);
    B.has(I) ? B.delete(I) : B.add(I), O("updateSelection", [...B]);
  }
  f(k, "updateSelection");
  function v() {
    const I = a.map(([F]) => F);
    Sc(I, p) ? t(0, p = []) : t(0, p = I), O("updateSelection", p);
  }
  f(v, "toggleAll");
  const O = it(), P = y(), D = /* @__PURE__ */ f(({ detail: I }) => k(I), "tagToggle_handler");
  return i.$$set = (I) => {
    "disabled" in I && t(1, s = I.disabled), "disabledOptions" in I && t(2, n = I.disabledOptions), "heading" in I && t(3, l = I.heading), "hint" in I && t(4, r = I.hint), "listClasses" in I && t(5, o = I.listClasses), "options" in I && t(6, a = I.options), "optionStyles" in I && t(7, c = I.optionStyles), "orange" in I && t(8, u = I.orange), "red" in I && t(9, d = I.red), "selected" in I && t(0, p = I.selected), "showToggleAllButton" in I && t(15, m = I.showToggleAllButton), "showWarning" in I && t(10, g = I.showWarning), "tooltipData" in I && t(11, h = I.tooltipData), "warning" in I && t(12, _ = I.warning);
  }, [
    p,
    s,
    n,
    l,
    r,
    o,
    a,
    c,
    u,
    d,
    g,
    h,
    _,
    k,
    P,
    m,
    D
  ];
}
f(KH, "instance$4h");
const vA = class vA extends ie {
  constructor(e) {
    super(), le(this, e, KH, WH, ne, {
      disabled: 1,
      disabledOptions: 2,
      heading: 3,
      hint: 4,
      listClasses: 5,
      options: 6,
      optionStyles: 7,
      orange: 8,
      red: 9,
      selected: 0,
      showToggleAllButton: 15,
      showWarning: 10,
      tooltipData: 11,
      warning: 12
    });
  }
};
f(vA, "CheckboxGroup");
let Ze = vA;
function aD(i, e, t) {
  const s = i.slice();
  return s[15] = e[t][0], s[16] = e[t][1], s;
}
f(aD, "get_each_context$1H");
function cD(i) {
  var s, n, l;
  let e, t;
  return e = new Cr({
    props: {
      active: (
        /*selected*/
        i[7] === /*value*/
        i[15] || /*selected*/
        ((s = i[7]) == null ? void 0 : s.toString()) === /*value*/
        ((n = i[15]) == null ? void 0 : n.toString())
      ),
      label: (
        /*label*/
        i[16]
      ),
      optionStyles: (
        /*optionStyles*/
        i[5]
      ),
      value: (
        /*value*/
        i[15]
      ),
      disabled: (
        /*disabled*/
        i[1].includes(
          /*value*/
          i[15]
        )
      ),
      tooltipText: (
        /*tooltipData*/
        ((l = i[9]) == null ? void 0 : l[
          /*value*/
          i[15]
        ]) ?? ""
      )
    }
  }), e.$on(
    "tagToggle",
    /*tagToggle_handler*/
    i[13]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(r, o) {
      N(e, r, o), t = !0;
    },
    p(r, o) {
      var c, u, d;
      const a = {};
      o & /*selected, options*/
      192 && (a.active = /*selected*/
      r[7] === /*value*/
      r[15] || /*selected*/
      ((c = r[7]) == null ? void 0 : c.toString()) === /*value*/
      ((u = r[15]) == null ? void 0 : u.toString())), o & /*options*/
      64 && (a.label = /*label*/
      r[16]), o & /*optionStyles*/
      32 && (a.optionStyles = /*optionStyles*/
      r[5]), o & /*options*/
      64 && (a.value = /*value*/
      r[15]), o & /*disabled, options*/
      66 && (a.disabled = /*disabled*/
      r[1].includes(
        /*value*/
        r[15]
      )), o & /*tooltipData, options*/
      576 && (a.tooltipText = /*tooltipData*/
      ((d = r[9]) == null ? void 0 : d[
        /*value*/
        r[15]
      ]) ?? ""), e.$set(a);
    },
    i(r) {
      t || (w(e.$$.fragment, r), t = !0);
    },
    o(r) {
      C(e.$$.fragment, r), t = !1;
    },
    d(r) {
      j(e, r);
    }
  };
}
f(cD, "create_each_block$1H");
function YH(i) {
  let e, t, s, n = oe(
    /*options*/
    i[6]
  ), l = [];
  for (let o = 0; o < n.length; o += 1)
    l[o] = cD(aD(i, n, o));
  const r = /* @__PURE__ */ f((o) => C(l[o], 1, 1, () => {
    l[o] = null;
  }), "out");
  return {
    c() {
      e = E("ul");
      for (let o = 0; o < l.length; o += 1)
        l[o].c();
      b(e, "class", t = "radio-group " + /*listClasses*/
      i[4] + " svelte-jppv09");
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < l.length; c += 1)
        l[c] && l[c].m(e, null);
      s = !0;
    },
    p(o, a) {
      if (a & /*selected, options, optionStyles, disabled, tooltipData, updateSelection*/
      2786) {
        n = oe(
          /*options*/
          o[6]
        );
        let c;
        for (c = 0; c < n.length; c += 1) {
          const u = aD(o, n, c);
          l[c] ? (l[c].p(u, a), w(l[c], 1)) : (l[c] = cD(u), l[c].c(), w(l[c], 1), l[c].m(e, null));
        }
        for (ce(), c = n.length; c < l.length; c += 1)
          r(c);
        ue();
      }
      (!s || a & /*listClasses*/
      16 && t !== (t = "radio-group " + /*listClasses*/
      o[4] + " svelte-jppv09")) && b(e, "class", t);
    },
    i(o) {
      if (!s) {
        for (let a = 0; a < n.length; a += 1)
          w(l[a]);
        s = !0;
      }
    },
    o(o) {
      l = l.filter(Boolean);
      for (let a = 0; a < l.length; a += 1)
        C(l[a]);
      s = !1;
    },
    d(o) {
      o && S(e), Le(l, o);
    }
  };
}
f(YH, "create_default_slot$2r");
function XH(i) {
  let e, t, s;
  return e = new de({
    props: {
      buttons: (
        /*buttons*/
        i[0]
      ),
      heading: (
        /*heading*/
        i[2]
      ),
      hint: (
        /*hint*/
        i[3]
      ),
      showWarning: (
        /*showWarning*/
        i[8]
      ),
      warning: (
        /*warning*/
        i[10]
      ),
      $$slots: { default: [YH] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-header-item-justification", "flex-start"), z(t, "--a5e-field-wrapper-header-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*buttons*/
      1 && (r.buttons = /*buttons*/
      n[0]), l & /*heading*/
      4 && (r.heading = /*heading*/
      n[2]), l & /*hint*/
      8 && (r.hint = /*hint*/
      n[3]), l & /*showWarning*/
      256 && (r.showWarning = /*showWarning*/
      n[8]), l & /*warning*/
      1024 && (r.warning = /*warning*/
      n[10]), l & /*$$scope, listClasses, options, selected, optionStyles, disabled, tooltipData*/
      525042 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(XH, "create_fragment$4p");
function JH(i, e, t) {
  let { allowDeselect: s = !0 } = e, { buttons: n = [] } = e, { disabled: l = [] } = e, { heading: r = "" } = e, { hint: o = "" } = e, { listClasses: a = "" } = e, { optionStyles: c = "" } = e, { options: u = [] } = e, { selected: d = "" } = e, { showWarning: p = !1 } = e, { tooltipData: m = {} } = e, { warning: g = "" } = e;
  const h = it();
  function _(k) {
    s ? h("updateSelection", k === d ? "" : k) : h("updateSelection", k);
  }
  f(_, "updateSelection");
  const y = /* @__PURE__ */ f(({ detail: k }) => _(k), "tagToggle_handler");
  return i.$$set = (k) => {
    "allowDeselect" in k && t(12, s = k.allowDeselect), "buttons" in k && t(0, n = k.buttons), "disabled" in k && t(1, l = k.disabled), "heading" in k && t(2, r = k.heading), "hint" in k && t(3, o = k.hint), "listClasses" in k && t(4, a = k.listClasses), "optionStyles" in k && t(5, c = k.optionStyles), "options" in k && t(6, u = k.options), "selected" in k && t(7, d = k.selected), "showWarning" in k && t(8, p = k.showWarning), "tooltipData" in k && t(9, m = k.tooltipData), "warning" in k && t(10, g = k.warning);
  }, [
    n,
    l,
    r,
    o,
    a,
    c,
    u,
    d,
    p,
    m,
    g,
    _,
    s,
    y
  ];
}
f(JH, "instance$4g");
const kA = class kA extends ie {
  constructor(e) {
    super(), le(this, e, JH, XH, ne, {
      allowDeselect: 12,
      buttons: 0,
      disabled: 1,
      heading: 2,
      hint: 3,
      listClasses: 4,
      optionStyles: 5,
      options: 6,
      selected: 7,
      showWarning: 8,
      tooltipData: 9,
      warning: 10
    });
  }
};
f(kA, "RadioGroup");
let Ye = kA;
function uD(i, e, t) {
  const s = i.slice();
  return s[8] = e[t].classes, s[9] = e[t].display, s[10] = e[t].handler, s[11] = e[t].htmlString, s[12] = e[t].label, s[13] = e[t].tooltip, s;
}
f(uD, "get_each_context$1G");
function fD(i) {
  let e, t, s = K(
    /*heading*/
    i[2]
  ) + "", n, l, r, o = (
    /*headerButtons*/
    i[0].length && dD(i)
  );
  return {
    c() {
      e = E("header"), t = E("h3"), n = x(s), l = R(), o && o.c(), b(t, "class", "a5e-section-header__heading"), b(e, "class", r = "a5e-section-header " + /*headerClasses*/
      i[1]);
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(t, n), A(e, l), o && o.m(e, null);
    },
    p(a, c) {
      c & /*heading*/
      4 && s !== (s = K(
        /*heading*/
        a[2]
      ) + "") && _e(n, s), /*headerButtons*/
      a[0].length ? o ? o.p(a, c) : (o = dD(a), o.c(), o.m(e, null)) : o && (o.d(1), o = null), c & /*headerClasses*/
      2 && r !== (r = "a5e-section-header " + /*headerClasses*/
      a[1]) && b(e, "class", r);
    },
    d(a) {
      a && S(e), o && o.d();
    }
  };
}
f(fD, "create_if_block_2$Y");
function dD(i) {
  let e, t = oe(
    /*headerButtons*/
    i[0]
  ), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = mD(uD(i, t, n));
  return {
    c() {
      e = E("div");
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      b(e, "class", "a5e-section-header__button-wrapper");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l & /*headerButtons*/
      1) {
        t = oe(
          /*headerButtons*/
          n[0]
        );
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = uD(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = mD(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && S(e), Le(s, n);
    }
  };
}
f(dD, "create_if_block_3$B");
function pD(i) {
  let e, t, s, n, l, r;
  function o(u, d) {
    return (
      /*htmlString*/
      u[11] ? xH : (
        /*label*/
        u[12] ? QH : ZH
      )
    );
  }
  f(o, "select_block_type");
  let a = o(i), c = a(i);
  return {
    c() {
      e = E("button"), c.c(), t = R(), b(e, "class", s = `a5e-section-header__button ${/*classes*/
      i[8]}`), b(e, "data-tooltip", n = /*tooltip*/
      i[13]), b(e, "data-tooltip-direction", "UP");
    },
    m(u, d) {
      T(u, e, d), c.m(e, null), A(e, t), l || (r = V(e, "click", We(function() {
        $t(
          /*handler*/
          i[10]
        ) && i[10].apply(this, arguments);
      })), l = !0);
    },
    p(u, d) {
      i = u, a === (a = o(i)) && c ? c.p(i, d) : (c.d(1), c = a(i), c && (c.c(), c.m(e, t))), d & /*headerButtons*/
      1 && s !== (s = `a5e-section-header__button ${/*classes*/
      i[8]}`) && b(e, "class", s), d & /*headerButtons*/
      1 && n !== (n = /*tooltip*/
      i[13]) && b(e, "data-tooltip", n);
    },
    d(u) {
      u && S(e), c.d(), l = !1, r();
    }
  };
}
f(pD, "create_if_block_4$s");
function ZH(i) {
  let e = K("") + "", t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p: ee,
    d(s) {
      s && S(t);
    }
  };
}
f(ZH, "create_else_block$F");
function QH(i) {
  let e = K(
    /*label*/
    i[12]
  ) + "", t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*headerButtons*/
      1 && e !== (e = K(
        /*label*/
        s[12]
      ) + "") && _e(t, e);
    },
    d(s) {
      s && S(t);
    }
  };
}
f(QH, "create_if_block_6$h");
function xH(i) {
  let e, t = (
    /*htmlString*/
    i[11] + ""
  ), s;
  return {
    c() {
      e = new As(!1), s = $e(), e.a = s;
    },
    m(n, l) {
      e.m(t, n, l), T(n, s, l);
    },
    p(n, l) {
      l & /*headerButtons*/
      1 && t !== (t = /*htmlString*/
      n[11] + "") && e.p(t);
    },
    d(n) {
      n && (S(s), e.d());
    }
  };
}
f(xH, "create_if_block_5$j");
function mD(i) {
  let e, t = (
    /*display*/
    (i[9] ?? !0) && pD(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*display*/
      s[9] ?? !0 ? t ? t.p(s, n) : (t = pD(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && S(e), t && t.d(s);
    }
  };
}
f(mD, "create_each_block$1G");
function hD(i) {
  let e, t = K(
    /*hint*/
    i[3]
  ) + "", s;
  return {
    c() {
      e = E("small"), s = x(t), b(e, "class", "a5e-section__hint");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*hint*/
      8 && t !== (t = K(
        /*hint*/
        n[3]
      ) + "") && _e(s, t);
    },
    d(n) {
      n && S(e);
    }
  };
}
f(hD, "create_if_block_1$1x");
function gD(i) {
  let e, t, s, n = K(
    /*warning*/
    i[5]
  ) + "", l;
  return {
    c() {
      e = E("small"), t = E("i"), s = R(), l = x(n), b(t, "class", "fa-solid fa-circle-exclamation"), b(e, "class", "a5e-section__warning");
    },
    m(r, o) {
      T(r, e, o), A(e, t), A(e, s), A(e, l);
    },
    p(r, o) {
      o & /*warning*/
      32 && n !== (n = K(
        /*warning*/
        r[5]
      ) + "") && _e(l, n);
    },
    d(r) {
      r && S(e);
    }
  };
}
f(gD, "create_if_block$2o");
function eU(i) {
  let e, t, s, n, l, r, o = (
    /*heading*/
    i[2] && fD(i)
  ), a = (
    /*hint*/
    i[3] && hD(i)
  ), c = (
    /*showWarning*/
    i[4] && gD(i)
  );
  const u = (
    /*#slots*/
    i[7].default
  ), d = Pt(
    u,
    i,
    /*$$scope*/
    i[6],
    null
  );
  return {
    c() {
      e = E("section"), o && o.c(), t = R(), s = E("div"), a && a.c(), n = R(), c && c.c(), l = R(), d && d.c(), b(s, "class", "a5e-section__body"), b(e, "class", "a5e-section");
    },
    m(p, m) {
      T(p, e, m), o && o.m(e, null), A(e, t), A(e, s), a && a.m(s, null), A(s, n), c && c.m(s, null), A(s, l), d && d.m(s, null), r = !0;
    },
    p(p, [m]) {
      /*heading*/
      p[2] ? o ? o.p(p, m) : (o = fD(p), o.c(), o.m(e, t)) : o && (o.d(1), o = null), /*hint*/
      p[3] ? a ? a.p(p, m) : (a = hD(p), a.c(), a.m(s, n)) : a && (a.d(1), a = null), /*showWarning*/
      p[4] ? c ? c.p(p, m) : (c = gD(p), c.c(), c.m(s, l)) : c && (c.d(1), c = null), d && d.p && (!r || m & /*$$scope*/
      64) && Rt(
        d,
        u,
        p,
        /*$$scope*/
        p[6],
        r ? Mt(
          u,
          /*$$scope*/
          p[6],
          m,
          null
        ) : Ft(
          /*$$scope*/
          p[6]
        ),
        null
      );
    },
    i(p) {
      r || (w(d, p), r = !0);
    },
    o(p) {
      C(d, p), r = !1;
    },
    d(p) {
      p && S(e), o && o.d(), a && a.d(), c && c.d(), d && d.d(p);
    }
  };
}
f(eU, "create_fragment$4o");
function tU(i, e, t) {
  let { $$slots: s = {}, $$scope: n } = e, { headerButtons: l = [] } = e, { headerClasses: r = "" } = e, { heading: o = "" } = e, { hint: a = "" } = e, { showWarning: c = !1 } = e, { warning: u = "" } = e;
  return i.$$set = (d) => {
    "headerButtons" in d && t(0, l = d.headerButtons), "headerClasses" in d && t(1, r = d.headerClasses), "heading" in d && t(2, o = d.heading), "hint" in d && t(3, a = d.hint), "showWarning" in d && t(4, c = d.showWarning), "warning" in d && t(5, u = d.warning), "$$scope" in d && t(6, n = d.$$scope);
  }, [
    l,
    r,
    o,
    a,
    c,
    u,
    n,
    s
  ];
}
f(tU, "instance$4f");
const wA = class wA extends ie {
  constructor(e) {
    super(), le(this, e, tU, eU, ne, {
      headerButtons: 0,
      headerClasses: 1,
      heading: 2,
      hint: 3,
      showWarning: 4,
      warning: 5
    });
  }
};
f(wA, "Section");
let Me = wA;
function sU(i) {
  let e, t;
  return e = new de({
    props: {
      $$slots: { default: [lU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope*/
      8192 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(sU, "create_if_block_2$X");
function nU(i) {
  let e, t;
  return e = new de({
    props: {
      $$slots: { default: [rU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, rollFormula*/
      8196 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(nU, "create_if_block_1$1w");
function iU(i) {
  let e, t, s = (
    /*cls*/
    i[0].averageHP + ""
  ), n;
  return {
    c() {
      e = E("div"), t = x("Average: "), n = x(s), b(e, "class", "roll-formula-preview svelte-1xocfwd");
    },
    m(l, r) {
      T(l, e, r), A(e, t), A(e, n);
    },
    p(l, r) {
      r & /*cls*/
      1 && s !== (s = /*cls*/
      l[0].averageHP + "") && _e(n, s);
    },
    i: ee,
    o: ee,
    d(l) {
      l && S(e);
    }
  };
}
f(iU, "create_if_block$2n");
function lU(i) {
  let e, t, s;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input a5e-input--small a5e-input--slim"), b(e, "type", "number"), b(e, "min", "0"), e.value = /*customHp*/
      i[6] ?? 0;
    },
    m(n, l) {
      T(n, e, l), t || (s = V(
        e,
        "change",
        /*change_handler_1*/
        i[11]
      ), t = !0);
    },
    p: ee,
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(lU, "create_default_slot_2$12");
function rU(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input a5e-input--small a5e-input--slim"), b(e, "type", "text"), e.value = t = /*rollFormula*/
      i[2] ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      r & /*rollFormula*/
      4 && t !== (t = /*rollFormula*/
      l[2] ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(rU, "create_default_slot_1$1u");
function oU(i) {
  let e, t, s, n, l, r;
  e = new Ye({
    props: {
      options: Object.entries(
        /*classHPTypes*/
        i[5]
      ),
      selected: (
        /*leveledHpType*/
        i[1]
      ),
      allowDeselect: !1
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[9]
  );
  const o = [iU, nU, sU], a = [];
  function c(u, d) {
    return (
      /*leveledHpType*/
      u[1] === "average" ? 0 : (
        /*leveledHpType*/
        u[1] === "roll" ? 1 : (
          /*leveledHpType*/
          u[1] === "custom" ? 2 : -1
        )
      )
    );
  }
  return f(c, "select_block_type"), ~(s = c(i)) && (n = a[s] = o[s](i)), {
    c() {
      L(e.$$.fragment), t = R(), n && n.c(), l = $e();
    },
    m(u, d) {
      N(e, u, d), T(u, t, d), ~s && a[s].m(u, d), T(u, l, d), r = !0;
    },
    p(u, d) {
      const p = {};
      d & /*leveledHpType*/
      2 && (p.selected = /*leveledHpType*/
      u[1]), e.$set(p);
      let m = s;
      s = c(u), s === m ? ~s && a[s].p(u, d) : (n && (ce(), C(a[m], 1, 1, () => {
        a[m] = null;
      }), ue()), ~s ? (n = a[s], n ? n.p(u, d) : (n = a[s] = o[s](u), n.c()), w(n, 1), n.m(l.parentNode, l)) : n = null);
    },
    i(u) {
      r || (w(e.$$.fragment, u), w(n), r = !0);
    },
    o(u) {
      C(e.$$.fragment, u), C(n), r = !1;
    },
    d(u) {
      u && (S(t), S(l)), j(e, u), ~s && a[s].d(u);
    }
  };
}
f(oU, "create_default_slot$2q");
function aU(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Hit Points Configuration",
      $$slots: { default: [oU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, cls, leveledHpType, rollFormula*/
      8199 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(aU, "create_fragment$4n");
function cU(i, e, t) {
  var _, y, k;
  let { cls: s } = e, { classLevel: n } = e, { clsReturnData: l } = e;
  function r() {
    return `1d${s.hitDice.size}`;
  }
  f(r, "getHpRollFormula");
  function o(v) {
    typeof v == "string" ? t(7, l.hpFormula = v, l) : t(7, l.hpValue = v, l), t(7, l.leveledHpType = u, l);
  }
  f(o, "updateHpValue");
  function a(v) {
    t(1, u = v), u === "average" ? o(s.averageHP) : u === "roll" ? o(r()) : u === "custom" && o(p);
  }
  f(a, "updateLeveledHpType");
  const { classHPTypes: c } = CONFIG.A5E;
  let u = "average", d = r(), p = ((k = (y = (_ = s.system) == null ? void 0 : _.hp) == null ? void 0 : y.levels) == null ? void 0 : k[n]) ?? 0;
  u === "average" ? o(s.averageHP) : u === "roll" && o(r());
  const m = /* @__PURE__ */ f(({ detail: v }) => {
    a(v);
  }, "updateSelection_handler"), g = /* @__PURE__ */ f(({ target: v }) => {
    t(2, d = v == null ? void 0 : v.value), o(d);
  }, "change_handler"), h = /* @__PURE__ */ f(({ target: v }) => {
    o(Number(v == null ? void 0 : v.value));
  }, "change_handler_1");
  return i.$$set = (v) => {
    "cls" in v && t(0, s = v.cls), "classLevel" in v && t(8, n = v.classLevel), "clsReturnData" in v && t(7, l = v.clsReturnData);
  }, [
    s,
    u,
    d,
    o,
    a,
    c,
    p,
    l,
    n,
    m,
    g,
    h
  ];
}
f(cU, "instance$4e");
const $A = class $A extends ie {
  constructor(e) {
    super(), le(this, e, cU, aU, ne, { cls: 0, classLevel: 8, clsReturnData: 7 });
  }
};
f($A, "ClassHitPointsSelection");
let z_ = $A;
function bD(i, e, t) {
  const s = i.slice();
  return s[25] = e[t].grant, s[26] = e[t].id, s;
}
f(bD, "get_each_context$1F");
function _D(i) {
  let e, t, s, n = (
    /*clsLevel*/
    i[1] > 1 && yD(i)
  ), l = (
    /*cls*/
    i[0].system.classLevels === 1 && /*cls*/
    i[0].system.spellcasting.ability.options.length && vD(i)
  );
  return {
    c() {
      n && n.c(), e = R(), l && l.c(), t = $e();
    },
    m(r, o) {
      n && n.m(r, o), T(r, e, o), l && l.m(r, o), T(r, t, o), s = !0;
    },
    p(r, o) {
      /*clsLevel*/
      r[1] > 1 ? n ? (n.p(r, o), o & /*clsLevel*/
      2 && w(n, 1)) : (n = yD(r), n.c(), w(n, 1), n.m(e.parentNode, e)) : n && (ce(), C(n, 1, 1, () => {
        n = null;
      }), ue()), /*cls*/
      r[0].system.classLevels === 1 && /*cls*/
      r[0].system.spellcasting.ability.options.length ? l ? (l.p(r, o), o & /*cls*/
      1 && w(l, 1)) : (l = vD(r), l.c(), w(l, 1), l.m(t.parentNode, t)) : l && (ce(), C(l, 1, 1, () => {
        l = null;
      }), ue());
    },
    i(r) {
      s || (w(n), w(l), s = !0);
    },
    o(r) {
      C(n), C(l), s = !1;
    },
    d(r) {
      r && (S(e), S(t)), n && n.d(r), l && l.d(r);
    }
  };
}
f(_D, "create_if_block_1$1v");
function yD(i) {
  let e, t, s;
  function n(r) {
    i[17](r);
  }
  f(n, "classhitpointsselection_clsReturnData_binding");
  let l = {
    cls: (
      /*cls*/
      i[0]
    ),
    classLevel: (
      /*clsLevel*/
      i[1]
    )
  };
  return (
    /*clsReturnData*/
    i[4] !== void 0 && (l.clsReturnData = /*clsReturnData*/
    i[4]), e = new z_({ props: l }), st.push(() => mt(e, "clsReturnData", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, o) {
        const a = {};
        o & /*cls*/
        1 && (a.cls = /*cls*/
        r[0]), o & /*clsLevel*/
        2 && (a.classLevel = /*clsLevel*/
        r[1]), !t && o & /*clsReturnData*/
        16 && (t = !0, a.clsReturnData = /*clsReturnData*/
        r[4], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(yD, "create_if_block_3$A");
function vD(i) {
  let e, t;
  return e = new Me({
    props: {
      heading: "Spellcasting Config",
      $$slots: { default: [uU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, spellCastingOptions, spellcastingAbility*/
      536871008 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(vD, "create_if_block_2$W");
function uU(i) {
  let e, t;
  return e = new Ye({
    props: {
      options: (
        /*spellCastingOptions*/
        i[6]
      ),
      allowDeselect: !1,
      selected: (
        /*spellcastingAbility*/
        i[5] || ""
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[18]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*spellCastingOptions*/
      64 && (l.options = /*spellCastingOptions*/
      s[6]), n & /*spellcastingAbility*/
      32 && (l.selected = /*spellcastingAbility*/
      s[5] || ""), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(uU, "create_default_slot_1$1t");
function kD(i) {
  let e, t;
  return e = new Me({
    props: {
      heading: "Optional Grants Selection",
      $$slots: { default: [fU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, optionalGrants, selectedOptionalGrants*/
      536871172 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(kD, "create_if_block$2m");
function fU(i) {
  let e, t;
  return e = new Ze({
    props: {
      options: (
        /*optionalGrants*/
        i[8].map(AD)
      ),
      selected: (
        /*selectedOptionalGrants*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[19]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*optionalGrants*/
      256 && (l.options = /*optionalGrants*/
      s[8].map(AD)), n & /*selectedOptionalGrants*/
      4 && (l.selected = /*selectedOptionalGrants*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(fU, "create_default_slot$2p");
function wD(i) {
  var a, c, u, d;
  let e, t, s;
  const n = [
    /*grant*/
    (c = (a = i[25]).getSelectionComponentProps) == null ? void 0 : c.call(
      a,
      /*applyData*/
      i[3].get(
        /*id*/
        i[26]
      ) ?? {}
    ),
    { grant: (
      /*grant*/
      i[25]
    ) }
  ];
  function l(...p) {
    return (
      /*updateSelection_handler_2*/
      i[20](
        /*id*/
        i[26],
        ...p
      )
    );
  }
  f(l, "updateSelection_handler_2");
  var r = (
    /*grant*/
    (d = (u = i[25]).getSelectionComponent) == null ? void 0 : d.call(u)
  );
  function o(p, m) {
    var h, _;
    let g = {};
    for (let y = 0; y < n.length; y += 1)
      g = fs(g, n[y]);
    return m !== void 0 && m & /*configurableGrants, applyData*/
    136 && (g = fs(g, hs(n, [
      Es(
        /*grant*/
        (_ = (h = p[25]).getSelectionComponentProps) == null ? void 0 : _.call(
          h,
          /*applyData*/
          p[3].get(
            /*id*/
            p[26]
          ) ?? {}
        )
      ),
      m & /*configurableGrants*/
      128 && { grant: (
        /*grant*/
        p[25]
      ) }
    ]))), { props: g };
  }
  return f(o, "switch_props"), r && (e = nt(r, o(i)), e.$on("updateSelection", l)), {
    c() {
      e && L(e.$$.fragment), t = $e();
    },
    m(p, m) {
      e && N(e, p, m), T(p, t, m), s = !0;
    },
    p(p, m) {
      var g, h, _, y;
      if (i = p, m & /*configurableGrants*/
      128 && r !== (r = /*grant*/
      (h = (g = i[25]).getSelectionComponent) == null ? void 0 : h.call(g))) {
        if (e) {
          ce();
          const k = e;
          C(k.$$.fragment, 1, 0, () => {
            j(k, 1);
          }), ue();
        }
        r ? (e = nt(r, o(i, m)), e.$on("updateSelection", l), L(e.$$.fragment), w(e.$$.fragment, 1), N(e, t.parentNode, t)) : e = null;
      } else if (r) {
        const k = m & /*configurableGrants, applyData*/
        136 ? hs(n, [
          Es(
            /*grant*/
            (y = (_ = i[25]).getSelectionComponentProps) == null ? void 0 : y.call(
              _,
              /*applyData*/
              i[3].get(
                /*id*/
                i[26]
              ) ?? {}
            )
          ),
          m & /*configurableGrants*/
          128 && { grant: (
            /*grant*/
            i[25]
          ) }
        ]) : {};
        e.$set(k);
      }
    },
    i(p) {
      s || (e && w(e.$$.fragment, p), s = !0);
    },
    o(p) {
      e && C(e.$$.fragment, p), s = !1;
    },
    d(p) {
      p && S(t), e && j(e, p);
    }
  };
}
f(wD, "create_each_block$1F");
function $D(i) {
  let e, t, s = oe(
    /*configurableGrants*/
    i[7]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = wD(bD(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, o) {
      if (o & /*configurableGrants, applyData*/
      136) {
        s = oe(
          /*configurableGrants*/
          r[7]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = bD(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = wD(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f($D, "create_key_block$4");
function dU(i) {
  var g;
  let e, t, s, n, l = (
    /*applyData*/
    i[3]
  ), r, o, a, c, u, d = (
    /*cls*/
    i[0] && /*cls*/
    ((g = i[0]) == null ? void 0 : g.type) === "class" && _D(i)
  ), p = (
    /*optionalGrants*/
    i[8].length && kD(i)
  ), m = $D(i);
  return {
    c() {
      e = E("article"), t = E("section"), d && d.c(), s = R(), p && p.c(), n = R(), m.c(), r = R(), o = E("button"), o.textContent = "Submit", b(t, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable"), b(e, "class", "svelte-144ec7h");
    },
    m(h, _) {
      T(h, e, _), A(e, t), d && d.m(t, null), A(t, s), p && p.m(t, null), A(t, n), m.m(t, null), A(t, r), A(t, o), a = !0, c || (u = V(o, "click", tt(
        /*onSubmit*/
        i[9]
      )), c = !0);
    },
    p(h, [_]) {
      var y;
      /*cls*/
      h[0] && /*cls*/
      ((y = h[0]) == null ? void 0 : y.type) === "class" ? d ? (d.p(h, _), _ & /*cls*/
      1 && w(d, 1)) : (d = _D(h), d.c(), w(d, 1), d.m(t, s)) : d && (ce(), C(d, 1, 1, () => {
        d = null;
      }), ue()), /*optionalGrants*/
      h[8].length ? p ? (p.p(h, _), _ & /*optionalGrants*/
      256 && w(p, 1)) : (p = kD(h), p.c(), w(p, 1), p.m(t, n)) : p && (ce(), C(p, 1, 1, () => {
        p = null;
      }), ue()), _ & /*applyData*/
      8 && ne(l, l = /*applyData*/
      h[3]) ? (ce(), C(m, 1, 1, ee), ue(), m = $D(h), m.c(), w(m, 1), m.m(t, r)) : m.p(h, _);
    },
    i(h) {
      a || (w(d), w(p), w(m), a = !0);
    },
    o(h) {
      C(d), C(p), C(m), a = !1;
    },
    d(h) {
      h && S(e), d && d.d(), p && p.d(), m.d(h), c = !1, u();
    }
  };
}
f(dU, "create_fragment$4m");
const AD = /* @__PURE__ */ f((i) => [i._id, i.label], "func$g");
function pU(i, e, t) {
  var ae, be, we;
  let s, n, l, r, o, { allGrants: a, dialog: c, optionalGrantsProp: u, actor: d, item: p, cls: m, clsLevel: g } = (
    // @ts-ignore
    fe("#external").application
  ), { allGrants: h = a, dialog: _ = c, optionalGrantsProp: y = u, actor: k = d, item: v = p, cls: O = m, clsLevel: P = g } = e;
  et("actor", k), et("item", v);
  function D() {
    return h.reduce(
      (ve, me) => {
        var he;
        return (he = me.grantedBy) != null && he.id || ve.add(me._id), ve;
      },
      /* @__PURE__ */ new Set()
    );
  }
  f(D, "getStartingSelectedGrants");
  function I() {
    return y.filter((ve) => {
      var me;
      return !((me = ve.grantedBy) != null && me.id);
    });
  }
  f(I, "getStartingOptionalGrants");
  function B() {
    const ve = D();
    h.forEach((me) => {
      me.grantType === "feature" && s.has(me._id) && ve.add(me._id);
    }), t(8, l = y.filter((me) => {
      var Fe, Ve;
      if (!((Fe = me.grantedBy) != null && Fe.id))
        return !0;
      if (!ve.has(me.grantedBy.id))
        return !1;
      const he = ((Ve = s.get(me.grantedBy.id)) == null ? void 0 : Ve.uuids) ?? [];
      return !!(me.grantedBy.selectionId ? he.includes(me.grantedBy.selectionId) : !1);
    })), t(15, G = /* @__PURE__ */ new Set([...ve, ...U])), t(16, n = F(G, U)), t(7, r = n.filter((me) => me.requiresConfig));
  }
  f(B, "updateActiveGrants");
  function F(ve, me) {
    const he = [];
    return h.forEach((Ae) => {
      var rt;
      const { grantedBy: Fe } = Ae;
      if (Fe != null && Fe.id && !ve.has(Fe.id))
        return;
      const Ve = ((rt = s.get((Fe == null ? void 0 : Fe.id) ?? "")) == null ? void 0 : rt.uuids) ?? [], je = Fe != null && Fe.selectionId ? Ve.includes(Fe.selectionId) : !0;
      if (Fe != null && Fe.id && Ve && !je || Ae.optional)
        return;
      let Pe = !1;
      Ae.requiresConfig() && (Pe = !0), he.push({ grant: Ae, requiresConfig: Pe, id: Ae._id });
    }), l.forEach((Ae) => {
      var rt;
      const { grantedBy: Fe } = Ae;
      if (Fe != null && Fe.id && !ve.has(Fe.id))
        return;
      const Ve = ((rt = s.get((Fe == null ? void 0 : Fe.id) ?? "")) == null ? void 0 : rt.uuids) ?? [], je = Fe != null && Fe.selectionId ? Ve.includes(Fe.selectionId) : !0;
      if (Fe != null && Fe.id && je || !me.includes(Ae._id))
        return;
      let Pe = !1;
      Ae.requiresConfig() && (Pe = !0), he.push({ grant: Ae, requiresConfig: Pe, id: Ae._id });
    }), he;
  }
  f(F, "getApplicableGrants");
  function H() {
    const { updateData: ve, documentData: me } = l9(k, n, s) ?? {};
    t(4, q.spellcastingAbility = W || "", q), _.submit({
      success: !0,
      updateData: ve,
      documentData: me,
      clsReturnData: q
    });
  }
  f(H, "onSubmit");
  let G = D(), U = [], q = {}, W = ((we = (be = (ae = O == null ? void 0 : O.system) == null ? void 0 : ae.spellcasting) == null ? void 0 : be.ability) == null ? void 0 : we.options[0]) ?? "";
  function X(ve) {
    q = ve, t(4, q);
  }
  f(X, "classhitpointsselection_clsReturnData_binding");
  const te = /* @__PURE__ */ f(({ detail: ve }) => t(5, W = ve), "updateSelection_handler"), J = /* @__PURE__ */ f(({ detail: ve }) => t(2, U = ve), "updateSelection_handler_1"), re = /* @__PURE__ */ f((ve, { detail: me }) => {
    s.set(ve, me), t(3, s);
  }, "updateSelection_handler_2");
  return i.$$set = (ve) => {
    "allGrants" in ve && t(10, h = ve.allGrants), "dialog" in ve && t(11, _ = ve.dialog), "optionalGrantsProp" in ve && t(12, y = ve.optionalGrantsProp), "actor" in ve && t(13, k = ve.actor), "item" in ve && t(14, v = ve.item), "cls" in ve && t(0, O = ve.cls), "clsLevel" in ve && t(1, P = ve.clsLevel);
  }, i.$$.update = () => {
    var ve, me, he, Ae;
    i.$$.dirty & /*activeGrants, selectedOptionalGrants*/
    32772 && t(16, n = F(G, U)), i.$$.dirty & /*grants*/
    65536 && t(7, r = n.filter((Fe) => Fe.requiresConfig)), i.$$.dirty & /*cls*/
    1 && t(6, o = (Ae = (he = (me = (ve = O == null ? void 0 : O.system) == null ? void 0 : ve.spellcasting) == null ? void 0 : me.ability) == null ? void 0 : he.options) == null ? void 0 : Ae.map((Fe) => [Fe, CONFIG.A5E.abilities[Fe]])), i.$$.dirty & /*selectedOptionalGrants, applyData*/
    12 && B();
  }, t(3, s = /* @__PURE__ */ new Map()), t(8, l = I()), [
    O,
    P,
    U,
    s,
    q,
    W,
    o,
    r,
    l,
    H,
    h,
    _,
    y,
    k,
    v,
    G,
    n,
    X,
    te,
    J,
    re
  ];
}
f(pU, "instance$4d");
const AA = class AA extends ie {
  constructor(e) {
    super(), le(this, e, pU, dU, ne, {
      allGrants: 10,
      dialog: 11,
      optionalGrantsProp: 12,
      actor: 13,
      item: 14,
      cls: 0,
      clsLevel: 1
    });
  }
  get allGrants() {
    return this.$$.ctx[10];
  }
  set allGrants(e) {
    this.$$set({ allGrants: e }), Ke();
  }
  get dialog() {
    return this.$$.ctx[11];
  }
  set dialog(e) {
    this.$$set({ dialog: e }), Ke();
  }
  get optionalGrantsProp() {
    return this.$$.ctx[12];
  }
  set optionalGrantsProp(e) {
    this.$$set({ optionalGrantsProp: e }), Ke();
  }
  get actor() {
    return this.$$.ctx[13];
  }
  set actor(e) {
    this.$$set({ actor: e }), Ke();
  }
  get item() {
    return this.$$.ctx[14];
  }
  set item(e) {
    this.$$set({ item: e }), Ke();
  }
  get cls() {
    return this.$$.ctx[0];
  }
  set cls(e) {
    this.$$set({ cls: e }), Ke();
  }
  get clsLevel() {
    return this.$$.ctx[1];
  }
  set clsLevel(e) {
    this.$$set({ clsLevel: e }), Ke();
  }
};
f(AA, "GrantApplicationDialog");
let H_ = AA;
function lb() {
  return {
    armor: {
      label: "A5E.ArmorPlural",
      config: Object.entries(CONFIG.A5E.armor),
      propertyKey: "system.proficiencies.armor"
    },
    tradition: {
      label: "A5E.ManeuverTraditionPlural",
      config: Object.entries(CONFIG.A5E.maneuverTraditions),
      propertyKey: "system.proficiencies.traditions"
    },
    skill: {
      label: "A5E.SkillPlural",
      config: Object.entries(CONFIG.A5E.skills),
      propertyKey: ""
    },
    savingThrow: {
      label: "A5E.SavingThrowPlural",
      config: Object.entries(CONFIG.A5E.abilities),
      propertyKey: ""
    },
    tool: {
      label: "A5E.ToolPlural",
      config: CONFIG.A5E.tools,
      propertyKey: "system.proficiencies.tools"
    },
    weapon: {
      label: "A5E.Weapons",
      config: CONFIG.A5E.weapons,
      propertyKey: "system.proficiencies.weapons"
    }
  };
}
f(lb, "prepareProficiencyConfigObject");
function rb() {
  return {
    conditionImmunities: {
      label: "A5E.ConditionImmunities",
      config: Object.entries(CONFIG.A5E.conditions),
      propertyKey: "system.traits.conditionImmunities"
    },
    creatureTypes: {
      label: "A5E.CreatureTypesLabel",
      config: Object.entries(CONFIG.A5E.creatureTypes),
      propertyKey: "system.details.creatureTypes"
    },
    damageImmunities: {
      label: "A5E.DamageImmunities",
      config: Object.entries(CONFIG.A5E.damageTypes),
      propertyKey: "system.traits.damageImmunities"
    },
    damageResistances: {
      label: "A5E.DamageResistances",
      config: Object.entries(CONFIG.A5E.damageTypes),
      propertyKey: "system.traits.damageResistances"
    },
    damageVulnerabilities: {
      label: "A5E.DamageVulnerabilities",
      config: Object.entries(CONFIG.A5E.damageTypes),
      propertyKey: "system.traits.damageVulnerabilities"
    },
    languages: {
      label: "A5E.Languages",
      config: Object.entries(CONFIG.A5E.languages),
      propertyKey: "system.proficiencies.languages"
    },
    size: {
      label: "A5E.Size",
      config: Object.entries(CONFIG.A5E.actorSizes),
      propertyKey: "system.traits.size"
    }
  };
}
f(rb, "prepareTraitGrantConfigObject");
async function mU(i, e = {}) {
  var p;
  const { relative: t, invalid: s = !1, parent: n = null } = e, l = i.map((m) => foundry.utils.parseUuid(m, { relative: t })), r = [], o = [], a = /* @__PURE__ */ new Map();
  for (const {
    collection: m,
    documentId: g,
    documentType: h,
    doc: _
  } of l)
    m instanceof CompendiumCollection ? h === "Folder" ? o.push(m.folders.get(g)) : (a.has(m) || a.set(m, []), (p = a.get(m)) == null || p.push(g)) : r.push(_ ?? (m == null ? void 0 : m.get(g, { invalid: s })));
  const c = [...a.entries()].map(([m, g]) => ({
    collection: m,
    query: { _id__in: g }
  }));
  return (await Promise.all(
    c.map(({ collection: m, query: g }) => m.getDocuments(g))
  )).flat().concat(r, o).reduce((m, g) => {
    const h = new Item.implementation(g.toObject(), { parent: n, keepId: !0 });
    return h.updateSource({ "flags.core.sourceId": g.uuid }), m.push(h), m;
  }, []);
}
f(mU, "fromUuidMulti");
var Im, r9, zo, od, ku, V_, Pm, o9, ur, Wa;
const EA = class EA extends Map {
  constructor(t) {
    super();
    Y(this, Im);
    Y(this, zo);
    Y(this, ku);
    Y(this, Pm);
    Y(this, ur);
    Ge(this, "actor");
    Ge(this, "allowedTypes", ["feature", "background", "class", "culture", "heritage"]);
    Ge(this, "grantedFeatureDocuments", /* @__PURE__ */ new Map());
    this.actor = t;
    const s = this.actor.system.grants ?? {};
    Object.entries(s).forEach(([n, l]) => {
      l.grantId ?? (l.grantId = n);
      let r = vn[l.grantType];
      r || console.warn(`Grant ${n} has no class mapping.`), r ?? (r = vn.base);
      const o = new r(l, { parent: t });
      this.set(n, o);
    }), [...this.values()].forEach((n) => {
      if (!(n instanceof vn.feature))
        return;
      const { documentIds: l } = n;
      l.forEach((r) => {
        var o;
        this.grantedFeatureDocuments.has(r) || this.grantedFeatureDocuments.set(r, []), (o = this.grantedFeatureDocuments.get(r)) == null || o.push(n.grantId);
      });
    });
  }
  byType(t) {
    return [...this.values()].filter((s) => s.grantType === t);
  }
  // *************************************************************
  // Data Retrieval Methods
  // *************************************************************
  getGrantedTraits(t) {
    return this.byType("trait").reduce((n, l) => (l.traitData.traitType !== t || (n[l.grantId] = {
      itemId: l.itemUuid,
      traits: l.traitData.traits
    }), n), {});
  }
  // *************************************************************
  // Update Methods
  // *************************************************************
  async createInitialGrants(t, s = !1) {
    var d;
    if (!t || !this.allowedTypes.includes(t.type))
      return;
    const n = [], l = [], r = this.actor.levels.character, o = ((d = this.actor.levels.classes) == null ? void 0 : d[t == null ? void 0 : t.slug]) ?? 1, a = [...t.grants.values()];
    a.forEach((p) => {
      p.grantedBy = { id: "", selectionId: "" };
    });
    const c = (await Promise.all(
      a.map((p) => Z(this, zo, od).call(this, p, r))
    )).flat().filter((p) => !!p);
    a.concat(c).forEach((p) => {
      if (this.has(p._id))
        return;
      const { levelType: m } = p;
      m === "character" && p.level > r || m === "class" && p.level > o || (p.optional && l.push(p), n.push(p));
    });
    const u = t.type === "class" ? t : null;
    await Z(this, ku, V_).call(this, n, l, {
      item: t,
      cls: u,
      clsLevel: o,
      useUpdateSource: s
    });
  }
  async createLeveledGrants(t = 0, s = 0, n = null) {
    var p, m;
    const l = s - t, r = Math.sign(l), o = this.actor.levels.character + l;
    if (r === 0)
      return !1;
    if (r === -1)
      return await this.removeGrantsByLevel(o);
    const a = [], c = [], u = this.actor.items.filter((g) => this.allowedTypes.includes(g.type));
    for await (const g of u) {
      const h = g.slug || ((p = g.system.classes) == null ? void 0 : p.slugify()) || "";
      let _ = ((m = this.actor.levels.classes) == null ? void 0 : m[h]) ?? 1;
      h === (n == null ? void 0 : n.slug) && (_ += l);
      const y = [...g.grants.values()];
      y.forEach((v) => {
        v.grantedBy = { id: "", selectionId: "" };
      });
      const k = (await Promise.all(
        y.map((v) => Z(this, zo, od).call(this, v, o))
      )).flat().filter((v) => !!v);
      y.concat(k).forEach((v) => {
        var D, I, B;
        let O = !1;
        if ((D = v.grantedBy) != null && D.id) {
          const F = g.grants.get(v.grantedBy.id);
          O = Z(this, Im, r9).call(this, F);
        }
        if (this.has(v._id) && !O || this.has(((I = v.grantedBy) == null ? void 0 : I.id) || "") && !O)
          return;
        const { levelType: P } = v;
        if (!(P === "character" && v.level > o) && !(P === "class" && v.level > _) && !a.find((F) => F._id === v._id)) {
          if (v.optional) {
            if (!(P === "class" ? v.level === _ : v.level === o) && !((B = v.grantedBy) != null && B.id) && !O)
              return;
            c.push(v);
          }
          a.push(v);
        }
      });
    }
    return await Z(this, ku, V_).call(this, a, c, { cls: n, clsLevel: s, useUpdateSource: !1 });
  }
  async removeGrantsByItem(t) {
    const s = {};
    for (const [n, l] of this)
      l.itemUuid === t && (s[`system.grants.-=${n}`] = null, foundry.utils.mergeObject(s, Z(this, ur, Wa).call(this, l)));
    await this.actor.update(s);
  }
  async removeGrantsByLevel(t) {
    const s = {};
    for (const [n, l] of this)
      l.level > t && (s[`system.grants.-=${n}`] = null, foundry.utils.mergeObject(s, Z(this, ur, Wa).call(this, l)));
    try {
      await this.actor.update(s);
    } catch (n) {
      return console.error(n), !1;
    }
    return !0;
  }
  async removeGrant(t) {
    const s = this.get(t);
    if (!s)
      return;
    const n = {
      [`system.grants.-=${t}`]: null,
      ...Z(this, ur, Wa).call(this, s)
    };
    await this.actor.update(n);
  }
  async removeAll() {
    const t = {};
    for (const [s, n] of this)
      t[`system.grants.-=${s}`] = null, foundry.utils.mergeObject(t, Z(this, ur, Wa).call(this, n));
    await this.actor.update(t);
  }
};
Im = new WeakSet(), r9 = /* @__PURE__ */ f(function(t) {
  if (!t || t.grantType !== "feature")
    return !1;
  const { features: s } = t;
  return s.base.concat(s.options).some((n) => !n.limitedReselection || n.selectionLimit > 1);
}, "#isReSelectable"), zo = new WeakSet(), od = /* @__PURE__ */ f(async function(t, s) {
  if (t.grantType !== "feature")
    return [];
  if (t.level > s)
    return [];
  const n = [...t.features.base, ...t.features.options].map((a) => a.uuid), r = (await mU(n, { parent: this.actor })).flatMap((a) => [...a.grants.values()].map((c) => {
    const u = !!t.features.options.length;
    return c.grantedBy = { id: t._id, selectionId: u ? a.flags.core.sourceId : "" }, c;
  })), o = (await Promise.all(
    r.map((a) => Z(this, zo, od).call(this, a, s))
  )).flat().filter((a) => !!a);
  return r.concat(o);
}, "#getSubGrants"), ku = new WeakSet(), V_ = /* @__PURE__ */ f(async function(t, s, n) {
  var o, a;
  if (!t.length && !n.cls)
    return !1;
  const l = [...t].some((c) => c.requiresConfig()) || !!s.length || n.cls;
  let r;
  if (l) {
    const c = new pa(
      `${this.actor.name} - Apply Grants`,
      H_,
      {
        actor: this.actor,
        allGrants: t,
        optionalGrantsProp: s,
        ...n
      }
    );
    if (await c.render(!0), r = await c.promise, !(r != null && r.success))
      return n != null && n.item && n.useUpdateSource && !n.cls && n.item.delete(), !1;
  } else {
    const c = t.map((p) => ({ id: p._id, grant: p })), { updateData: u, documentData: d } = l9(this.actor, c, /* @__PURE__ */ new Map());
    r = {
      success: !0,
      updateData: u,
      documentData: d,
      clsReturnData: {}
    };
  }
  if (r.documentData.size) {
    const c = {};
    for await (const [u, d] of r.documentData) {
      const p = await Promise.all(
        d.map(async ({ uuid: m, type: g, quantity: h }) => {
          const _ = (await fromUuid(m)).toObject();
          return g === "feature" || !h || (_.system.quantity = h), _;
        })
      );
      try {
        if (((o = d[0]) == null ? void 0 : o.type) === "object") {
          const m = (await this.actor.createEmbeddedDocuments("Item", p, { noHook: !0 })).map((g) => g.id);
          c[`system.grants.${u}.documentIds`] = m;
        } else if (((a = d[0]) == null ? void 0 : a.type) === "feature") {
          const m = p.map((k) => k._id), h = this.actor.items.filter((k) => m.includes(k.id)).map((k) => k.id), _ = p.filter((k) => !h.includes(k._id)), y = (await this.actor.createEmbeddedDocuments("Item", _, { noHook: !0, keepId: !0 })).map((k) => k.id);
          c[`system.grants.${u}.documentIds`] = [...y, ...h];
        }
      } catch (m) {
        return console.error(m), !1;
      }
    }
    foundry.utils.mergeObject(r.updateData, c);
  }
  if (r.updateData && await this.actor.update(r.updateData), n.cls) {
    const { clsReturnData: c } = r, { leveledHpType: u, hpFormula: d, hpValue: p } = c;
    let m;
    if (u === "roll" && d) {
      const _ = await new Roll(d).roll({ async: !0 });
      m = _.total, Z(this, Pm, o9).call(this, n.cls, _);
    } else
      ["custom", "average"].includes(u) && p ? m = p : m = n.cls.system.classLevels === 1 ? n.cls.system.hp.levels[1] : n.cls.averageHP;
    const g = c.spellcastingAbility || n.cls.system.spellcasting.ability.options[0] || n.cls.system.spellcasting.ability.base;
    await (n.useUpdateSource ? n.cls.updateSource.bind(n.cls) : n.cls.update.bind(n.cls))({
      [`system.hp.levels.${n.clsLevel}`]: m,
      "system.spellcasting.ability.value": g
    });
  }
  return !0;
}, "#applyGrants"), Pm = new WeakSet(), o9 = /* @__PURE__ */ f(function(t, s) {
  var r, o;
  const n = `Hit Dice Roll - ${t.name}`, l = {
    user: (r = game.user) == null ? void 0 : r.id,
    speaker: ChatMessage.getSpeaker({ actor: this.actor }),
    type: CONST.CHAT_MESSAGE_TYPES.ROLL,
    sound: CONFIG.sounds.dice,
    rolls: [s],
    flags: {
      a5e: {
        actorId: this.actor.uuid,
        img: ((o = this.actor.token) == null ? void 0 : o.img) ?? this.actor.img,
        name: this.actor.name,
        title: n
      }
    }
  };
  ChatMessage.create(l);
}, "#createRolledHpCard"), ur = new WeakSet(), Wa = /* @__PURE__ */ f(function(t) {
  const s = {};
  if (t instanceof vn.bonus && t.bonusId && (s[`system.bonuses.${t.type}.-=${t.bonusId}`] = null), t instanceof vn.exertion && t.exertionData.exertionType === "bonus" && (s[`system.bonuses.exertion.-=${t.exertionData.bonusId}`] = null), t instanceof vn.feature || t instanceof vn.item) {
    let n;
    if (t instanceof vn.feature) {
      const { grantedFeatureDocuments: r } = this, { documentIds: o } = t;
      n = o.reduce((a, c) => {
        var u;
        return r.has(c) && ((u = r.get(c)) == null ? void 0 : u.length) === 1 && a.push(c), a;
      }, []);
    } else
      n = t.documentIds;
    if (!(n != null && n.length))
      return s;
    const l = this.actor.items.reduce((r, o) => (n.includes(o.id) && r.push(o.id), r), []);
    this.actor.deleteEmbeddedDocuments("Item", l);
  }
  if (t instanceof vn.proficiency) {
    const { keys: n, proficiencyType: l } = t.proficiencyData;
    if (l === "savingThrow")
      n.forEach((r) => {
        s[`system.abilities.${r}.save.proficient`] = !1;
      });
    else if (l === "skill")
      n.forEach((r) => {
        s[`system.skills.${r}.proficient`] = 0;
      });
    else {
      const r = lb(), { propertyKey: o } = r[l] ?? {};
      if (!o)
        return {};
      const a = new Set(n), c = new Set(
        foundry.utils.getProperty(this.actor, o) ?? []
      );
      s[o] = [...c.difference(a)];
    }
  }
  if (t instanceof vn.skillSpecialty) {
    const { skill: n } = t.specialtyData, l = new Set(
      foundry.utils.getProperty(
        this.actor,
        `system.skills.${n}.specialties`
      ) ?? []
    ), r = new Set(t.specialtyData.specialties);
    s[`system.skills.${n}.specialties`] = [...l.difference(r)];
  }
  if (t instanceof vn.trait) {
    const n = rb(), { propertyKey: l } = n[t.traitData.traitType] ?? {};
    if (!l)
      return {};
    const r = new Set(t.traitData.traits), o = new Set(
      foundry.utils.getProperty(this.actor, l) ?? []
    );
    t.traitData.traitType === "size" ? s[l] = "" : s[l] = [...o.difference(r)];
  }
  return s;
}, "#getRemoveUpdates"), f(EA, "ActorGrantsManger");
let U_ = EA;
var Hs, ps;
const SA = class SA {
  constructor(e) {
    Y(this, Hs, void 0);
    Y(this, ps, void 0);
    ye(this, Hs, e), ye(this, ps, M(this, Hs).system.bonuses ?? {});
  }
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  //  Utility Helpers
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  getDefaultSelections(e, t = {}) {
    let s;
    return e === "abilities" && t.abilityKey ? s = this.prepareAbilityBonuses(t.abilityKey, t.abilityType ?? "check") : e === "attacks" && t.item && t.attackType ? s = this.prepareAttackBonuses(t.item, t.attackType) : e === "damage" && t.item && t.rolls ? s = this.prepareGlobalDamageBonuses(t.item, t.rolls) : e === "healing" && t.item && t.rolls ? s = this.prepareGlobalHealingBonuses(t.item, t.rolls) : e === "initiative" && (t.skillKey || t.abilityKey) ? s = this.prepareInitiativeBonuses(
      { abilityKey: t.abilityKey, skillKey: t.skillKey }
    ) : e === "skills" && t.skillKey && (s = this.prepareSkillBonuses(t.skillKey, t.abilityKey, "check", !1)), s ? (s = { bonuses: s }, Object.values(s ?? {}).flat().reduce((l, [r, o]) => (o.formula && (o.default ?? !0) && l.push(r), l), [])) : [];
  }
  getDefaultSelectionsFromBonuses(e) {
    return Object.values(e ?? {}).flat().reduce((t, [s, n]) => (["generic", "healing", "damage"].includes(n.type) && !n.formula || (n.default ?? !0) && t.push(s), t), []);
  }
  getSelectedBonusesFormula(e, t) {
    const s = M(this, ps)[e];
    return t.map((l) => {
      var r;
      return (r = s[l]) == null ? void 0 : r.formula;
    }).join(" + ").trim();
  }
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  // Formula Wrappers
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  /**
   * Wrapper for {@link getAbilityBonuses} that returns a formula string instead of an array.
   *
   * @param abilityKey
   * @param type
   * @param selectedBonuses
   * @returns
   */
  getAbilityBonusesFormula(e, t = "check") {
    return this.prepareAbilityBonuses(e, t).map(([, l]) => {
      var a;
      const r = ((a = M(this, Hs)._source.system.abilities[e]) == null ? void 0 : a.value) ?? 0;
      return l.formula.trim().replace("@original", r.toString());
    }).join(" + ").trim();
  }
  /**
   * Wrapper for {@link getGlobalAbilityBonuses} that returns a formula string instead of an array.
   * @param type
   * @returns
   */
  getGlobalAbilityBonusesFormula(e = "check") {
    return this.prepareGlobalAbilityBonuses(e).map(([, n]) => n.formula).join(" + ").trim();
  }
  /**
   * Wrapper for {@link getAttackBonuses} that returns a formula string instead of an array.
   * @param item
   * @param type
   * @returns
   */
  getAttackBonusFormula(e, t = "meleeWeaponAttack") {
    return this.prepareAttackBonuses(e, t).map(([, l]) => l.formula).join(" + ").trim();
  }
  getExertionBonusFormula() {
    const e = M(this, ps).exertion ?? {};
    return Object.values(e).reduce((s, n) => {
      const l = n.formula.trim();
      return l && s.push(l), s;
    }, []).join(" + ").trim();
  }
  getHitPointsBonusFormula() {
    return this.prepareHitPointsBonuses().map(([, s]) => {
      let { formula: n } = s;
      return s.context.perLevel && (n = `(${n}) * @level`), n;
    }).join(" + ").trim();
  }
  getHitPointsBonusPerLevelFormula() {
    return this.prepareHitPointsBonuses().reduce((s, [, n]) => {
      const { formula: l } = n;
      return n.context.perLevel && s.push(l), s;
    }, []).join(" + ").trim();
  }
  /**
   * Wrapper for {@link getInitiativeBonuses} that returns a formula string instead of an array.
   * @param ablKey
   * @param skillKey
   * @returns
   */
  getInitiativeBonusFormula({ abilityKey: e, skillKey: t } = {}) {
    return this.prepareInitiativeBonuses({ abilityKey: e, skillKey: t }).map(([, l]) => l.formula).join(" + ").trim();
  }
  getMovementBonusFormula(e) {
    return this.prepareMovementBonuses(e).map(([, n]) => {
      var o;
      const l = ((o = M(this, Hs)._source.system.attributes.movement[e]) == null ? void 0 : o.distance) ?? 0;
      return n.formula.trim().replace("@original", l.toString());
    }).join(" + ").trim();
  }
  getSensesBonusFormula(e) {
    const t = this.prepareSensesBonuses(e);
    let s = !1;
    const n = t.map(([, l]) => {
      var a;
      const r = ((a = M(this, Hs)._source.system.attributes.senses[e]) == null ? void 0 : a.distance) ?? 0;
      return l.unit === "unlimited" && (s = !0), l.formula.trim().replace("@original", r.toString());
    });
    return s ? "unlimited" : n.join(" + ").trim();
  }
  /**
   * Wrapper for {@link getSkillBonuses} that returns a formula string instead of an array.
   * @param skillKey              The skill key to get bonuses for.
   * @param abilityKey            The ability key to get bonuses for. If not provided, the default
   * @param type                  The type of bonus to get. Can be either 'check' or 'passive'.
   * @param includeAbilityBonuses Whether or not to include ability bonuses in the formula.
   * @param selectedBonuses       Whether or not to include only selected bonuses.
   * @returns
   */
  getSkillBonusesFormula(e, t, s = "check", n = !1) {
    const r = this.prepareSkillBonuses(e, t, s, n).map(([, a]) => {
      var d;
      const c = ((d = M(this, Hs)._source.system.skills[e]) == null ? void 0 : d.value) ?? 0;
      return a.formula.trim().replace("@original", c.toString());
    }), o = M(this, Hs).system.skills[e];
    if (s === "passive" && (o != null && o.expertiseDice)) {
      const a = game.settings.storage.get("world").getItem("a5e.useNPCExpertisePassiveRulesForCharacters") ?? !1;
      if (M(this, Hs).type === "character" && !a)
        r.push("3");
      else {
        const c = CONFIG.A5E.expertiseDiceSidesMap[o.expertiseDice ?? 0];
        r.push((c / 2).toString());
      }
    }
    return r.join(" + ").trim();
  }
  /**
   * Wrapper for {@link getGlobalSkillBonuses} that returns a formula string instead of an array.
   *
   * @param type
   * @returns
   */
  getGlobalSkillBonusesFormula(e = "check") {
    return this.prepareGlobalSkillBonuses(e).map(([, n]) => n.formula).join(" + ").trim();
  }
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  // Bonuses Prepare Functions
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  prepareAbilityBonuses(e, t = "check") {
    const s = M(this, ps).abilities ?? {}, n = M(this, Hs).system.abilities[e];
    if (!n)
      return [];
    const l = n.save.proficient ?? !1, r = {};
    return Object.entries(s).filter(
      ([, { context: a, formula: c }]) => {
        if (!c)
          return !1;
        const { abilities: u, requiresProficiency: d, types: p } = a ?? { abilities: [], requiresProficiency: !1, types: [] };
        return !(!(u != null && u.includes(e)) || !(p != null && p.includes(t)) || d && !l);
      }
    ).map(([a, c]) => {
      if (!c.label) {
        const u = game.i18n.format("A5E.bonuses.labels.abilityBonusSpecific", {
          ability: game.i18n.localize(CONFIG.A5E.abilities[e] ?? "")
        });
        r[e] ?? (r[e] = 0), r[e] += 1, c.defaultLabel = `${u} #${r[e]}`;
      }
      return [a, c];
    });
  }
  prepareGlobalAbilityBonuses(e = "check") {
    const t = M(this, ps).abilities ?? {};
    let s = 0;
    return Object.entries(t).filter(
      ([, { context: l, formula: r }]) => {
        if (!r)
          return !1;
        const { abilities: o, requiresProficiency: a, types: c } = l ?? { abilities: [], requiresProficiency: !1, types: [] };
        return !(!(c != null && c.includes(e)) || a || !Sc(o, Object.keys(CONFIG.A5E.abilities)));
      }
    ).map(([l, r]) => {
      if (!r.label) {
        const o = game.i18n.localize("A5E.bonuses.labels.abilityBonusGlobal");
        s += 1, r.defaultLabel = `${o} #${s[l]}`;
      }
      return [l, r];
    });
  }
  prepareAttackBonuses(e, t = "meleeWeaponAttack") {
    const s = M(this, ps).attacks, n = e.system.level ?? null, l = {};
    return Object.entries(s).filter(
      ([, { context: o, formula: a }]) => {
        if (!a)
          return !1;
        const { attackTypes: c, spellLevels: u } = o ?? { attackTypes: [], spellLevels: [] };
        return !(!(c != null && c.includes(t)) || n !== null && (u != null && u.length) && !(u != null && u.includes(`${n}`)));
      }
    ).map(([o, a]) => {
      if (!a.label) {
        const c = game.i18n.format("A5E.bonuses.labels.attackBonusSpecific", {
          attackType: game.i18n.localize(CONFIG.A5E.attackTypes[t] ?? "")
        });
        l[t] ?? (l[t] = 0), l[t] += 1, a.defaultLabel = `${c} #${l[t]}`;
      }
      return [o, a];
    });
  }
  prepareHitPointsBonuses() {
    const e = M(this, ps).hitPoint ?? {};
    return Object.entries(e).reduce((t, [s, n]) => (n.formula && (n.formula = n.formula.trim(), t.push([s, n])), t), []);
  }
  /**
   *
   * @returns
   */
  prepareGlobalDamageBonuses(e, t) {
    const s = t.attack ?? [], n = t.damage ?? [], l = e.system.level ?? null;
    if (!Array.isArray(s))
      return [];
    if (!s.length)
      return [];
    const { attackType: r } = s[0][1] ?? {}, o = new Set(n.map(([, { damageType: d }]) => d)), a = M(this, ps).damage ?? {}, c = {};
    return Object.entries(a).filter(
      ([, { context: d, formula: p }]) => {
        if (!p)
          return !1;
        const { attackTypes: m, spellLevels: g } = d ?? { attackTypes: [], spellLevels: [] }, h = new Set(d.damageTypes ?? []);
        return !(m != null && m.length && !m.includes(r || "meleeWeaponAttack") || l !== null && g.length && !g.includes(`${l}`) || h.size && !h.intersects(o));
      }
    ).map(([d, p]) => {
      var m;
      if (!p.label) {
        const g = game.i18n.format("A5E.DamageBonusSpecific", {
          damageType: game.i18n.localize(CONFIG.A5E.damageTypes[p.damageType] ?? "")
        });
        c[m = p.damageType] ?? (c[m] = 0), c[p.damageType] += 1, p.defaultLabel = `${g} #${c[p.damageType]}`;
      }
      return [d, p];
    });
  }
  prepareGlobalHealingBonuses(e, t) {
    const s = M(this, ps).healing, n = {}, l = t.healing ?? [], r = e.system.level ?? null;
    if (!l.length)
      return [];
    const o = new Set(l.map(([, { healingType: c }]) => c));
    return Object.entries(s).filter(
      ([, { context: c, formula: u }]) => {
        if (!u)
          return !1;
        const { spellLevels: d } = c ?? { spellLevels: [] }, p = new Set(c.healingTypes ?? []);
        return !(p.size && !p.intersects(o) || r !== null && d.length && !d.includes(`${r}`));
      }
    ).map(([c, u]) => {
      const d = u.healingType || "healing";
      if (!u.label) {
        const p = game.i18n.localize(CONFIG.A5E.healingTypes[d]);
        n[d] ?? (n[d] = 0), n[d] += 1, u.defaultLabel = `${p} #${n[d]}`;
      }
      return [c, u];
    });
  }
  prepareInitiativeBonuses({ abilityKey: e, skillKey: t } = {}) {
    const s = M(this, ps).initiative;
    let n = 0;
    return e = e === "none" ? void 0 : e, t = t === "none" ? void 0 : t, Object.entries(s).filter(
      ([, { context: r, formula: o }]) => {
        if (!o)
          return !1;
        const { abilities: a, skills: c } = r ?? { abilities: [], skills: [] };
        return !(e && (a != null && a.length) && !a.includes(e) || t && (c != null && c.length) && !c.includes(t));
      }
    ).map(([r, o]) => {
      if (!o.label) {
        const a = game.i18n.localize("A5E.bonuses.labels.initiativeBonus");
        n += 1, o.defaultLabel = `${a} #${n}`;
      }
      return [r, o];
    });
  }
  prepareMovementBonuses(e) {
    const t = M(this, ps).movement;
    return Object.entries(t).filter(
      ([, { context: n, formula: l }]) => {
        if (!l)
          return !1;
        const { movementTypes: r } = n ?? { movementTypes: [] };
        return !!(r != null && r.includes(e));
      }
    ).map(([n, l]) => {
      if (!l.label) {
        const r = game.i18n.format("A5E.bonuses.labels.movementBonus", {
          movementType: game.i18n.localize(CONFIG.A5E.movementAbbreviations[e] ?? "")
        });
        l.defaultLabel = r;
      }
      return [n, l];
    });
  }
  prepareSensesBonuses(e) {
    const t = M(this, ps).senses;
    return Object.entries(t).filter(
      ([, { context: n, formula: l, unit: r }]) => {
        if (!l && r !== "unlimited")
          return !1;
        const { senses: o } = n ?? { senses: [] };
        return !!(o != null && o.includes(e));
      }
    ).map(([n, l]) => {
      if (!l.label) {
        const r = game.i18n.format("A5E.bonuses.labels.sensesBonus", {
          sense: game.i18n.localize(CONFIG.A5E.senses[e] ?? "")
        });
        l.defaultLabel = r;
      }
      return [n, l];
    });
  }
  prepareSkillBonuses(e, t, s = "check", n = !1) {
    const l = M(this, ps).skills, r = M(this, Hs).system.skills[e], o = {};
    if (!r)
      return [];
    const a = r.ability, u = Object.entries(l).filter(
      ([, { context: p, formula: m }]) => {
        if (!m)
          return !1;
        const { skills: g, passiveOnly: h } = p ?? { skills: [], passiveOnly: !1 };
        return !(!g.includes(e) || s !== "passive" && h);
      }
    ).map(([p, m]) => {
      if (!m.label) {
        const g = game.i18n.format("A5E.bonuses.labels.skillBonusSpecific", {
          skill: game.i18n.localize(CONFIG.A5E.skills[e] ?? "")
        });
        o[e] ?? (o[e] = 0), o[e] += 1, m.defaultLabel = `${g} #${o[e]}`;
      }
      return [p, m];
    });
    return n ? [...this.prepareAbilityBonuses(t ?? a, "check"), ...u] : u;
  }
  prepareGlobalSkillBonuses(e = "check") {
    const t = M(this, ps).skills;
    let s = 0;
    return Object.entries(t).filter(
      ([, { context: l, formula: r }]) => {
        if (!r)
          return !1;
        const { passiveOnly: o, requiresProficiency: a } = l ?? { passiveOnly: !1, requiresProficiency: !1 };
        return !(a || e !== "passive" && o || !Sc(l.skills, Object.keys(CONFIG.A5E.skills)));
      }
    ).map(([l, r]) => {
      if (!r.label) {
        const o = game.i18n.localize("A5E.bonuses.labels.skillBonusGlobal");
        s += 1, r.defaultLabel = `${o} #${s[l]}`;
      }
      return [l, r];
    });
  }
};
Hs = new WeakMap(), ps = new WeakMap(), f(SA, "BonusesManager");
let W_ = SA;
var wu, K_, $u;
let hU = ($u = class extends ys {
  constructor(t, s = {}) {
    super(t, s);
    Y(this, wu);
    Ge(this, "spells", new foundry.utils.Collection());
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return {
      name: new t.StringField({ required: !0, initial: "New Spell Book" }),
      img: new t.StringField({ required: !0, initial: "icons/svg/book.svg" }),
      ability: new t.StringField({ required: !0, initial: "default" }),
      disableSpellConsumers: new t.BooleanField({ required: !0, initial: !1 }),
      showSpellPoints: new t.BooleanField({ required: !0, initial: !1 }),
      showSpellSlots: new t.BooleanField({ required: !0, initial: !0 })
    };
  }
  // ======================================
  // Getters
  // ======================================
  get spellIds() {
    return this.spells.map((t) => t.id);
  }
  // ======================================
  // Data Preparation
  // ======================================
  prepareBaseData() {
    super.prepareBaseData();
    const t = this.parent;
    if (this.spells = new foundry.utils.Collection(), !!t) {
      for (const s of t.items)
        s.type === "spell" && s.system.spellBook === this._id && this.spells.set(s.id, s);
      this.slug = `spellbook-${this.name}`.slugify(), this.prepareSpellBookStats();
    }
  }
  prepareSpellBookStats() {
    const t = this.parent;
    if (!t)
      return;
    let { ability: s } = this;
    this.ability === "default" && (s = t.system.attributes.spellcasting), s || (s = "int");
    const n = at([
      8,
      t.system.attributes.prof,
      t.system.bonuses.spellDC || 0,
      t.system.abilities[s].check.mod
    ].join(" + "), t.getRollData()) || 10, { abilities: l } = t.system, r = l[s].check.mod, o = {
      ability: this.ability,
      dc: n,
      mod: r
    };
    this.stats = o;
  }
  // ======================================
  // API Methods
  // ======================================
  addSpell(t) {
    const s = this.parent;
    if (!s)
      return;
    const n = Z(this, wu, K_).call(this, t);
    n && s.createEmbeddedDocuments("Item", [n]);
  }
  addSpells(t) {
    const s = this.parent;
    if (!s)
      return;
    const n = t.map((l) => Z(this, wu, K_).call(this, l));
    s.createEmbeddedDocuments("Item", n);
  }
  async delete() {
    const { spellIds: t } = this;
    await this.parent.deleteEmbeddedDocuments("Item", t);
    const s = this._id;
    this.parent.update({
      [`system.spellBooks.-=${s}`]: null
    });
  }
}, wu = new WeakSet(), K_ = /* @__PURE__ */ f(function(t) {
  if (!this.parent)
    return null;
  const n = t.toObject();
  return n.system.spellBook = this._id, n;
}, "#updateSpellData"), f($u, "SpellBook"), $u);
const TA = class TA extends Map {
  constructor(t) {
    super();
    Ge(this, "actor");
    this.actor = t;
    const s = this.actor.system.spellBooks ?? {};
    Object.entries(s ?? {}).forEach(([n, l]) => {
      const r = new hU(l, { parent: this.actor });
      r._id = n, this.set(n, r), this.actor.system.spellBooks[n] = r;
    });
  }
  async add(t) {
    const s = (t == null ? void 0 : t._id) ?? foundry.utils.randomID();
    return await this.actor.update({
      [`system.spellBooks.${s}`]: t
    }), s;
  }
  remove(t) {
    const s = this.get(t);
    s && s.delete();
  }
  removeAll() {
    this.forEach((t) => t.delete());
  }
  first() {
    return this.values().next().value;
  }
};
f(TA, "SpellBookManager");
let Y_ = TA;
var cs, Ho, ol, Qt, Mm, a9, Rm, c9, Fm, u9, Nm, f9, jm, d9, Lm, p9, Bm, m9, qm, h9, Gm, g9;
const CA = class CA {
  constructor(e, t) {
    Y(this, Mm);
    Y(this, Rm);
    Y(this, Fm);
    Y(this, Nm);
    Y(this, jm);
    Y(this, Lm);
    Y(this, Bm);
    Y(this, qm);
    Y(this, Gm);
    Y(this, cs, void 0);
    Y(this, Ho, void 0);
    Y(this, ol, void 0);
    Y(this, Qt, void 0);
    ye(this, cs, e), ye(this, Ho, t), ye(this, ol, t.restType ?? "short"), ye(this, Qt, { actor: {}, effects: [], items: [] });
  }
  get restTypes() {
    return M(this, ol) === "long" ? ["shortRest", "recharge", "round", "turn", "minute", "hour", "longRest", "day"] : ["shortRest", "recharge", "round", "turn", "minute", "hour"];
  }
  async restoreResources() {
    const {
      consumeSupply: e,
      haven: t,
      recoverStrifeAndFatigue: s,
      restType: n
    } = M(this, Ho);
    M(this, ol) === "long" && (Z(this, Mm, a9).call(this), Z(this, jm, d9).call(this), Z(this, Lm, p9).call(this), await Z(this, Gm, g9).call(this)), e && Z(this, Rm, c9).call(this), Z(this, Nm, f9).call(this), Z(this, Fm, u9).call(this), Z(this, qm, h9).call(this), Z(this, Bm, m9).call(this), await M(this, cs).update(M(this, Qt).actor), await M(this, cs).updateEmbeddedDocuments("Item", M(this, Qt).items), Hooks.callAll("a5e.restCompleted", this, {
      consumeSupply: e,
      haven: t,
      restType: n,
      recoverStrifeAndFatigue: s
    });
  }
};
cs = new WeakMap(), Ho = new WeakMap(), ol = new WeakMap(), Qt = new WeakMap(), Mm = new WeakSet(), a9 = /* @__PURE__ */ f(function() {
  const { haven: e, recoverStrifeAndFatigue: t } = M(this, Ho), { strife: s, fatigue: n } = M(this, cs).system.attributes;
  t ? e ? (M(this, Qt).actor["system.attributes.fatigue"] = Math.max(n - 1, 0), M(this, Qt).actor["system.attributes.strife"] = Math.max(s - 1, 0)) : (M(this, Qt).actor["system.attributes.fatigue"] = n === 1 ? 0 : n, M(this, Qt).actor["system.attributes.strife"] = s === 1 ? 0 : s) : M(this, Qt).actor["system.attributes.fatigue"] = n + 1;
}, "#adjustStrifeAndFatigue"), Rm = new WeakSet(), c9 = /* @__PURE__ */ f(function() {
  M(this, Qt).actor["system.supply"] = Math.max(M(this, cs).system.supply - 1, 0);
}, "#consumeSupply"), Fm = new WeakSet(), u9 = /* @__PURE__ */ f(function() {
  const { exertion: e } = M(this, cs).system.attributes;
  e != null && e.recoverOnRest && (M(this, Qt).actor["system.attributes.exertion.current"] = e.max);
}, "#restoreExertion"), Nm = new WeakSet(), f9 = /* @__PURE__ */ f(function() {
  ["primary", "secondary", "tertiary", "quaternary"].forEach((e) => {
    const t = M(this, cs).system.resources[e];
    !this.restTypes.includes(t.per) || !t.max || (M(this, Qt).actor[`system.resources.${e}.value`] = at(t.max, M(this, cs).getRollData()));
  });
}, "#restoreGenericResources"), jm = new WeakSet(), d9 = /* @__PURE__ */ f(function() {
  const { updates: e, type: t } = M(this, cs).HitDiceManager.getUpdateData();
  t === "actor" && (M(this, Qt).actor = foundry.utils.mergeObject(M(this, Qt).actor, e)), t === "embedded" && (M(this, Qt).items = M(this, Qt).items.concat(e));
}, "#restoreHitDice"), Lm = new WeakSet(), p9 = /* @__PURE__ */ f(function() {
  const { max: e, bonus: t } = M(this, cs).system.attributes.hp;
  M(this, Qt).actor["system.attributes.hp"] = {
    bonus: 0,
    value: e - t,
    temp: 0
  };
}, "#restoreHitPoints"), Bm = new WeakSet(), m9 = /* @__PURE__ */ f(function() {
  Array.from(M(this, cs).items).forEach((t) => {
    const s = M(this, cs).getRollData(t), { uses: n } = t.system, l = { _id: t.id };
    if (t.actions && t.actions.entries().forEach(([r, o]) => {
      const a = o.uses ?? {};
      !this.restTypes.includes(a == null ? void 0 : a.per) || !(a != null && a.max) || (l[`system.actions.${r}.uses.value`] = at(a.max, s));
    }), !this.restTypes.includes(n == null ? void 0 : n.per) || !(n != null && n.max)) {
      if (Object.keys(l).length < 2)
        return;
      M(this, Qt).items.push(l);
      return;
    }
    l["system.uses.value"] = at(n.max, s), M(this, Qt).items.push(l);
  });
}, "#restoreUses"), qm = new WeakSet(), h9 = /* @__PURE__ */ f(function() {
  var l, r;
  const { spellResources: e } = M(this, cs).system, t = ((r = (l = M(this, cs)) == null ? void 0 : l.flags) == null ? void 0 : r.a5e) ?? {}, s = (t == null ? void 0 : t.restoreSpellPointsOnShortRest) ?? !0, n = (t == null ? void 0 : t.restoreSpellSlotsOnShortRest) ?? !1;
  (M(this, ol) === "long" || s) && (M(this, Qt).actor["system.spellResources.points.current"] = Math.max(e.points.max, 0)), (M(this, ol) === "long" || n) && Object.entries(e.slots ?? {}).forEach(([o, { max: a }]) => {
    M(this, Qt).actor[`system.spellResources.slots.${o}.current`] = Math.max(a, 0);
  });
}, "#restoreSpellResources"), Gm = new WeakSet(), g9 = /* @__PURE__ */ f(async function() {
  if (!game.settings.get("a5e", "removeActiveEffectsOnLongRest"))
    return;
  const e = Array.from(M(this, cs).effects).filter((t) => {
    var s, n;
    return ((n = (s = t.flags) == null ? void 0 : s.a5e) == null ? void 0 : n.transferType) === "onUse";
  });
  e.length && await M(this, cs).deleteEmbeddedDocuments("ActiveEffect", e.map((t) => t.id));
}, "#removeTemporaryActiveEffects"), f(CA, "RestManager");
let qd = CA;
var fr, Ka, Au, J_;
const OA = class OA {
  constructor(e) {
    Y(this, fr);
    Y(this, Au);
    Ge(this, "actor");
    Ge(this, "overrides");
    Ge(this, "ready");
    this.actor = e, this.overrides = /* @__PURE__ */ new Map(), this.overrides.set("abilityCheck.all", []), this.overrides.set("abilitySave.all", []), Object.keys(CONFIG.A5E.abilities).forEach((t) => {
      this.overrides.set(`system.abilities.${t}.check`, []), this.overrides.set(`system.abilities.${t}.save`, []);
    }), this.overrides.set("skillCheck.all", []), Object.keys(CONFIG.A5E.skills).forEach((t) => {
      this.overrides.set(`system.skills.${t}`, []);
    }), this.overrides.set("attack.all", []), Object.keys(CONFIG.A5E.attackTypes).forEach((t) => {
      this.overrides.set(`attackTypes.${t}`, []);
    }), this.overrides.set("concentration", []), this.overrides.set("deathSave", []), this.overrides.set("initiative", []), this.ready = !1;
  }
  initialize() {
    Object.entries(this.actor.system.abilities).forEach(([t, s]) => {
      ["check", "save"].forEach((n) => {
        var l, r, o;
        if ((l = s[n]) != null && l.expertiseDice) {
          const a = (r = s[n]) == null ? void 0 : r.expertiseDice;
          (o = this.overrides.get(`system.abilities.${t}.${n}`)) == null || o.push(
            {
              value: a,
              overrideType: "expertiseDice",
              source: CONFIG.A5E.abilities[t],
              mode: CONFIG.A5E.ACTIVE_EFFECT_MODES.OVERRIDE
            }
          );
        }
      });
    }), Object.entries(this.actor.system.skills).forEach(([t, s]) => {
      var n;
      if (s.expertiseDice) {
        const l = s.expertiseDice;
        (n = this.overrides.get(`system.skills.${t}`)) == null || n.push(
          {
            value: l,
            overrideType: "expertiseDice",
            source: CONFIG.A5E.skills[t],
            mode: CONFIG.A5E.ACTIVE_EFFECT_MODES.OVERRIDE
          }
        );
      }
    }), this.actor.grants.byType("expertiseDice").forEach((t) => {
      const { expertiseType: s, expertiseCount: n, keys: l } = t.expertiseDiceData ?? {}, { name: r } = fromUuidSync(t.itemUuid) ?? {};
      s === "abilityCheck" ? l.forEach((o) => {
        var a;
        (a = this.overrides.get(`system.abilities.${o}.check`)) == null || a.push(
          {
            value: n,
            overrideType: "expertiseDice",
            source: r,
            mode: CONFIG.A5E.ACTIVE_EFFECT_MODES.ADD
          }
        );
      }) : s === "abilitySave" ? l.forEach((o) => {
        var a;
        (a = this.overrides.get(`system.abilities.${o}.save`)) == null || a.push(
          {
            value: n,
            overrideType: "expertiseDice",
            source: r,
            mode: CONFIG.A5E.ACTIVE_EFFECT_MODES.ADD
          }
        );
      }) : s === "skill" ? l.forEach((o) => {
        var a;
        (a = this.overrides.get(`system.skills.${o}`)) == null || a.push(
          {
            value: n,
            overrideType: "expertiseDice",
            source: r,
            mode: CONFIG.A5E.ACTIVE_EFFECT_MODES.ADD
          }
        );
      }) : s === "attack" && l.forEach((o) => {
        var a;
        (a = this.overrides.get(`attackTypes.${o}`)) == null || a.push(
          {
            value: n,
            overrideType: "expertiseDice",
            source: r,
            mode: CONFIG.A5E.ACTIVE_EFFECT_MODES.ADD
          }
        );
      });
    }), this.actor.grants.byType("rollOverride").forEach((t) => {
      const { rollOverrideType: s, rollMode: n, keys: l } = t.rollOverrideData ?? {}, { name: r } = fromUuidSync(t.itemUuid) ?? {}, o = [];
      s === "abilityCheck" ? l.forEach((a) => o.push(`system.abilities.${a}.check`)) : s === "abilitySave" ? l.forEach((a) => o.push(`system.abilities.${a}.save`)) : s === "skill" ? l.forEach((a) => o.push(`system.skills.${a}`)) : s === "attack" ? l.forEach((a) => o.push(`attackTypes.${a}`)) : s === "concentration" ? o.push("concentration") : s === "deathSave" ? o.push("deathSave") : s === "initiative" && o.push("initiative"), o.forEach((a) => {
        var c;
        (c = this.overrides.get(a)) == null || c.push({ value: n, overrideType: "rollMode", source: r });
      });
    }), this.actor.items.forEach((t) => {
      var s, n;
      t.type !== "object" && ((s = t.system) == null ? void 0 : s.objectType) !== "armor" || t.system.equippedState === CONFIG.A5E.ARMOR_MODES.OVERRIDE && t.system.ac.grantsDisadvantage && ((n = this.overrides.get("system.skills.ste")) == null || n.push({ value: -1, overrideType: "rollMode", source: t.name }));
    }), this.actor.effects.reduce((t, s) => {
      if (s.disabled || s.changes.length === 0)
        return t;
      const n = [];
      return s.changes.forEach((l) => {
        if (!l.key.startsWith("flags.a5e.effects.rollMode") && !l.key.startsWith("flags.a5e.effects.expertiseDice"))
          return;
        let r = l.key.replace("flags.a5e.effects.", "");
        const o = r.split(".").shift();
        o === "rollMode" ? r = r.replace("rollMode.", "") : r = r.replace("expertiseDice.", ""), n.push({
          key: r,
          value: parseInt(l.value, 10) || 0,
          mode: l.mode,
          name: s.name,
          type: o
        });
      }), n.length && t.push(...n), t;
    }, []).forEach((t) => {
      var u, d, p, m, g, h, _, y, k, v, O;
      const {
        key: s,
        value: n,
        name: l,
        type: r,
        mode: o
      } = t;
      if (["concentration", "deathSave", "initiative"].includes(s)) {
        (u = this.overrides.get(s)) == null || u.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        });
        return;
      }
      if (s === "abilityCheck.all") {
        (d = this.overrides.get("abilityCheck.all")) == null || d.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        });
        return;
      }
      if (s === "abilitySave.all") {
        (p = this.overrides.get("abilitySave.all")) == null || p.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        });
        return;
      }
      if (s === "skillCheck.all") {
        (m = this.overrides.get("skillCheck.all")) == null || m.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        });
        return;
      }
      if (s === "attack.all") {
        (g = this.overrides.get("attack.all")) == null || g.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        });
        return;
      }
      if (s === "all" && r === "expertiseDice") {
        (h = this.overrides.get("abilityCheck.all")) == null || h.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        }), (_ = this.overrides.get("abilitySave.all")) == null || _.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        }), (y = this.overrides.get("attack.all")) == null || y.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        });
        return;
      }
      const [a, c] = s.split(".");
      if (["abilityCheck", "abilitySave"].includes(a)) {
        const P = a === "abilityCheck" ? "check" : "save";
        (k = this.overrides.get(`system.abilities.${c}.${P}`)) == null || k.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        });
        return;
      }
      if (a === "skillCheck") {
        (v = this.overrides.get(`system.skills.${c}`)) == null || v.push({
          value: n,
          overrideType: r,
          source: l,
          mode: o
        });
        return;
      }
      a === "attack" && ((O = this.overrides.get(`attackTypes.${c}`)) == null || O.push({
        value: n,
        overrideType: r,
        source: l,
        mode: o
      }));
    }), this.ready = !0;
  }
  // *********************************************************************************************
  //  Roll Override Methods
  // *********************************************************************************************
  getRollOverride(e, t = 0, s = {}) {
    const n = Z(this, fr, Ka).call(this, e, "rollMode", s);
    if (!(n != null && n.length))
      return t;
    const l = n.some((o) => o.value === CONFIG.A5E.ROLL_MODE.ADVANTAGE), r = n.some((o) => o.value === CONFIG.A5E.ROLL_MODE.DISADVANTAGE);
    return l && r ? CONFIG.A5E.ROLL_MODE.NORMAL : !l && !r ? t : l ? Z(this, Au, J_).call(this, t, CONFIG.A5E.ROLL_MODE.ADVANTAGE) : Z(this, Au, J_).call(this, t, CONFIG.A5E.ROLL_MODE.DISADVANTAGE);
  }
  getRollOverridesSource(e, t = 0, s = {}) {
    const n = Z(this, fr, Ka).call(this, e, "rollMode", s);
    if (!(n != null && n.length))
      return "";
    let l;
    t === CONFIG.A5E.ROLL_MODE.ADVANTAGE ? l = "Advantage" : t === CONFIG.A5E.ROLL_MODE.DISADVANTAGE ? l = "Disadvantage" : l = "Normal";
    const { adv: r, dis: o } = n.reduce((p, m) => (m.value === CONFIG.A5E.ROLL_MODE.ADVANTAGE ? p.adv.push(m.source) : m.value === CONFIG.A5E.ROLL_MODE.DISADVANTAGE && p.dis.push(m.source), p), { adv: [], dis: [] });
    let a = "", c = "";
    r.length && (a = `<p> <strong>Advantage:</strong> ${r.join(", ")}</p>`), o.length && (c = `<p> <strong>Disadvantage:</strong> ${o.join(", ")}</p>`);
    const u = this.getRollOverride(e, t);
    let d;
    return u === CONFIG.A5E.ROLL_MODE.ADVANTAGE ? d = "Advantage" : u === CONFIG.A5E.ROLL_MODE.DISADVANTAGE ? d = "Disadvantage" : d = "Normal", `<div class='u-text-xs u-text-left'>
      <p> <strong>Base Roll Mode:</strong> ${l}</p>
      ${a}
      ${c}
      <p> <strong>Result:</strong> ${d}</p>
    </div>
    `;
  }
  // *********************************************************************************************
  //  Expertise Override Methods
  // *********************************************************************************************
  getExpertiseDice(e, t = 0, s = {}) {
    const n = Z(this, fr, Ka).call(this, e, "expertiseDice", s);
    if (!(n != null && n.length))
      return t;
    n.sort((r, o) => (o.mode ?? 2) - (r.mode ?? 2));
    let l = t;
    return n.forEach((r) => {
      r.mode === CONFIG.A5E.ACTIVE_EFFECT_MODES.OVERRIDE ? l = r.value : l += r.value;
    }), Math.clamped(l, 0, 5);
  }
  getExpertiseDiceSource(e, t = 0, s = {}) {
    const n = Z(this, fr, Ka).call(this, e, "expertiseDice", s);
    if (!(n != null && n.length))
      return "";
    n.sort((a, c) => (c.mode ?? 2) - (a.mode ?? 2));
    const l = t ? `d${CONFIG.A5E.expertiseDiceSidesMap[t]}` : "None", r = n.map((a) => `${a.source} (d${CONFIG.A5E.expertiseDiceSidesMap[a.value]})`), o = this.getExpertiseDice(e, t);
    return `<div class='u-text-xs u-text-left'>
      <p> <strong>Base Die:</strong> ${l}</p>
      <p> <strong>Overrides:</strong> ${r.join(", ")}</p>
      <p> <strong>Total Bonus:</strong> d${CONFIG.A5E.expertiseDiceSidesMap[o]}</p>
      </div>`;
  }
};
fr = new WeakSet(), Ka = /* @__PURE__ */ f(function(e, t = "rollMode", s = {}) {
  var l, r, o, a, c, u, d, p, m, g, h;
  const n = ((l = this.overrides.get(e)) == null ? void 0 : l.filter((_) => _.overrideType === t)) ?? [];
  if (e.includes("abilities") && ((r = this.overrides.get("abilityCheck.all")) == null || r.forEach((_) => {
    _.overrideType === t && n.push(_);
  })), e.includes("skills")) {
    (o = this.overrides.get("skillCheck.all")) == null || o.forEach((y) => {
      y.overrideType === t && n.push(y);
    });
    const _ = s.ability || ((a = this.actor.system.skills[e.split(".").pop()]) == null ? void 0 : a.ability) || "";
    _ && ((c = this.overrides.get(`system.abilities.${_}.check`)) == null || c.forEach((y) => {
      y.overrideType === t && n.push(y);
    })), (u = this.overrides.get("abilityCheck.all")) == null || u.forEach((y) => {
      y.overrideType === t && n.push(y);
    });
  }
  if (e === "initiative") {
    (d = this.overrides.get("abilityCheck.all")) == null || d.forEach((k) => {
      k.overrideType === t && n.push(k);
    }), (p = this.overrides.get("skillCheck.all")) == null || p.forEach((k) => {
      k.overrideType === t && n.push(k);
    });
    const _ = s.ability || "";
    _ && ((m = this.overrides.get(`system.abilities.${_}.check`)) == null || m.forEach((k) => {
      k.overrideType === t && n.push(k);
    }));
    const y = s.skill || "";
    y && ((g = this.overrides.get(`system.skills.${y}`)) == null || g.forEach((k) => {
      k.overrideType === t && n.push(k);
    }));
  }
  if (e.includes("attack")) {
    (h = this.overrides.get("attack.all")) == null || h.forEach((_) => {
      _.overrideType === t && n.push(_);
    });
    try {
      const _ = game.settings.get("a5e-flanking", "flankingDND5EMode") ?? !1, y = !!this.actor.getFlag("a5e", "flanking");
      _ && y && t === "rollMode" ? n.push({
        overrideType: "rollMode",
        source: "Flanking",
        value: CONFIG.A5E.ROLL_MODE.ADVANTAGE
      }) : !_ && y && t === "expertiseDice" && n.push({
        overrideType: "expertiseDice",
        source: "Flanking",
        value: 1
      });
    } catch {
    }
  }
  return n;
}, "#prepareOverrides"), Au = new WeakSet(), J_ = /* @__PURE__ */ f(function(e, t) {
  return (e ^ t) < -1 ? 0 : t;
}, "#determineRollMode"), f(OA, "RollOverrideManager");
let X_ = OA;
async function gU(i) {
  return [
    ...i.terms,
    await new OperatorTerm({ operator: "+" }).evaluate({ async: !0 }),
    await new NumericTerm({
      number: i.total,
      options: { flavor: K("A5E.CritDamage") }
    }).evaluate({ async: !0 })
  ];
}
f(gU, "doubleRolledDamage");
async function bU(i) {
  const e = i.dice.reduce((s, n) => s + n.total, 0);
  return [
    ...i.terms,
    await new OperatorTerm({ operator: "+" }).evaluate({ async: !0 }),
    await new NumericTerm({
      number: e,
      options: { flavor: K("A5E.CritDamage") }
    }).evaluate({ async: !0 })
  ];
}
f(bU, "doubleDiceDamage");
async function _U(i) {
  return [
    ...i.terms,
    ...i.dice.flatMap((e) => {
      const t = new OperatorTerm({ operator: "+" }).evaluate(), s = new Die({
        faces: e.faces,
        number: e.number,
        modifiers: e.modifiers,
        options: e.options
      }).evaluate();
      return [t, s];
    })
  ];
}
f(_U, "doubleDiceQuantity");
async function yU(i) {
  return [
    ...i.terms.map((e) => e instanceof MathTerm || e instanceof NumericTerm ? new NumericTerm({ number: e.total * 2, options: e.options }).evaluate() : e),
    ...i.dice.flatMap((e) => {
      const t = new OperatorTerm({ operator: "+" }).evaluate(), s = new Die({
        faces: e.faces,
        number: e.number,
        modifiers: e.modifiers,
        options: e.options
      }).evaluate();
      return [t, s];
    })
  ];
}
f(yU, "doubleDiceQuantityAndMods");
async function vU(i) {
  const e = await new Roll(i).evaluate({ async: !0 });
  return [
    await new OperatorTerm({ operator: "+" }).evaluate({ async: !0 }),
    ...e.terms
  ];
}
f(vU, "getBonusCritDamage");
async function kU(i) {
  const e = i.clone();
  return await e.evaluate({ maximize: !0 }), e.terms;
}
f(kU, "maxDamagePlusRoll");
async function wU(i) {
  const e = i.clone();
  return await e.evaluate({ maximize: !0 }), [
    ...e.terms,
    await new OperatorTerm({ operator: "+" }).evaluate({ async: !0 }),
    ...i.terms
  ];
}
f(wU, "maxDamage");
function Tc(i) {
  return i.reduce((e, t, s) => {
    const n = e[e.length - 1], l = /* @__PURE__ */ new Set([n == null ? void 0 : n.operator, t.operator]);
    return s === i.length - 1 && t.operator || (l.has(void 0) ? e.push(t) : l.has("+") && l.has("-") ? e.splice(-1, 1, new OperatorTerm({ operator: "-" })) : l.has("-") && l.size === 1 ? e.splice(-1, 1, new OperatorTerm({ operator: "+" })) : l.has("+") || e.push(t)), e;
  }, []);
}
f(Tc, "simplifyOperatorTerms");
function ad(i) {
  if (i.some((t) => t.operator === "*" || t.operator === "/"))
    return i;
  const e = Tc(i).reduce((t, s, n) => {
    if (n === 0)
      return t.push(s), t;
    const l = i[n - 1];
    if (s instanceof OperatorTerm)
      return t;
    if (!(s instanceof DiceTerm) || l.operator === "-")
      return t.push(l, s), t;
    if (s.flavor) {
      const o = t.findIndex(
        ({ faces: a, flavor: c }) => a === s.faces && c === s.flavor
      );
      if (o !== -1) {
        const a = t[o].number + s.number, c = [...t[o].results, ...s.results], u = new Die({
          faces: s.faces,
          number: a,
          results: c,
          options: {
            flavor: s.flavor
          }
        });
        t.splice(o, 1, u);
      } else
        t.push(l, s);
      return t;
    }
    const r = t.findIndex(
      ({ faces: o, flavor: a }) => o === s.faces && !a
    );
    if (r !== -1) {
      const o = t[r].number + s.number, a = [...t[r].results, ...s.results], c = new Die({
        faces: s.faces,
        number: o,
        results: a
      });
      t.splice(r, 1, c);
    } else
      t.push(l, s);
    return t;
  }, []);
  return e.forEach((t) => {
    t._evaluated = !0;
  }), e;
}
f(ad, "simplifyDiceTerms");
const $U = {
  doubleAllDamage: gU,
  doubleDiceDamage: bU,
  doubleDiceQuantity: _U,
  doubleDiceQuantityAndMods: yU,
  maxDamage: kU,
  maxDamagePlusRoll: wU
};
async function AU(i, e) {
  const t = game.settings.get("a5e", "critCalculationMode"), s = await $U[t](i);
  return e && s.push(...await vU(e)), Roll.fromTerms(ad(s));
}
f(AU, "constructCritDamageRoll");
function EU({ actor: i, minRoll: e, rollMode: t }) {
  var n, l;
  let s = "1d20";
  return [CONFIG.A5E.ROLL_MODE.ADVANTAGE, CONFIG.A5E.ROLL_MODE.DISADVANTAGE].includes(t) && (s = "2d20"), (l = (n = i == null ? void 0 : i.flags) == null ? void 0 : n.a5e) != null && l.halflingLuck && (s += "r1"), e > 1 && (s += `min${e}`), t === CONFIG.A5E.ROLL_MODE.ADVANTAGE ? s += "kh" : t === CONFIG.A5E.ROLL_MODE.DISADVANTAGE && (s += "kl"), s;
}
f(EU, "constructD20Term");
function V5({
  actor: i,
  item: e,
  minRoll: t,
  modifiers: s,
  rollMode: n
}) {
  const l = i.getRollData(e), o = [
    EU({ actor: i, minRoll: t, rollMode: n }),
    ...(s ?? []).map(({ label: u, value: d }) => {
      if (!d || d === 0)
        return null;
      const p = new Roll(d.toString(), l);
      return p.terms.forEach((m) => {
        var g;
        m.constructor.name !== "OperatorTerm" && ((g = m.options).flavor ?? (g.flavor = u));
      }), p.formula;
    })
  ].filter((u) => u && u !== "0").join(" + "), { terms: a } = new Roll(o, l), c = Tc(a);
  return { rollFormula: Roll.getFormula(c) };
}
f(V5, "constructD20RollFormula");
function Ya({
  actor: i,
  formula: e,
  item: t,
  modifiers: s
}) {
  const n = i.getRollData(t), l = [
    e,
    ...(s ?? []).map(({ label: a, value: c }) => {
      if (!c || c === 0)
        return null;
      const u = new Roll(c.toString(), n);
      return u.terms.forEach((d) => {
        var p;
        ["OperatorTerm", "StringTerm"].includes(d.constructor.name) || ((p = d.options).flavor ?? (p.flavor = a));
      }), u.formula;
    })
  ], { terms: r } = new Roll(
    l.filter((a) => a && a !== "0").join(" + "),
    n
  ), o = Tc(r);
  return { rollFormula: Roll.getFormula(o) };
}
f(Ya, "constructRollFormula");
var ms, Oi, Uo, Vo, Vn, Eu, zm, b9, Hm, _9, Um, y9, Vm, v9, Wm, k9, Km, w9, Su, Z_, Ym, $9, Xm, A9, Wo, cd, Jm, E9, Zm, S9, Qm, T9, Ko, ud, xm, C9, eh, O9, th, D9, sh, I9, nh, P9, dr, Xa;
const DA = class DA {
  constructor({
    actor: e,
    item: t,
    consumers: s,
    damageBonuses: n,
    healingBonuses: l,
    rolls: r
  }) {
    Y(this, zm);
    Y(this, Hm);
    Y(this, Um);
    Y(this, Vm);
    Y(this, Wm);
    Y(this, Km);
    Y(this, Su);
    /**
     * Prepares the damage bonuses without any damage type. These are folded into the first
     * damage roll for the action.
     */
    Y(this, Ym);
    Y(this, Xm);
    Y(this, Wo);
    Y(this, Jm);
    Y(this, Zm);
    Y(this, Qm);
    Y(this, Ko);
    Y(this, xm);
    Y(this, eh);
    Y(this, th);
    Y(this, sh);
    Y(this, nh);
    Y(this, dr);
    Y(this, ms, void 0);
    Y(this, Oi, void 0);
    Y(this, Uo, void 0);
    Y(this, Vo, void 0);
    Y(this, Vn, void 0);
    Y(this, Eu, void 0);
    ye(this, ms, e), ye(this, Oi, s), ye(this, Uo, n), ye(this, Vo, l), ye(this, Vn, t), ye(this, Eu, r);
  }
  async prepareRolls() {
    const {
      attack: e,
      damage: t,
      healing: s,
      other: n
    } = M(this, Eu).reduce((c, u) => (u && (u == null ? void 0 : u.type) === "attack" ? c.attack = u : u && (u == null ? void 0 : u.type) === "damage" ? c.damage.push(u) : u && (u == null ? void 0 : u.type) === "healing" ? c.healing.push(u) : c.other.push(u), c), {
      attack: null,
      damage: [],
      healing: [],
      other: []
    }), l = await Z(this, Um, y9).call(this, e ?? {}), r = await Promise.all(
      t.map(async (c, u) => Z(this, Su, Z_).call(this, c, l, u))
    ), o = (await Promise.all(
      s.map(async (c) => Z(this, Wo, cd).call(this, c))
    )).filter(Boolean);
    if (r.length) {
      const c = await Z(this, Vm, v9).call(this, l);
      r.push(...c);
    }
    if (o.some(({ healingType: c }) => c === "healing" || !c)) {
      const c = await Z(this, Wm, k9).call(this);
      o.push(...c);
    }
    if (o.some(({ healingType: c }) => c === "temporaryHealing")) {
      const c = await Z(this, Km, w9).call(this);
      o.push(...c);
    }
    const a = await Promise.all(
      n.map(async (c) => Z(this, zm, b9).call(this, c))
    );
    return [l, ...r, ...o, ...a].filter(Boolean);
  }
};
ms = new WeakMap(), Oi = new WeakMap(), Uo = new WeakMap(), Vo = new WeakMap(), Vn = new WeakMap(), Eu = new WeakMap(), zm = new WeakSet(), b9 = /* @__PURE__ */ f(function(e) {
  switch (e == null ? void 0 : e.type) {
    case "abilityCheck":
      return Z(this, Hm, _9).call(this, e);
    case "generic":
      return Z(this, Xm, A9).call(this, e);
    case "savingThrow":
      return Z(this, Jm, E9).call(this, e);
    case "skillCheck":
      return Z(this, Zm, S9).call(this, e);
    case "toolCheck":
      return Z(this, Qm, T9).call(this, e);
    default:
      return null;
  }
}, "#prepareItemRoll"), Hm = new WeakSet(), _9 = /* @__PURE__ */ f(async function(e) {
  const t = M(this, ms).getDefaultAbilityCheckData(
    e.ability,
    { situationalMods: e.bonus }
  ), s = e.rollFormula ?? t.rollFormula;
  if (!s)
    return null;
  const n = K(CONFIG.A5E.abilities[(e == null ? void 0 : e.ability) ?? ""]), l = await new Roll(s).evaluate({ async: !0 }), r = K("A5E.AbilityCheckSpecific", { ability: n });
  return {
    expertiseDice: e.expertiseDie ?? t.expertiseDie,
    label: r,
    userLabel: e.label,
    roll: l,
    rollMode: e.rollMode ?? t._rollMode,
    type: "abilityCheck"
  };
}, "#prepareAbilityCheckRoll"), Um = new WeakSet(), y9 = /* @__PURE__ */ f(async function(e) {
  const { rollFormula: t } = Ya({
    actor: M(this, ms),
    formula: e.formula,
    item: M(this, Vn)
  });
  if (!t)
    return null;
  const s = e.critThreshold ?? 20, n = await new Roll(t).evaluate({ async: !0 }), l = K(CONFIG.A5E.attackTypes[(e == null ? void 0 : e.attackType) ?? "meleeWeaponAttack"]), r = n.dice[0].total >= s;
  return {
    attackType: e.attackType,
    critThreshold: s,
    expertiseDice: e.expertiseDie,
    isCrit: r,
    label: l,
    roll: n,
    rollMode: e.rollMode,
    type: "attack"
  };
}, "#prepareAttackRoll"), Vm = new WeakSet(), v9 = /* @__PURE__ */ f(async function(e) {
  const t = Object.values(M(this, Uo)).filter(
    ({ damageType: s }) => s && s !== "null"
  );
  return Promise.all(
    t.map(({
      label: s,
      formula: n,
      damageType: l,
      context: r
    }) => Z(this, Su, Z_).call(this, {
      label: s,
      formula: n,
      canCrit: !0,
      critBonus: 0,
      damageType: l,
      context: r
    }, e))
  );
}, "#prepareBonusDamageRolls"), Wm = new WeakSet(), k9 = /* @__PURE__ */ f(async function() {
  const e = Object.values(M(this, Vo)).filter(
    ({ healingType: t }) => t === "healing" || !t
  );
  return Promise.all(
    e.map(({ label: t, formula: s, healingType: n }) => Z(this, Wo, cd).call(this, {
      label: t || "Bonus Healing",
      formula: s,
      healingType: n || "healing"
    }))
  );
}, "#prepareBonusHealingRolls"), Km = new WeakSet(), w9 = /* @__PURE__ */ f(async function() {
  const e = Object.values(M(this, Vo)).filter(
    ({ healingType: t }) => t === "temporaryHealing"
  );
  return Promise.all(
    e.map(({ label: t, formula: s, healingType: n }) => Z(this, Wo, cd).call(this, {
      label: t || "Bonus Temporary Healing",
      formula: s,
      healingType: n
    }))
  );
}, "#prepareBonusTemporaryHealingRolls"), Su = new WeakSet(), Z_ = /* @__PURE__ */ f(async function(e, t, s) {
  const { isCrit: n } = t ?? {}, { canCrit: l, critBonus: r, damageType: o } = e, a = [], c = [], { context: u } = e;
  let d = "";
  s === 0 && (Z(this, Ym, $9).call(this, n).forEach((v) => {
    var O;
    (O = v.context) != null && O.isCritBonus ? a.push(v.formula) : c.push({ value: v.formula, label: v.label });
  }), a.length && (d = a.join(" + ")));
  const { rollFormula: p } = Ya({
    actor: M(this, ms),
    formula: Z(this, Ko, ud).call(this, e),
    item: M(this, Vn),
    modifiers: c
  });
  if (!p)
    return null;
  const m = await new Roll(p).evaluate({ async: !0 });
  let g = Roll.fromTerms(ad(m.terms)), h = g, _ = g;
  if (l ?? !0)
    if (u && u.isCritBonus)
      _ = h, g = await new Roll("0").evaluate({ async: !0 }), h = g;
    else {
      let k = r || "";
      k += d ? ` + ${d}` : "", _ = await AU(h, k);
    }
  n && (h = _);
  const y = o ? K("A5E.DamageSpecific", { damageType: K(CONFIG.A5E.damageTypes[o]) }) : K("A5E.Damage");
  return {
    baseRoll: g,
    canCrit: l ?? !0,
    critRoll: _,
    damageType: o,
    label: y,
    userLabel: e.label,
    roll: h,
    type: "damage"
  };
}, "#prepareDamageRoll"), Ym = new WeakSet(), $9 = /* @__PURE__ */ f(function() {
  return Object.values(M(this, Uo)).filter(
    ({ damageType: t }) => !t || t === "null"
  ).map(({ formula: t, context: s, label: n }) => ({ formula: t, context: s, label: n }));
}, "#prepareGenericBonusDamage"), Xm = new WeakSet(), A9 = /* @__PURE__ */ f(async function(e) {
  const { rollFormula: t } = Ya({
    actor: M(this, ms),
    formula: Z(this, Ko, ud).call(this, e),
    item: M(this, Vn)
  });
  if (!t)
    return null;
  const s = await new Roll(t).evaluate({ async: !0 }), n = Roll.fromTerms(ad(s.terms));
  return {
    label: e.label || K("A5E.GenericRoll"),
    roll: n,
    type: "generic"
  };
}, "#prepareGenericRoll"), Wo = new WeakSet(), cd = /* @__PURE__ */ f(async function(e) {
  const { rollFormula: t } = Ya({
    actor: M(this, ms),
    formula: Z(this, Ko, ud).call(this, e),
    item: M(this, Vn)
  });
  if (!t)
    return null;
  const s = await new Roll(t).evaluate({ async: !0 }), n = Roll.fromTerms(ad(s.terms)), l = CONFIG.A5E.healingTypes[e.healingType ?? "healing"];
  return {
    label: K(l),
    userLabel: e.label,
    healingType: e.healingType,
    roll: n,
    type: "healing"
  };
}, "#prepareHealingRoll"), Jm = new WeakSet(), E9 = /* @__PURE__ */ f(async function(e) {
  const t = M(this, ms).getDefaultSavingThrowData(
    e.ability,
    { situationalMods: e.bonus }
  ), s = e.rollFormula ?? t.rollFormula;
  if (!s)
    return null;
  const n = K(CONFIG.A5E.abilities[(e == null ? void 0 : e.ability) ?? ""]), l = await new Roll(s).evaluate({ async: !0 });
  let r;
  return e.saveType === "concentration" ? r = K("A5E.ConcentrationCheck") : e.saveType === "death" ? r = K("A5E.DeathSavingThrow") : r = K("A5E.SavingThrowSpecific", { ability: n }), {
    expertiseDice: e.expertiseDie ?? t.expertiseDie,
    label: r,
    userLabel: e.label,
    roll: l,
    rollMode: e.rollMode ?? t._rollMode,
    saveType: e.saveType,
    type: "savingThrow"
  };
}, "#prepareSavingThrowRoll"), Zm = new WeakSet(), S9 = /* @__PURE__ */ f(async function(e) {
  const t = K(CONFIG.A5E.skills[e == null ? void 0 : e.skill]), s = M(this, ms).getDefaultSkillCheckData(
    e.skill,
    e.ability,
    { situationalMods: e.bonus }
  ), n = e.ability ?? s.ability, l = e.rollFormula ?? s.rollFormula;
  if (!l)
    return null;
  const r = await new Roll(l).evaluate({ async: !0 }), o = n && n !== "none" ? K("A5E.SkillCheckAbility", { skill: t, ability: CONFIG.A5E.abilityAbbreviations[n] }) : K("A5E.SkillCheck", { skill: t });
  return {
    expertiseDice: e.expertiseDie ?? s.expertiseDie,
    label: o,
    userLabel: e.label,
    roll: r,
    rollMode: e.rollMode ?? s._rollMode,
    skillKey: e == null ? void 0 : e.skill,
    type: "skillCheck"
  };
}, "#prepareSkillCheckRoll"), Qm = new WeakSet(), T9 = /* @__PURE__ */ f(async function(e) {
  var c, u, d;
  const t = e.ability === "none" ? null : e.ability, s = (u = (c = M(this, ms).system.proficiencies) == null ? void 0 : c.tools) == null ? void 0 : u.includes(e.tool), n = [], l = Object.values(CONFIG.A5E.tools).reduce(
    (p, m) => ({ ...p, ...m }),
    {}
  ), r = K("A5E.ToolCheckSpecific", { tool: K(l[e == null ? void 0 : e.tool] ?? "") });
  t && n.push({
    label: K("A5E.AbilityCheckMod", {
      ability: K(CONFIG.A5E.abilities[t])
    }),
    value: (d = M(this, ms).system.abilities[t]) == null ? void 0 : d.check.mod
  }), s && n.push({
    label: K("A5E.Proficiency"),
    value: M(this, ms).system.attributes.prof
  }), n.push({
    label: K("A5E.AbilityCheckBonusGlobal"),
    value: M(this, ms).BonusesManager.getGlobalAbilityBonusesFormula("check")
  }), n.push({
    value: e.bonus
  });
  const { rollFormula: o } = V5({
    actor: M(this, ms),
    item: M(this, Vn),
    modifiers: n
  });
  if (!o)
    return null;
  const a = await new Roll(o).evaluate({ async: !0 });
  return {
    label: r,
    userLabel: e.label,
    roll: a,
    type: "toolCheck"
  };
}, "#prepareToolCheckRoll"), Ko = new WeakSet(), ud = /* @__PURE__ */ f(function(e) {
  var s;
  const t = (s = e.scaling) == null ? void 0 : s.mode;
  return t ? t === "cantrip" ? Z(this, xm, C9).call(this, e) : t === "spellLevel" ? Z(this, eh, O9).call(this, e) : t === "spellPoints" ? Z(this, th, D9).call(this, e) : t === "actionUses" ? Z(this, sh, I9).call(this, e) : t === "itemUses" ? Z(this, nh, P9).call(this, e) : e.formula ?? 0 : (e == null ? void 0 : e.formula) ?? 0;
}, "#applyScaling"), xm = new WeakSet(), C9 = /* @__PURE__ */ f(function(e) {
  var o;
  const t = M(this, ms).system, s = t.details.level ?? t.attributes.casterLevel, n = e.formula;
  if (s < 5)
    return n;
  const l = new Roll(((o = e.scaling) == null ? void 0 : o.formula) ?? 0);
  let r = 0;
  return s >= 17 ? r = 3 : s >= 11 ? r = 2 : s >= 5 && (r = 1), [n, l.alter(r, 0, { multiplyNumeric: !0 }).formula].join("+");
}, "#applyCantripScaling"), eh = new WeakSet(), O9 = /* @__PURE__ */ f(function(e) {
  var l, r;
  const t = ((l = M(this, Oi).spell) == null ? void 0 : l.baseLevel) ?? M(this, Vn).system.level ?? 1, n = (((r = M(this, Oi).spell) == null ? void 0 : r.level) ?? t) - t;
  return Z(this, dr, Xa).call(this, e, n);
}, "#applySpellLevelScaling"), th = new WeakSet(), D9 = /* @__PURE__ */ f(function(e) {
  const t = M(this, Oi).spell;
  if (foundry.utils.isEmpty(t))
    return e.formula;
  const s = (t == null ? void 0 : t.basePoints) || 1;
  if (s >= t.points)
    return e.formula;
  const n = Math.max(0, t.points - s);
  return Z(this, dr, Xa).call(this, e, n);
}, "#applySpellPointScaling"), sh = new WeakSet(), I9 = /* @__PURE__ */ f(function(e) {
  const t = M(this, Oi).actionUses;
  if (foundry.utils.isEmpty(t))
    return e.formula;
  const s = t.baseUses;
  if (s >= t.quantity)
    return e.formula;
  const n = t.quantity - s;
  return Z(this, dr, Xa).call(this, e, n);
}, "#applyActionUsesScaling"), nh = new WeakSet(), P9 = /* @__PURE__ */ f(function(e) {
  const t = M(this, Oi).itemUses;
  if (foundry.utils.isEmpty(t))
    return e.formula;
  const s = t.baseUses;
  if (s >= t.quantity)
    return e.formula;
  const n = t.quantity - s;
  return Z(this, dr, Xa).call(this, e, n);
}, "#applyItemUsesScaling"), dr = new WeakSet(), Xa = /* @__PURE__ */ f(function(e, t) {
  var o, a;
  const s = e.formula;
  if (!t)
    return s;
  const n = new Roll(((o = e.scaling) == null ? void 0 : o.formula) ?? 0), l = ((a = e.scaling) == null ? void 0 : a.step) || 1, r = Math.floor(t / l);
  return r === 0 ? s : [s, n.alter(r, 0, { multiplyNumeric: !0 }).formula].join("+");
}, "#applyResourceBasedScaling"), f(DA, "RollPreparationManager");
let $r = DA;
function se(i, e, t) {
  i.update({ [e]: t });
}
f(se, "updateDocumentDataFromField");
function SU(i) {
  let e, t, s, n, l = K(
    /*label*/
    i[1]
  ) + "", r, o, a;
  return {
    c() {
      e = E("div"), t = E("input"), s = R(), n = E("label"), r = x(l), b(t, "class", "checkbox svelte-16wp6ih"), b(t, "type", "checkbox"), t.disabled = /*disabled*/
      i[2], b(
        t,
        "id",
        /*id*/
        i[3]
      ), t.checked = /*checked*/
      i[0], b(n, "class", "label svelte-16wp6ih"), b(
        n,
        "for",
        /*id*/
        i[3]
      ), b(e, "class", "checkbox-wrapper svelte-16wp6ih");
    },
    m(c, u) {
      T(c, e, u), A(e, t), A(e, s), A(e, n), A(n, r), o || (a = V(
        t,
        "change",
        /*change_handler*/
        i[5]
      ), o = !0);
    },
    p(c, [u]) {
      u & /*disabled*/
      4 && (t.disabled = /*disabled*/
      c[2]), u & /*checked*/
      1 && (t.checked = /*checked*/
      c[0]), u & /*label*/
      2 && l !== (l = K(
        /*label*/
        c[1]
      ) + "") && _e(r, l);
    },
    i: ee,
    o: ee,
    d(c) {
      c && S(e), o = !1, a();
    }
  };
}
f(SU, "create_fragment$4l");
function TU(i, e, t) {
  let { checked: s } = e, { label: n } = e, { disabled: l = !1 } = e;
  const r = foundry.utils.randomID(), o = it(), a = /* @__PURE__ */ f(({ target: c }) => o("updateSelection", c.checked), "change_handler");
  return i.$$set = (c) => {
    "checked" in c && t(0, s = c.checked), "label" in c && t(1, n = c.label), "disabled" in c && t(2, l = c.disabled);
  }, [s, n, l, r, o, a];
}
f(TU, "instance$4c");
const IA = class IA extends ie {
  constructor(e) {
    super(), le(this, e, TU, SU, ne, { checked: 0, label: 1, disabled: 2 });
  }
};
f(IA, "Checkbox");
let De = IA;
function CU(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*abilityBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      r & /*abilityBonus*/
      1 && t !== (t = /*abilityBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(CU, "create_default_slot_4$o");
function OU(i) {
  let e, t;
  return e = new de({
    props: {
      heading: "A5E.Formula",
      $$slots: { default: [CU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, abilityBonus*/
      4194305 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(OU, "create_default_slot_3$K");
function DU(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.contexts.requiresProficiency",
      checked: (
        /*requiresProficiency*/
        i[1]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[18]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*requiresProficiency*/
      2 && (l.checked = /*requiresProficiency*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(DU, "create_default_slot_2$11");
function IU(i) {
  let e, t;
  return e = new De({
    props: {
      label: "Select Ability Bonus Automatically in Roll Prompt",
      checked: (
        /*abilityBonus*/
        i[0].default ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[19]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*abilityBonus*/
      1 && (l.checked = /*abilityBonus*/
      s[0].default ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(IU, "create_default_slot_1$1s");
function PU(i) {
  let e, t, s, n, l, r, o, a;
  return e = new Ze({
    props: {
      heading: "A5E.contexts.abilities",
      options: Object.entries(
        /*abilities*/
        i[7]
      ),
      selected: (
        /*abilitiesContext*/
        i[3]
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[16]
  ), s = new Ze({
    props: {
      heading: "A5E.contexts.bonusTypes",
      options: Object.entries(
        /*abilityBonusContexts*/
        i[8]
      ),
      selected: (
        /*abilityTypeContext*/
        i[2]
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[17]
  ), l = new de({
    props: {
      $$slots: { default: [DU] },
      $$scope: { ctx: i }
    }
  }), o = new de({
    props: {
      $$slots: { default: [IU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment), r = R(), L(o.$$.fragment);
    },
    m(c, u) {
      N(e, c, u), T(c, t, u), N(s, c, u), T(c, n, u), N(l, c, u), T(c, r, u), N(o, c, u), a = !0;
    },
    p(c, u) {
      const d = {};
      u & /*abilitiesContext*/
      8 && (d.selected = /*abilitiesContext*/
      c[3]), e.$set(d);
      const p = {};
      u & /*abilityTypeContext*/
      4 && (p.selected = /*abilityTypeContext*/
      c[2]), s.$set(p);
      const m = {};
      u & /*$$scope, requiresProficiency*/
      4194306 && (m.$$scope = { dirty: u, ctx: c }), l.$set(m);
      const g = {};
      u & /*$$scope, abilityBonus*/
      4194305 && (g.$$scope = { dirty: u, ctx: c }), o.$set(g);
    },
    i(c) {
      a || (w(e.$$.fragment, c), w(s.$$.fragment, c), w(l.$$.fragment, c), w(o.$$.fragment, c), a = !0);
    },
    o(c) {
      C(e.$$.fragment, c), C(s.$$.fragment, c), C(l.$$.fragment, c), C(o.$$.fragment, c), a = !1;
    },
    d(c) {
      c && (S(t), S(n), S(r)), j(e, c), j(s, c), j(l, c), j(o, c);
    }
  };
}
f(PU, "create_default_slot$2o");
function MU(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k;
  return d = new Me({
    props: {
      $$slots: { default: [OU] },
      $$scope: { ctx: i }
    }
  }), g = new Me({
    props: {
      heading: "Contexts",
      hint: "The context determines when the ability bonus applies",
      $$slots: { default: [PU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), p = E("div"), L(d.$$.fragment), m = R(), h = E("div"), L(g.$$.fragment), b(s, "class", "bonus-image svelte-1gxe7tx"), ze(s.src, n = /*abilityBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*abilityBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*abilityBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1gxe7tx"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1gxe7tx"), b(t, "class", "sheet-header svelte-1gxe7tx"), z(p, "display", "contents"), z(p, "--a5e-section-margin", "0.25rem 0"), z(h, "display", "contents"), z(h, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1gxe7tx");
    },
    m(v, O) {
      T(v, e, O), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, u), A(e, p), N(d, p, null), A(e, m), A(e, h), N(g, h, null), _ = !0, y || (k = [
        V(
          s,
          "click",
          /*click_handler*/
          i[13]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[14]
        )
      ], y = !0);
    },
    p(v, [O]) {
      (!_ || O & /*abilityBonus*/
      1 && !ze(s.src, n = /*abilityBonus*/
      v[0].img)) && b(s, "src", n), (!_ || O & /*abilityBonus*/
      1 && l !== (l = /*abilityBonus*/
      v[0].label)) && b(s, "alt", l), (!_ || O & /*abilityBonus*/
      1 && c !== (c = /*abilityBonus*/
      v[0].label ?? "") && a.value !== c) && (a.value = c);
      const P = {};
      O & /*$$scope, abilityBonus*/
      4194305 && (P.$$scope = { dirty: O, ctx: v }), d.$set(P);
      const D = {};
      O & /*$$scope, abilityBonus, requiresProficiency, abilityTypeContext, abilitiesContext*/
      4194319 && (D.$$scope = { dirty: O, ctx: v }), g.$set(D);
    },
    i(v) {
      _ || (w(d.$$.fragment, v), w(g.$$.fragment, v), _ = !0);
    },
    o(v) {
      C(d.$$.fragment, v), C(g.$$.fragment, v), _ = !1;
    },
    d(v) {
      v && S(e), j(d), j(g), y = !1, Ne(k);
    }
  };
}
f(MU, "create_fragment$4k");
function RU(i, e, t) {
  let s, n, l, r, o, { document: a, bonusID: c } = fe("#external").application, { document: u = a, bonusID: d = c } = e, { jsonValue: p = null } = e;
  const m = u;
  pe(i, m, (G) => t(12, o = G));
  const g = it();
  function h() {
    const G = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: G,
      callback: (q) => {
        _("img", q);
      }
    }).browse();
  }
  f(h, "updateImage");
  function _(G, U) {
    if (p === null) {
      G = `system.bonuses.abilities.${d}.${G}`, se(o, G, U);
      return;
    }
    const q = foundry.utils.expandObject({ ...s, [G]: U });
    g("change", JSON.stringify(q));
  }
  f(_, "onUpdateValue");
  function y() {
    if (p === null)
      return o.system.bonuses.abilities[d];
    try {
      const G = JSON.parse(p || '""') ?? {};
      if (typeof G != "object")
        throw new Error();
      return G.label = G.label ?? "", G.formula = G.formula ?? "", G.context = G.context ?? {
        abilities: [],
        types: [],
        requiresProficiency: !1
      }, G.default = G.default ?? !0, G.img = G.img || "icons/svg/upgrade.svg", G;
    } catch {
      return {
        label: "",
        formula: "",
        damageType: "",
        context: {
          abilities: [],
          types: [],
          requiresProficiency: !1
        },
        default: !0,
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  f(y, "getAbilityBonus");
  const { abilities: k, abilityBonusContexts: v } = CONFIG.A5E, O = /* @__PURE__ */ f(() => h(), "click_handler"), P = /* @__PURE__ */ f(({ target: G }) => _("label", G.value), "change_handler"), D = /* @__PURE__ */ f(({ target: G }) => _("formula", G.value), "change_handler_1"), I = /* @__PURE__ */ f(({ detail: G }) => {
    _("context.abilities", G);
  }, "updateSelection_handler"), B = /* @__PURE__ */ f(({ detail: G }) => {
    _("context.types", G);
  }, "updateSelection_handler_1"), F = /* @__PURE__ */ f(({ detail: G }) => {
    _("context.requiresProficiency", G);
  }, "updateSelection_handler_2"), H = /* @__PURE__ */ f(({ detail: G }) => {
    _("default", G);
  }, "updateSelection_handler_3");
  return i.$$set = (G) => {
    "document" in G && t(9, u = G.document), "bonusID" in G && t(10, d = G.bonusID), "jsonValue" in G && t(11, p = G.jsonValue);
  }, i.$$.update = () => {
    var G, U, q;
    i.$$.dirty & /*$actor, jsonValue*/
    6144 && t(0, s = y() ?? {}), i.$$.dirty & /*abilityBonus*/
    1 && t(3, n = ((G = s.context) == null ? void 0 : G.abilities) ?? []), i.$$.dirty & /*abilityBonus*/
    1 && t(2, l = ((U = s.context) == null ? void 0 : U.types) ?? []), i.$$.dirty & /*abilityBonus*/
    1 && t(1, r = ((q = s.context) == null ? void 0 : q.requiresProficiency) ?? !1);
  }, [
    s,
    r,
    l,
    n,
    m,
    h,
    _,
    k,
    v,
    u,
    d,
    p,
    o,
    O,
    P,
    D,
    I,
    B,
    F,
    H
  ];
}
f(RU, "instance$4b");
const PA = class PA extends ie {
  constructor(e) {
    super(), le(this, e, RU, MU, ne, { document: 9, bonusID: 10, jsonValue: 11 });
  }
};
f(PA, "AbilityBonusConfigDialog");
let Gd = PA;
function M9(i = "character") {
  const e = [
    [0, game.i18n.localize("A5E.None")],
    [1, "d4"],
    [2, "d6"],
    [3, "d8"],
    [4, "d10"],
    [5, "d12"]
  ];
  return i !== "character" && e.push([6, "d20"]), e;
}
f(M9, "prepareExpertiseDiceOptions");
function FU(i) {
  let e, t;
  return e = new Ye({
    props: {
      heading: "A5E.ExpertiseDie",
      buttons: (
        /*buttons*/
        i[1]
      ),
      options: (
        /*options*/
        i[2]
      ),
      selected: (
        /*selected*/
        i[0]
      ),
      allowDeselect: !1,
      optionStyles: "min-width: 1.75rem; text-align: center;"
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[6]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*buttons*/
      2 && (l.buttons = /*buttons*/
      s[1]), n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(FU, "create_if_block$2l");
function NU(i) {
  let e, t, s = !/*hideExpertiseDice*/
  i[3] && FU(i);
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, [l]) {
      /*hideExpertiseDice*/
      n[3] || s.p(n, l);
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f(NU, "create_fragment$4j");
function jU(i, e, t) {
  let s, { type: n = "character" } = e, { selected: l } = e, { source: r = "" } = e;
  const o = M9(n), a = game.settings.get("a5e", "hideExpertiseDice");
  function c(u) {
    gt.call(this, i, u);
  }
  return f(c, "updateSelection_handler"), i.$$set = (u) => {
    "type" in u && t(4, n = u.type), "selected" in u && t(0, l = u.selected), "source" in u && t(5, r = u.source);
  }, i.$$.update = () => {
    i.$$.dirty & /*source*/
    32 && t(1, s = r.length ? [
      {
        classes: "fas fa-question-circle",
        tooltip: r
      }
    ] : []);
  }, [
    l,
    s,
    o,
    a,
    n,
    r,
    c
  ];
}
f(jU, "instance$4a");
const MA = class MA extends ie {
  constructor(e) {
    super(), le(this, e, jU, NU, ne, { type: 4, selected: 0, source: 5 });
  }
};
f(MA, "ExpertiseDiePicker");
let hn = MA;
function LU(i) {
  let e, t;
  return e = new Me({
    props: {
      heading: "Ability Check Configuration",
      $$slots: { default: [BU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, ability, $actor, abilityKey*/
      2055 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(LU, "create_if_block_2$V");
function BU(i) {
  var s;
  let e, t;
  return e = new hn({
    props: {
      selected: (
        /*ability*/
        (s = i[2]) == null ? void 0 : s.check.expertiseDice
      ),
      type: (
        /*$actor*/
        i[1].type
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*ability*/
      4 && (r.selected = /*ability*/
      (o = n[2]) == null ? void 0 : o.check.expertiseDice), l & /*$actor*/
      2 && (r.type = /*$actor*/
      n[1].type), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(BU, "create_default_slot_3$J");
function qU(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.ProficiencyProficient",
      checked: (
        /*ability*/
        i[2].save.proficient
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[8]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*ability*/
      4 && (l.checked = /*ability*/
      s[2].save.proficient), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(qU, "create_default_slot_2$10");
function GU(i) {
  var s;
  let e, t;
  return e = new hn({
    props: {
      selected: (
        /*ability*/
        (s = i[2]) == null ? void 0 : s.save.expertiseDice
      ),
      type: (
        /*$actor*/
        i[1].type
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[9]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*ability*/
      4 && (r.selected = /*ability*/
      (o = n[2]) == null ? void 0 : o.save.expertiseDice), l & /*$actor*/
      2 && (r.type = /*$actor*/
      n[1].type), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(GU, "create_if_block_1$1u");
function ED(i) {
  let e, t;
  return e = new de({
    props: {
      heading: "A5E.ConcentrationCheckBonus",
      hint: "This field accepts any values valid in roll formulae.",
      $$slots: { default: [zU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, ability, $actor*/
      2054 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(ED, "create_if_block$2k");
function zU(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), e.value = t = /*ability*/
      ((l = i[2].save) == null ? void 0 : l.concentrationBonus) ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r & /*ability*/
      4 && t !== (t = /*ability*/
      ((o = l[2].save) == null ? void 0 : o.concentrationBonus) ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(zU, "create_default_slot_1$1r");
function HU(i) {
  let e, t, s, n, l;
  e = new de({
    props: {
      hint: "Determines whether to add this actor's proficiency bonus to its saving throws",
      $$slots: { default: [qU] },
      $$scope: { ctx: i }
    }
  });
  let r = !/*hideExpertiseDice*/
  i[4] && GU(i), o = (
    /*abilityKey*/
    i[0] === "con" && ED(i)
  );
  return {
    c() {
      L(e.$$.fragment), t = R(), r && r.c(), s = R(), o && o.c(), n = $e();
    },
    m(a, c) {
      N(e, a, c), T(a, t, c), r && r.m(a, c), T(a, s, c), o && o.m(a, c), T(a, n, c), l = !0;
    },
    p(a, c) {
      const u = {};
      c & /*$$scope, ability, $actor, abilityKey*/
      2055 && (u.$$scope = { dirty: c, ctx: a }), e.$set(u), /*hideExpertiseDice*/
      a[4] || r.p(a, c), /*abilityKey*/
      a[0] === "con" ? o ? (o.p(a, c), c & /*abilityKey*/
      1 && w(o, 1)) : (o = ED(a), o.c(), w(o, 1), o.m(n.parentNode, n)) : o && (ce(), C(o, 1, 1, () => {
        o = null;
      }), ue());
    },
    i(a) {
      l || (w(e.$$.fragment, a), w(r), w(o), l = !0);
    },
    o(a) {
      C(e.$$.fragment, a), C(r), C(o), l = !1;
    },
    d(a) {
      a && (S(t), S(s), S(n)), j(e, a), r && r.d(a), o && o.d(a);
    }
  };
}
f(HU, "create_default_slot$2n");
function UU(i) {
  let e, t, s, n, l, r = !/*hideExpertiseDice*/
  i[4] && LU(i);
  return s = new Me({
    props: {
      heading: "Saving Throw Configuration",
      $$slots: { default: [HU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("article"), r && r.c(), t = R(), n = E("div"), L(s.$$.fragment), z(n, "display", "contents"), z(n, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1avvd3a");
    },
    m(o, a) {
      T(o, e, a), r && r.m(e, null), A(e, t), A(e, n), N(s, n, null), l = !0;
    },
    p(o, [a]) {
      /*hideExpertiseDice*/
      o[4] || r.p(o, a);
      const c = {};
      a & /*$$scope, ability, $actor, abilityKey*/
      2055 && (c.$$scope = { dirty: a, ctx: o }), s.$set(c);
    },
    i(o) {
      l || (w(r), w(s.$$.fragment, o), l = !0);
    },
    o(o) {
      C(r), C(s.$$.fragment, o), l = !1;
    },
    d(o) {
      o && S(e), r && r.d(), j(s);
    }
  };
}
f(UU, "create_fragment$4i");
function VU(i, e, t) {
  let s, n, { document: l, appId: r, abilityKey: o } = fe("#external").application, { document: a = l, appId: c = r, abilityKey: u = o } = e;
  const d = a;
  pe(i, d, (y) => t(1, n = y));
  const p = game.settings.get("a5e", "hideExpertiseDice"), m = /* @__PURE__ */ f(({ detail: y }) => se(n, `system.abilities.${u}.check.expertiseDice`, y), "updateSelection_handler"), g = /* @__PURE__ */ f(({ detail: y }) => {
    se(n, `system.abilities.${u}.save.proficient`, y);
  }, "updateSelection_handler_1"), h = /* @__PURE__ */ f(({ detail: y }) => se(n, `system.abilities.${u}.save.expertiseDice`, y), "updateSelection_handler_2"), _ = /* @__PURE__ */ f(({ target: y }) => se(n, "system.abilities.con.save.concentrationBonus", y.value), "change_handler");
  return i.$$set = (y) => {
    "document" in y && t(5, a = y.document), "appId" in y && t(6, c = y.appId), "abilityKey" in y && t(0, u = y.abilityKey);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, abilityKey*/
    3 && t(2, s = n.system.abilities[u]);
  }, [
    u,
    n,
    s,
    d,
    p,
    a,
    c,
    m,
    g,
    h,
    _
  ];
}
f(VU, "instance$49");
const RA = class RA extends ie {
  constructor(e) {
    super(), le(this, e, VU, UU, ne, { document: 5, appId: 6, abilityKey: 0 });
  }
};
f(RA, "ActorAbilityConfigDialog");
let Q_ = RA;
function WU(i) {
  let e, t;
  return e = new Ye({
    props: {
      heading: "Visibility Mode",
      options: Object.entries(
        /*rollModes*/
        i[1]
      ).map(
        /*func*/
        i[3]
      ),
      selected: (
        /*visibilityMode*/
        i[0]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[4]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*visibilityMode*/
      1 && (l.selected = /*visibilityMode*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(WU, "create_fragment$4h");
function KU(i, e, t) {
  const s = CONST.DICE_ROLL_MODES, { DICE_ROLL_MODES: n } = CONFIG.A5E;
  let { visibilityMode: l } = e;
  const r = /* @__PURE__ */ f(([a, c]) => [c, n[c]], "func"), o = /* @__PURE__ */ f(({ detail: a }) => t(0, l = a), "updateSelection_handler");
  return i.$$set = (a) => {
    "visibilityMode" in a && t(0, l = a.visibilityMode);
  }, [l, s, n, r, o];
}
f(KU, "instance$48");
const FA = class FA extends ie {
  constructor(e) {
    super(), le(this, e, KU, WU, ne, { visibilityMode: 0 });
  }
};
f(FA, "OutputVisibilitySection");
let ma = FA;
function Cc(i, e = !0) {
  let t;
  if (i === 1)
    t = "d4";
  else if (i === 2)
    t = "d6";
  else if (i === 3)
    t = "d8";
  else if (i === 4)
    t = "d10";
  else if (i >= 5)
    t = "d12";
  else
    return null;
  return `${e ? 1 : ""}${t}`;
}
f(Cc, "getExpertiseDieSize");
var ih, R9, lh, F9, rh, N9, oh, j9, Tu, x_, Cu, ey, pr, Ja, ah, L9, ch, B9, uh, q9, fh, G9, mr, Za, dh, z9, ph, H9, mh, U9, hh, V9, gh, W9, hr, Qa;
const NA = class NA {
  constructor(e, t) {
    Y(this, ih);
    Y(this, lh);
    Y(this, rh);
    Y(this, oh);
    Y(this, Tu);
    Y(this, Cu);
    Y(this, pr);
    Y(this, ah);
    Y(this, ch);
    Y(this, uh);
    Y(this, fh);
    Y(this, mr);
    Y(this, dh);
    Y(this, ph);
    Y(this, mh);
    Y(this, hh);
    Y(this, gh);
    Y(this, hr);
    this.actor = e, this.rollData = t;
  }
  getModifiers() {
    switch (this.rollData.type) {
      case "abilityCheck":
        return Z(this, ih, R9).call(this).filter(Boolean);
      case "attack":
        return Z(this, lh, F9).call(this).filter(Boolean);
      case "initiative":
        return Z(this, rh, N9).call(this).filter(Boolean);
      case "savingThrow":
        return Z(this, oh, j9).call(this).filter(Boolean);
      case "skillCheck":
        return Z(this, Tu, x_).call(this).filter(Boolean);
      default:
        return [];
    }
  }
};
ih = new WeakSet(), R9 = /* @__PURE__ */ f(function() {
  return [
    Z(this, pr, Ja).call(this),
    Z(this, Cu, ey).call(this),
    Z(this, mr, Za).call(this),
    Z(this, hr, Qa).call(this)
  ];
}, "#getAbilityCheckModifiers"), lh = new WeakSet(), F9 = /* @__PURE__ */ f(function() {
  return [
    Z(this, mh, U9).call(this),
    Z(this, pr, Ja).call(this),
    Z(this, uh, q9).call(this),
    Z(this, dh, z9).call(this),
    Z(this, mr, Za).call(this),
    Z(this, hr, Qa).call(this)
  ];
}, "#getAttackRollModifiers"), rh = new WeakSet(), N9 = /* @__PURE__ */ f(function() {
  return [
    Z(this, ph, H9).call(this),
    ...Z(this, Tu, x_).call(this)
  ];
}, "#getInitiativeRollModifiers"), oh = new WeakSet(), j9 = /* @__PURE__ */ f(function() {
  return [
    Z(this, ch, B9).call(this),
    Z(this, pr, Ja).call(this),
    Z(this, ah, L9).call(this),
    Z(this, fh, G9).call(this),
    Z(this, mr, Za).call(this),
    Z(this, hr, Qa).call(this)
  ];
}, "#getSavingThrowModifiers"), Tu = new WeakSet(), x_ = /* @__PURE__ */ f(function() {
  return [
    Z(this, hh, V9).call(this),
    Z(this, pr, Ja).call(this),
    Z(this, gh, W9).call(this),
    Z(this, Cu, ey).call(this),
    Z(this, mr, Za).call(this),
    Z(this, hr, Qa).call(this)
  ];
}, "#getSkillCheckModifiers"), Cu = new WeakSet(), ey = /* @__PURE__ */ f(function() {
  const { ability: e, selectedAbilityBonuses: t } = this.rollData;
  if (!e)
    return null;
  let s;
  return t ? s = this.actor.BonusesManager.getSelectedBonusesFormula("abilities", t) : s = this.actor.BonusesManager.getAbilityBonusesFormula(e, "check"), {
    label: K("A5E.AbilityCheckBonus", {
      ability: CONFIG.A5E.abilities[e]
    }),
    value: s || null
  };
}, "#getAbilityCheckBonus"), pr = new WeakSet(), Ja = /* @__PURE__ */ f(function() {
  var t;
  const { ability: e } = this.rollData;
  return e ? {
    label: K("A5E.AbilityCheckMod", {
      ability: CONFIG.A5E.abilities[e] ?? e
    }),
    value: ((t = this.actor.system.abilities[e]) == null ? void 0 : t.mod) ?? null
  } : null;
}, "#getAbilityModifier"), ah = new WeakSet(), L9 = /* @__PURE__ */ f(function() {
  const { ability: e, selectedAbilityBonuses: t } = this.rollData;
  if (!e)
    return null;
  let s;
  return t ? s = this.actor.BonusesManager.getSelectedBonusesFormula("abilities", t) : s = this.actor.BonusesManager.getAbilityBonusesFormula(e, "save"), {
    label: K("A5E.AbilitySaveBonus", {
      ability: CONFIG.A5E.abilities[e]
    }),
    value: s || null
  };
}, "#getAbilitySaveBonus"), ch = new WeakSet(), B9 = /* @__PURE__ */ f(function() {
  var n, l;
  const { ability: e } = this.rollData;
  if (!e)
    return null;
  const t = (l = (n = this.actor.system.abilities[e]) == null ? void 0 : n.save) == null ? void 0 : l.proficient, s = this.actor.system.attributes.prof;
  return {
    label: K("A5E.ProficiencyBonus"),
    value: t ? s : 0
  };
}, "#getAbilitySaveModifier"), uh = new WeakSet(), q9 = /* @__PURE__ */ f(function() {
  return {
    label: K("A5E.AttackBonus"),
    value: this.rollData.attackBonus ?? 0
  };
}, "#getAttackBonus"), fh = new WeakSet(), G9 = /* @__PURE__ */ f(function() {
  return this.rollData.saveType !== "concentration" ? null : {
    label: K("A5E.ConcentrationBonus"),
    value: this.actor.system.abilities.con.save.concentrationBonus
  };
}, "#getConcentrationBonus"), mr = new WeakSet(), Za = /* @__PURE__ */ f(function() {
  var e;
  return {
    label: K("A5E.ExpertiseDie"),
    value: Cc(((e = this.rollData) == null ? void 0 : e.expertiseDie) ?? 0)
  };
}, "#getExpertiseDice"), dh = new WeakSet(), z9 = /* @__PURE__ */ f(function() {
  const { BonusesManager: e } = this.actor, { attackType: t, item: s, selectedAttackBonuses: n } = this.rollData;
  let l;
  switch (n ? l = e.getSelectedBonusesFormula("attacks", n) : l = e.getAttackBonusFormula(s, t), t) {
    case "meleeSpellAttack":
      return { label: K("A5E.BonusMeleeSpellAttack"), value: l };
    case "meleeWeaponAttack":
      return { label: K("A5E.BonusMeleeWeaponAttack"), value: l };
    case "rangedSpellAttack":
      return { label: K("A5E.BonusRangedSpellAttack"), value: l };
    case "rangedWeaponAttack":
      return { label: K("A5E.BonusRangedWeaponAttack"), value: l };
    default:
      return null;
  }
}, "#getGlobalAttackBonus"), ph = new WeakSet(), H9 = /* @__PURE__ */ f(function() {
  const { ability: e, selectedInitiativeBonuses: t, skill: s } = this.rollData;
  let n;
  return t ? n = this.actor.BonusesManager.getSelectedBonusesFormula("initiative", t) : n = this.actor.BonusesManager.getInitiativeBonusFormula(
    { abilityKey: e, skillKey: s }
  ), {
    label: K("A5E.InitiativeBonus"),
    value: n || null
  };
}, "#getInitiativeBonus"), mh = new WeakSet(), U9 = /* @__PURE__ */ f(function() {
  return this.rollData.proficient ? {
    label: K("A5E.ProficiencyBonus"),
    value: this.actor.system.attributes.prof
  } : null;
}, "#getProficiencyBonus"), hh = new WeakSet(), V9 = /* @__PURE__ */ f(function() {
  var l;
  const { skill: e } = this.rollData;
  if (!e)
    return null;
  let t = "A5E.SkillCheckMod";
  const s = (l = this.actor.flags.a5e) == null ? void 0 : l.jackOfAllTrades, n = this.actor.system.skills[e];
  return (n == null ? void 0 : n.proficient) === 2 ? t = "A5E.ProficiencyBonusExpertise" : n != null && n.proficient ? t = "A5E.ProficiencyBonus" : s && (t = "A5E.ProficiencyBonusJack"), {
    label: t ? K(t, { skill: CONFIG.A5E.skills[e] }) : "",
    value: (n == null ? void 0 : n.mod) ?? null
  };
}, "#getSkillCheckModifier"), gh = new WeakSet(), W9 = /* @__PURE__ */ f(function() {
  const { ability: e, selectedSkillBonuses: t, skill: s } = this.rollData;
  if (!s)
    return null;
  let n;
  return t ? n = this.actor.BonusesManager.getSelectedBonusesFormula("skills", t) : n = this.actor.BonusesManager.getSkillBonusesFormula(s, e), {
    label: K("A5E.SkillCheckBonus", { skill: CONFIG.A5E.skills[s] }),
    value: n || null
  };
}, "#getSkillCheckBonus"), hr = new WeakSet(), Qa = /* @__PURE__ */ f(function() {
  return { value: this.rollData.situationalMods };
}, "#getSituationalModifiers"), f(NA, "ModifierManager");
let Oc = NA;
function si(i, e = {}) {
  const t = new Oc(i, e);
  return V5({
    actor: i,
    rollMode: e.rollMode ?? CONFIG.A5E.ROLL_MODE.NORMAL,
    minRoll: e.minRoll ?? 1,
    item: e.item ?? null,
    modifiers: t.getModifiers()
  }).rollFormula;
}
f(si, "getRollFormula");
function YU(i) {
  let e, t;
  return e = new Ye({
    props: {
      heading: "A5E.RollModeHeading",
      buttons: (
        /*buttons*/
        i[1]
      ),
      options: (
        /*options*/
        i[2]
      ),
      selected: (
        /*selected*/
        i[0]
      ),
      allowDeselect: !1
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[4]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*buttons*/
      2 && (l.buttons = /*buttons*/
      s[1]), n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(YU, "create_fragment$4g");
function XU(i, e, t) {
  let s, { selected: n } = e, { source: l } = e;
  const o = Object.entries(CONFIG.A5E.rollModes ?? {}).map(([c, u]) => [CONFIG.A5E.ROLL_MODE[c.toUpperCase()], K(u)]);
  function a(c) {
    gt.call(this, i, c);
  }
  return f(a, "updateSelection_handler"), i.$$set = (c) => {
    "selected" in c && t(0, n = c.selected), "source" in c && t(3, l = c.source);
  }, i.$$.update = () => {
    i.$$.dirty & /*source*/
    8 && t(1, s = l.length ? [
      {
        classes: "fas fa-question-circle",
        tooltip: l
      }
    ] : []);
  }, [n, s, o, l, a];
}
f(XU, "instance$47");
const jA = class jA extends ie {
  constructor(e) {
    super(), le(this, e, XU, YU, ne, { selected: 0, source: 3 });
  }
};
f(jA, "RollModePicker");
let ml = jA;
function JU(i) {
  let e, t;
  return e = new Ze({
    props: {
      heading: "Ability Bonuses",
      options: (
        /*abilityBonuses*/
        i[10].map(xU)
      ),
      selected: (
        /*selectedAbilityBonuses*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[21]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*selectedAbilityBonuses*/
      8 && (l.selected = /*selectedAbilityBonuses*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(JU, "create_if_block$2j");
function ZU(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), b(e, "id", t = /*$actor*/
      i[4].id + "-" + /*appId*/
      i[9] + "-situational-mod");
    },
    m(l, r) {
      T(l, e, r), qe(
        e,
        /*situationalMods*/
        i[2]
      ), s || (n = V(
        e,
        "input",
        /*input_input_handler*/
        i[22]
      ), s = !0);
    },
    p(l, r) {
      r & /*$actor*/
      16 && t !== (t = /*$actor*/
      l[4].id + "-" + /*appId*/
      l[9] + "-situational-mod") && b(e, "id", t), r & /*situationalMods*/
      4 && e.value !== /*situationalMods*/
      l[2] && qe(
        e,
        /*situationalMods*/
        l[2]
      );
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(ZU, "create_default_slot$2m");
function QU(i) {
  let e, t, s, n, l, r, o, a, c = Object.values(
    /*abilityBonuses*/
    i[10]
  ).flat().length, u, d, p, m, g, h, _, y, k, v, O;
  function P(B) {
    i[18](B);
  }
  f(P, "outputvisibilitysection_visibilityMode_binding");
  let D = {};
  /*visibilityMode*/
  i[5] !== void 0 && (D.visibilityMode = /*visibilityMode*/
  i[5]), t = new ma({ props: D }), st.push(() => mt(t, "visibilityMode", P)), l = new ml({
    props: {
      selected: (
        /*rollMode*/
        i[1]
      ),
      source: (
        /*rollModeString*/
        i[13]
      )
    }
  }), l.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[19]
  ), o = new hn({
    props: {
      source: (
        /*expertiseDieSource*/
        i[12]
      ),
      selected: (
        /*expertiseDie*/
        i[0]
      ),
      type: (
        /*$actor*/
        i[4].type
      )
    }
  }), o.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[20]
  );
  let I = c && JU(i);
  return d = new de({
    props: {
      heading: "A5E.SituationalMods",
      $$slots: { default: [ZU] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), L(t.$$.fragment), n = R(), L(l.$$.fragment), r = R(), L(o.$$.fragment), a = R(), I && I.c(), u = R(), L(d.$$.fragment), p = R(), m = E("section"), g = x(
        /*rollFormula*/
        i[6]
      ), h = R(), _ = E("section"), y = E("button"), y.textContent = `${/*buttonText*/
      i[11]}`, b(m, "class", "roll-formula-preview svelte-cfnill"), b(e, "class", "svelte-cfnill");
    },
    m(B, F) {
      T(B, e, F), N(t, e, null), A(e, n), N(l, e, null), A(e, r), N(o, e, null), A(e, a), I && I.m(e, null), A(e, u), N(d, e, null), A(e, p), A(e, m), A(m, g), A(e, h), A(e, _), A(_, y), k = !0, v || (O = V(y, "click", tt(
        /*onSubmit*/
        i[7]
      )), v = !0);
    },
    p(B, [F]) {
      const H = {};
      !s && F & /*visibilityMode*/
      32 && (s = !0, H.visibilityMode = /*visibilityMode*/
      B[5], _t(() => s = !1)), t.$set(H);
      const G = {};
      F & /*rollMode*/
      2 && (G.selected = /*rollMode*/
      B[1]), l.$set(G);
      const U = {};
      F & /*expertiseDie*/
      1 && (U.selected = /*expertiseDie*/
      B[0]), F & /*$actor*/
      16 && (U.type = /*$actor*/
      B[4].type), o.$set(U), c && I.p(B, F);
      const q = {};
      F & /*$$scope, $actor, situationalMods*/
      134217748 && (q.$$scope = { dirty: F, ctx: B }), d.$set(q), (!k || F & /*rollFormula*/
      64) && _e(
        g,
        /*rollFormula*/
        B[6]
      );
    },
    i(B) {
      k || (w(t.$$.fragment, B), w(l.$$.fragment, B), w(o.$$.fragment, B), w(I), w(d.$$.fragment, B), k = !0);
    },
    o(B) {
      C(t.$$.fragment, B), C(l.$$.fragment, B), C(o.$$.fragment, B), C(I), C(d.$$.fragment, B), k = !1;
    },
    d(B) {
      B && S(e), j(t), j(l), j(o), I && I.d(), j(d), v = !1, O();
    }
  };
}
f(QU, "create_fragment$4f");
const xU = /* @__PURE__ */ f(([i, e]) => [i, e.label || e.defaultLabel], "func$f");
function eV(i, e, t) {
  var re;
  let s, n, { document: l, abilityKey: r, dialog: o, options: a } = fe("#external").application, { document: c = l, abilityKey: u = r, dialog: d = o, options: p = a } = e;
  function m() {
    return k ? 0 : n.RollOverrideManager.getExpertiseDice(`system.abilities.${u}.check`, p.expertiseDice ?? 0);
  }
  f(m, "getInitialExpertiseDieSelection");
  function g() {
    d.submit({
      expertiseDie: P,
      rollFormula: G,
      rollMode: B,
      visibilityMode: H
    });
  }
  f(g, "onSubmit");
  const h = new Bt(c);
  pe(i, h, (ae) => t(4, n = ae));
  const _ = d.id, y = n.BonusesManager.prepareAbilityBonuses(u, "check"), k = game.settings.get("a5e", "hideExpertiseDice"), v = K(CONFIG.A5E.abilities[u]), O = K("A5E.RollPromptAbilityCheck", { ability: v });
  let P = m(), D = p.rollMode ?? CONFIG.A5E.ROLL_MODE.NORMAL, I = n.RollOverrideManager.getExpertiseDiceSource(`system.abilities.${u}.check`, p.expertiseDie ?? 0), B = n.RollOverrideManager.getRollOverride(`system.abilities.${u}.check`, D), F = (re = n.RollOverrideManager) == null ? void 0 : re.getRollOverridesSource(`system.abilities.${u}.check`, D), H = p.visibilityMode ?? game.settings.get("core", "rollMode"), G, U = p.situationalMods ?? "";
  function q(ae) {
    H = ae, t(5, H);
  }
  f(q, "outputvisibilitysection_visibilityMode_binding");
  const W = /* @__PURE__ */ f(({ detail: ae }) => t(1, B = ae), "updateSelection_handler"), X = /* @__PURE__ */ f(({ detail: ae }) => t(0, P = ae), "updateSelection_handler_1"), te = /* @__PURE__ */ f(({ detail: ae }) => t(3, s = ae), "updateSelection_handler_2");
  function J() {
    U = this.value, t(2, U);
  }
  return f(J, "input_input_handler"), i.$$set = (ae) => {
    "document" in ae && t(14, c = ae.document), "abilityKey" in ae && t(15, u = ae.abilityKey), "dialog" in ae && t(16, d = ae.dialog), "options" in ae && t(17, p = ae.options);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, abilityKey*/
    32784 && t(3, s = n.BonusesManager.getDefaultSelections("abilities", { abilityKey: u, abilityType: "check" })), i.$$.dirty & /*$actor, abilityKey, expertiseDie, rollMode, situationalMods, selectedAbilityBonuses*/
    32799 && t(6, G = si(n, {
      ability: u,
      expertiseDie: P,
      rollMode: B,
      situationalMods: U,
      selectedAbilityBonuses: s,
      type: "abilityCheck"
    }));
  }, [
    P,
    B,
    U,
    s,
    n,
    H,
    G,
    g,
    h,
    _,
    y,
    O,
    I,
    F,
    c,
    u,
    d,
    p,
    q,
    W,
    X,
    te,
    J
  ];
}
f(eV, "instance$46");
const LA = class LA extends ie {
  constructor(e) {
    super(), le(this, e, eV, QU, ne, {
      document: 14,
      abilityKey: 15,
      dialog: 16,
      options: 17
    });
  }
};
f(LA, "AbilityCheckRollDialog");
let ty = LA;
function SD(i) {
  let e, t = K(
    /*heading*/
    i[0]
  ) + "", s;
  return {
    c() {
      e = E("h3"), s = x(t), b(e, "class", "form-heading svelte-17u2cc2");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*heading*/
      1 && t !== (t = K(
        /*heading*/
        n[0]
      ) + "") && _e(s, t);
    },
    d(n) {
      n && S(e);
    }
  };
}
f(SD, "create_if_block_2$U");
function TD(i) {
  let e, t = K(
    /*hint*/
    i[1]
  ) + "", s;
  return {
    c() {
      e = E("small"), s = x(t), b(e, "class", "hint svelte-17u2cc2");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*hint*/
      2 && t !== (t = K(
        /*hint*/
        n[1]
      ) + "") && _e(s, t);
    },
    d(n) {
      n && S(e);
    }
  };
}
f(TD, "create_if_block_1$1t");
function CD(i) {
  let e, t, s, n = K(
    /*warning*/
    i[3]
  ) + "", l;
  return {
    c() {
      e = E("small"), t = E("i"), s = R(), l = x(n), b(t, "class", "fa-solid fa-circle-exclamation"), b(e, "class", "warning svelte-17u2cc2");
    },
    m(r, o) {
      T(r, e, o), A(e, t), A(e, s), A(e, l);
    },
    p(r, o) {
      o & /*warning*/
      8 && n !== (n = K(
        /*warning*/
        r[3]
      ) + "") && _e(l, n);
    },
    d(r) {
      r && S(e);
    }
  };
}
f(CD, "create_if_block$2i");
function tV(i) {
  let e, t, s, n, l, r = (
    /*heading*/
    i[0] && SD(i)
  );
  const o = (
    /*#slots*/
    i[5].default
  ), a = Pt(
    o,
    i,
    /*$$scope*/
    i[4],
    null
  );
  let c = (
    /*hint*/
    i[1] && TD(i)
  ), u = (
    /*showWarning*/
    i[2] && CD(i)
  );
  return {
    c() {
      e = E("section"), r && r.c(), t = R(), a && a.c(), s = R(), c && c.c(), n = R(), u && u.c(), b(e, "class", "form-section svelte-17u2cc2");
    },
    m(d, p) {
      T(d, e, p), r && r.m(e, null), A(e, t), a && a.m(e, null), A(e, s), c && c.m(e, null), A(e, n), u && u.m(e, null), l = !0;
    },
    p(d, [p]) {
      /*heading*/
      d[0] ? r ? r.p(d, p) : (r = SD(d), r.c(), r.m(e, t)) : r && (r.d(1), r = null), a && a.p && (!l || p & /*$$scope*/
      16) && Rt(
        a,
        o,
        d,
        /*$$scope*/
        d[4],
        l ? Mt(
          o,
          /*$$scope*/
          d[4],
          p,
          null
        ) : Ft(
          /*$$scope*/
          d[4]
        ),
        null
      ), /*hint*/
      d[1] ? c ? c.p(d, p) : (c = TD(d), c.c(), c.m(e, n)) : c && (c.d(1), c = null), /*showWarning*/
      d[2] ? u ? u.p(d, p) : (u = CD(d), u.c(), u.m(e, null)) : u && (u.d(1), u = null);
    },
    i(d) {
      l || (w(a, d), l = !0);
    },
    o(d) {
      C(a, d), l = !1;
    },
    d(d) {
      d && S(e), r && r.d(), a && a.d(d), c && c.d(), u && u.d();
    }
  };
}
f(tV, "create_fragment$4e");
function sV(i, e, t) {
  let { $$slots: s = {}, $$scope: n } = e, { heading: l = null } = e, { hint: r = null } = e, { showWarning: o = !1 } = e, { warning: a = null } = e;
  return i.$$set = (c) => {
    "heading" in c && t(0, l = c.heading), "hint" in c && t(1, r = c.hint), "showWarning" in c && t(2, o = c.showWarning), "warning" in c && t(3, a = c.warning), "$$scope" in c && t(4, n = c.$$scope);
  }, [l, r, o, a, n, s];
}
f(sV, "instance$45");
const BA = class BA extends ie {
  constructor(e) {
    super(), le(this, e, sV, tV, ne, {
      heading: 0,
      hint: 1,
      showWarning: 2,
      warning: 3
    });
  }
};
f(BA, "LegacyFormSection");
let bt = BA;
function ob(i) {
  const e = i.type, t = ["d6", "d8", "d10", "d12"];
  return e === "npc" && (t.unshift("d4"), t.push("d20")), t.map((s) => ({
    die: s,
    dieSize: s,
    current: i.system.attributes.hitDice[s].current,
    total: i.system.attributes.hitDice[s].total
  }));
}
f(ob, "prepareHitDice");
function OD(i, e, t) {
  const s = i.slice();
  return s[13] = e[t].die, s[14] = e[t].dieSize, s[15] = e[t].current, s[16] = e[t].total, s;
}
f(OD, "get_each_context$1E");
function DD(i, e, t) {
  const s = i.slice();
  return s[19] = e[t].label, s[20] = e[t].updateAttribute, s;
}
f(DD, "get_each_context_1$n");
function nV(i) {
  let e, t, s, n, l, r;
  return {
    c() {
      e = E("div"), t = E("input"), b(t, "class", "a5e-input"), b(t, "type", "number"), b(t, "data-dtype", "Number"), b(t, "name", "system.attributes.hp." + /*updateAttribute*/
      i[20]), t.value = s = /*hp*/
      i[3][
        /*updateAttribute*/
        i[20]
      ], t.disabled = n = /*updateAttribute*/
      i[20] === "baseMax" && /*disableMaxHp*/
      i[2], b(e, "class", "u-w-20");
    },
    m(o, a) {
      T(o, e, a), A(e, t), l || (r = V(
        t,
        "change",
        /*change_handler*/
        i[10]
      ), l = !0);
    },
    p(o, a) {
      a & /*hp*/
      8 && s !== (s = /*hp*/
      o[3][
        /*updateAttribute*/
        o[20]
      ]) && t.value !== s && (t.value = s), a & /*disableMaxHp*/
      4 && n !== (n = /*updateAttribute*/
      o[20] === "baseMax" && /*disableMaxHp*/
      o[2]) && (t.disabled = n);
    },
    d(o) {
      o && S(e), l = !1, r();
    }
  };
}
f(nV, "create_default_slot$2l");
function ID(i) {
  let e, t, s;
  return e = new bt({
    props: {
      heading: (
        /*label*/
        i[19]
      ),
      $$slots: { default: [nV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--item-alignment", "center"), z(t, "--label-width", "7.5rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, hp, disableMaxHp, $actor*/
      8388621 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(ID, "create_each_block_1$n");
function PD(i) {
  let e, t, s, n, l, r, o, a, c, u, d;
  return {
    c() {
      e = E("div"), t = E("div"), s = E("span"), s.textContent = `${/*dieSize*/
      i[14]}`, n = R(), l = E("div"), r = E("input"), o = x(`
                        /
                        `), a = E("input"), c = R(), b(s, "class", "a5e-hit-die__label"), b(t, "class", "a5e-hit-die"), b(r, "class", "a5e-hit-die__quantity"), b(r, "type", "number"), b(r, "data-dtype", "Number"), b(r, "min", "0"), b(r, "name", "system.attributes.hitDice." + /*dieSize*/
      i[14] + ".current"), r.value = /*current*/
      i[15], b(a, "class", "a5e-hit-die__quantity"), b(a, "data-dtype", "Number"), b(a, "type", "number"), b(a, "min", "0"), b(a, "name", "system.attributes.hitDice." + /*dieSize*/
      i[14] + ".total"), a.disabled = /*disableHitDice*/
      i[1], a.value = /*total*/
      i[16], b(l, "class", "a5e-hit-die__input-container"), b(e, "class", "a5e-hit-die-wrapper");
    },
    m(p, m) {
      T(p, e, m), A(e, t), A(t, s), A(e, n), A(e, l), A(l, r), A(l, o), A(l, a), A(e, c), u || (d = [
        V(
          r,
          "change",
          /*change_handler_1*/
          i[11]
        ),
        V(
          a,
          "change",
          /*change_handler_2*/
          i[12]
        )
      ], u = !0);
    },
    p(p, m) {
      m & /*disableHitDice*/
      2 && (a.disabled = /*disableHitDice*/
      p[1]);
    },
    d(p) {
      p && S(e), u = !1, Ne(d);
    }
  };
}
f(PD, "create_each_block$1E");
function iV(i) {
  let e, t, s, n, l, r, o, a, c = oe(
    /*hpFields*/
    i[5]
  ), u = [];
  for (let g = 0; g < c.length; g += 1)
    u[g] = ID(DD(i, c, g));
  const d = /* @__PURE__ */ f((g) => C(u[g], 1, 1, () => {
    u[g] = null;
  }), "out");
  let p = oe(
    /*hitDice*/
    i[7]
  ), m = [];
  for (let g = 0; g < p.length; g += 1)
    m[g] = PD(OD(i, p, g));
  return {
    c() {
      e = E("article"), t = E("div");
      for (let g = 0; g < u.length; g += 1)
        u[g].c();
      s = R(), n = E("hr"), l = R(), r = E("section");
      for (let g = 0; g < m.length; g += 1)
        m[g].c();
      b(n, "class", "a5e-rule a5e-rule--from u-my-sm"), b(r, "class", o = `u-mt-0 ${/*hitDieClasses*/
      i[4]}`), b(t, "class", "u-flex u-flex-col u-gap-md"), b(e, "class", "svelte-5iup0s");
    },
    m(g, h) {
      T(g, e, h), A(e, t);
      for (let _ = 0; _ < u.length; _ += 1)
        u[_] && u[_].m(t, null);
      A(t, s), A(t, n), A(t, l), A(t, r);
      for (let _ = 0; _ < m.length; _ += 1)
        m[_] && m[_].m(r, null);
      a = !0;
    },
    p(g, [h]) {
      if (h & /*hpFields, hp, disableMaxHp, $actor, Number*/
      45) {
        c = oe(
          /*hpFields*/
          g[5]
        );
        let _;
        for (_ = 0; _ < c.length; _ += 1) {
          const y = DD(g, c, _);
          u[_] ? (u[_].p(y, h), w(u[_], 1)) : (u[_] = ID(y), u[_].c(), w(u[_], 1), u[_].m(t, s));
        }
        for (ce(), _ = c.length; _ < u.length; _ += 1)
          d(_);
        ue();
      }
      if (h & /*hitDice, disableHitDice, $actor, Number*/
      131) {
        p = oe(
          /*hitDice*/
          g[7]
        );
        let _;
        for (_ = 0; _ < p.length; _ += 1) {
          const y = OD(g, p, _);
          m[_] ? m[_].p(y, h) : (m[_] = PD(y), m[_].c(), m[_].m(r, null));
        }
        for (; _ < m.length; _ += 1)
          m[_].d(1);
        m.length = p.length;
      }
      (!a || h & /*hitDieClasses*/
      16 && o !== (o = `u-mt-0 ${/*hitDieClasses*/
      g[4]}`)) && b(r, "class", o);
    },
    i(g) {
      if (!a) {
        for (let h = 0; h < c.length; h += 1)
          w(u[h]);
        a = !0;
      }
    },
    o(g) {
      u = u.filter(Boolean);
      for (let h = 0; h < u.length; h += 1)
        C(u[h]);
      a = !1;
    },
    d(g) {
      g && S(e), Le(u, g), Le(m, g);
    }
  };
}
f(iV, "create_fragment$4d");
function lV(i, e, t) {
  let s, n, l, r, o, { document: a, appId: c } = fe("#external").application, { document: u = a, appId: d = c } = e;
  const p = [
    {
      label: "A5E.HitPointsCurrent",
      updateAttribute: "value"
    },
    {
      label: "A5E.HitPointsBaseMaximum",
      updateAttribute: "baseMax"
    },
    {
      label: "A5E.HitPointsTemporary",
      updateAttribute: "temp"
    },
    {
      label: "A5E.HitPointsMaxModifier",
      updateAttribute: "bonus"
    }
  ], m = u;
  pe(i, m, (k) => t(0, o = k));
  const g = ob(o), h = /* @__PURE__ */ f(({ target: k }) => se(o, k.name, Number(k.value)), "change_handler"), _ = /* @__PURE__ */ f(({ target: k }) => se(o, k.name, Number(k.value)), "change_handler_1"), y = /* @__PURE__ */ f(({ target: k }) => se(o, k.name, Number(k.value)), "change_handler_2");
  return i.$$set = (k) => {
    "document" in k && t(8, u = k.document), "appId" in k && t(9, d = k.appId);
  }, i.$$.update = () => {
    var k;
    i.$$.dirty & /*$actor*/
    1 && t(4, s = o.type === "character" ? "u-flex u-gap-md" : "u-grid u-grid-3 u-gap-lg"), i.$$.dirty & /*$actor*/
    1 && t(3, n = o.system.attributes.hp), i.$$.dirty & /*$actor*/
    1 && t(2, l = Object.keys(o.classes ?? {}).length ?? !((k = o.classAutomationFlags) != null && k.hitPoints) ?? !1), i.$$.dirty & /*$actor*/
    1 && t(1, r = Object.keys(o.classes ?? {}).length ?? !1);
  }, [
    o,
    r,
    l,
    n,
    s,
    p,
    m,
    g,
    u,
    d,
    h,
    _,
    y
  ];
}
f(lV, "instance$44");
const qA = class qA extends ie {
  constructor(e) {
    super(), le(this, e, lV, iV, ne, { document: 8, appId: 9 });
  }
};
f(qA, "ActorHpConfigDialog");
let sy = qA;
function ci(i = !1, e = !1) {
  const t = Object.entries(CONFIG.A5E.abilityAbbreviations).map(
    ([s, n]) => [s, game.i18n.localize(n)]
  );
  return i && t.unshift([null, game.i18n.localize("A5E.None")]), e && t.unshift(["none", game.i18n.localize("A5E.None")]), t;
}
f(ci, "prepareAbilityOptions");
function rV(i) {
  let e, t, s, n;
  return e = new Ye({
    props: {
      heading: "A5E.AbilityScore",
      optionStyles: "min-width:2rem; text-align: center;",
      options: (
        /*abilityOptions*/
        i[3]
      ),
      selected: (
        /*$actor*/
        i[0].system.attributes.initiative.ability
      ),
      allowDeselect: !1
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[6]
  ), s = new hn({
    props: {
      selected: (
        /*initiative*/
        i[1].expertiseDice
      ),
      type: (
        /*$actor*/
        i[0].type
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[7]
  ), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$actor*/
      1 && (o.selected = /*$actor*/
      l[0].system.attributes.initiative.ability), e.$set(o);
      const a = {};
      r & /*initiative*/
      2 && (a.selected = /*initiative*/
      l[1].expertiseDice), r & /*$actor*/
      1 && (a.type = /*$actor*/
      l[0].type), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(rV, "create_default_slot$2k");
function oV(i) {
  let e, t, s;
  return e = new Me({
    props: {
      $$slots: { default: [rV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem"), z(t, "--a5e-section-padding", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, initiative, $actor*/
      259 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(oV, "create_fragment$4c");
function aV(i, e, t) {
  let s, n, { document: l, appId: r } = fe("#external").application, { document: o = l, appId: a = r } = e;
  const c = o;
  pe(i, c, (m) => t(0, n = m));
  const u = ci(), d = /* @__PURE__ */ f((m) => se(n, "system.attributes.initiative.ability", m.detail), "updateSelection_handler"), p = /* @__PURE__ */ f((m) => se(n, "system.attributes.initiative.expertiseDice", m.detail), "updateSelection_handler_1");
  return i.$$set = (m) => {
    "document" in m && t(4, o = m.document), "appId" in m && t(5, a = m.appId);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    1 && t(1, s = n.system.attributes.initiative);
  }, [
    n,
    s,
    c,
    u,
    o,
    a,
    d,
    p
  ];
}
f(aV, "instance$43");
const GA = class GA extends ie {
  constructor(e) {
    super(), le(this, e, aV, oV, ne, { document: 4, appId: 5 });
  }
};
f(GA, "ActorInitConfigDialog");
let ny = GA;
function cV(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), b(e, "name", "system.bonuses.maneuverDC"), e.value = t = /*$actor*/
      i[0].system.bonuses.maneuverDC;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[4]
      ), s = !0);
    },
    p(l, r) {
      r & /*$actor*/
      1 && t !== (t = /*$actor*/
      l[0].system.bonuses.maneuverDC) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(cV, "create_default_slot_1$1q");
function MD(i) {
  let e, t;
  return e = new bt({
    props: {
      $$slots: { default: [uV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $actor*/
      65 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(MD, "create_if_block$2h");
function uV(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.ExertionRecoveryConfigPrompt",
      checked: (
        /*$actor*/
        i[0].system.attributes.exertion.recoverOnRest
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[5]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$actor*/
      1 && (l.checked = /*$actor*/
      s[0].system.attributes.exertion.recoverOnRest), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(uV, "create_default_slot$2j");
function fV(i) {
  let e, t, s, n, l;
  t = new bt({
    props: {
      heading: "A5E.ManeuverDCBonus",
      $$slots: { default: [cV] },
      $$scope: { ctx: i }
    }
  });
  let r = (
    /*$actor*/
    i[0].type === "character" && MD(i)
  );
  return {
    c() {
      e = E("article"), s = E("div"), L(t.$$.fragment), n = R(), r && r.c(), z(s, "display", "contents"), z(s, "--direction", "column"), b(e, "class", "svelte-5iup0s");
    },
    m(o, a) {
      T(o, e, a), A(e, s), N(t, s, null), A(e, n), r && r.m(e, null), l = !0;
    },
    p(o, [a]) {
      const c = {};
      a & /*$$scope, $actor*/
      65 && (c.$$scope = { dirty: a, ctx: o }), t.$set(c), /*$actor*/
      o[0].type === "character" ? r ? (r.p(o, a), a & /*$actor*/
      1 && w(r, 1)) : (r = MD(o), r.c(), w(r, 1), r.m(e, null)) : r && (ce(), C(r, 1, 1, () => {
        r = null;
      }), ue());
    },
    i(o) {
      l || (w(t.$$.fragment, o), w(r), l = !0);
    },
    o(o) {
      C(t.$$.fragment, o), C(r), l = !1;
    },
    d(o) {
      o && S(e), j(t), r && r.d();
    }
  };
}
f(fV, "create_fragment$4b");
function dV(i, e, t) {
  let s, { document: n, appId: l } = fe("#external").application, { document: r = n, appId: o = l } = e;
  const a = r;
  pe(i, a, (d) => t(0, s = d));
  const c = /* @__PURE__ */ f(({ target: d }) => se(s, d.name, d.value), "change_handler"), u = /* @__PURE__ */ f(({ detail: d }) => {
    se(s, "system.attributes.exertion.recoverOnRest", d);
  }, "updateSelection_handler");
  return i.$$set = (d) => {
    "document" in d && t(2, r = d.document), "appId" in d && t(3, o = d.appId);
  }, [s, a, r, o, c, u];
}
f(dV, "instance$42");
const zA = class zA extends ie {
  constructor(e) {
    super(), le(this, e, dV, fV, ne, { document: 2, appId: 3 });
  }
};
f(zA, "ActorManueverConfigDialog");
let iy = zA;
function pV(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("div"), t = E("input"), b(t, "class", "a5e-input"), b(t, "type", "text"), b(t, "name", "system.bonuses.spellDC"), t.value = s = /*$actor*/
      i[0].system.bonuses.spellDC, b(e, "class", "u-w-full");
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = V(
        t,
        "change",
        /*change_handler*/
        i[7]
      ), n = !0);
    },
    p(r, o) {
      o & /*$actor*/
      1 && s !== (s = /*$actor*/
      r[0].system.bonuses.spellDC) && t.value !== s && (t.value = s);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(pV, "create_default_slot_3$I");
function mV(i) {
  let e, t, s, n;
  return e = new De({
    props: {
      label: "A5E.SpellShowSpellSlots",
      checked: (
        /*flags*/
        i[1].showSpellSlots ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[8]
  ), s = new De({
    props: {
      label: "A5E.SpellShowSpellPoints",
      checked: (
        /*flags*/
        i[1].showSpellPoints ?? !1
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[9]
  ), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*flags*/
      2 && (o.checked = /*flags*/
      l[1].showSpellSlots ?? !0), e.$set(o);
      const a = {};
      r & /*flags*/
      2 && (a.checked = /*flags*/
      l[1].showSpellPoints ?? !1), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(mV, "create_default_slot_2$$");
function RD(i) {
  let e, t;
  return e = new bt({
    props: {
      $$slots: { default: [hV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, flags, $actor*/
      8195 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(RD, "create_if_block$2g");
function hV(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.restoreSpellPointsOnShortRest",
      checked: (
        /*flags*/
        i[1].restoreSpellPointsOnShortRest ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[10]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*flags*/
      2 && (l.checked = /*flags*/
      s[1].restoreSpellPointsOnShortRest ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(hV, "create_default_slot_1$1p");
function gV(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.restoreSpellSlotsOnShortRest",
      checked: (
        /*flags*/
        i[1].restoreSpellSlotsOnShortRest ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[11]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*flags*/
      2 && (l.checked = /*flags*/
      s[1].restoreSpellSlotsOnShortRest ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(gV, "create_default_slot$2i");
function bV(i) {
  let e, t, s, n, l, r, o, a, c, u, d;
  t = new Ye({
    props: {
      heading: "A5E.SpellcastingAbilityScore",
      optionStyles: "min-width:2rem; text-align: center;",
      options: Object.entries(
        /*abilityAbbreviations*/
        i[3]
      ),
      selected: (
        /*$actor*/
        i[0].system.attributes.spellcasting
      )
    }
  }), t.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[6]
  ), n = new bt({
    props: {
      heading: "A5E.SpellDCBonus",
      $$slots: { default: [pV] },
      $$scope: { ctx: i }
    }
  }), r = new bt({
    props: {
      $$slots: { default: [mV] },
      $$scope: { ctx: i }
    }
  });
  let p = (
    /*flags*/
    (i[1].showSpellPoints ?? !1) && RD(i)
  );
  return u = new bt({
    props: {
      $$slots: { default: [gV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("article"), L(t.$$.fragment), s = R(), L(n.$$.fragment), l = R(), o = E("div"), L(r.$$.fragment), a = R(), p && p.c(), c = R(), L(u.$$.fragment), z(o, "display", "contents"), z(o, "--gap", "0.5rem 1.25rem"), b(e, "class", "svelte-5iup0s");
    },
    m(m, g) {
      T(m, e, g), N(t, e, null), A(e, s), N(n, e, null), A(e, l), A(e, o), N(r, o, null), A(e, a), p && p.m(e, null), A(e, c), N(u, e, null), d = !0;
    },
    p(m, [g]) {
      const h = {};
      g & /*$actor*/
      1 && (h.selected = /*$actor*/
      m[0].system.attributes.spellcasting), t.$set(h);
      const _ = {};
      g & /*$$scope, $actor*/
      8193 && (_.$$scope = { dirty: g, ctx: m }), n.$set(_);
      const y = {};
      g & /*$$scope, flags, $actor*/
      8195 && (y.$$scope = { dirty: g, ctx: m }), r.$set(y), /*flags*/
      m[1].showSpellPoints ?? !1 ? p ? (p.p(m, g), g & /*flags*/
      2 && w(p, 1)) : (p = RD(m), p.c(), w(p, 1), p.m(e, c)) : p && (ce(), C(p, 1, 1, () => {
        p = null;
      }), ue());
      const k = {};
      g & /*$$scope, flags, $actor*/
      8195 && (k.$$scope = { dirty: g, ctx: m }), u.$set(k);
    },
    i(m) {
      d || (w(t.$$.fragment, m), w(n.$$.fragment, m), w(r.$$.fragment, m), w(p), w(u.$$.fragment, m), d = !0);
    },
    o(m) {
      C(t.$$.fragment, m), C(n.$$.fragment, m), C(r.$$.fragment, m), C(p), C(u.$$.fragment, m), d = !1;
    },
    d(m) {
      m && S(e), j(t), j(n), j(r), p && p.d(), j(u);
    }
  };
}
f(bV, "create_fragment$4a");
function _V(i, e, t) {
  let s, n, { document: l, appId: r } = fe("#external").application, { document: o = l, appId: a = r } = e;
  const c = o;
  pe(i, c, (k) => t(0, n = k));
  const { abilityAbbreviations: u, spellLevels: d } = CONFIG.A5E, p = /* @__PURE__ */ f((k) => se(n, "system.attributes.spellcasting", k.detail), "updateSelection_handler"), m = /* @__PURE__ */ f(({ target: k }) => se(n, k.name, k.value), "change_handler"), g = /* @__PURE__ */ f(({ detail: k }) => {
    se(n, "flags.a5e.showSpellSlots", k);
  }, "updateSelection_handler_1"), h = /* @__PURE__ */ f(({ detail: k }) => {
    se(n, "flags.a5e.showSpellPoints", k);
  }, "updateSelection_handler_2"), _ = /* @__PURE__ */ f(({ detail: k }) => {
    se(n, "flags.a5e.restoreSpellPointsOnShortRest", k);
  }, "updateSelection_handler_3"), y = /* @__PURE__ */ f(({ detail: k }) => {
    se(n, "flags.a5e.restoreSpellSlotsOnShortRest", k);
  }, "updateSelection_handler_4");
  return i.$$set = (k) => {
    "document" in k && t(4, o = k.document), "appId" in k && t(5, a = k.appId);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    1 && t(1, s = n.flags.a5e);
  }, [
    n,
    s,
    c,
    u,
    o,
    a,
    p,
    m,
    g,
    h,
    _,
    y
  ];
}
f(_V, "instance$41");
const HA = class HA extends ie {
  constructor(e) {
    super(), le(this, e, _V, bV, ne, { document: 4, appId: 5 });
  }
};
f(HA, "ActorSpellConfigDialog");
let ly = HA;
function K9(i) {
  var r;
  const e = i.system.attributes.ac.changes ?? {};
  if (!(e != null && e.override) && !((r = e == null ? void 0 : e.bonuses) != null && r.length))
    return "";
  const t = i.effects.reduce((o, a) => {
    if (a.isSuppressed)
      return o;
    const c = a.changes.reduce((u, d) => {
      if (d.key !== "system.attributes.ac.changes.bonuses.value")
        return u;
      let p = 0;
      try {
        p = at(d.value, i.getRollData());
      } catch (m) {
        console.error(m);
      }
      return u.push({
        name: a.name,
        mode: d.mode,
        value: p
      }), u;
    }, []);
    return o.concat(c);
  }, []);
  let s;
  t.find(({ mode: o }) => o === CONFIG.A5E.ACTIVE_EFFECT_MODES.OVERRIDE) ? s = t : s = (e.bonuses.components ?? []).concat(e.bonuses.value ? t : []);
  const n = s.map(({ name: o, value: a }) => `${a >= 0 ? "+" : "-"} ${Math.abs(a)}[${o}]`);
  if (e.override.formula) {
    const o = new Roll(e.override.formula, i.getRollData()).evaluate({ async: !1 }).terms, a = Tc(o ?? []).reduce((c, u) => {
      var d;
      return u instanceof OperatorTerm ? `${c} ${u.operator} ` : (c += `${u.total}`, (d = u.options) != null && d.flavor && (c += `[${u.options.flavor}]`), c);
    }, "");
    n.unshift(a);
  } else
    n.unshift(`${e.override.value}[${e.override.name}]`);
  const l = Tc(
    new Roll(n.join(" "), i.getRollData()).evaluate({ async: !1 }).terms ?? []
  );
  return Roll.getFormula(l);
}
f(K9, "getACComponents");
function yV(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), b(e, "name", "system.attributes.ac.baseFormula"), e.value = t = /*$actor*/
      i[0].system.attributes.ac.baseFormula;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[5]
      ), s = !0);
    },
    p(l, r) {
      r & /*$actor*/
      1 && t !== (t = /*$actor*/
      l[0].system.attributes.ac.baseFormula) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(yV, "create_default_slot_2$_");
function vV(i) {
  let e, t;
  return {
    c() {
      e = E("div"), t = x(
        /*acFormula*/
        i[1]
      ), b(e, "class", "u-w-full ac-formula-preview svelte-116dsjk");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n & /*acFormula*/
      2 && _e(
        t,
        /*acFormula*/
        s[1]
      );
    },
    d(s) {
      s && S(e);
    }
  };
}
f(vV, "create_default_slot_1$1o");
function kV(i) {
  let e, t, s, n;
  return e = new de({
    props: {
      heading: "A5E.armorClass.baseFormula",
      hint: "For NPCs this value states their Natural Armor.",
      $$slots: { default: [yV] },
      $$scope: { ctx: i }
    }
  }), s = new de({
    props: {
      heading: "A5E.armorClass.formula",
      $$slots: { default: [vV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$$scope, $actor*/
      65 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$$scope, acFormula*/
      66 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(kV, "create_default_slot$2h");
function wV(i) {
  let e, t, s;
  return e = new Me({
    props: {
      $$slots: { default: [kV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem"), z(t, "--a5e-section-padding", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, acFormula, $actor*/
      67 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(wV, "create_fragment$49");
function $V(i, e, t) {
  let s, n, { document: l, appId: r } = fe("#external").application, { document: o = l, appId: a = r } = e;
  const c = o;
  pe(i, c, (d) => t(0, n = d));
  const u = /* @__PURE__ */ f(({ target: d }) => se(n, d.name, d.value), "change_handler");
  return i.$$set = (d) => {
    "document" in d && t(3, o = d.document), "appId" in d && t(4, a = d.appId);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    1 && t(1, s = K9(n));
  }, [n, s, c, o, a, u];
}
f($V, "instance$40");
const UA = class UA extends ie {
  constructor(e) {
    super(), le(this, e, $V, wV, ne, { document: 3, appId: 4 });
  }
};
f(UA, "ArmorClassConfigDialog");
let ry = UA;
function AV(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*attackBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      r & /*attackBonus*/
      1 && t !== (t = /*attackBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(AV, "create_default_slot_3$H");
function EV(i) {
  let e, t, s;
  return e = new de({
    props: {
      heading: "A5E.Formula",
      $$slots: { default: [AV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-grow", "1");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, attackBonus*/
      4194305 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(EV, "create_default_slot_2$Z");
function SV(i) {
  let e, t;
  return e = new De({
    props: {
      label: "Select Attack Bonus Automatically in Roll Prompt",
      checked: (
        /*attackBonus*/
        i[0].default ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[19]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*attackBonus*/
      1 && (l.checked = /*attackBonus*/
      s[0].default ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(SV, "create_default_slot_1$1n");
function TV(i) {
  let e, t, s, n, l, r, o, a;
  return e = new Ze({
    props: {
      heading: "A5E.contexts.attackType",
      options: Object.entries(
        /*attackTypes*/
        i[7]
      ),
      selected: (
        /*attackTypesContext*/
        i[3]
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[16]
  ), s = new Ze({
    props: {
      heading: "A5E.contexts.spellLevel",
      options: Object.entries(
        /*spellLevels*/
        i[8]
      ),
      selected: (
        /*spellLevelsContext*/
        i[2]
      ),
      showToggleAllButton: !0
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[17]
  ), l = new De({
    props: {
      label: "A5E.contexts.requiresProficiency",
      checked: (
        /*requiresProficiency*/
        i[1]
      )
    }
  }), l.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[18]
  ), o = new de({
    props: {
      $$slots: { default: [SV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment), r = R(), L(o.$$.fragment);
    },
    m(c, u) {
      N(e, c, u), T(c, t, u), N(s, c, u), T(c, n, u), N(l, c, u), T(c, r, u), N(o, c, u), a = !0;
    },
    p(c, u) {
      const d = {};
      u & /*attackTypesContext*/
      8 && (d.selected = /*attackTypesContext*/
      c[3]), e.$set(d);
      const p = {};
      u & /*spellLevelsContext*/
      4 && (p.selected = /*spellLevelsContext*/
      c[2]), s.$set(p);
      const m = {};
      u & /*requiresProficiency*/
      2 && (m.checked = /*requiresProficiency*/
      c[1]), l.$set(m);
      const g = {};
      u & /*$$scope, attackBonus*/
      4194305 && (g.$$scope = { dirty: u, ctx: c }), o.$set(g);
    },
    i(c) {
      a || (w(e.$$.fragment, c), w(s.$$.fragment, c), w(l.$$.fragment, c), w(o.$$.fragment, c), a = !0);
    },
    o(c) {
      C(e.$$.fragment, c), C(s.$$.fragment, c), C(l.$$.fragment, c), C(o.$$.fragment, c), a = !1;
    },
    d(c) {
      c && (S(t), S(n), S(r)), j(e, c), j(s, c), j(l, c), j(o, c);
    }
  };
}
f(TV, "create_default_slot$2g");
function CV(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k;
  return d = new Me({
    props: {
      $$slots: { default: [EV] },
      $$scope: { ctx: i }
    }
  }), g = new Me({
    props: {
      heading: "Contexts",
      hint: "The context determines when the attack bonus applies",
      $$slots: { default: [TV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), p = E("div"), L(d.$$.fragment), m = R(), h = E("div"), L(g.$$.fragment), b(s, "class", "bonus-image svelte-1gxe7tx"), ze(s.src, n = /*attackBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*attackBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*attackBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1gxe7tx"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1gxe7tx"), b(t, "class", "sheet-header svelte-1gxe7tx"), z(p, "display", "contents"), z(p, "--a5e-section-body-direction", "row"), z(p, "--a5e-section-margin", "0.25rem 0"), z(h, "display", "contents"), z(h, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1gxe7tx");
    },
    m(v, O) {
      T(v, e, O), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, u), A(e, p), N(d, p, null), A(e, m), A(e, h), N(g, h, null), _ = !0, y || (k = [
        V(
          s,
          "click",
          /*click_handler*/
          i[13]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[14]
        )
      ], y = !0);
    },
    p(v, [O]) {
      (!_ || O & /*attackBonus*/
      1 && !ze(s.src, n = /*attackBonus*/
      v[0].img)) && b(s, "src", n), (!_ || O & /*attackBonus*/
      1 && l !== (l = /*attackBonus*/
      v[0].label)) && b(s, "alt", l), (!_ || O & /*attackBonus*/
      1 && c !== (c = /*attackBonus*/
      v[0].label ?? "") && a.value !== c) && (a.value = c);
      const P = {};
      O & /*$$scope, attackBonus*/
      4194305 && (P.$$scope = { dirty: O, ctx: v }), d.$set(P);
      const D = {};
      O & /*$$scope, attackBonus, requiresProficiency, spellLevelsContext, attackTypesContext*/
      4194319 && (D.$$scope = { dirty: O, ctx: v }), g.$set(D);
    },
    i(v) {
      _ || (w(d.$$.fragment, v), w(g.$$.fragment, v), _ = !0);
    },
    o(v) {
      C(d.$$.fragment, v), C(g.$$.fragment, v), _ = !1;
    },
    d(v) {
      v && S(e), j(d), j(g), y = !1, Ne(k);
    }
  };
}
f(CV, "create_fragment$48");
function OV(i, e, t) {
  let s, n, l, r, o, { document: a, bonusID: c } = fe("#external").application, { document: u = a, bonusID: d = c } = e, { jsonValue: p = null } = e;
  const m = u;
  pe(i, m, (G) => t(12, o = G));
  const g = it();
  function h() {
    const G = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: G,
      callback: (q) => {
        _("img", q);
      }
    }).browse();
  }
  f(h, "updateImage");
  function _(G, U) {
    if (p === null) {
      G = `system.bonuses.attacks.${d}.${G}`, se(o, G, U);
      return;
    }
    const q = foundry.utils.expandObject({ ...s, [G]: U });
    g("change", JSON.stringify(q));
  }
  f(_, "onUpdateValue");
  function y() {
    if (p === null)
      return o.system.bonuses.attacks[d];
    try {
      const G = JSON.parse(p || '""') ?? {};
      if (typeof G != "object")
        throw new Error();
      return G.label = G.label ?? "", G.formula = G.formula ?? "", G.context = G.context ?? {
        attackTypes: [],
        spellLevels: [],
        requiresProficiency: !1
      }, G.default = G.default ?? !0, G.img = G.img || "icons/svg/upgrade.svg", G;
    } catch {
      return {
        label: "",
        formula: "",
        context: {
          attackTypes: [],
          spellLevels: [],
          requiresProficiency: !1
        },
        default: !0,
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  f(y, "getAttackBonus");
  const { attackTypes: k, spellLevels: v } = CONFIG.A5E, O = /* @__PURE__ */ f(() => h(), "click_handler"), P = /* @__PURE__ */ f(({ target: G }) => _("label", G.value), "change_handler"), D = /* @__PURE__ */ f(({ target: G }) => _("formula", G.value), "change_handler_1"), I = /* @__PURE__ */ f(({ detail: G }) => {
    _("context.attackTypes", G);
  }, "updateSelection_handler"), B = /* @__PURE__ */ f(({ detail: G }) => {
    _("context.spellLevels", G);
  }, "updateSelection_handler_1"), F = /* @__PURE__ */ f(({ detail: G }) => {
    _("context.requiresProficiency", G);
  }, "updateSelection_handler_2"), H = /* @__PURE__ */ f(({ detail: G }) => {
    _("default", G);
  }, "updateSelection_handler_3");
  return i.$$set = (G) => {
    "document" in G && t(9, u = G.document), "bonusID" in G && t(10, d = G.bonusID), "jsonValue" in G && t(11, p = G.jsonValue);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, jsonValue*/
    6144 && t(0, s = y() ?? {}), i.$$.dirty & /*attackBonus*/
    1 && t(3, n = s.context.attackTypes ?? []), i.$$.dirty & /*attackBonus*/
    1 && t(2, l = s.context.spellLevels ?? []), i.$$.dirty & /*attackBonus*/
    1 && t(1, r = s.context.requiresProficiency ?? !1);
  }, [
    s,
    r,
    l,
    n,
    m,
    h,
    _,
    k,
    v,
    u,
    d,
    p,
    o,
    O,
    P,
    D,
    I,
    B,
    F,
    H
  ];
}
f(OV, "instance$3$");
const VA = class VA extends ie {
  constructor(e) {
    super(), le(this, e, OV, CV, ne, { document: 9, bonusID: 10, jsonValue: 11 });
  }
};
f(VA, "AttackBonusConfigDialog");
let zd = VA;
function FD(i, e, t) {
  const s = i.slice();
  return s[26] = e[t][0], s[27] = e[t][1], s;
}
f(FD, "get_each_context$1D");
function DV(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*damageBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[17]
      ), s = !0);
    },
    p(l, r) {
      r & /*damageBonus*/
      1 && t !== (t = /*damageBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(DV, "create_default_slot_4$n");
function ND(i, e) {
  let t, s = K(
    /*name*/
    e[27]
  ) + "", n, l, r;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = x(s), l = R(), t.__value = /*key*/
      e[26], qe(t, t.__value), t.selected = r = /*damageBonus*/
      e[0].damageType === /*key*/
      e[26], this.first = t;
    },
    m(o, a) {
      T(o, t, a), A(t, n), A(t, l);
    },
    p(o, a) {
      e = o, a & /*damageBonus*/
      1 && r !== (r = /*damageBonus*/
      e[0].damageType === /*key*/
      e[26]) && (t.selected = r);
    },
    d(o) {
      o && S(t);
    }
  };
}
f(ND, "create_each_block$1D");
function IV(i) {
  let e, t, s = K("A5E.None") + "", n, l, r, o = [], a = /* @__PURE__ */ new Map(), c, u, d = oe(Object.entries(
    /*damageTypes*/
    i[9]
  ));
  const p = /* @__PURE__ */ f((m) => (
    /*key*/
    m[26]
  ), "get_key");
  for (let m = 0; m < d.length; m += 1) {
    let g = FD(i, d, m), h = p(g);
    a.set(h, o[m] = ND(h, g));
  }
  return {
    c() {
      e = E("select"), t = E("option"), n = x(s), l = R();
      for (let m = 0; m < o.length; m += 1)
        o[m].c();
      t.__value = null, qe(t, t.__value), t.selected = r = /*damageBonus*/
      i[0].damageType === "null" || /*damageBonus*/
      i[0].damageType === null, b(e, "class", "u-w-fit damage-type-select");
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(t, n), A(t, l);
      for (let h = 0; h < o.length; h += 1)
        o[h] && o[h].m(e, null);
      c || (u = V(
        e,
        "change",
        /*change_handler_2*/
        i[18]
      ), c = !0);
    },
    p(m, g) {
      g & /*damageBonus*/
      1 && r !== (r = /*damageBonus*/
      m[0].damageType === "null" || /*damageBonus*/
      m[0].damageType === null) && (t.selected = r), g & /*Object, damageTypes, damageBonus*/
      513 && (d = oe(Object.entries(
        /*damageTypes*/
        m[9]
      )), o = kt(o, g, p, 1, m, d, a, e, vs, ND, null, FD));
    },
    d(m) {
      m && S(e);
      for (let g = 0; g < o.length; g += 1)
        o[g].d();
      c = !1, u();
    }
  };
}
f(IV, "create_default_slot_3$G");
function PV(i) {
  let e, t, s, n, l, r;
  return e = new de({
    props: {
      heading: "A5E.DamageFormula",
      $$slots: { default: [DV] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      heading: "A5E.DamageType",
      $$slots: { default: [IV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), l = E("div"), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-grow", "1"), z(l, "display", "contents"), z(l, "--background", "none"), z(l, "--direction", "column"), z(l, "--padding", "0");
    },
    m(o, a) {
      T(o, t, a), N(e, t, null), T(o, s, a), T(o, l, a), N(n, l, null), r = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$$scope, damageBonus*/
      1073741825 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const u = {};
      a & /*$$scope, damageBonus*/
      1073741825 && (u.$$scope = { dirty: a, ctx: o }), n.$set(u);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(n.$$.fragment, o), r = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(n.$$.fragment, o), r = !1;
    },
    d(o) {
      o && S(s), o && e && S(t), j(e, o), o && n && S(l), j(n, o);
    }
  };
}
f(PV, "create_default_slot_2$Y");
function MV(i) {
  let e, t;
  return e = new De({
    props: {
      label: "Select Damage Bonus Automatically in Roll Prompt",
      checked: (
        /*damageBonus*/
        i[0].default ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[23]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*damageBonus*/
      1 && (l.checked = /*damageBonus*/
      s[0].default ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(MV, "create_default_slot_1$1m");
function RV(i) {
  let e, t, s, n, l, r, o, a, c, u;
  return e = new Ze({
    props: {
      heading: "A5E.contexts.attackType",
      options: Object.entries(
        /*damageBonusContexts*/
        i[8]
      ),
      selected: (
        /*attackTypesContext*/
        i[4]
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[19]
  ), s = new Ze({
    props: {
      heading: "A5E.contexts.damageType",
      options: Object.entries(
        /*damageTypes*/
        i[9]
      ),
      selected: (
        /*damageTypesContext*/
        i[3]
      ),
      showToggleAllButton: !0
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[20]
  ), l = new Ze({
    props: {
      heading: "A5E.contexts.spellLevel",
      options: Object.entries(
        /*spellLevels*/
        i[10]
      ),
      selected: (
        /*spellLevelsContext*/
        i[1]
      ),
      showToggleAllButton: !0
    }
  }), l.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[21]
  ), o = new De({
    props: {
      label: "This bonus only applies to critical hits.",
      checked: (
        /*isCritBonus*/
        i[2]
      )
    }
  }), o.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[22]
  ), c = new de({
    props: {
      $$slots: { default: [MV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment), r = R(), L(o.$$.fragment), a = R(), L(c.$$.fragment);
    },
    m(d, p) {
      N(e, d, p), T(d, t, p), N(s, d, p), T(d, n, p), N(l, d, p), T(d, r, p), N(o, d, p), T(d, a, p), N(c, d, p), u = !0;
    },
    p(d, p) {
      const m = {};
      p & /*attackTypesContext*/
      16 && (m.selected = /*attackTypesContext*/
      d[4]), e.$set(m);
      const g = {};
      p & /*damageTypesContext*/
      8 && (g.selected = /*damageTypesContext*/
      d[3]), s.$set(g);
      const h = {};
      p & /*spellLevelsContext*/
      2 && (h.selected = /*spellLevelsContext*/
      d[1]), l.$set(h);
      const _ = {};
      p & /*isCritBonus*/
      4 && (_.checked = /*isCritBonus*/
      d[2]), o.$set(_);
      const y = {};
      p & /*$$scope, damageBonus*/
      1073741825 && (y.$$scope = { dirty: p, ctx: d }), c.$set(y);
    },
    i(d) {
      u || (w(e.$$.fragment, d), w(s.$$.fragment, d), w(l.$$.fragment, d), w(o.$$.fragment, d), w(c.$$.fragment, d), u = !0);
    },
    o(d) {
      C(e.$$.fragment, d), C(s.$$.fragment, d), C(l.$$.fragment, d), C(o.$$.fragment, d), C(c.$$.fragment, d), u = !1;
    },
    d(d) {
      d && (S(t), S(n), S(r), S(a)), j(e, d), j(s, d), j(l, d), j(o, d), j(c, d);
    }
  };
}
f(RV, "create_default_slot$2f");
function FV(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k;
  return d = new Me({
    props: {
      $$slots: { default: [PV] },
      $$scope: { ctx: i }
    }
  }), g = new Me({
    props: {
      heading: "Contexts",
      hint: "The context determines when the damage bonus applies",
      $$slots: { default: [RV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), p = E("div"), L(d.$$.fragment), m = R(), h = E("div"), L(g.$$.fragment), b(s, "class", "bonus-image svelte-1gxe7tx"), ze(s.src, n = /*damageBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*damageBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*damageBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1gxe7tx"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1gxe7tx"), b(t, "class", "sheet-header svelte-1gxe7tx"), z(p, "display", "contents"), z(p, "--a5e-section-body-direction", "row"), z(p, "--a5e-section-margin", "0.25rem 0"), z(h, "display", "contents"), z(h, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1gxe7tx");
    },
    m(v, O) {
      T(v, e, O), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, u), A(e, p), N(d, p, null), A(e, m), A(e, h), N(g, h, null), _ = !0, y || (k = [
        V(
          s,
          "click",
          /*click_handler*/
          i[15]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[16]
        )
      ], y = !0);
    },
    p(v, [O]) {
      (!_ || O & /*damageBonus*/
      1 && !ze(s.src, n = /*damageBonus*/
      v[0].img)) && b(s, "src", n), (!_ || O & /*damageBonus*/
      1 && l !== (l = /*damageBonus*/
      v[0].label)) && b(s, "alt", l), (!_ || O & /*damageBonus*/
      1 && c !== (c = /*damageBonus*/
      v[0].label ?? "") && a.value !== c) && (a.value = c);
      const P = {};
      O & /*$$scope, damageBonus*/
      1073741825 && (P.$$scope = { dirty: O, ctx: v }), d.$set(P);
      const D = {};
      O & /*$$scope, damageBonus, isCritBonus, spellLevelsContext, damageTypesContext, attackTypesContext*/
      1073741855 && (D.$$scope = { dirty: O, ctx: v }), g.$set(D);
    },
    i(v) {
      _ || (w(d.$$.fragment, v), w(g.$$.fragment, v), _ = !0);
    },
    o(v) {
      C(d.$$.fragment, v), C(g.$$.fragment, v), _ = !1;
    },
    d(v) {
      v && S(e), j(d), j(g), y = !1, Ne(k);
    }
  };
}
f(FV, "create_fragment$47");
function NV(i, e, t) {
  let s, n, l, r, o, a, { document: c, bonusID: u } = fe("#external").application, { document: d = c, bonusID: p = u } = e, { jsonValue: m = null } = e;
  const g = d;
  pe(i, g, (X) => t(14, a = X));
  const h = it();
  function _() {
    const X = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: X,
      callback: (J) => {
        y("img", J);
      }
    }).browse();
  }
  f(_, "updateImage");
  function y(X, te) {
    if (m === null) {
      X = `system.bonuses.damage.${p}.${X}`, se(a, X, te);
      return;
    }
    const J = foundry.utils.expandObject({ ...s, [X]: te });
    h("change", JSON.stringify(J));
  }
  f(y, "onUpdateValue");
  function k() {
    if (m === null)
      return a.system.bonuses.damage[p];
    try {
      const X = JSON.parse(m || '""') ?? {};
      if (typeof X != "object")
        throw new Error();
      return X.label = X.label ?? "", X.formula = X.formula ?? "", X.damageType = X.damageType ?? "", X.context = X.context ?? {
        attackTypes: [],
        damageTypes: [],
        spellLevels: [],
        isCritBonus: !1
      }, X.default = X.default ?? !0, X.img = X.img || "icons/svg/upgrade.svg", X;
    } catch {
      return {
        label: "",
        formula: "",
        damageType: "",
        context: {
          attackTypes: [],
          damageTypes: [],
          spellLevels: [],
          isCritBonus: !1
        },
        default: !0,
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  f(k, "getDamageBonus");
  const { damageBonusContexts: v, damageTypes: O, spellLevels: P } = CONFIG.A5E, D = /* @__PURE__ */ f(() => _(), "click_handler"), I = /* @__PURE__ */ f(({ target: X }) => y("label", X.value), "change_handler"), B = /* @__PURE__ */ f(({ target: X }) => y("formula", X.value), "change_handler_1"), F = /* @__PURE__ */ f(({ target: X }) => y("damageType", X.value), "change_handler_2"), H = /* @__PURE__ */ f(({ detail: X }) => {
    y("context.attackTypes", X);
  }, "updateSelection_handler"), G = /* @__PURE__ */ f(({ detail: X }) => {
    y("context.damageTypes", X);
  }, "updateSelection_handler_1"), U = /* @__PURE__ */ f(({ detail: X }) => {
    y("context.spellLevels", X);
  }, "updateSelection_handler_2"), q = /* @__PURE__ */ f(({ detail: X }) => {
    y("context.isCritBonus", X);
  }, "updateSelection_handler_3"), W = /* @__PURE__ */ f(({ detail: X }) => {
    y("default", X);
  }, "updateSelection_handler_4");
  return i.$$set = (X) => {
    "document" in X && t(11, d = X.document), "bonusID" in X && t(12, p = X.bonusID), "jsonValue" in X && t(13, m = X.jsonValue);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, jsonValue*/
    24576 && t(0, s = k() ?? {}), i.$$.dirty & /*damageBonus*/
    1 && t(4, n = s.context.attackTypes ?? []), i.$$.dirty & /*damageBonus*/
    1 && t(3, l = s.context.damageTypes ?? []), i.$$.dirty & /*damageBonus*/
    1 && t(2, r = s.context.isCritBonus ?? !1), i.$$.dirty & /*damageBonus*/
    1 && t(1, o = s.context.spellLevels ?? []);
  }, [
    s,
    o,
    r,
    l,
    n,
    g,
    _,
    y,
    v,
    O,
    P,
    d,
    p,
    m,
    a,
    D,
    I,
    B,
    F,
    H,
    G,
    U,
    q,
    W
  ];
}
f(NV, "instance$3_");
const WA = class WA extends ie {
  constructor(e) {
    super(), le(this, e, NV, FV, ne, { document: 11, bonusID: 12, jsonValue: 13 });
  }
};
f(WA, "DamageBonusConfigDialog");
let Hd = WA;
function jD(i) {
  let e, t;
  return e = new de({
    props: {
      hint: "A5E.HintSeparateBySemiColon",
      $$slots: { default: [jV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, selectedCustomOptions*/
      4210688 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(jD, "create_if_block$2f");
function jV(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), e.value = t = /*selectedCustomOptions*/
      i[14].join("; ");
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[18]
      ), s = !0);
    },
    p(l, r) {
      r & /*selectedCustomOptions*/
      16384 && t !== (t = /*selectedCustomOptions*/
      l[14].join("; ")) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(jV, "create_default_slot$2e");
function LV(i) {
  let e, t, s, n;
  e = new Ze({
    props: {
      heading: (
        /*heading*/
        i[2]
      ),
      hint: (
        /*hint*/
        i[3]
      ),
      listClasses: (
        /*listClasses*/
        i[4]
      ),
      options: (
        /*options*/
        i[5]
      ),
      optionStyles: (
        /*optionStyles*/
        i[6]
      ),
      orange: (
        /*orange*/
        i[7]
      ),
      red: (
        /*red*/
        i[8]
      ),
      selected: (
        /*selectedCoreOptions*/
        i[15]
      ),
      disabled: (
        /*disabled*/
        i[0]
      ),
      disabledOptions: (
        /*disabledOptions*/
        i[1]
      ),
      showToggleAllButton: (
        /*showToggleAllButton*/
        i[10]
      ),
      showWarning: (
        /*showWarning*/
        i[11]
      ),
      tooltipData: (
        /*tooltipData*/
        i[12]
      ),
      warning: (
        /*warning*/
        i[13]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[17]
  );
  let l = (
    /*showCustomInput*/
    i[9] && jD(i)
  );
  return {
    c() {
      L(e.$$.fragment), t = R(), l && l.c(), s = $e();
    },
    m(r, o) {
      N(e, r, o), T(r, t, o), l && l.m(r, o), T(r, s, o), n = !0;
    },
    p(r, [o]) {
      const a = {};
      o & /*heading*/
      4 && (a.heading = /*heading*/
      r[2]), o & /*hint*/
      8 && (a.hint = /*hint*/
      r[3]), o & /*listClasses*/
      16 && (a.listClasses = /*listClasses*/
      r[4]), o & /*options*/
      32 && (a.options = /*options*/
      r[5]), o & /*optionStyles*/
      64 && (a.optionStyles = /*optionStyles*/
      r[6]), o & /*orange*/
      128 && (a.orange = /*orange*/
      r[7]), o & /*red*/
      256 && (a.red = /*red*/
      r[8]), o & /*selectedCoreOptions*/
      32768 && (a.selected = /*selectedCoreOptions*/
      r[15]), o & /*disabled*/
      1 && (a.disabled = /*disabled*/
      r[0]), o & /*disabledOptions*/
      2 && (a.disabledOptions = /*disabledOptions*/
      r[1]), o & /*showToggleAllButton*/
      1024 && (a.showToggleAllButton = /*showToggleAllButton*/
      r[10]), o & /*showWarning*/
      2048 && (a.showWarning = /*showWarning*/
      r[11]), o & /*tooltipData*/
      4096 && (a.tooltipData = /*tooltipData*/
      r[12]), o & /*warning*/
      8192 && (a.warning = /*warning*/
      r[13]), e.$set(a), /*showCustomInput*/
      r[9] ? l ? (l.p(r, o), o & /*showCustomInput*/
      512 && w(l, 1)) : (l = jD(r), l.c(), w(l, 1), l.m(s.parentNode, s)) : l && (ce(), C(l, 1, 1, () => {
        l = null;
      }), ue());
    },
    i(r) {
      n || (w(e.$$.fragment, r), w(l), n = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(l), n = !1;
    },
    d(r) {
      r && (S(t), S(s)), j(e, r), l && l.d(r);
    }
  };
}
f(LV, "create_fragment$46");
function BV(i) {
  return i.split(";").map((e) => e.trim()).filter(Boolean);
}
f(BV, "splitCustomSelections");
function qV(i, e, t) {
  let s, n, { disabled: l = !1 } = e, { disabledOptions: r = [] } = e, { heading: o = "" } = e, { hint: a = "" } = e, { listClasses: c = "" } = e, { options: u = [] } = e, { optionStyles: d = "" } = e, { orange: p = [] } = e, { red: m = [] } = e, { selected: g = [] } = e, { showCustomInput: h = !0 } = e, { showToggleAllButton: _ = !0 } = e, { showWarning: y = !1 } = e, { tooltipData: k = {} } = e, { warning: v = "" } = e;
  function O() {
    t(16, g = [...s, ...n]), D("updateSelection", g);
  }
  f(O, "updateSelections");
  const P = u.map(([F]) => F), D = it(), I = /* @__PURE__ */ f((F) => t(15, s = F.detail), "updateSelection_handler"), B = /* @__PURE__ */ f(({ target: F }) => {
    t(14, n = BV(F.value));
  }, "change_handler");
  return i.$$set = (F) => {
    "disabled" in F && t(0, l = F.disabled), "disabledOptions" in F && t(1, r = F.disabledOptions), "heading" in F && t(2, o = F.heading), "hint" in F && t(3, a = F.hint), "listClasses" in F && t(4, c = F.listClasses), "options" in F && t(5, u = F.options), "optionStyles" in F && t(6, d = F.optionStyles), "orange" in F && t(7, p = F.orange), "red" in F && t(8, m = F.red), "selected" in F && t(16, g = F.selected), "showCustomInput" in F && t(9, h = F.showCustomInput), "showToggleAllButton" in F && t(10, _ = F.showToggleAllButton), "showWarning" in F && t(11, y = F.showWarning), "tooltipData" in F && t(12, k = F.tooltipData), "warning" in F && t(13, v = F.warning);
  }, i.$$.update = () => {
    i.$$.dirty & /*selected*/
    65536 && t(15, s = g.filter((F) => P.includes(F))), i.$$.dirty & /*selected*/
    65536 && t(14, n = g.filter((F) => !P.includes(F))), i.$$.dirty & /*selectedCoreOptions, selectedCustomOptions*/
    49152 && O();
  }, [
    l,
    r,
    o,
    a,
    c,
    u,
    d,
    p,
    m,
    h,
    _,
    y,
    k,
    v,
    n,
    s,
    g,
    I,
    B
  ];
}
f(qV, "instance$3Z");
const KA = class KA extends ie {
  constructor(e) {
    super(), le(this, e, qV, LV, ne, {
      disabled: 0,
      disabledOptions: 1,
      heading: 2,
      hint: 3,
      listClasses: 4,
      options: 5,
      optionStyles: 6,
      orange: 7,
      red: 8,
      selected: 16,
      showCustomInput: 9,
      showToggleAllButton: 10,
      showWarning: 11,
      tooltipData: 12,
      warning: 13
    });
  }
};
f(KA, "CustomTagGroup");
let Dc = KA;
const { Boolean: GV } = q5;
function LD(i, e, t) {
  const s = i.slice();
  return s[13] = e[t], s;
}
f(LD, "get_each_context$1C");
function zV(i) {
  let e, t;
  function s(...n) {
    return (
      /*updateSelection_handler*/
      i[10](
        /*key*/
        i[13],
        ...n
      )
    );
  }
  return f(s, "updateSelection_handler"), e = new Ze({
    props: {
      heading: (
        /*headings*/
        i[3][
          /*key*/
          i[13]
        ] ?? /*key*/
        i[13]
      ),
      options: Object.entries(
        /*configObject*/
        i[0][
          /*key*/
          i[13]
        ]
      ),
      selected: (
        /*proficiencies*/
        i[6][
          /*key*/
          i[13]
        ]
      ),
      disabled: !!/*max*/
      i[5] && /*existingProperties*/
      i[2].length >= /*max*/
      i[5],
      disabledOptions: (
        /*disabledProperties*/
        i[1]
      ),
      showToggleAllButton: !0
    }
  }), e.$on("updateSelection", s), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      i = n;
      const r = {};
      l & /*headings*/
      8 && (r.heading = /*headings*/
      i[3][
        /*key*/
        i[13]
      ] ?? /*key*/
      i[13]), l & /*configObject*/
      1 && (r.options = Object.entries(
        /*configObject*/
        i[0][
          /*key*/
          i[13]
        ]
      )), l & /*proficiencies*/
      64 && (r.selected = /*proficiencies*/
      i[6][
        /*key*/
        i[13]
      ]), l & /*max, existingProperties*/
      36 && (r.disabled = !!/*max*/
      i[5] && /*existingProperties*/
      i[2].length >= /*max*/
      i[5]), l & /*disabledProperties*/
      2 && (r.disabledOptions = /*disabledProperties*/
      i[1]), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(zV, "create_if_block$2e");
function BD(i) {
  let e, t, s = (
    /*key*/
    i[13] !== "other" && zV(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*key*/
      n[13] !== "other" && s.p(n, l);
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f(BD, "create_each_block$1C");
function HV(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), e.value = t = /*otherProficiencies*/
      i[7] || "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[11]
      ), s = !0);
    },
    p(l, r) {
      r & /*otherProficiencies*/
      128 && t !== (t = /*otherProficiencies*/
      l[7] || "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(HV, "create_default_slot_1$1l");
function UV(i) {
  let e, t, s, n = oe(
    /*configKeys*/
    i[9]
  ), l = [];
  for (let o = 0; o < n.length; o += 1)
    l[o] = BD(LD(i, n, o));
  const r = /* @__PURE__ */ f((o) => C(l[o], 1, 1, () => {
    l[o] = null;
  }), "out");
  return t = new de({
    props: {
      $$slots: { default: [HV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      for (let o = 0; o < l.length; o += 1)
        l[o].c();
      e = R(), L(t.$$.fragment);
    },
    m(o, a) {
      for (let c = 0; c < l.length; c += 1)
        l[c] && l[c].m(o, a);
      T(o, e, a), N(t, o, a), s = !0;
    },
    p(o, a) {
      if (a & /*headings, configKeys, Object, configObject, proficiencies, max, existingProperties, disabledProperties, updateFunction*/
      879) {
        n = oe(
          /*configKeys*/
          o[9]
        );
        let u;
        for (u = 0; u < n.length; u += 1) {
          const d = LD(o, n, u);
          l[u] ? (l[u].p(d, a), w(l[u], 1)) : (l[u] = BD(d), l[u].c(), w(l[u], 1), l[u].m(e.parentNode, e));
        }
        for (ce(), u = n.length; u < l.length; u += 1)
          r(u);
        ue();
      }
      const c = {};
      a & /*$$scope, otherProficiencies*/
      65664 && (c.$$scope = { dirty: a, ctx: o }), t.$set(c);
    },
    i(o) {
      if (!s) {
        for (let a = 0; a < n.length; a += 1)
          w(l[a]);
        w(t.$$.fragment, o), s = !0;
      }
    },
    o(o) {
      l = l.filter(GV);
      for (let a = 0; a < l.length; a += 1)
        C(l[a]);
      C(t.$$.fragment, o), s = !1;
    },
    d(o) {
      o && S(e), Le(l, o), j(t, o);
    }
  };
}
f(UV, "create_default_slot$2d");
function VV(i) {
  let e, t, s;
  return e = new de({
    props: {
      hint: (
        /*hint*/
        i[4]
      ),
      $$slots: { default: [UV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*hint*/
      16 && (r.hint = /*hint*/
      n[4]), l & /*$$scope, otherProficiencies, headings, configObject, proficiencies, max, existingProperties, disabledProperties*/
      65775 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(VV, "create_fragment$45");
function WV(i, e, t) {
  let s, n, { configObject: l = {} } = e, { disabledProperties: r = [] } = e, { existingProperties: o = [] } = e, { headings: a = {} } = e, { hint: c = "" } = e, { max: u = 0 } = e;
  function d() {
    const _ = [
      ...Object.entries(s).reduce(
        (y, [k, v]) => (k === "other" || y.push(...v), y),
        []
      ),
      ...n.split(";").map((y) => y.trim()).filter(Boolean)
    ];
    m("updateSelection", _);
  }
  f(d, "updateFunction");
  const p = [...Object.keys(l), "other"], m = it(), g = /* @__PURE__ */ f((_, { detail: y }) => {
    t(6, s[_] = y, s), d();
  }, "updateSelection_handler"), h = /* @__PURE__ */ f(({ target: _ }) => {
    t(7, n = _.value), d();
  }, "change_handler");
  return i.$$set = (_) => {
    "configObject" in _ && t(0, l = _.configObject), "disabledProperties" in _ && t(1, r = _.disabledProperties), "existingProperties" in _ && t(2, o = _.existingProperties), "headings" in _ && t(3, a = _.headings), "hint" in _ && t(4, c = _.hint), "max" in _ && t(5, u = _.max);
  }, i.$$.update = () => {
    i.$$.dirty & /*existingProperties, configObject*/
    5 && t(6, s = o.reduce(
      (_, y) => {
        let k = !1;
        return p.forEach((v) => {
          var O, P;
          (P = (O = Object.keys((l == null ? void 0 : l[v]) ?? [])).includes) != null && P.call(O, y) && (_[v].push(y), k = !0);
        }), k || _.other.push(y), _;
      },
      Object.fromEntries(p.map((_) => [_, []]))
    )), i.$$.dirty & /*proficiencies*/
    64 && t(7, n = s.other.join("; "));
  }, [
    l,
    r,
    o,
    a,
    c,
    u,
    s,
    n,
    d,
    p,
    g,
    h
  ];
}
f(WV, "instance$3Y");
const YA = class YA extends ie {
  constructor(e) {
    super(), le(this, e, WV, VV, ne, {
      configObject: 0,
      disabledProperties: 1,
      existingProperties: 2,
      headings: 3,
      hint: 4,
      max: 5
    });
  }
};
f(YA, "ComplexDetailEmbed");
let ha = YA;
function KV(i) {
  let e, t;
  return e = new de({
    props: {
      $$slots: { default: [ZV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, heading, selected, tooltipData, $actor, propertyKey*/
      2097269 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(KV, "create_else_block$E");
function YV(i) {
  let e, t;
  return e = new ha({
    props: {
      existingProperties: (
        /*$actor*/
        i[4].system.proficiencies.tools
      ),
      headings: (
        /*toolCategories*/
        i[11]
      ),
      configObject: (
        /*configObject*/
        i[1]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[16]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$actor*/
      16 && (l.existingProperties = /*$actor*/
      s[4].system.proficiencies.tools), n & /*configObject*/
      2 && (l.configObject = /*configObject*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(YV, "create_if_block_4$r");
function XV(i) {
  let e, t;
  return e = new ha({
    props: {
      existingProperties: (
        /*$actor*/
        i[4].system.proficiencies.weapons
      ),
      headings: (
        /*weaponCategories*/
        i[10]
      ),
      configObject: (
        /*configObject*/
        i[1]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[15]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$actor*/
      16 && (l.existingProperties = /*$actor*/
      s[4].system.proficiencies.weapons), n & /*configObject*/
      2 && (l.configObject = /*configObject*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(XV, "create_if_block_3$z");
function JV(i) {
  let e, t;
  return e = new de({
    props: {
      $$slots: { default: [QV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, heading, selected, $actor, propertyKey*/
      2097237 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(JV, "create_if_block_2$T");
function ZV(i) {
  let e, t;
  return e = new Dc({
    props: {
      heading: (
        /*heading*/
        i[2]
      ),
      options: (
        /*options*/
        i[8]
      ),
      selected: (
        /*selected*/
        i[6]
      ),
      tooltipData: (
        /*tooltipData*/
        i[5]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[17]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*heading*/
      4 && (l.heading = /*heading*/
      s[2]), n & /*selected*/
      64 && (l.selected = /*selected*/
      s[6]), n & /*tooltipData*/
      32 && (l.tooltipData = /*tooltipData*/
      s[5]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(ZV, "create_default_slot_3$F");
function QV(i) {
  let e, t;
  return e = new Ye({
    props: {
      heading: (
        /*heading*/
        i[2]
      ),
      options: (
        /*options*/
        i[8]
      ),
      selected: (
        /*selected*/
        i[6]
      ),
      allowDeselect: !1
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[14]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*heading*/
      4 && (l.heading = /*heading*/
      s[2]), n & /*selected*/
      64 && (l.selected = /*selected*/
      s[6]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(QV, "create_default_slot_2$X");
function qD(i) {
  let e, t;
  return e = new de({
    props: {
      $$slots: { default: [xV] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $actor*/
      2097168 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(qD, "create_if_block$2d");
function GD(i) {
  let e, t;
  return e = new De({
    props: {
      label: "Squad",
      checked: (
        /*$actor*/
        i[4].system.details.isSquad
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[18]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$actor*/
      16 && (l.checked = /*$actor*/
      s[4].system.details.isSquad), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(GD, "create_if_block_1$1s");
function xV(i) {
  let e, t, s, n = (
    /*$actor*/
    i[4].type === "npc" && GD(i)
  );
  return t = new De({
    props: {
      label: "A5E.CreatureSwarm",
      checked: (
        /*$actor*/
        i[4].system.details.isSwarm
      )
    }
  }), t.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[19]
  ), {
    c() {
      n && n.c(), e = R(), L(t.$$.fragment);
    },
    m(l, r) {
      n && n.m(l, r), T(l, e, r), N(t, l, r), s = !0;
    },
    p(l, r) {
      /*$actor*/
      l[4].type === "npc" ? n ? (n.p(l, r), r & /*$actor*/
      16 && w(n, 1)) : (n = GD(l), n.c(), w(n, 1), n.m(e.parentNode, e)) : n && (ce(), C(n, 1, 1, () => {
        n = null;
      }), ue());
      const o = {};
      r & /*$actor*/
      16 && (o.checked = /*$actor*/
      l[4].system.details.isSwarm), t.$set(o);
    },
    i(l) {
      s || (w(n), w(t.$$.fragment, l), s = !0);
    },
    o(l) {
      C(n), C(t.$$.fragment, l), s = !1;
    },
    d(l) {
      l && S(e), n && n.d(l), j(t, l);
    }
  };
}
f(xV, "create_default_slot_1$1k");
function eW(i) {
  let e, t, s, n, l;
  const r = [JV, XV, YV, KV], o = [];
  function a(u, d) {
    return (
      /*isRadioGroup*/
      u[9] ? 0 : (
        /*type*/
        u[3] === "weapons" ? 1 : (
          /*type*/
          u[3] === "tools" ? 2 : 3
        )
      )
    );
  }
  f(a, "select_block_type"), e = a(i), t = o[e] = r[e](i);
  let c = (
    /*type*/
    i[3] === "creatureTypes" && qD(i)
  );
  return {
    c() {
      t.c(), s = R(), c && c.c(), n = $e();
    },
    m(u, d) {
      o[e].m(u, d), T(u, s, d), c && c.m(u, d), T(u, n, d), l = !0;
    },
    p(u, d) {
      let p = e;
      e = a(u), e === p ? o[e].p(u, d) : (ce(), C(o[p], 1, 1, () => {
        o[p] = null;
      }), ue(), t = o[e], t ? t.p(u, d) : (t = o[e] = r[e](u), t.c()), w(t, 1), t.m(s.parentNode, s)), /*type*/
      u[3] === "creatureTypes" ? c ? (c.p(u, d), d & /*type*/
      8 && w(c, 1)) : (c = qD(u), c.c(), w(c, 1), c.m(n.parentNode, n)) : c && (ce(), C(c, 1, 1, () => {
        c = null;
      }), ue());
    },
    i(u) {
      l || (w(t), w(c), l = !0);
    },
    o(u) {
      C(t), C(c), l = !1;
    },
    d(u) {
      u && (S(s), S(n)), o[e].d(u), c && c.d(u);
    }
  };
}
f(eW, "create_default_slot$2c");
function tW(i) {
  let e, t, s;
  return e = new Me({
    props: {
      $$slots: { default: [eW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-padding", "0.75rem"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, $actor, type, heading, selected, propertyKey, configObject, tooltipData*/
      2097279 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(tW, "create_fragment$44");
function sW(i, e, t) {
  let s, n, l, { document: r, appId: o, propertyKey: a, configObject: c, heading: u, type: d } = fe("#external").application, { document: p = r, appId: m = o, propertyKey: g = a, configObject: h = c, heading: _ = u, type: y = d } = e;
  function k() {
    const W = l.grants.getGrantedTraits(y), X = {};
    for (const te of Object.values(W))
      te.traits.forEach((J) => {
        var ae;
        const re = (ae = fromUuidSync(te.itemId)) == null ? void 0 : ae.name;
        X[J] = `Granted by ${re}`;
      });
    return X;
  }
  f(k, "getTooltipData");
  const v = p;
  pe(i, v, (W) => t(4, l = W));
  const O = Object.entries(h), P = ["size"].includes(y), { weaponCategories: D, toolCategories: I } = CONFIG.A5E, B = /* @__PURE__ */ f((W) => se(l, g, W.detail), "updateSelection_handler"), F = /* @__PURE__ */ f((W) => se(l, g, W.detail), "updateSelection_handler_1"), H = /* @__PURE__ */ f((W) => se(l, g, W.detail), "updateSelection_handler_2"), G = /* @__PURE__ */ f((W) => se(l, g, W.detail), "updateSelection_handler_3"), U = /* @__PURE__ */ f(({ detail: W }) => {
    se(l, "system.details.isSquad", W);
  }, "updateSelection_handler_4"), q = /* @__PURE__ */ f(({ detail: W }) => {
    se(l, "system.details.isSwarm", W);
  }, "updateSelection_handler_5");
  return i.$$set = (W) => {
    "document" in W && t(12, p = W.document), "appId" in W && t(13, m = W.appId), "propertyKey" in W && t(0, g = W.propertyKey), "configObject" in W && t(1, h = W.configObject), "heading" in W && t(2, _ = W.heading), "type" in W && t(3, y = W.type);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, propertyKey*/
    17 && t(6, s = foundry.utils.getProperty(l, g)), i.$$.dirty & /*$actor*/
    16 && t(5, n = k());
  }, [
    g,
    h,
    _,
    y,
    l,
    n,
    s,
    v,
    O,
    P,
    D,
    I,
    p,
    m,
    B,
    F,
    H,
    G,
    U,
    q
  ];
}
f(sW, "instance$3X");
const XA = class XA extends ie {
  constructor(e) {
    super(), le(this, e, sW, tW, ne, {
      document: 12,
      appId: 13,
      propertyKey: 0,
      configObject: 1,
      heading: 2,
      type: 3
    });
  }
};
f(XA, "DetailsConfigDialog");
let ws = XA;
function nW(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*exertionBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      r & /*exertionBonus*/
      1 && t !== (t = /*exertionBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(nW, "create_default_slot_1$1j");
function iW(i) {
  let e, t;
  return e = new de({
    props: {
      heading: "A5E.Formula",
      $$slots: { default: [nW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, exertionBonus*/
      8193 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(iW, "create_default_slot$2b");
function lW(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h;
  return d = new Me({
    props: {
      $$slots: { default: [iW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), p = E("div"), L(d.$$.fragment), b(s, "class", "bonus-image svelte-1gxe7tx"), ze(s.src, n = /*exertionBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*exertionBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*exertionBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1gxe7tx"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1gxe7tx"), b(t, "class", "sheet-header svelte-1gxe7tx"), z(p, "display", "contents"), z(p, "--a5e-section-margin", "0.25rem 0"), b(e, "class", "svelte-1gxe7tx");
    },
    m(_, y) {
      T(_, e, y), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, u), A(e, p), N(d, p, null), m = !0, g || (h = [
        V(
          s,
          "click",
          /*click_handler*/
          i[8]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[9]
        )
      ], g = !0);
    },
    p(_, [y]) {
      (!m || y & /*exertionBonus*/
      1 && !ze(s.src, n = /*exertionBonus*/
      _[0].img)) && b(s, "src", n), (!m || y & /*exertionBonus*/
      1 && l !== (l = /*exertionBonus*/
      _[0].label)) && b(s, "alt", l), (!m || y & /*exertionBonus*/
      1 && c !== (c = /*exertionBonus*/
      _[0].label ?? "") && a.value !== c) && (a.value = c);
      const k = {};
      y & /*$$scope, exertionBonus*/
      8193 && (k.$$scope = { dirty: y, ctx: _ }), d.$set(k);
    },
    i(_) {
      m || (w(d.$$.fragment, _), m = !0);
    },
    o(_) {
      C(d.$$.fragment, _), m = !1;
    },
    d(_) {
      _ && S(e), j(d), g = !1, Ne(h);
    }
  };
}
f(lW, "create_fragment$43");
function rW(i, e, t) {
  let s, n, { document: l, bonusID: r } = fe("#external").application, { document: o = l, bonusID: a = r } = e, { jsonValue: c = null } = e;
  const u = o;
  pe(i, u, (k) => t(7, n = k));
  const d = it();
  function p() {
    const k = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: k,
      callback: (O) => {
        m("img", O);
      }
    }).browse();
  }
  f(p, "updateImage");
  function m(k, v) {
    if (c === null) {
      k = `system.bonuses.exertion.${a}.${k}`, se(n, k, v);
      return;
    }
    const O = foundry.utils.expandObject({ ...s, [k]: v });
    d("change", JSON.stringify(O));
  }
  f(m, "onUpdateValue");
  function g() {
    if (c === null)
      return n.system.bonuses.exertion[a];
    try {
      const k = JSON.parse(c || '""') ?? {};
      if (typeof k != "object")
        throw new Error();
      return k.label = k.label ?? "", k.formula = k.formula ?? "", k.img = k.img || "icons/svg/upgrade.svg", k;
    } catch {
      return {
        label: "",
        formula: "",
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  f(g, "getExertionBonus");
  const h = /* @__PURE__ */ f(() => p(), "click_handler"), _ = /* @__PURE__ */ f(({ target: k }) => m("label", k.value), "change_handler"), y = /* @__PURE__ */ f(({ target: k }) => m("formula", k.value), "change_handler_1");
  return i.$$set = (k) => {
    "document" in k && t(4, o = k.document), "bonusID" in k && t(5, a = k.bonusID), "jsonValue" in k && t(6, c = k.jsonValue);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, jsonValue*/
    192 && t(0, s = g() ?? {});
  }, [
    s,
    u,
    p,
    m,
    o,
    a,
    c,
    n,
    h,
    _,
    y
  ];
}
f(rW, "instance$3W");
const JA = class JA extends ie {
  constructor(e) {
    super(), le(this, e, rW, lW, ne, { document: 4, bonusID: 5, jsonValue: 6 });
  }
};
f(JA, "ExertionBonusConfigDialog");
let oy = JA;
function oW(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*initiativeBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[14]
      ), s = !0);
    },
    p(l, r) {
      r & /*initiativeBonus*/
      1 && t !== (t = /*initiativeBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(oW, "create_default_slot_3$E");
function aW(i) {
  let e, t;
  return e = new de({
    props: {
      heading: "A5E.Formula",
      $$slots: { default: [oW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, initiativeBonus*/
      1048577 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(aW, "create_default_slot_2$W");
function cW(i) {
  let e, t;
  return e = new De({
    props: {
      label: "Select Ability Bonus Automatically in Roll Prompt",
      checked: (
        /*initiativeBonus*/
        i[0].default ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[17]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*initiativeBonus*/
      1 && (l.checked = /*initiativeBonus*/
      s[0].default ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(cW, "create_default_slot_1$1i");
function uW(i) {
  let e, t, s, n, l, r;
  return e = new Ze({
    props: {
      heading: "A5E.contexts.abilities",
      options: Object.entries(
        /*abilities*/
        i[6]
      ),
      selected: (
        /*abilitiesContext*/
        i[2]
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[15]
  ), s = new Ze({
    props: {
      heading: "A5E.contexts.skills",
      options: Object.entries(
        /*skills*/
        i[7]
      ),
      selected: (
        /*skillsContext*/
        i[1]
      ),
      showToggleAllButton: !0
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[16]
  ), l = new de({
    props: {
      $$slots: { default: [cW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment);
    },
    m(o, a) {
      N(e, o, a), T(o, t, a), N(s, o, a), T(o, n, a), N(l, o, a), r = !0;
    },
    p(o, a) {
      const c = {};
      a & /*abilitiesContext*/
      4 && (c.selected = /*abilitiesContext*/
      o[2]), e.$set(c);
      const u = {};
      a & /*skillsContext*/
      2 && (u.selected = /*skillsContext*/
      o[1]), s.$set(u);
      const d = {};
      a & /*$$scope, initiativeBonus*/
      1048577 && (d.$$scope = { dirty: a, ctx: o }), l.$set(d);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(s.$$.fragment, o), C(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (S(t), S(n)), j(e, o), j(s, o), j(l, o);
    }
  };
}
f(uW, "create_default_slot$2a");
function fW(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k;
  return d = new Me({
    props: {
      $$slots: { default: [aW] },
      $$scope: { ctx: i }
    }
  }), g = new Me({
    props: {
      heading: "Contexts",
      hint: "The context determines when the ability bonus applies",
      $$slots: { default: [uW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), p = E("div"), L(d.$$.fragment), m = R(), h = E("div"), L(g.$$.fragment), b(s, "class", "bonus-image svelte-1gxe7tx"), ze(s.src, n = /*initiativeBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*initiativeBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*initiativeBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1gxe7tx"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1gxe7tx"), b(t, "class", "sheet-header svelte-1gxe7tx"), z(p, "display", "contents"), z(p, "--a5e-section-margin", "0.25rem 0"), z(h, "display", "contents"), z(h, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1gxe7tx");
    },
    m(v, O) {
      T(v, e, O), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, u), A(e, p), N(d, p, null), A(e, m), A(e, h), N(g, h, null), _ = !0, y || (k = [
        V(
          s,
          "click",
          /*click_handler*/
          i[12]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[13]
        )
      ], y = !0);
    },
    p(v, [O]) {
      (!_ || O & /*initiativeBonus*/
      1 && !ze(s.src, n = /*initiativeBonus*/
      v[0].img)) && b(s, "src", n), (!_ || O & /*initiativeBonus*/
      1 && l !== (l = /*initiativeBonus*/
      v[0].label)) && b(s, "alt", l), (!_ || O & /*initiativeBonus*/
      1 && c !== (c = /*initiativeBonus*/
      v[0].label ?? "") && a.value !== c) && (a.value = c);
      const P = {};
      O & /*$$scope, initiativeBonus*/
      1048577 && (P.$$scope = { dirty: O, ctx: v }), d.$set(P);
      const D = {};
      O & /*$$scope, initiativeBonus, skillsContext, abilitiesContext*/
      1048583 && (D.$$scope = { dirty: O, ctx: v }), g.$set(D);
    },
    i(v) {
      _ || (w(d.$$.fragment, v), w(g.$$.fragment, v), _ = !0);
    },
    o(v) {
      C(d.$$.fragment, v), C(g.$$.fragment, v), _ = !1;
    },
    d(v) {
      v && S(e), j(d), j(g), y = !1, Ne(k);
    }
  };
}
f(fW, "create_fragment$42");
function dW(i, e, t) {
  let s, n, l, r, { document: o, bonusID: a } = fe("#external").application, { document: c = o, bonusID: u = a } = e, { jsonValue: d = null } = e;
  const p = c;
  pe(i, p, (F) => t(11, r = F));
  const m = it();
  function g() {
    const F = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: F,
      callback: (G) => {
        h("img", G);
      }
    }).browse();
  }
  f(g, "updateImage");
  function h(F, H) {
    if (d === null) {
      F = `system.bonuses.initiative.${u}.${F}`, se(r, F, H);
      return;
    }
    const G = foundry.utils.expandObject({ ...s, [F]: H });
    m("change", JSON.stringify(G));
  }
  f(h, "onUpdateValue");
  function _() {
    if (d === null)
      return r.system.bonuses.initiative[u];
    try {
      const F = JSON.parse(d || '""') ?? {};
      if (typeof F != "object")
        throw new Error();
      return F.label = F.label ?? "", F.formula = F.formula ?? "", F.context = F.context ?? {
        abilities: Object.keys(CONFIG.A5E.abilities),
        skills: Object.keys(CONFIG.A5E.skills)
      }, F.default = F.default ?? !0, F.img = F.img || "icons/svg/upgrade.svg", F;
    } catch {
      return {
        label: "",
        formula: "",
        damageType: "",
        context: {
          abilities: Object.keys(CONFIG.A5E.abilities),
          skills: Object.keys(CONFIG.A5E.skills)
        },
        default: !0,
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  f(_, "getAbilityBonus");
  const { abilities: y, skills: k } = CONFIG.A5E, v = /* @__PURE__ */ f(() => g(), "click_handler"), O = /* @__PURE__ */ f(({ target: F }) => h("label", F.value), "change_handler"), P = /* @__PURE__ */ f(({ target: F }) => h("formula", F.value), "change_handler_1"), D = /* @__PURE__ */ f(({ detail: F }) => {
    h("context.abilities", F);
  }, "updateSelection_handler"), I = /* @__PURE__ */ f(({ detail: F }) => {
    h("context.skills", F);
  }, "updateSelection_handler_1"), B = /* @__PURE__ */ f(({ detail: F }) => {
    h("default", F);
  }, "updateSelection_handler_2");
  return i.$$set = (F) => {
    "document" in F && t(8, c = F.document), "bonusID" in F && t(9, u = F.bonusID), "jsonValue" in F && t(10, d = F.jsonValue);
  }, i.$$.update = () => {
    var F, H;
    i.$$.dirty & /*$actor, jsonValue*/
    3072 && t(0, s = _() ?? {}), i.$$.dirty & /*initiativeBonus*/
    1 && t(2, n = ((F = s.context) == null ? void 0 : F.abilities) ?? []), i.$$.dirty & /*initiativeBonus*/
    1 && t(1, l = ((H = s.context) == null ? void 0 : H.skills) ?? []);
  }, [
    s,
    l,
    n,
    p,
    g,
    h,
    y,
    k,
    c,
    u,
    d,
    r,
    v,
    O,
    P,
    D,
    I,
    B
  ];
}
f(dW, "instance$3V");
const ZA = class ZA extends ie {
  constructor(e) {
    super(), le(this, e, dW, fW, ne, { document: 8, bonusID: 9, jsonValue: 10 });
  }
};
f(ZA, "InitiativeBonusConfigDialog");
let Ud = ZA;
function zD(i, e, t) {
  const s = i.slice();
  return s[22] = e[t][0], s[23] = e[t][1], s;
}
f(zD, "get_each_context$1B");
function pW(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*healingBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      r & /*healingBonus*/
      1 && t !== (t = /*healingBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(pW, "create_default_slot_4$m");
function HD(i, e) {
  let t, s = K(
    /*name*/
    e[23]
  ) + "", n, l, r;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = x(s), l = R(), t.__value = /*key*/
      e[22], qe(t, t.__value), t.selected = r = /*healingBonus*/
      e[0].healingType === /*key*/
      e[22], this.first = t;
    },
    m(o, a) {
      T(o, t, a), A(t, n), A(t, l);
    },
    p(o, a) {
      e = o, a & /*healingBonus*/
      1 && r !== (r = /*healingBonus*/
      e[0].healingType === /*key*/
      e[22]) && (t.selected = r);
    },
    d(o) {
      o && S(t);
    }
  };
}
f(HD, "create_each_block$1B");
function mW(i) {
  let e, t, s = K("A5E.None") + "", n, l, r, o = [], a = /* @__PURE__ */ new Map(), c, u, d = oe(Object.entries(
    /*healingTypes*/
    i[7]
  ));
  const p = /* @__PURE__ */ f((m) => (
    /*key*/
    m[22]
  ), "get_key");
  for (let m = 0; m < d.length; m += 1) {
    let g = zD(i, d, m), h = p(g);
    a.set(h, o[m] = HD(h, g));
  }
  return {
    c() {
      e = E("select"), t = E("option"), n = x(s), l = R();
      for (let m = 0; m < o.length; m += 1)
        o[m].c();
      t.__value = null, qe(t, t.__value), t.selected = r = /*healingBonus*/
      i[0].healingType === "null" || /*healingBonus*/
      i[0].healingType === null, b(e, "class", "u-w-fit healing-type-select");
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(t, n), A(t, l);
      for (let h = 0; h < o.length; h += 1)
        o[h] && o[h].m(e, null);
      c || (u = V(
        e,
        "change",
        /*change_handler_2*/
        i[16]
      ), c = !0);
    },
    p(m, g) {
      g & /*healingBonus*/
      1 && r !== (r = /*healingBonus*/
      m[0].healingType === "null" || /*healingBonus*/
      m[0].healingType === null) && (t.selected = r), g & /*Object, healingTypes, healingBonus*/
      129 && (d = oe(Object.entries(
        /*healingTypes*/
        m[7]
      )), o = kt(o, g, p, 1, m, d, a, e, vs, HD, null, zD));
    },
    d(m) {
      m && S(e);
      for (let g = 0; g < o.length; g += 1)
        o[g].d();
      c = !1, u();
    }
  };
}
f(mW, "create_default_slot_3$D");
function hW(i) {
  let e, t, s, n, l;
  return e = new de({
    props: {
      heading: "A5E.HealingFormula",
      $$slots: { default: [pW] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      heading: "A5E.HealingType",
      $$slots: { default: [mW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-grow", "1");
    },
    m(r, o) {
      T(r, t, o), N(e, t, null), T(r, s, o), N(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*$$scope, healingBonus*/
      67108865 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, healingBonus*/
      67108865 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && S(s), r && e && S(t), j(e, r), j(n, r);
    }
  };
}
f(hW, "create_default_slot_2$V");
function gW(i) {
  let e, t;
  return e = new De({
    props: {
      label: "Select Healing Bonus Automatically in Roll Prompt",
      checked: (
        /*healingBonus*/
        i[0].default ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[19]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*healingBonus*/
      1 && (l.checked = /*healingBonus*/
      s[0].default ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(gW, "create_default_slot_1$1h");
function bW(i) {
  let e, t, s, n, l, r;
  return e = new Ze({
    props: {
      heading: "A5E.contexts.healingType",
      options: Object.entries(
        /*healingBonusContexts*/
        i[6]
      ),
      selected: (
        /*healingTypesContext*/
        i[2]
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[17]
  ), s = new Ze({
    props: {
      heading: "A5E.contexts.spellLevel",
      options: Object.entries(
        /*spellLevels*/
        i[8]
      ),
      selected: (
        /*spellLevelsContext*/
        i[1]
      ),
      showToggleAllButton: !0
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[18]
  ), l = new de({
    props: {
      $$slots: { default: [gW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment);
    },
    m(o, a) {
      N(e, o, a), T(o, t, a), N(s, o, a), T(o, n, a), N(l, o, a), r = !0;
    },
    p(o, a) {
      const c = {};
      a & /*healingTypesContext*/
      4 && (c.selected = /*healingTypesContext*/
      o[2]), e.$set(c);
      const u = {};
      a & /*spellLevelsContext*/
      2 && (u.selected = /*spellLevelsContext*/
      o[1]), s.$set(u);
      const d = {};
      a & /*$$scope, healingBonus*/
      67108865 && (d.$$scope = { dirty: a, ctx: o }), l.$set(d);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(s.$$.fragment, o), C(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (S(t), S(n)), j(e, o), j(s, o), j(l, o);
    }
  };
}
f(bW, "create_default_slot$29");
function _W(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k;
  return d = new Me({
    props: {
      $$slots: { default: [hW] },
      $$scope: { ctx: i }
    }
  }), g = new Me({
    props: {
      heading: "Contexts",
      hint: "The context determines when the healing bonus applies",
      $$slots: { default: [bW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), p = E("div"), L(d.$$.fragment), m = R(), h = E("div"), L(g.$$.fragment), b(s, "class", "bonus-image svelte-1gxe7tx"), ze(s.src, n = /*healingBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*healingBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*healingBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1gxe7tx"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1gxe7tx"), b(t, "class", "sheet-header svelte-1gxe7tx"), z(p, "display", "contents"), z(p, "--a5e-section-body-direction", "row"), z(p, "--a5e-section-margin", "0.25rem 0"), z(h, "display", "contents"), z(h, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1gxe7tx");
    },
    m(v, O) {
      T(v, e, O), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, u), A(e, p), N(d, p, null), A(e, m), A(e, h), N(g, h, null), _ = !0, y || (k = [
        V(
          s,
          "click",
          /*click_handler*/
          i[13]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[14]
        )
      ], y = !0);
    },
    p(v, [O]) {
      (!_ || O & /*healingBonus*/
      1 && !ze(s.src, n = /*healingBonus*/
      v[0].img)) && b(s, "src", n), (!_ || O & /*healingBonus*/
      1 && l !== (l = /*healingBonus*/
      v[0].label)) && b(s, "alt", l), (!_ || O & /*healingBonus*/
      1 && c !== (c = /*healingBonus*/
      v[0].label ?? "") && a.value !== c) && (a.value = c);
      const P = {};
      O & /*$$scope, healingBonus*/
      67108865 && (P.$$scope = { dirty: O, ctx: v }), d.$set(P);
      const D = {};
      O & /*$$scope, healingBonus, spellLevelsContext, healingTypesContext*/
      67108871 && (D.$$scope = { dirty: O, ctx: v }), g.$set(D);
    },
    i(v) {
      _ || (w(d.$$.fragment, v), w(g.$$.fragment, v), _ = !0);
    },
    o(v) {
      C(d.$$.fragment, v), C(g.$$.fragment, v), _ = !1;
    },
    d(v) {
      v && S(e), j(d), j(g), y = !1, Ne(k);
    }
  };
}
f(_W, "create_fragment$41");
function yW(i, e, t) {
  let s, n, l, r, { document: o, bonusID: a } = fe("#external").application, { document: c = o, bonusID: u = a } = e, { jsonValue: d = null } = e;
  const p = c;
  pe(i, p, (G) => t(12, r = G));
  const m = it();
  function g() {
    const G = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: G,
      callback: (q) => {
        h("img", q);
      }
    }).browse();
  }
  f(g, "updateImage");
  function h(G, U) {
    if (d === null) {
      G = `system.bonuses.healing.${u}.${G}`, se(r, G, U);
      return;
    }
    const q = foundry.utils.expandObject({ ...s, [G]: U });
    m("change", JSON.stringify(q));
  }
  f(h, "onUpdateValue");
  function _() {
    if (d === null)
      return r.system.bonuses.healing[u];
    try {
      const G = JSON.parse(d || '""') ?? {};
      if (typeof G != "object")
        throw new Error();
      return G.label = G.label ?? "", G.formula = G.formula ?? "", G.healingType = G.healingType ?? "", G.context = G.context ?? { healingTypes: [], spellLevels: [] }, G.default = G.default ?? !0, G.img = G.img || "icons/svg/upgrade.svg", G;
    } catch {
      return {
        label: "",
        formula: "",
        healingType: "",
        context: { healingTypes: [], spellLevels: [] },
        default: !0,
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  f(_, "getHealingBonus");
  const { healingBonusContexts: y, healingTypes: k, spellLevels: v } = CONFIG.A5E, O = /* @__PURE__ */ f(() => g(), "click_handler"), P = /* @__PURE__ */ f(({ target: G }) => h("label", G.value), "change_handler"), D = /* @__PURE__ */ f(({ target: G }) => h("formula", G.value), "change_handler_1"), I = /* @__PURE__ */ f(({ target: G }) => h("healingType", G.value), "change_handler_2"), B = /* @__PURE__ */ f(({ detail: G }) => h("context.healingTypes", G), "updateSelection_handler"), F = /* @__PURE__ */ f(({ detail: G }) => h("context.spellLevels", G), "updateSelection_handler_1"), H = /* @__PURE__ */ f(({ detail: G }) => {
    h("default", G);
  }, "updateSelection_handler_2");
  return i.$$set = (G) => {
    "document" in G && t(9, c = G.document), "bonusID" in G && t(10, u = G.bonusID), "jsonValue" in G && t(11, d = G.jsonValue);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, jsonValue*/
    6144 && t(0, s = _() ?? {}), i.$$.dirty & /*healingBonus*/
    1 && t(2, n = s.context.healingTypes ?? []), i.$$.dirty & /*healingBonus*/
    1 && t(1, l = s.context.spellLevels ?? []);
  }, [
    s,
    l,
    n,
    p,
    g,
    h,
    y,
    k,
    v,
    c,
    u,
    d,
    r,
    O,
    P,
    D,
    I,
    B,
    F,
    H
  ];
}
f(yW, "instance$3U");
const QA = class QA extends ie {
  constructor(e) {
    super(), le(this, e, yW, _W, ne, { document: 9, bonusID: 10, jsonValue: 11 });
  }
};
f(QA, "HealingBonusConfigDialog");
let Vd = QA;
function vW(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*hitPointsBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      r & /*hitPointsBonus*/
      1 && t !== (t = /*hitPointsBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(vW, "create_default_slot_3$C");
function kW(i) {
  let e, t, s;
  return e = new de({
    props: {
      heading: "Hit Points Formula",
      $$slots: { default: [vW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-grow", "1");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, hitPointsBonus*/
      16385 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(kW, "create_default_slot_2$U");
function wW(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "Apply Healing Bonus Every Level",
      checked: (
        /*hitPointsBonus*/
        ((s = i[0].context) == null ? void 0 : s.perLevel) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[11]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*hitPointsBonus*/
      1 && (r.checked = /*hitPointsBonus*/
      ((o = n[0].context) == null ? void 0 : o.perLevel) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(wW, "create_default_slot_1$1g");
function $W(i) {
  let e, t;
  return e = new de({
    props: {
      $$slots: { default: [wW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, hitPointsBonus*/
      16385 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f($W, "create_default_slot$28");
function AW(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k;
  return d = new Me({
    props: {
      $$slots: { default: [kW] },
      $$scope: { ctx: i }
    }
  }), g = new Me({
    props: {
      heading: "Contexts",
      hint: "The context determines when the healing bonus applies",
      $$slots: { default: [$W] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), p = E("div"), L(d.$$.fragment), m = R(), h = E("div"), L(g.$$.fragment), b(s, "class", "bonus-image svelte-1gxe7tx"), ze(s.src, n = /*hitPointsBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*hitPointsBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*hitPointsBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1gxe7tx"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1gxe7tx"), b(t, "class", "sheet-header svelte-1gxe7tx"), z(p, "display", "contents"), z(p, "--a5e-section-margin", "0.25rem 0"), z(h, "display", "contents"), z(h, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1gxe7tx");
    },
    m(v, O) {
      T(v, e, O), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, u), A(e, p), N(d, p, null), A(e, m), A(e, h), N(g, h, null), _ = !0, y || (k = [
        V(
          s,
          "click",
          /*click_handler*/
          i[8]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[9]
        )
      ], y = !0);
    },
    p(v, [O]) {
      (!_ || O & /*hitPointsBonus*/
      1 && !ze(s.src, n = /*hitPointsBonus*/
      v[0].img)) && b(s, "src", n), (!_ || O & /*hitPointsBonus*/
      1 && l !== (l = /*hitPointsBonus*/
      v[0].label)) && b(s, "alt", l), (!_ || O & /*hitPointsBonus*/
      1 && c !== (c = /*hitPointsBonus*/
      v[0].label ?? "") && a.value !== c) && (a.value = c);
      const P = {};
      O & /*$$scope, hitPointsBonus*/
      16385 && (P.$$scope = { dirty: O, ctx: v }), d.$set(P);
      const D = {};
      O & /*$$scope, hitPointsBonus*/
      16385 && (D.$$scope = { dirty: O, ctx: v }), g.$set(D);
    },
    i(v) {
      _ || (w(d.$$.fragment, v), w(g.$$.fragment, v), _ = !0);
    },
    o(v) {
      C(d.$$.fragment, v), C(g.$$.fragment, v), _ = !1;
    },
    d(v) {
      v && S(e), j(d), j(g), y = !1, Ne(k);
    }
  };
}
f(AW, "create_fragment$40");
function EW(i, e, t) {
  let s, n, { document: l, bonusID: r } = fe("#external").application, { document: o = l, bonusID: a = r } = e, { jsonValue: c = null } = e;
  const u = o;
  pe(i, u, (v) => t(7, n = v));
  const d = it();
  function p() {
    const v = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: v,
      callback: (P) => {
        m("img", P);
      }
    }).browse();
  }
  f(p, "updateImage");
  function m(v, O) {
    if (c === null) {
      v = `system.bonuses.hitPoint.${a}.${v}`, se(n, v, O);
      return;
    }
    const P = foundry.utils.expandObject({ ...s, [v]: O });
    d("change", JSON.stringify(P));
  }
  f(m, "onUpdateValue");
  function g() {
    if (c === null)
      return n.system.bonuses.hitPoint[a];
    try {
      const v = JSON.parse(c || '""') ?? {};
      if (typeof v != "object")
        throw new Error();
      return v.label = v.label ?? "", v.formula = v.formula ?? "", v.context = v.context ?? { perLevel: !1 }, v.default = v.default ?? !0, v.img = v.img || "icons/svg/upgrade.svg", v;
    } catch {
      return {
        label: "",
        formula: "",
        context: { perLevel: !1 },
        default: !0,
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  f(g, "getHealingBonus");
  const h = /* @__PURE__ */ f(() => p(), "click_handler"), _ = /* @__PURE__ */ f(({ target: v }) => m("label", v.value), "change_handler"), y = /* @__PURE__ */ f(({ target: v }) => m("formula", v.value), "change_handler_1"), k = /* @__PURE__ */ f(({ detail: v }) => {
    m("context.perLevel", v);
  }, "updateSelection_handler");
  return i.$$set = (v) => {
    "document" in v && t(4, o = v.document), "bonusID" in v && t(5, a = v.bonusID), "jsonValue" in v && t(6, c = v.jsonValue);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, jsonValue*/
    192 && t(0, s = g() ?? {});
  }, [
    s,
    u,
    p,
    m,
    o,
    a,
    c,
    n,
    h,
    _,
    y,
    k
  ];
}
f(EW, "instance$3T");
const xA = class xA extends ie {
  constructor(e) {
    super(), le(this, e, EW, AW, ne, { document: 4, bonusID: 5, jsonValue: 6 });
  }
};
f(xA, "HitPointsBonusConfigDialog");
let ay = xA;
function UD(i, e, t) {
  const s = i.slice();
  return s[20] = e[t][0], s[21] = e[t][1], s;
}
f(UD, "get_each_context$1A");
function SW(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*movementBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[14]
      ), s = !0);
    },
    p(l, r) {
      r & /*movementBonus*/
      1 && t !== (t = /*movementBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(SW, "create_default_slot_4$l");
function VD(i, e) {
  let t, s = K(
    /*name*/
    e[21]
  ) + "", n, l, r;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = x(s), l = R(), t.__value = /*key*/
      e[20], qe(t, t.__value), t.selected = r = /*movementBonus*/
      e[0].unit === /*key*/
      e[20], this.first = t;
    },
    m(o, a) {
      T(o, t, a), A(t, n), A(t, l);
    },
    p(o, a) {
      e = o, a & /*movementBonus*/
      1 && r !== (r = /*movementBonus*/
      e[0].unit === /*key*/
      e[20]) && (t.selected = r);
    },
    d(o) {
      o && S(t);
    }
  };
}
f(VD, "create_each_block$1A");
function TW(i) {
  let e, t, s = K("A5E.None") + "", n, l, r, o = [], a = /* @__PURE__ */ new Map(), c, u, d = oe(Object.entries(
    /*distanceUnits*/
    i[7]
  ));
  const p = /* @__PURE__ */ f((m) => (
    /*key*/
    m[20]
  ), "get_key");
  for (let m = 0; m < d.length; m += 1) {
    let g = UD(i, d, m), h = p(g);
    a.set(h, o[m] = VD(h, g));
  }
  return {
    c() {
      e = E("select"), t = E("option"), n = x(s), l = R();
      for (let m = 0; m < o.length; m += 1)
        o[m].c();
      t.__value = null, qe(t, t.__value), t.selected = r = /*movementBonus*/
      i[0].unit === "null" || /*movementBonus*/
      i[0].unit === null, b(e, "class", "u-w-fit damage-type-select");
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(t, n), A(t, l);
      for (let h = 0; h < o.length; h += 1)
        o[h] && o[h].m(e, null);
      c || (u = V(
        e,
        "change",
        /*change_handler_2*/
        i[15]
      ), c = !0);
    },
    p(m, g) {
      g & /*movementBonus*/
      1 && r !== (r = /*movementBonus*/
      m[0].unit === "null" || /*movementBonus*/
      m[0].unit === null) && (t.selected = r), g & /*Object, distanceUnits, movementBonus*/
      129 && (d = oe(Object.entries(
        /*distanceUnits*/
        m[7]
      )), o = kt(o, g, p, 1, m, d, a, e, vs, VD, null, UD));
    },
    d(m) {
      m && S(e);
      for (let g = 0; g < o.length; g += 1)
        o[g].d();
      c = !1, u();
    }
  };
}
f(TW, "create_default_slot_3$B");
function CW(i) {
  let e, t, s, n, l, r;
  return e = new de({
    props: {
      heading: "A5E.Formula",
      $$slots: { default: [SW] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      heading: "A5E.Unit",
      $$slots: { default: [TW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), l = E("div"), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-grow", "1"), z(l, "display", "contents"), z(l, "--background", "none"), z(l, "--direction", "column"), z(l, "--padding", "0");
    },
    m(o, a) {
      T(o, t, a), N(e, t, null), T(o, s, a), T(o, l, a), N(n, l, null), r = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$$scope, movementBonus*/
      16777217 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const u = {};
      a & /*$$scope, movementBonus*/
      16777217 && (u.$$scope = { dirty: a, ctx: o }), n.$set(u);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(n.$$.fragment, o), r = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(n.$$.fragment, o), r = !1;
    },
    d(o) {
      o && S(s), o && e && S(t), j(e, o), o && n && S(l), j(n, o);
    }
  };
}
f(CW, "create_default_slot_2$T");
function OW(i) {
  let e, t;
  return e = new De({
    props: {
      label: "Is Hover For Flying Speed",
      checked: (
        /*isHover*/
        i[1] ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[17]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*isHover*/
      2 && (l.checked = /*isHover*/
      s[1] ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(OW, "create_default_slot_1$1f");
function DW(i) {
  let e, t, s, n;
  return e = new Ze({
    props: {
      heading: "A5E.contexts.movementTypes",
      options: Object.entries(
        /*movement*/
        i[6]
      ),
      selected: (
        /*movementTypes*/
        i[2]
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[16]
  ), s = new de({
    props: {
      $$slots: { default: [OW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*movementTypes*/
      4 && (o.selected = /*movementTypes*/
      l[2]), e.$set(o);
      const a = {};
      r & /*$$scope, isHover*/
      16777218 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(DW, "create_default_slot$27");
function IW(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k;
  return d = new Me({
    props: {
      $$slots: { default: [CW] },
      $$scope: { ctx: i }
    }
  }), g = new Me({
    props: {
      heading: "Contexts",
      hint: "The context determines when the ability bonus applies",
      $$slots: { default: [DW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), p = E("div"), L(d.$$.fragment), m = R(), h = E("div"), L(g.$$.fragment), b(s, "class", "bonus-image svelte-1gxe7tx"), ze(s.src, n = /*movementBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*movementBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*movementBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1gxe7tx"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1gxe7tx"), b(t, "class", "sheet-header svelte-1gxe7tx"), z(p, "display", "contents"), z(p, "--a5e-section-body-direction", "row"), z(p, "--a5e-section-margin", "0.25rem 0"), z(h, "display", "contents"), z(h, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1gxe7tx");
    },
    m(v, O) {
      T(v, e, O), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, u), A(e, p), N(d, p, null), A(e, m), A(e, h), N(g, h, null), _ = !0, y || (k = [
        V(
          s,
          "click",
          /*click_handler*/
          i[12]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[13]
        )
      ], y = !0);
    },
    p(v, [O]) {
      (!_ || O & /*movementBonus*/
      1 && !ze(s.src, n = /*movementBonus*/
      v[0].img)) && b(s, "src", n), (!_ || O & /*movementBonus*/
      1 && l !== (l = /*movementBonus*/
      v[0].label)) && b(s, "alt", l), (!_ || O & /*movementBonus*/
      1 && c !== (c = /*movementBonus*/
      v[0].label ?? "") && a.value !== c) && (a.value = c);
      const P = {};
      O & /*$$scope, movementBonus*/
      16777217 && (P.$$scope = { dirty: O, ctx: v }), d.$set(P);
      const D = {};
      O & /*$$scope, isHover, movementTypes*/
      16777222 && (D.$$scope = { dirty: O, ctx: v }), g.$set(D);
    },
    i(v) {
      _ || (w(d.$$.fragment, v), w(g.$$.fragment, v), _ = !0);
    },
    o(v) {
      C(d.$$.fragment, v), C(g.$$.fragment, v), _ = !1;
    },
    d(v) {
      v && S(e), j(d), j(g), y = !1, Ne(k);
    }
  };
}
f(IW, "create_fragment$3$");
function PW(i, e, t) {
  let s, n, l, r, { document: o, bonusID: a } = fe("#external").application, { document: c = o, bonusID: u = a } = e, { jsonValue: d = null } = e;
  const p = c;
  pe(i, p, (F) => t(11, r = F));
  const m = it();
  function g() {
    const F = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: F,
      callback: (G) => {
        h("img", G);
      }
    }).browse();
  }
  f(g, "updateImage");
  function h(F, H) {
    if (d === null) {
      F = `system.bonuses.movement.${u}.${F}`, se(r, F, H);
      return;
    }
    const G = foundry.utils.expandObject({ ...s, [F]: H });
    m("change", JSON.stringify(G));
  }
  f(h, "onUpdateValue");
  function _() {
    if (d === null)
      return r.system.bonuses.movement[u];
    try {
      const F = JSON.parse(d || '""') ?? {};
      if (typeof F != "object")
        throw new Error();
      return F.label = F.label ?? "", F.unit = F.unit || "feet", F.formula = F.formula ?? "", F.context = F.context ?? { movementTypes: [], isHover: !1 }, F.img = F.img || "icons/svg/upgrade.svg", F;
    } catch {
      return {
        label: "",
        formula: "",
        unit: "feet",
        damageType: "",
        context: { movementTypes: [], isHover: !1 },
        // valueIfOriginalIsZero: "",
        default: !0,
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  f(_, "getMovementBonus");
  const { movement: y, distanceUnits: k } = CONFIG.A5E, v = /* @__PURE__ */ f(() => g(), "click_handler"), O = /* @__PURE__ */ f(({ target: F }) => h("label", F.value), "change_handler"), P = /* @__PURE__ */ f(({ target: F }) => h("formula", F.value), "change_handler_1"), D = /* @__PURE__ */ f(({ target: F }) => h("unit", F.value), "change_handler_2"), I = /* @__PURE__ */ f(({ detail: F }) => {
    h("context.movementTypes", F);
  }, "updateSelection_handler"), B = /* @__PURE__ */ f(({ detail: F }) => {
    h("context.isHover", F);
  }, "updateSelection_handler_1");
  return i.$$set = (F) => {
    "document" in F && t(8, c = F.document), "bonusID" in F && t(9, u = F.bonusID), "jsonValue" in F && t(10, d = F.jsonValue);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, jsonValue*/
    3072 && t(0, s = _() ?? {}), i.$$.dirty & /*movementBonus*/
    1 && t(2, n = s.context.movementTypes ?? []), i.$$.dirty & /*movementBonus*/
    1 && t(1, l = s.context.isHover ?? !1);
  }, [
    s,
    l,
    n,
    p,
    g,
    h,
    y,
    k,
    c,
    u,
    d,
    r,
    v,
    O,
    P,
    D,
    I,
    B
  ];
}
f(PW, "instance$3S");
const eE = class eE extends ie {
  constructor(e) {
    super(), le(this, e, PW, IW, ne, { document: 8, bonusID: 9, jsonValue: 10 });
  }
};
f(eE, "MovementBonusConfigDialog");
let cy = eE;
function WD(i, e, t) {
  const s = i.slice();
  return s[9] = e[t][0], s[10] = e[t][1], s;
}
f(WD, "get_each_context$1z");
function KD(i, e, t) {
  const s = i.slice();
  return s[13] = e[t][0], s[14] = e[t][1], s;
}
f(KD, "get_each_context_1$m");
function YD(i) {
  let e, t, s;
  return e = new bt({
    props: {
      heading: (
        /*headings*/
        i[3][
          /*mode*/
          i[9]
        ]
      ),
      $$slots: { default: [MW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--item-alignment", "center"), z(t, "--label-width", "7.5rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$actor*/
      1 && (r.heading = /*headings*/
      n[3][
        /*mode*/
        n[9]
      ]), l & /*$$scope, $actor*/
      131073 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(YD, "create_if_block$2c");
function XD(i) {
  let e, t = K(
    /*name*/
    i[14]
  ) + "", s, n, l;
  return {
    c() {
      e = E("option"), s = x(t), n = R(), b(
        e,
        "key",
        /*key*/
        i[13]
      ), e.__value = /*key*/
      i[13], qe(e, e.__value), e.selected = l = /*movementData*/
      i[10].unit === /*key*/
      i[13];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      o & /*$actor*/
      1 && l !== (l = /*movementData*/
      r[10].unit === /*key*/
      r[13]) && (e.selected = l);
    },
    d(r) {
      r && S(e);
    }
  };
}
f(XD, "create_each_block_1$m");
function JD(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.MovementHover",
      checked: (
        /*movementData*/
        (s = i[10]) == null ? void 0 : s.hover
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[8]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*$actor*/
      1 && (r.checked = /*movementData*/
      (o = n[10]) == null ? void 0 : o.hover), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(JD, "create_if_block_1$1r");
function MW(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m = oe(Object.entries(
    /*A5E*/
    i[2].distanceUnits
  )), g = [];
  for (let _ = 0; _ < m.length; _ += 1)
    g[_] = XD(KD(i, m, _));
  let h = (
    /*mode*/
    i[9] === "fly" && JD(i)
  );
  return {
    c() {
      e = E("div"), t = E("input"), l = R(), r = E("select");
      for (let _ = 0; _ < g.length; _ += 1)
        g[_].c();
      a = R(), h && h.c(), c = R(), b(t, "class", "a5e-input"), b(t, "type", "number"), b(t, "name", s = "system.attributes.movement." + /*mode*/
      i[9] + ".distance"), t.value = n = /*movementData*/
      i[10].distance || 0, b(t, "min", "0"), b(e, "class", "u-w-20"), b(r, "class", "u-w-30"), b(r, "name", o = `system.attributes.movement.${/*mode*/
      i[9]}.unit`);
    },
    m(_, y) {
      T(_, e, y), A(e, t), T(_, l, y), T(_, r, y);
      for (let k = 0; k < g.length; k += 1)
        g[k] && g[k].m(r, null);
      T(_, a, y), h && h.m(_, y), T(_, c, y), u = !0, d || (p = [
        V(
          t,
          "change",
          /*change_handler*/
          i[6]
        ),
        V(
          r,
          "change",
          /*change_handler_1*/
          i[7]
        )
      ], d = !0);
    },
    p(_, y) {
      if ((!u || y & /*$actor*/
      1 && s !== (s = "system.attributes.movement." + /*mode*/
      _[9] + ".distance")) && b(t, "name", s), (!u || y & /*$actor*/
      1 && n !== (n = /*movementData*/
      _[10].distance || 0) && t.value !== n) && (t.value = n), y & /*Object, A5E, $actor*/
      5) {
        m = oe(Object.entries(
          /*A5E*/
          _[2].distanceUnits
        ));
        let k;
        for (k = 0; k < m.length; k += 1) {
          const v = KD(_, m, k);
          g[k] ? g[k].p(v, y) : (g[k] = XD(v), g[k].c(), g[k].m(r, null));
        }
        for (; k < g.length; k += 1)
          g[k].d(1);
        g.length = m.length;
      }
      (!u || y & /*$actor*/
      1 && o !== (o = `system.attributes.movement.${/*mode*/
      _[9]}.unit`)) && b(r, "name", o), /*mode*/
      _[9] === "fly" ? h ? (h.p(_, y), y & /*$actor*/
      1 && w(h, 1)) : (h = JD(_), h.c(), w(h, 1), h.m(c.parentNode, c)) : h && (ce(), C(h, 1, 1, () => {
        h = null;
      }), ue());
    },
    i(_) {
      u || (w(h), u = !0);
    },
    o(_) {
      C(h), u = !1;
    },
    d(_) {
      _ && (S(e), S(l), S(r), S(a), S(c)), Le(g, _), h && h.d(_), d = !1, Ne(p);
    }
  };
}
f(MW, "create_default_slot$26");
function ZD(i) {
  let e, t, s = (
    /*mode*/
    i[9] != "traits" && YD(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*mode*/
      n[9] != "traits" ? s ? (s.p(n, l), l & /*$actor*/
      1 && w(s, 1)) : (s = YD(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ce(), C(s, 1, 1, () => {
        s = null;
      }), ue());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f(ZD, "create_each_block$1z");
function RW(i) {
  let e, t, s = oe(Object.entries(
    /*$actor*/
    i[0]._source.system.attributes.movement
  )), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = ZD(WD(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("article");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "svelte-5iup0s");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, [o]) {
      if (o & /*headings, Object, $actor, A5E, Math, Number*/
      13) {
        s = oe(Object.entries(
          /*$actor*/
          r[0]._source.system.attributes.movement
        ));
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = WD(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = ZD(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f(RW, "create_fragment$3_");
function FW(i, e, t) {
  let s, { document: n, appId: l } = fe("#external").application, { document: r = n, appId: o = l } = e;
  const a = r;
  pe(i, a, (g) => t(0, s = g));
  const { A5E: c } = CONFIG, u = {
    burrow: "A5E.MovementBurrowingSpeed",
    climb: "A5E.MovementClimbingSpeed",
    fly: "A5E.MovementFlyingSpeed",
    swim: "A5E.MovementSwimmingSpeed",
    walk: "A5E.MovementWalkingSpeed"
  }, d = /* @__PURE__ */ f(({ target: g }) => {
    se(s, g.name, Math.max(Number(g.value), 0));
  }, "change_handler"), p = /* @__PURE__ */ f(({ target: g }) => se(s, g.name, g.value), "change_handler_1"), m = /* @__PURE__ */ f(({ detail: g }) => {
    se(s, "system.attributes.movement.traits.hover", g);
  }, "updateSelection_handler");
  return i.$$set = (g) => {
    "document" in g && t(4, r = g.document), "appId" in g && t(5, o = g.appId);
  }, [
    s,
    a,
    c,
    u,
    r,
    o,
    d,
    p,
    m
  ];
}
f(FW, "instance$3R");
const tE = class tE extends ie {
  constructor(e) {
    super(), le(this, e, FW, RW, ne, { document: 4, appId: 5 });
  }
};
f(tE, "MovementConfigDialog");
let uy = tE;
function QD(i, e, t) {
  const s = i.slice();
  return s[19] = e[t], s;
}
f(QD, "get_each_context$1y");
function xD(i) {
  let e, t, s;
  return e = new Me({
    props: {
      $$slots: { default: [BW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-padding", "0"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, consumeSupply, $actor, recoverStrifeAndFatigue, haven*/
      4194333 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(xD, "create_if_block_1$1q");
function NW(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.HavenPrompt",
      checked: (
        /*haven*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[15]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*haven*/
      4 && (l.checked = /*haven*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(NW, "create_default_slot_5$e");
function jW(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.SupplyFatigueStrifePrompt",
      checked: (
        /*recoverStrifeAndFatigue*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[16]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*recoverStrifeAndFatigue*/
      8 && (l.checked = /*recoverStrifeAndFatigue*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(jW, "create_default_slot_4$k");
function eI(i) {
  let e, t;
  return e = new de({
    props: {
      $$slots: { default: [LW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, consumeSupply*/
      4194320 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(eI, "create_if_block_2$S");
function LW(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.SupplyConsume",
      checked: (
        /*consumeSupply*/
        i[4]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[17]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*consumeSupply*/
      16 && (l.checked = /*consumeSupply*/
      s[4]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(LW, "create_default_slot_3$A");
function BW(i) {
  let e, t, s, n, l, r;
  e = new de({
    props: {
      $$slots: { default: [NW] },
      $$scope: { ctx: i }
    }
  }), s = new de({
    props: {
      $$slots: { default: [jW] },
      $$scope: { ctx: i }
    }
  });
  let o = (
    /*$actor*/
    i[0].type === "character" && eI(i)
  );
  return {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), o && o.c(), l = $e();
    },
    m(a, c) {
      N(e, a, c), T(a, t, c), N(s, a, c), T(a, n, c), o && o.m(a, c), T(a, l, c), r = !0;
    },
    p(a, c) {
      const u = {};
      c & /*$$scope, haven*/
      4194308 && (u.$$scope = { dirty: c, ctx: a }), e.$set(u);
      const d = {};
      c & /*$$scope, recoverStrifeAndFatigue*/
      4194312 && (d.$$scope = { dirty: c, ctx: a }), s.$set(d), /*$actor*/
      a[0].type === "character" ? o ? (o.p(a, c), c & /*$actor*/
      1 && w(o, 1)) : (o = eI(a), o.c(), w(o, 1), o.m(l.parentNode, l)) : o && (ce(), C(o, 1, 1, () => {
        o = null;
      }), ue());
    },
    i(a) {
      r || (w(e.$$.fragment, a), w(s.$$.fragment, a), w(o), r = !0);
    },
    o(a) {
      C(e.$$.fragment, a), C(s.$$.fragment, a), C(o), r = !1;
    },
    d(a) {
      a && (S(t), S(n), S(l)), j(e, a), j(s, a), o && o.d(a);
    }
  };
}
f(BW, "create_default_slot_2$S");
function tI(i) {
  let e, t, s;
  return e = new Me({
    props: {
      $$slots: { default: [GW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-padding", "0");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, hitDice*/
      4194336 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(tI, "create_if_block$2b");
function sI(i) {
  let e, t, s, n, l, r = (
    /*hitDice*/
    i[5][
      /*die*/
      i[19]
    ].current + ""
  ), o, a, c, u;
  function d() {
    return (
      /*click_handler*/
      i[18](
        /*die*/
        i[19]
      )
    );
  }
  return f(d, "click_handler"), {
    c() {
      e = E("div"), t = E("div"), s = E("span"), s.textContent = `${/*die*/
      i[19]}`, n = R(), l = E("span"), o = x(r), a = R(), b(s, "class", "a5e-hit-die__label"), b(t, "class", "a5e-hit-die a5e-hit-die--rollable a5e-hit-die--" + /*die*/
      i[19] + " svelte-1d2n06y"), Q(
        t,
        "disabled",
        /*hitDice*/
        i[5][
          /*die*/
          i[19]
        ].current === 0
      ), b(l, "class", "a5e-hit-die__quantity"), b(e, "class", "a5e-hit-die-wrapper");
    },
    m(p, m) {
      T(p, e, m), A(e, t), A(t, s), A(e, n), A(e, l), A(l, o), A(e, a), c || (u = V(t, "click", d), c = !0);
    },
    p(p, m) {
      i = p, m & /*hitDice*/
      32 && Q(
        t,
        "disabled",
        /*hitDice*/
        i[5][
          /*die*/
          i[19]
        ].current === 0
      ), m & /*hitDice*/
      32 && r !== (r = /*hitDice*/
      i[5][
        /*die*/
        i[19]
      ].current + "") && _e(o, r);
    },
    d(p) {
      p && S(e), c = !1, u();
    }
  };
}
f(sI, "create_each_block$1y");
function qW(i) {
  let e, t = oe(["d6", "d8", "d10", "d12"]), s = [];
  for (let n = 0; n < 4; n += 1)
    s[n] = sI(QD(i, t, n));
  return {
    c() {
      e = E("div");
      for (let n = 0; n < 4; n += 1)
        s[n].c();
      b(e, "class", "u-flex u-gap-md u-text-md");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < 4; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l & /*hitDice, rollHitDie*/
      544) {
        t = oe(["d6", "d8", "d10", "d12"]);
        let r;
        for (r = 0; r < 4; r += 1) {
          const o = QD(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = sI(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < 4; r += 1)
          s[r].d(1);
      }
    },
    d(n) {
      n && S(e), Le(s, n);
    }
  };
}
f(qW, "create_default_slot_1$1e");
function GW(i) {
  let e, t;
  return e = new de({
    props: {
      heading: "A5E.HitDiceLabel",
      $$slots: { default: [qW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, hitDice*/
      4194336 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(GW, "create_default_slot$25");
function zW(i) {
  let e, t, s, n, l, r, o, a, c = K("A5E.Rest") + "", u, d, p, m;
  t = new Ye({
    props: {
      heading: "A5E.RestType",
      options: Object.entries(
        /*restTypeOptions*/
        i[7]
      ),
      selected: (
        /*restType*/
        i[1]
      )
    }
  }), t.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[14]
  );
  let g = (
    /*restType*/
    i[1] === "long" && !/*simpleRests*/
    i[8] && xD(i)
  ), h = (
    /*restType*/
    i[1] === "short" && tI(i)
  );
  return {
    c() {
      e = E("form"), L(t.$$.fragment), s = R(), g && g.c(), n = R(), h && h.c(), l = R(), r = E("button"), o = E("i"), a = R(), u = x(c), b(o, "class", "fas fa-campground"), b(r, "class", "a5e-button"), b(e, "class", "form svelte-1d2n06y");
    },
    m(_, y) {
      T(_, e, y), N(t, e, null), A(e, s), g && g.m(e, null), A(e, n), h && h.m(e, null), A(e, l), A(e, r), A(r, o), A(r, a), A(r, u), d = !0, p || (m = V(r, "click", tt(
        /*onSubmit*/
        i[10]
      )), p = !0);
    },
    p(_, [y]) {
      const k = {};
      y & /*restType*/
      2 && (k.selected = /*restType*/
      _[1]), t.$set(k), /*restType*/
      _[1] === "long" && !/*simpleRests*/
      _[8] ? g ? (g.p(_, y), y & /*restType*/
      2 && w(g, 1)) : (g = xD(_), g.c(), w(g, 1), g.m(e, n)) : g && (ce(), C(g, 1, 1, () => {
        g = null;
      }), ue()), /*restType*/
      _[1] === "short" ? h ? (h.p(_, y), y & /*restType*/
      2 && w(h, 1)) : (h = tI(_), h.c(), w(h, 1), h.m(e, l)) : h && (ce(), C(h, 1, 1, () => {
        h = null;
      }), ue());
    },
    i(_) {
      d || (w(t.$$.fragment, _), w(g), w(h), d = !0);
    },
    o(_) {
      C(t.$$.fragment, _), C(g), C(h), d = !1;
    },
    d(_) {
      _ && S(e), j(t), g && g.d(), h && h.d(), p = !1, m();
    }
  };
}
f(zW, "create_fragment$3Z");
function HW(i, e, t) {
  let s, n, { application: l } = fe("#external"), { application: r = l } = e, { document: o, appId: a } = fe("#external").application, { document: c = o, appId: u = a } = e;
  const d = c;
  pe(i, d, (F) => t(0, n = F));
  const p = {
    short: "A5E.RestShort",
    long: "A5E.RestLong"
  };
  let m = "short", g = !0, h = !0, _ = game.settings.get("a5e", "simpleRests"), y = !1;
  async function k(F) {
    try {
      await n.rollHitDice(F);
    } catch (H) {
      console.log(H);
      return;
    }
  }
  f(k, "rollHitDie");
  function v() {
    const F = game.settings.get("a5e", "simpleRests");
    r.submit({
      consumeSupply: F ? !1 : y,
      haven: F ? !0 : g,
      restType: m,
      recoverStrifeAndFatigue: F ? !0 : h
    });
  }
  f(v, "onSubmit");
  const O = /* @__PURE__ */ f(({ detail: F }) => t(1, m = F), "updateSelection_handler"), P = /* @__PURE__ */ f(({ detail: F }) => {
    t(2, g = F);
  }, "updateSelection_handler_1"), D = /* @__PURE__ */ f(({ detail: F }) => {
    t(3, h = F);
  }, "updateSelection_handler_2"), I = /* @__PURE__ */ f(({ detail: F }) => {
    t(4, y = F);
  }, "updateSelection_handler_3"), B = /* @__PURE__ */ f((F) => k(F), "click_handler");
  return i.$$set = (F) => {
    "application" in F && t(11, r = F.application), "document" in F && t(12, c = F.document), "appId" in F && t(13, u = F.appId);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    1 && t(5, s = n.system.attributes.hitDice);
  }, [
    n,
    m,
    g,
    h,
    y,
    s,
    d,
    p,
    _,
    k,
    v,
    r,
    c,
    u,
    O,
    P,
    D,
    I,
    B
  ];
}
f(HW, "instance$3Q");
const sE = class sE extends ie {
  constructor(e) {
    super(), le(this, e, HW, zW, ne, { application: 11, document: 12, appId: 13 });
  }
};
f(sE, "RestDialog");
let fy = sE;
function nI(i) {
  let e, t;
  return e = new ml({
    props: {
      selected: (
        /*rollMode*/
        i[4]
      ),
      source: (
        /*rollModeString*/
        i[10]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[22]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*rollMode*/
      16 && (l.selected = /*rollMode*/
      s[4]), n[0] & /*rollModeString*/
      1024 && (l.source = /*rollModeString*/
      s[10]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(nI, "create_key_block$3");
function iI(i) {
  let e, t;
  return e = new Ye({
    props: {
      heading: "A5E.ItemSavingThrowType",
      options: (
        /*saveTypes*/
        i[12]
      ),
      selected: (
        /*saveType*/
        i[1]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[24]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*saveType*/
      2 && (l.selected = /*saveType*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(iI, "create_if_block_1$1p");
function UW(i) {
  let e, t;
  return e = new Ze({
    props: {
      heading: "Ability Bonuses",
      options: (
        /*abilityBonuses*/
        i[14].map(YW)
      ),
      selected: (
        /*selectedAbilityBonuses*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[25]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*selectedAbilityBonuses*/
      8 && (l.selected = /*selectedAbilityBonuses*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(UW, "create_if_block$2a");
function VW(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), b(e, "id", t = /*$actor*/
      i[6].id + "-" + /*appId*/
      i[15] + "-situational-mods");
    },
    m(l, r) {
      T(l, e, r), qe(
        e,
        /*situationalMods*/
        i[2]
      ), s || (n = V(
        e,
        "input",
        /*input_input_handler*/
        i[26]
      ), s = !0);
    },
    p(l, r) {
      r[0] & /*$actor*/
      64 && t !== (t = /*$actor*/
      l[6].id + "-" + /*appId*/
      l[15] + "-situational-mods") && b(e, "id", t), r[0] & /*situationalMods*/
      4 && e.value !== /*situationalMods*/
      l[2] && qe(
        e,
        /*situationalMods*/
        l[2]
      );
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(VW, "create_default_slot$24");
function WW(i) {
  let e, t, s, n, l = (
    /*saveType*/
    i[1]
  ), r, o, a, c, u = Object.values(
    /*abilityBonuses*/
    i[14]
  ).flat().length, d, p, m, g, h, _, y, k, v, O, P, D;
  function I(U) {
    i[21](U);
  }
  f(I, "outputvisibilitysection_visibilityMode_binding");
  let B = {};
  /*visibilityMode*/
  i[7] !== void 0 && (B.visibilityMode = /*visibilityMode*/
  i[7]), t = new ma({ props: B }), st.push(() => mt(t, "visibilityMode", I));
  let F = nI(i);
  o = new hn({
    props: {
      source: (
        /*expertiseDieSource*/
        i[11]
      ),
      selected: (
        /*expertiseDie*/
        i[5]
      ),
      type: (
        /*$actor*/
        i[6].type
      )
    }
  }), o.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[23]
  );
  let H = (
    /*abilityKey*/
    i[0] === "con" && /*saveType*/
    i[1] !== "death" && iI(i)
  ), G = u && UW(i);
  return p = new de({
    props: {
      heading: "A5E.SituationalMods",
      $$slots: { default: [VW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), L(t.$$.fragment), n = R(), F.c(), r = R(), L(o.$$.fragment), a = R(), H && H.c(), c = R(), G && G.c(), d = R(), L(p.$$.fragment), m = R(), g = E("section"), h = x(
        /*rollFormula*/
        i[8]
      ), _ = R(), y = E("section"), k = E("button"), v = x(
        /*buttonText*/
        i[9]
      ), b(g, "class", "roll-formula-preview svelte-cfnill"), b(e, "class", "svelte-cfnill");
    },
    m(U, q) {
      T(U, e, q), N(t, e, null), A(e, n), F.m(e, null), A(e, r), N(o, e, null), A(e, a), H && H.m(e, null), A(e, c), G && G.m(e, null), A(e, d), N(p, e, null), A(e, m), A(e, g), A(g, h), A(e, _), A(e, y), A(y, k), A(k, v), O = !0, P || (D = V(k, "click", tt(
        /*onSubmit*/
        i[16]
      )), P = !0);
    },
    p(U, q) {
      const W = {};
      !s && q[0] & /*visibilityMode*/
      128 && (s = !0, W.visibilityMode = /*visibilityMode*/
      U[7], _t(() => s = !1)), t.$set(W), q[0] & /*saveType*/
      2 && ne(l, l = /*saveType*/
      U[1]) ? (ce(), C(F, 1, 1, ee), ue(), F = nI(U), F.c(), w(F, 1), F.m(e, r)) : F.p(U, q);
      const X = {};
      q[0] & /*expertiseDieSource*/
      2048 && (X.source = /*expertiseDieSource*/
      U[11]), q[0] & /*expertiseDie*/
      32 && (X.selected = /*expertiseDie*/
      U[5]), q[0] & /*$actor*/
      64 && (X.type = /*$actor*/
      U[6].type), o.$set(X), /*abilityKey*/
      U[0] === "con" && /*saveType*/
      U[1] !== "death" ? H ? (H.p(U, q), q[0] & /*abilityKey, saveType*/
      3 && w(H, 1)) : (H = iI(U), H.c(), w(H, 1), H.m(e, c)) : H && (ce(), C(H, 1, 1, () => {
        H = null;
      }), ue()), u && G.p(U, q);
      const te = {};
      q[0] & /*$actor, situationalMods*/
      68 | q[1] & /*$$scope*/
      2 && (te.$$scope = { dirty: q, ctx: U }), p.$set(te), (!O || q[0] & /*rollFormula*/
      256) && _e(
        h,
        /*rollFormula*/
        U[8]
      ), (!O || q[0] & /*buttonText*/
      512) && _e(
        v,
        /*buttonText*/
        U[9]
      );
    },
    i(U) {
      O || (w(t.$$.fragment, U), w(F), w(o.$$.fragment, U), w(H), w(G), w(p.$$.fragment, U), O = !0);
    },
    o(U) {
      C(t.$$.fragment, U), C(F), C(o.$$.fragment, U), C(H), C(G), C(p.$$.fragment, U), O = !1;
    },
    d(U) {
      U && S(e), j(t), F.d(U), j(o), H && H.d(), G && G.d(), j(p), P = !1, D();
    }
  };
}
f(WW, "create_fragment$3Y");
function KW(i, e) {
  return e ? i === "concentration" ? "concentration" : `system.abilities.${e}.save` : "deathSave";
}
f(KW, "getRollModeKey");
const YW = /* @__PURE__ */ f(([i, e]) => [i, e.label || e.defaultLabel], "func$e");
function XW(i, e, t) {
  let s, n, l, r, o, a, c, u, { document: d, abilityKey: p, dialog: m, options: g } = fe("#external").application, { document: h = d, abilityKey: _ = p, dialog: y = m, options: k = g } = e;
  function v() {
    return F ? 0 : u.RollOverrideManager.getExpertiseDice(n ?? "", k.expertiseDice ?? 0);
  }
  f(v, "getInitialExpertiseDieSelection");
  function O(me, he) {
    return me === "death" ? "Roll Death Saving Throw" : he === "con" && me === "concentration" ? K("A5E.RollConcentrationCheck") : k.dc ? K("A5E.RollPromptSavingThrowWithDC", { ability: H, dc: k.dc }) : K("A5E.RollPromptSavingThrow", { ability: H });
  }
  f(O, "getSubmitButtonText");
  const P = [
    ["standard", "A5E.SavingThrowNormal"],
    ["concentration", "A5E.ConcentrationCheck"]
  ], D = new Bt(h);
  pe(i, D, (me) => t(6, u = me));
  const I = u.BonusesManager.prepareAbilityBonuses(_, "save"), B = y.id, F = game.settings.get("a5e", "hideExpertiseDice"), H = K(CONFIG.A5E.abilities[_]);
  function G() {
    y.submit({
      expertiseDie: l,
      rollFormula: X,
      rollMode: o,
      saveType: q,
      visibilityMode: U
    });
  }
  f(G, "onSubmit");
  let U = k.visibilityMode ?? game.settings.get("core", "rollMode"), q = k.saveType ?? "standard", W = k.rollMode ?? CONFIG.A5E.ROLL_MODE.NORMAL, X, te = k.situationalMods ?? "";
  function J(me) {
    U = me, t(7, U);
  }
  f(J, "outputvisibilitysection_visibilityMode_binding");
  const re = /* @__PURE__ */ f(({ detail: me }) => t(4, o = me), "updateSelection_handler"), ae = /* @__PURE__ */ f(({ detail: me }) => t(5, l = me), "updateSelection_handler_1"), be = /* @__PURE__ */ f((me) => t(1, q = me.detail), "updateSelection_handler_2"), we = /* @__PURE__ */ f(({ detail: me }) => t(3, s = me), "updateSelection_handler_3");
  function ve() {
    te = this.value, t(2, te);
  }
  return f(ve, "input_input_handler"), i.$$set = (me) => {
    "document" in me && t(17, h = me.document), "abilityKey" in me && t(0, _ = me.abilityKey), "dialog" in me && t(18, y = me.dialog), "options" in me && t(19, k = me.options);
  }, i.$$.update = () => {
    i.$$.dirty[0] & /*$actor, abilityKey*/
    65 && t(3, s = u.BonusesManager.getDefaultSelections("abilities", { abilityKey: _, abilityType: "save" })), i.$$.dirty[0] & /*saveType, abilityKey*/
    3 && t(20, n = KW(q, _)), i.$$.dirty[0] & /*$actor, rollModeKey, options*/
    1572928 && t(11, r = u.RollOverrideManager.getExpertiseDiceSource(n, k.expertiseDie ?? 0)), i.$$.dirty[0] & /*$actor, rollModeKey*/
    1048640 && t(4, o = u.RollOverrideManager.getRollOverride(n, W)), i.$$.dirty[0] & /*$actor, rollModeKey*/
    1048640 && t(10, a = u.RollOverrideManager.getRollOverridesSource(n, W)), i.$$.dirty[0] & /*saveType, abilityKey*/
    3 && t(9, c = O(q, _)), i.$$.dirty[0] & /*$actor, abilityKey, expertiseDie, rollMode, saveType, situationalMods, selectedAbilityBonuses*/
    127 && t(8, X = si(u, {
      ability: _,
      expertiseDie: l,
      rollMode: o,
      saveType: q,
      situationalMods: te,
      selectedAbilityBonuses: s,
      type: "savingThrow"
    }));
  }, t(5, l = v()), [
    _,
    q,
    te,
    s,
    o,
    l,
    u,
    U,
    X,
    c,
    a,
    r,
    P,
    D,
    I,
    B,
    G,
    h,
    y,
    k,
    n,
    J,
    re,
    ae,
    be,
    we,
    ve
  ];
}
f(XW, "instance$3P");
const nE = class nE extends ie {
  constructor(e) {
    super(), le(
      this,
      e,
      XW,
      WW,
      ne,
      {
        document: 17,
        abilityKey: 0,
        dialog: 18,
        options: 19
      },
      null,
      [-1, -1]
    );
  }
};
f(nE, "SavingThrowRollDialog");
let dy = nE;
function lI(i, e, t) {
  const s = i.slice();
  return s[20] = e[t][0], s[21] = e[t][1], s;
}
f(lI, "get_each_context$1x");
function JW(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*sensesBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[14]
      ), s = !0);
    },
    p(l, r) {
      r & /*sensesBonus*/
      1 && t !== (t = /*sensesBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(JW, "create_default_slot_4$j");
function rI(i, e) {
  let t, s = K(
    /*name*/
    e[21]
  ) + "", n, l, r;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = x(s), l = R(), t.__value = /*key*/
      e[20], qe(t, t.__value), t.selected = r = /*sensesBonus*/
      e[0].unit === /*key*/
      e[20], this.first = t;
    },
    m(o, a) {
      T(o, t, a), A(t, n), A(t, l);
    },
    p(o, a) {
      e = o, a & /*sensesBonus*/
      1 && r !== (r = /*sensesBonus*/
      e[0].unit === /*key*/
      e[20]) && (t.selected = r);
    },
    d(o) {
      o && S(t);
    }
  };
}
f(rI, "create_each_block$1x");
function ZW(i) {
  let e, t, s = K("A5E.None") + "", n, l, r, o = [], a = /* @__PURE__ */ new Map(), c, u, d = oe(Object.entries(
    /*visionUnits*/
    i[7]
  ));
  const p = /* @__PURE__ */ f((m) => (
    /*key*/
    m[20]
  ), "get_key");
  for (let m = 0; m < d.length; m += 1) {
    let g = lI(i, d, m), h = p(g);
    a.set(h, o[m] = rI(h, g));
  }
  return {
    c() {
      e = E("select"), t = E("option"), n = x(s), l = R();
      for (let m = 0; m < o.length; m += 1)
        o[m].c();
      t.__value = null, qe(t, t.__value), t.selected = r = /*sensesBonus*/
      i[0].unit === "null" || /*sensesBonus*/
      i[0].unit === null, b(e, "class", "u-w-fit damage-type-select");
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(t, n), A(t, l);
      for (let h = 0; h < o.length; h += 1)
        o[h] && o[h].m(e, null);
      c || (u = V(
        e,
        "change",
        /*change_handler_2*/
        i[15]
      ), c = !0);
    },
    p(m, g) {
      g & /*sensesBonus*/
      1 && r !== (r = /*sensesBonus*/
      m[0].unit === "null" || /*sensesBonus*/
      m[0].unit === null) && (t.selected = r), g & /*Object, visionUnits, sensesBonus*/
      129 && (d = oe(Object.entries(
        /*visionUnits*/
        m[7]
      )), o = kt(o, g, p, 1, m, d, a, e, vs, rI, null, lI));
    },
    d(m) {
      m && S(e);
      for (let g = 0; g < o.length; g += 1)
        o[g].d();
      c = !1, u();
    }
  };
}
f(ZW, "create_default_slot_3$z");
function QW(i) {
  let e, t, s, n, l, r;
  return e = new de({
    props: {
      heading: "A5E.Formula",
      $$slots: { default: [JW] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      heading: "A5E.Unit",
      $$slots: { default: [ZW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), l = E("div"), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-grow", "1"), z(l, "display", "contents"), z(l, "--background", "none"), z(l, "--direction", "column"), z(l, "--padding", "0");
    },
    m(o, a) {
      T(o, t, a), N(e, t, null), T(o, s, a), T(o, l, a), N(n, l, null), r = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$$scope, sensesBonus*/
      16777217 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const u = {};
      a & /*$$scope, sensesBonus*/
      16777217 && (u.$$scope = { dirty: a, ctx: o }), n.$set(u);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(n.$$.fragment, o), r = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(n.$$.fragment, o), r = !1;
    },
    d(o) {
      o && S(s), o && e && S(t), j(e, o), o && n && S(l), j(n, o);
    }
  };
}
f(QW, "create_default_slot_2$R");
function xW(i) {
  let e, t;
  return e = new De({
    props: {
      label: "Is Blind Beyond Vision Range",
      checked: (
        /*otherwiseBlind*/
        i[1] ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[17]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*otherwiseBlind*/
      2 && (l.checked = /*otherwiseBlind*/
      s[1] ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(xW, "create_default_slot_1$1d");
function eK(i) {
  let e, t, s, n;
  return e = new Ze({
    props: {
      heading: "A5E.contexts.senses",
      options: Object.entries(
        /*senses*/
        i[6]
      ),
      selected: (
        /*sensesTypes*/
        i[2]
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[16]
  ), s = new de({
    props: {
      $$slots: { default: [xW] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*sensesTypes*/
      4 && (o.selected = /*sensesTypes*/
      l[2]), e.$set(o);
      const a = {};
      r & /*$$scope, otherwiseBlind*/
      16777218 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(eK, "create_default_slot$23");
function tK(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k;
  return d = new Me({
    props: {
      $$slots: { default: [QW] },
      $$scope: { ctx: i }
    }
  }), g = new Me({
    props: {
      heading: "Contexts",
      hint: "The context determines when the ability bonus applies",
      $$slots: { default: [eK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), p = E("div"), L(d.$$.fragment), m = R(), h = E("div"), L(g.$$.fragment), b(s, "class", "bonus-image svelte-1gxe7tx"), ze(s.src, n = /*sensesBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*sensesBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*sensesBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1gxe7tx"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1gxe7tx"), b(t, "class", "sheet-header svelte-1gxe7tx"), z(p, "display", "contents"), z(p, "--a5e-section-body-direction", "row"), z(p, "--a5e-section-margin", "0.25rem 0"), z(h, "display", "contents"), z(h, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1gxe7tx");
    },
    m(v, O) {
      T(v, e, O), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, u), A(e, p), N(d, p, null), A(e, m), A(e, h), N(g, h, null), _ = !0, y || (k = [
        V(
          s,
          "click",
          /*click_handler*/
          i[12]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[13]
        )
      ], y = !0);
    },
    p(v, [O]) {
      (!_ || O & /*sensesBonus*/
      1 && !ze(s.src, n = /*sensesBonus*/
      v[0].img)) && b(s, "src", n), (!_ || O & /*sensesBonus*/
      1 && l !== (l = /*sensesBonus*/
      v[0].label)) && b(s, "alt", l), (!_ || O & /*sensesBonus*/
      1 && c !== (c = /*sensesBonus*/
      v[0].label ?? "") && a.value !== c) && (a.value = c);
      const P = {};
      O & /*$$scope, sensesBonus*/
      16777217 && (P.$$scope = { dirty: O, ctx: v }), d.$set(P);
      const D = {};
      O & /*$$scope, otherwiseBlind, sensesTypes*/
      16777222 && (D.$$scope = { dirty: O, ctx: v }), g.$set(D);
    },
    i(v) {
      _ || (w(d.$$.fragment, v), w(g.$$.fragment, v), _ = !0);
    },
    o(v) {
      C(d.$$.fragment, v), C(g.$$.fragment, v), _ = !1;
    },
    d(v) {
      v && S(e), j(d), j(g), y = !1, Ne(k);
    }
  };
}
f(tK, "create_fragment$3X");
function sK(i, e, t) {
  let s, n, l, r, { document: o, bonusID: a } = fe("#external").application, { document: c = o, bonusID: u = a } = e, { jsonValue: d = null } = e;
  const p = c;
  pe(i, p, (F) => t(11, r = F));
  const m = it();
  function g() {
    const F = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: F,
      callback: (G) => {
        h("img", G);
      }
    }).browse();
  }
  f(g, "updateImage");
  function h(F, H) {
    if (d === null) {
      F = `system.bonuses.senses.${u}.${F}`, se(r, F, H);
      return;
    }
    const G = foundry.utils.expandObject({ ...s, [F]: H });
    m("change", JSON.stringify(G));
  }
  f(h, "onUpdateValue");
  function _() {
    if (d === null)
      return r.system.bonuses.senses[u];
    try {
      const F = JSON.parse(d || '""') ?? {};
      if (typeof F != "object")
        throw new Error();
      return F.label = F.label ?? "", F.unit = F.unit || "feet", F.formula = F.formula ?? "", F.context = F.context ?? { senses: [], otherwiseBlind: !1 }, F.img = F.img || "icons/svg/upgrade.svg", F;
    } catch {
      return {
        label: "",
        unit: "feet",
        formula: "",
        damageType: "",
        context: { senses: [], otherwiseBlind: !1 },
        // valueIfOriginalIsZero: "",
        default: !0,
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  f(_, "getSensesBonus");
  const { senses: y, visionUnits: k } = CONFIG.A5E, v = /* @__PURE__ */ f(() => g(), "click_handler"), O = /* @__PURE__ */ f(({ target: F }) => h("label", F.value), "change_handler"), P = /* @__PURE__ */ f(({ target: F }) => h("formula", F.value), "change_handler_1"), D = /* @__PURE__ */ f(({ target: F }) => h("unit", F.value), "change_handler_2"), I = /* @__PURE__ */ f(({ detail: F }) => {
    h("context.senses", F);
  }, "updateSelection_handler"), B = /* @__PURE__ */ f(({ detail: F }) => {
    h("context.otherwiseBlind", F);
  }, "updateSelection_handler_1");
  return i.$$set = (F) => {
    "document" in F && t(8, c = F.document), "bonusID" in F && t(9, u = F.bonusID), "jsonValue" in F && t(10, d = F.jsonValue);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, jsonValue*/
    3072 && t(0, s = _() ?? {}), i.$$.dirty & /*sensesBonus*/
    1 && t(2, n = s.context.senses ?? []), i.$$.dirty & /*sensesBonus*/
    1 && t(1, l = s.context.otherwiseBlind ?? !1);
  }, [
    s,
    l,
    n,
    p,
    g,
    h,
    y,
    k,
    c,
    u,
    d,
    r,
    v,
    O,
    P,
    D,
    I,
    B
  ];
}
f(sK, "instance$3O");
const iE = class iE extends ie {
  constructor(e) {
    super(), le(this, e, sK, tK, ne, { document: 8, bonusID: 9, jsonValue: 10 });
  }
};
f(iE, "SensesBonusConfigDialog");
let py = iE;
function oI(i, e, t) {
  const s = i.slice();
  return s[9] = e[t][0], s[10] = e[t][1], s;
}
f(oI, "get_each_context$1w");
function aI(i, e, t) {
  const s = i.slice();
  return s[13] = e[t][0], s[14] = e[t][1], s;
}
f(aI, "get_each_context_1$l");
function cI(i) {
  let e, t = K(
    /*name*/
    i[14]
  ) + "", s, n, l;
  return {
    c() {
      e = E("option"), s = x(t), n = R(), b(
        e,
        "key",
        /*key*/
        i[13]
      ), e.__value = /*key*/
      i[13], qe(e, e.__value), e.selected = l = /*$actor*/
      i[0].system.attributes.senses[
        /*sense*/
        i[9]
      ].unit === /*key*/
      i[13];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      o & /*$actor*/
      1 && l !== (l = /*$actor*/
      r[0].system.attributes.senses[
        /*sense*/
        r[9]
      ].unit === /*key*/
      r[13]) && (e.selected = l);
    },
    d(r) {
      r && S(e);
    }
  };
}
f(cI, "create_each_block_1$l");
function uI(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "Blind Beyond this Range",
      checked: (
        /*$actor*/
        (s = i[0].system.attributes.senses.blindsight) == null ? void 0 : s.otherwiseBlind
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[8]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*$actor*/
      1 && (r.checked = /*$actor*/
      (o = n[0].system.attributes.senses.blindsight) == null ? void 0 : o.otherwiseBlind), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(uI, "create_if_block$29");
function nK(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h = oe(Object.entries(
    /*A5E*/
    i[2].visionUnits
  )), _ = [];
  for (let k = 0; k < h.length; k += 1)
    _[k] = cI(aI(i, h, k));
  let y = (
    /*sense*/
    i[9] === "blindsight" && uI(i)
  );
  return {
    c() {
      e = E("div"), t = E("input"), o = R(), a = E("select");
      for (let k = 0; k < _.length; k += 1)
        _[k].c();
      u = R(), y && y.c(), d = R(), b(t, "class", "a5e-input"), t.disabled = s = /*senseData*/
      i[10].unit === "unlimited", b(t, "type", n = /*senseData*/
      i[10].unit === "unlimited" ? "text" : "number"), b(t, "name", l = "system.attributes.senses." + /*sense*/
      i[9] + ".distance"), b(t, "min", "0"), t.value = r = /*senseData*/
      i[10].unit === "unlimited" ? "—" : (
        /*senseData*/
        i[10].distance || 0
      ), b(e, "class", "u-w-20"), b(a, "name", c = "system.attributes.senses." + /*sense*/
      i[9] + ".unit");
    },
    m(k, v) {
      T(k, e, v), A(e, t), T(k, o, v), T(k, a, v);
      for (let O = 0; O < _.length; O += 1)
        _[O] && _[O].m(a, null);
      T(k, u, v), y && y.m(k, v), T(k, d, v), p = !0, m || (g = [
        V(
          t,
          "change",
          /*change_handler*/
          i[6]
        ),
        V(
          a,
          "change",
          /*change_handler_1*/
          i[7]
        )
      ], m = !0);
    },
    p(k, v) {
      if ((!p || v & /*$actor*/
      1 && s !== (s = /*senseData*/
      k[10].unit === "unlimited")) && (t.disabled = s), (!p || v & /*$actor*/
      1 && n !== (n = /*senseData*/
      k[10].unit === "unlimited" ? "text" : "number")) && b(t, "type", n), (!p || v & /*$actor*/
      1 && l !== (l = "system.attributes.senses." + /*sense*/
      k[9] + ".distance")) && b(t, "name", l), (!p || v & /*$actor*/
      1 && r !== (r = /*senseData*/
      k[10].unit === "unlimited" ? "—" : (
        /*senseData*/
        k[10].distance || 0
      )) && t.value !== r) && (t.value = r), v & /*Object, A5E, $actor*/
      5) {
        h = oe(Object.entries(
          /*A5E*/
          k[2].visionUnits
        ));
        let O;
        for (O = 0; O < h.length; O += 1) {
          const P = aI(k, h, O);
          _[O] ? _[O].p(P, v) : (_[O] = cI(P), _[O].c(), _[O].m(a, null));
        }
        for (; O < _.length; O += 1)
          _[O].d(1);
        _.length = h.length;
      }
      (!p || v & /*$actor*/
      1 && c !== (c = "system.attributes.senses." + /*sense*/
      k[9] + ".unit")) && b(a, "name", c), /*sense*/
      k[9] === "blindsight" ? y ? (y.p(k, v), v & /*$actor*/
      1 && w(y, 1)) : (y = uI(k), y.c(), w(y, 1), y.m(d.parentNode, d)) : y && (ce(), C(y, 1, 1, () => {
        y = null;
      }), ue());
    },
    i(k) {
      p || (w(y), p = !0);
    },
    o(k) {
      C(y), p = !1;
    },
    d(k) {
      k && (S(e), S(o), S(a), S(u), S(d)), Le(_, k), y && y.d(k), m = !1, Ne(g);
    }
  };
}
f(nK, "create_default_slot$22");
function fI(i) {
  let e, t, s;
  return e = new bt({
    props: {
      heading: (
        /*headings*/
        i[3][
          /*sense*/
          i[9]
        ]
      ),
      $$slots: { default: [nK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--item-alignment", "center"), z(t, "--label-width", "7.5rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$actor*/
      1 && (r.heading = /*headings*/
      n[3][
        /*sense*/
        n[9]
      ]), l & /*$$scope, $actor*/
      131073 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(fI, "create_each_block$1w");
function iK(i) {
  let e, t, s = oe(Object.entries(
    /*$actor*/
    i[0]._source.system.attributes.senses
  )), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = fI(oI(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("article");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "svelte-5iup0s");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, [o]) {
      if (o & /*headings, Object, $actor, A5E, Math, Number*/
      13) {
        s = oe(Object.entries(
          /*$actor*/
          r[0]._source.system.attributes.senses
        ));
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = oI(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = fI(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f(iK, "create_fragment$3W");
function lK(i, e, t) {
  let s, { document: n, appId: l } = fe("#external").application, { document: r = n, appId: o = l } = e;
  const a = r;
  pe(i, a, (g) => t(0, s = g));
  const { A5E: c } = CONFIG, u = {
    blindsight: "A5E.SenseBlindsightRange",
    darkvision: "A5E.SenseDarkvisionRange",
    tremorsense: "A5E.SenseTremorsenseRange",
    truesight: "A5E.SenseTruesightRange"
  }, d = /* @__PURE__ */ f(({ target: g }) => {
    se(s, g.name, Math.max(Number(g.value), 0));
  }, "change_handler"), p = /* @__PURE__ */ f(({ target: g }) => se(s, g.name, g.value), "change_handler_1"), m = /* @__PURE__ */ f(({ detail: g }) => se(s, "system.attributes.senses.blindsight.otherwiseBlind", g), "updateSelection_handler");
  return i.$$set = (g) => {
    "document" in g && t(4, r = g.document), "appId" in g && t(5, o = g.appId);
  }, [
    s,
    a,
    c,
    u,
    r,
    o,
    d,
    p,
    m
  ];
}
f(lK, "instance$3N");
const lE = class lE extends ie {
  constructor(e) {
    super(), le(this, e, lK, iK, ne, { document: 4, appId: 5 });
  }
};
f(lE, "SensesConfigDialog");
let my = lE;
function rK(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*skillBonus*/
      i[0].formula ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[14]
      ), s = !0);
    },
    p(l, r) {
      r & /*skillBonus*/
      1 && t !== (t = /*skillBonus*/
      l[0].formula ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(rK, "create_default_slot_3$y");
function oK(i) {
  let e, t;
  return e = new de({
    props: {
      heading: "A5E.Formula",
      $$slots: { default: [rK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, skillBonus*/
      2097153 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(oK, "create_default_slot_2$Q");
function aK(i) {
  let e, t;
  return e = new De({
    props: {
      label: "Select Skill Bonus Automatically in Roll Prompt",
      checked: (
        /*skillBonus*/
        i[0].default ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[18]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*skillBonus*/
      1 && (l.checked = /*skillBonus*/
      s[0].default ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(aK, "create_default_slot_1$1c");
function cK(i) {
  let e, t, s, n, l, r, o, a;
  return e = new Ze({
    props: {
      heading: "A5E.contexts.skills",
      options: Object.entries(
        /*skills*/
        i[7]
      ),
      selected: (
        /*skillsContext*/
        i[2]
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[15]
  ), s = new De({
    props: {
      label: "A5E.contexts.requiresProficiency",
      checked: (
        /*requiresProficiency*/
        i[1]
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[16]
  ), l = new De({
    props: {
      label: "A5E.contexts.passiveOnly",
      checked: (
        /*passiveOnly*/
        i[3]
      )
    }
  }), l.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[17]
  ), o = new de({
    props: {
      $$slots: { default: [aK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment), r = R(), L(o.$$.fragment);
    },
    m(c, u) {
      N(e, c, u), T(c, t, u), N(s, c, u), T(c, n, u), N(l, c, u), T(c, r, u), N(o, c, u), a = !0;
    },
    p(c, u) {
      const d = {};
      u & /*skillsContext*/
      4 && (d.selected = /*skillsContext*/
      c[2]), e.$set(d);
      const p = {};
      u & /*requiresProficiency*/
      2 && (p.checked = /*requiresProficiency*/
      c[1]), s.$set(p);
      const m = {};
      u & /*passiveOnly*/
      8 && (m.checked = /*passiveOnly*/
      c[3]), l.$set(m);
      const g = {};
      u & /*$$scope, skillBonus*/
      2097153 && (g.$$scope = { dirty: u, ctx: c }), o.$set(g);
    },
    i(c) {
      a || (w(e.$$.fragment, c), w(s.$$.fragment, c), w(l.$$.fragment, c), w(o.$$.fragment, c), a = !0);
    },
    o(c) {
      C(e.$$.fragment, c), C(s.$$.fragment, c), C(l.$$.fragment, c), C(o.$$.fragment, c), a = !1;
    },
    d(c) {
      c && (S(t), S(n), S(r)), j(e, c), j(s, c), j(l, c), j(o, c);
    }
  };
}
f(cK, "create_default_slot$21");
function uK(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k;
  return d = new Me({
    props: {
      $$slots: { default: [oK] },
      $$scope: { ctx: i }
    }
  }), g = new Me({
    props: {
      heading: "Contexts",
      hint: "The context determines when the ability bonus applies",
      $$slots: { default: [cK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), p = E("div"), L(d.$$.fragment), m = R(), h = E("div"), L(g.$$.fragment), b(s, "class", "bonus-image svelte-1gxe7tx"), ze(s.src, n = /*skillBonus*/
      i[0].img) || b(s, "src", n), b(s, "alt", l = /*skillBonus*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*skillBonus*/
      i[0].label ?? "", b(a, "class", "bonus-name svelte-1gxe7tx"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-1gxe7tx"), b(t, "class", "sheet-header svelte-1gxe7tx"), z(p, "display", "contents"), z(p, "--a5e-section-margin", "0.25rem 0"), z(h, "display", "contents"), z(h, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1gxe7tx");
    },
    m(v, O) {
      T(v, e, O), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, u), A(e, p), N(d, p, null), A(e, m), A(e, h), N(g, h, null), _ = !0, y || (k = [
        V(
          s,
          "click",
          /*click_handler*/
          i[12]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[13]
        )
      ], y = !0);
    },
    p(v, [O]) {
      (!_ || O & /*skillBonus*/
      1 && !ze(s.src, n = /*skillBonus*/
      v[0].img)) && b(s, "src", n), (!_ || O & /*skillBonus*/
      1 && l !== (l = /*skillBonus*/
      v[0].label)) && b(s, "alt", l), (!_ || O & /*skillBonus*/
      1 && c !== (c = /*skillBonus*/
      v[0].label ?? "") && a.value !== c) && (a.value = c);
      const P = {};
      O & /*$$scope, skillBonus*/
      2097153 && (P.$$scope = { dirty: O, ctx: v }), d.$set(P);
      const D = {};
      O & /*$$scope, skillBonus, passiveOnly, requiresProficiency, skillsContext*/
      2097167 && (D.$$scope = { dirty: O, ctx: v }), g.$set(D);
    },
    i(v) {
      _ || (w(d.$$.fragment, v), w(g.$$.fragment, v), _ = !0);
    },
    o(v) {
      C(d.$$.fragment, v), C(g.$$.fragment, v), _ = !1;
    },
    d(v) {
      v && S(e), j(d), j(g), y = !1, Ne(k);
    }
  };
}
f(uK, "create_fragment$3V");
function fK(i, e, t) {
  let s, n, l, r, o, { document: a, bonusID: c } = fe("#external").application, { document: u = a, bonusID: d = c } = e, { jsonValue: p = null } = e;
  const m = u;
  pe(i, m, (H) => t(11, o = H));
  const g = it();
  function h() {
    const H = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: H,
      callback: (U) => {
        _("img", U);
      }
    }).browse();
  }
  f(h, "updateImage");
  function _(H, G) {
    if (p === null) {
      H = `system.bonuses.skills.${d}.${H}`, se(o, H, G);
      return;
    }
    const U = foundry.utils.expandObject({ ...s, [H]: G });
    g("change", JSON.stringify(U));
  }
  f(_, "onUpdateValue");
  function y() {
    if (p === null)
      return o.system.bonuses.skills[d];
    try {
      const H = JSON.parse(p || '""') ?? {};
      if (typeof H != "object")
        throw new Error();
      return H.label = H.label ?? "", H.formula = H.formula ?? "", H.context = H.context ?? {
        skills: [],
        requiresProficiency: !1,
        passiveOnly: !1
      }, H.default = H.default ?? !0, H.img = H.img || "icons/svg/upgrade.svg", H;
    } catch {
      return {
        label: "",
        formula: "",
        damageType: "",
        context: {
          skills: [],
          requiresProficiency: !1,
          passiveOnly: !1
        },
        default: !0,
        img: "icons/svg/upgrade.svg"
      };
    }
  }
  f(y, "getSKillBonus");
  const { skills: k } = CONFIG.A5E, v = /* @__PURE__ */ f(() => h(), "click_handler"), O = /* @__PURE__ */ f(({ target: H }) => _("label", H.value), "change_handler"), P = /* @__PURE__ */ f(({ target: H }) => _("formula", H.value), "change_handler_1"), D = /* @__PURE__ */ f(({ detail: H }) => {
    _("context.skills", H);
  }, "updateSelection_handler"), I = /* @__PURE__ */ f(({ detail: H }) => {
    _("context.requiresProficiency", H);
  }, "updateSelection_handler_1"), B = /* @__PURE__ */ f(({ detail: H }) => {
    _("context.passiveOnly", H);
  }, "updateSelection_handler_2"), F = /* @__PURE__ */ f(({ detail: H }) => {
    _("default", H);
  }, "updateSelection_handler_3");
  return i.$$set = (H) => {
    "document" in H && t(8, u = H.document), "bonusID" in H && t(9, d = H.bonusID), "jsonValue" in H && t(10, p = H.jsonValue);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, jsonValue*/
    3072 && t(0, s = y() ?? {}), i.$$.dirty & /*skillBonus*/
    1 && t(3, n = s.context.passiveOnly ?? !1), i.$$.dirty & /*skillBonus*/
    1 && t(2, l = s.context.skills ?? []), i.$$.dirty & /*skillBonus*/
    1 && t(1, r = s.context.requiresProficiency ?? !1);
  }, [
    s,
    r,
    l,
    n,
    m,
    h,
    _,
    k,
    u,
    d,
    p,
    o,
    v,
    O,
    P,
    D,
    I,
    B,
    F
  ];
}
f(fK, "instance$3M");
const rE = class rE extends ie {
  constructor(e) {
    super(), le(this, e, fK, uK, ne, { document: 8, bonusID: 9, jsonValue: 10 });
  }
};
f(rE, "SkillBonusConfigDialog");
let Wd = rE;
function dI(i) {
  let e, t;
  return e = new Ze({
    props: {
      heading: "Ability Bonuses",
      options: (
        /*abilityBonuses*/
        i[12].map(mI)
      ),
      selected: (
        /*selectedAbilityBonuses*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[26]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*abilityBonuses*/
      4096 && (l.options = /*abilityBonuses*/
      s[12].map(mI)), n[0] & /*selectedAbilityBonuses*/
      8 && (l.selected = /*selectedAbilityBonuses*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(dI, "create_if_block_1$1o");
function pI(i) {
  let e, t;
  return e = new Ze({
    props: {
      heading: "Skill Bonuses",
      options: (
        /*skillBonuses*/
        i[11].map(hI)
      ),
      selected: (
        /*selectedSkillBonuses*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[27]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*skillBonuses*/
      2048 && (l.options = /*skillBonuses*/
      s[11].map(hI)), n[0] & /*selectedSkillBonuses*/
      4 && (l.selected = /*selectedSkillBonuses*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(pI, "create_if_block$28");
function dK(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), b(e, "id", t = /*$actor*/
      i[6].id + "-" + /*appId*/
      i[15] + "-situational-mods");
    },
    m(l, r) {
      T(l, e, r), qe(
        e,
        /*situationalMods*/
        i[1]
      ), s || (n = V(
        e,
        "input",
        /*input_input_handler*/
        i[28]
      ), s = !0);
    },
    p(l, r) {
      r[0] & /*$actor*/
      64 && t !== (t = /*$actor*/
      l[6].id + "-" + /*appId*/
      l[15] + "-situational-mods") && b(e, "id", t), r[0] & /*situationalMods*/
      2 && e.value !== /*situationalMods*/
      l[1] && qe(
        e,
        /*situationalMods*/
        l[1]
      );
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(dK, "create_default_slot$20");
function pK(i) {
  let e, t, s, n, l, r, o, a, c, u, d = Object.values(
    /*abilityBonuses*/
    i[12]
  ).flat().length, p, m = Object.values(
    /*skillBonuses*/
    i[11]
  ).flat().length, g, h, _, y, k, v, O, P, D, I, B;
  function F(q) {
    i[22](q);
  }
  f(F, "outputvisibilitysection_visibilityMode_binding");
  let H = {};
  /*visibilityMode*/
  i[7] !== void 0 && (H.visibilityMode = /*visibilityMode*/
  i[7]), t = new ma({ props: H }), st.push(() => mt(t, "visibilityMode", F)), l = new ml({
    props: {
      selected: (
        /*rollMode*/
        i[4]
      ),
      source: (
        /*rollModeString*/
        i[9]
      )
    }
  }), l.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[23]
  ), o = new Ye({
    props: {
      heading: "A5E.AbilityScore",
      options: Object.entries(
        /*abilities*/
        i[16]
      ),
      selected: (
        /*abilityKey*/
        i[0]
      ),
      allowDeselect: !1
    }
  }), o.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[24]
  ), c = new hn({
    props: {
      source: (
        /*expertiseDieSource*/
        i[10]
      ),
      selected: (
        /*expertiseDie*/
        i[5]
      ),
      type: (
        /*$actor*/
        i[6].type
      )
    }
  }), c.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[25]
  );
  let G = d && dI(i), U = m && pI(i);
  return h = new de({
    props: {
      heading: "A5E.SituationalMods",
      $$slots: { default: [dK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), L(t.$$.fragment), n = R(), L(l.$$.fragment), r = R(), L(o.$$.fragment), a = R(), L(c.$$.fragment), u = R(), G && G.c(), p = R(), U && U.c(), g = R(), L(h.$$.fragment), _ = R(), y = E("section"), k = x(
        /*rollFormula*/
        i[8]
      ), v = R(), O = E("section"), P = E("button"), P.textContent = `${/*buttonText*/
      i[17]}`, b(y, "class", "roll-formula-preview svelte-cfnill"), b(e, "class", "svelte-cfnill");
    },
    m(q, W) {
      T(q, e, W), N(t, e, null), A(e, n), N(l, e, null), A(e, r), N(o, e, null), A(e, a), N(c, e, null), A(e, u), G && G.m(e, null), A(e, p), U && U.m(e, null), A(e, g), N(h, e, null), A(e, _), A(e, y), A(y, k), A(e, v), A(e, O), A(O, P), D = !0, I || (B = V(P, "click", tt(
        /*onSubmit*/
        i[13]
      )), I = !0);
    },
    p(q, W) {
      const X = {};
      !s && W[0] & /*visibilityMode*/
      128 && (s = !0, X.visibilityMode = /*visibilityMode*/
      q[7], _t(() => s = !1)), t.$set(X);
      const te = {};
      W[0] & /*rollMode*/
      16 && (te.selected = /*rollMode*/
      q[4]), W[0] & /*rollModeString*/
      512 && (te.source = /*rollModeString*/
      q[9]), l.$set(te);
      const J = {};
      W[0] & /*abilityKey*/
      1 && (J.selected = /*abilityKey*/
      q[0]), o.$set(J);
      const re = {};
      W[0] & /*expertiseDieSource*/
      1024 && (re.source = /*expertiseDieSource*/
      q[10]), W[0] & /*expertiseDie*/
      32 && (re.selected = /*expertiseDie*/
      q[5]), W[0] & /*$actor*/
      64 && (re.type = /*$actor*/
      q[6].type), c.$set(re), W[0] & /*abilityBonuses*/
      4096 && (d = Object.values(
        /*abilityBonuses*/
        q[12]
      ).flat().length), d ? G ? (G.p(q, W), W[0] & /*abilityBonuses*/
      4096 && w(G, 1)) : (G = dI(q), G.c(), w(G, 1), G.m(e, p)) : G && (ce(), C(G, 1, 1, () => {
        G = null;
      }), ue()), W[0] & /*skillBonuses*/
      2048 && (m = Object.values(
        /*skillBonuses*/
        q[11]
      ).flat().length), m ? U ? (U.p(q, W), W[0] & /*skillBonuses*/
      2048 && w(U, 1)) : (U = pI(q), U.c(), w(U, 1), U.m(e, g)) : U && (ce(), C(U, 1, 1, () => {
        U = null;
      }), ue());
      const ae = {};
      W[0] & /*$actor, situationalMods*/
      66 | W[1] & /*$$scope*/
      8 && (ae.$$scope = { dirty: W, ctx: q }), h.$set(ae), (!D || W[0] & /*rollFormula*/
      256) && _e(
        k,
        /*rollFormula*/
        q[8]
      );
    },
    i(q) {
      D || (w(t.$$.fragment, q), w(l.$$.fragment, q), w(o.$$.fragment, q), w(c.$$.fragment, q), w(G), w(U), w(h.$$.fragment, q), D = !0);
    },
    o(q) {
      C(t.$$.fragment, q), C(l.$$.fragment, q), C(o.$$.fragment, q), C(c.$$.fragment, q), C(G), C(U), C(h.$$.fragment, q), D = !1;
    },
    d(q) {
      q && S(e), j(t), j(l), j(o), j(c), G && G.d(), U && U.d(), j(h), I = !1, B();
    }
  };
}
f(pK, "create_fragment$3U");
const mI = /* @__PURE__ */ f(([i, e]) => [i, e.label || e.defaultLabel], "func$d"), hI = /* @__PURE__ */ f(([i, e]) => [i, e.label || e.defaultLabel], "func_1$4");
function mK(i, e, t) {
  let s, n, l, r, o, a, c, u, d, { document: p, dialog: m, skillKey: g, options: h } = fe("#external").application, { document: _ = p, dialog: y = m, skillKey: k = g, options: v = h } = e;
  function O() {
    return H ? 0 : d.RollOverrideManager.getExpertiseDice(`system.skills.${k}` ?? "", v.expertiseDice ?? 0, { ability: U });
  }
  f(O, "getInitialExpertiseDieSelection");
  function P() {
    y.submit({
      expertiseDie: o,
      rollFormula: X,
      abilityKey: U,
      rollMode: c,
      visibilityMode: q
    });
  }
  f(P, "onSubmit");
  const D = new Bt(_);
  pe(i, D, (Ae) => t(6, d = Ae));
  const I = y.id, B = K(CONFIG.A5E.skills[k]), F = {
    none: "A5E.None",
    ...CONFIG.A5E.abilities
  }, H = game.settings.get("a5e", "hideExpertiseDice"), G = K("A5E.RollPromptAbilityCheck", { ability: B });
  let U = v.abilityKey ?? d.system.skills[k].ability, q = v.visibilityMode ?? game.settings.get("core", "rollMode"), { minRoll: W } = v.minRoll ?? d.system.skills[k], X, te = v.rollMode ?? CONFIG.A5E.ROLL_MODE.NORMAL, J = v.situationalMods ?? "";
  function re(Ae) {
    q = Ae, t(7, q);
  }
  f(re, "outputvisibilitysection_visibilityMode_binding");
  const ae = /* @__PURE__ */ f(({ detail: Ae }) => t(4, c = Ae), "updateSelection_handler"), be = /* @__PURE__ */ f(({ detail: Ae }) => t(0, U = Ae), "updateSelection_handler_1"), we = /* @__PURE__ */ f(({ detail: Ae }) => t(5, o = Ae), "updateSelection_handler_2"), ve = /* @__PURE__ */ f(({ detail: Ae }) => t(3, l = Ae), "updateSelection_handler_3"), me = /* @__PURE__ */ f(({ detail: Ae }) => t(2, r = Ae), "updateSelection_handler_4");
  function he() {
    J = this.value, t(1, J);
  }
  return f(he, "input_input_handler"), i.$$set = (Ae) => {
    "document" in Ae && t(18, _ = Ae.document), "dialog" in Ae && t(19, y = Ae.dialog), "skillKey" in Ae && t(20, k = Ae.skillKey), "options" in Ae && t(21, v = Ae.options);
  }, i.$$.update = () => {
    var Ae;
    i.$$.dirty[0] & /*$actor, abilityKey*/
    65 && t(12, s = d.BonusesManager.prepareAbilityBonuses(U, "check")), i.$$.dirty[0] & /*$actor, skillKey, abilityKey*/
    1048641 && t(11, n = d.BonusesManager.prepareSkillBonuses(k, U)), i.$$.dirty[0] & /*$actor, abilityKey*/
    65 && t(3, l = d.BonusesManager.getDefaultSelections("abilities", { abilityKey: U, abilityType: "check" })), i.$$.dirty[0] & /*$actor, skillKey, abilityKey*/
    1048641 && t(2, r = d.BonusesManager.getDefaultSelections("skills", { skillKey: k, abilityKey: U })), i.$$.dirty[0] & /*$actor, skillKey, options, abilityKey*/
    3145793 && t(10, a = d.RollOverrideManager.getExpertiseDiceSource(`system.skills.${k}`, v.expertiseDice ?? 0, { ability: U })), i.$$.dirty[0] & /*$actor, skillKey, abilityKey*/
    1048641 && t(4, c = d.RollOverrideManager.getRollOverride(`system.skills.${k}`, te, { ability: U })), i.$$.dirty[0] & /*$actor, skillKey, abilityKey*/
    1048641 && t(9, u = (Ae = d.RollOverrideManager) == null ? void 0 : Ae.getRollOverridesSource(`system.skills.${k}`, te, { ability: U })), i.$$.dirty[0] & /*$actor, abilityKey, expertiseDie, rollMode, situationalMods, skillKey, selectedAbilityBonuses, selectedSkillBonuses*/
    1048703 && t(8, X = si(d, {
      ability: U,
      expertiseDie: o,
      minRoll: W,
      rollMode: c,
      situationalMods: J,
      skill: k,
      selectedAbilityBonuses: l,
      selectedSkillBonuses: r,
      type: "skillCheck"
    }));
  }, t(5, o = O()), [
    U,
    J,
    r,
    l,
    c,
    o,
    d,
    q,
    X,
    u,
    a,
    n,
    s,
    P,
    D,
    I,
    F,
    G,
    _,
    y,
    k,
    v,
    re,
    ae,
    be,
    we,
    ve,
    me,
    he
  ];
}
f(mK, "instance$3L");
const oE = class oE extends ie {
  constructor(e) {
    super(), le(
      this,
      e,
      mK,
      pK,
      ne,
      {
        document: 18,
        dialog: 19,
        skillKey: 20,
        options: 21
      },
      null,
      [-1, -1]
    );
  }
};
f(oE, "SkillCheckRollDialog");
let hy = oE;
function hK(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.ProficiencyProficient",
      checked: (
        /*skill*/
        i[2].proficient
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[11]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*skill*/
      4 && (l.checked = /*skill*/
      s[2].proficient), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(hK, "create_else_block$D");
function gK(i) {
  let e, t;
  return e = new Ye({
    props: {
      heading: "Proficiency Level",
      options: [[0, "None"], [1, "Proficient"], [2, "Expertise"]],
      selected: (
        /*skill*/
        i[2].proficient
      ),
      allowDeselect: !1
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[10]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*skill*/
      4 && (l.selected = /*skill*/
      s[2].proficient), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(gK, "create_if_block_1$1n");
function bK(i) {
  let e, t, s, n;
  const l = [gK, hK], r = [];
  function o(a, c) {
    return (
      /*dnd5eStyleExpertise*/
      a[6] ? 0 : 1
    );
  }
  return f(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      t.p(a, c);
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), r[e].d(a);
    }
  };
}
f(bK, "create_default_slot_2$P");
function _K(i) {
  let e, t;
  return e = new Dc({
    props: {
      heading: "A5E.SkillSpecialties",
      options: (
        /*specialtyOptions*/
        i[5]
      ),
      selected: (
        /*skill*/
        i[2].specialties
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[12]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*skill*/
      4 && (l.selected = /*skill*/
      s[2].specialties), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(_K, "create_if_block$27");
function yK(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("div"), t = E("input"), b(t, "class", "a5e-input"), b(t, "type", "number"), t.value = s = /*skill*/
      i[2].minRoll, b(t, "min", "0"), b(e, "class", "u-w-20");
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = V(
        t,
        "change",
        /*change_handler*/
        i[15]
      ), n = !0);
    },
    p(r, o) {
      o & /*skill*/
      4 && s !== (s = /*skill*/
      r[2].minRoll) && t.value !== s && (t.value = s);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(yK, "create_default_slot_1$1b");
function vK(i) {
  let e, t, s, n, l, r, o, a, c, u;
  e = new de({
    props: {
      $$slots: { default: [bK] },
      $$scope: { ctx: i }
    }
  });
  let d = !/*hideSkillSpecialties*/
  i[7] && _K(i);
  return n = new Ye({
    props: {
      heading: "A5E.AbilityScore",
      optionStyles: "min-width:2rem; text-align: center;",
      options: [
        .../*abilityOptions*/
        i[4],
        ["@attributes.spellcasting", "Spellcasting"]
      ],
      selected: (
        /*$actor*/
        i[1]._source.system.skills[
          /*skillKey*/
          i[0]
        ].ability
      ),
      allowDeselect: !1
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[13]
  ), r = new hn({
    props: {
      selected: (
        /*skill*/
        i[2].expertiseDice
      ),
      type: (
        /*$actor*/
        i[1].type
      )
    }
  }), r.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[14]
  ), a = new de({
    props: {
      heading: "A5E.MinimumD20Roll",
      $$slots: { default: [yK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), d && d.c(), s = R(), L(n.$$.fragment), l = R(), L(r.$$.fragment), o = R(), c = E("div"), L(a.$$.fragment), z(c, "display", "contents"), z(c, "--direction", "column");
    },
    m(p, m) {
      N(e, p, m), T(p, t, m), d && d.m(p, m), T(p, s, m), N(n, p, m), T(p, l, m), N(r, p, m), T(p, o, m), T(p, c, m), N(a, c, null), u = !0;
    },
    p(p, m) {
      const g = {};
      m & /*$$scope, skill, $actor, skillKey*/
      65543 && (g.$$scope = { dirty: m, ctx: p }), e.$set(g), /*hideSkillSpecialties*/
      p[7] || d.p(p, m);
      const h = {};
      m & /*$actor, skillKey*/
      3 && (h.selected = /*$actor*/
      p[1]._source.system.skills[
        /*skillKey*/
        p[0]
      ].ability), n.$set(h);
      const _ = {};
      m & /*skill*/
      4 && (_.selected = /*skill*/
      p[2].expertiseDice), m & /*$actor*/
      2 && (_.type = /*$actor*/
      p[1].type), r.$set(_);
      const y = {};
      m & /*$$scope, skill, $actor, skillKey*/
      65543 && (y.$$scope = { dirty: m, ctx: p }), a.$set(y);
    },
    i(p) {
      u || (w(e.$$.fragment, p), w(d), w(n.$$.fragment, p), w(r.$$.fragment, p), w(a.$$.fragment, p), u = !0);
    },
    o(p) {
      C(e.$$.fragment, p), C(d), C(n.$$.fragment, p), C(r.$$.fragment, p), C(a.$$.fragment, p), u = !1;
    },
    d(p) {
      p && (S(t), S(s), S(l), S(o)), j(e, p), d && d.d(p), j(n, p), j(r, p), p && a && S(c), j(a, p);
    }
  };
}
f(vK, "create_default_slot$1$");
function kK(i) {
  let e, t, s, n;
  return t = new Me({
    props: {
      $$slots: { default: [vK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("article"), s = E("div"), L(t.$$.fragment), z(s, "display", "contents"), z(s, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-1os9nuq");
    },
    m(l, r) {
      T(l, e, r), A(e, s), N(t, s, null), n = !0;
    },
    p(l, [r]) {
      const o = {};
      r & /*$$scope, skill, $actor, skillKey*/
      65543 && (o.$$scope = { dirty: r, ctx: l }), t.$set(o);
    },
    i(l) {
      n || (w(t.$$.fragment, l), n = !0);
    },
    o(l) {
      C(t.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(e), j(t);
    }
  };
}
f(kK, "create_fragment$3T");
function wK(i, e, t) {
  let s, n, { document: l, appId: r, skillKey: o } = fe("#external").application, { document: a = l, appId: c = r, skillKey: u = o } = e;
  const d = a;
  pe(i, d, (D) => t(1, n = D));
  const p = ci(), m = Object.entries(CONFIG.A5E.skillSpecialties[u]);
  let g = game.settings.get("a5e", "5eStyleExpertise"), h = game.settings.get("a5e", "hideSkillSpecialties") ?? !1;
  const _ = /* @__PURE__ */ f(({ detail: D }) => {
    se(n, `system.skills.${u}.proficient`, D);
  }, "updateSelection_handler"), y = /* @__PURE__ */ f(({ detail: D }) => {
    se(n, `system.skills.${u}.proficient`, D);
  }, "updateSelection_handler_1"), k = /* @__PURE__ */ f((D) => se(n, `system.skills.${u}.specialties`, D.detail), "updateSelection_handler_2"), v = /* @__PURE__ */ f((D) => se(n, `system.skills.${u}.ability`, D.detail), "updateSelection_handler_3"), O = /* @__PURE__ */ f(({ detail: D }) => se(n, `system.skills.${u}.expertiseDice`, D), "updateSelection_handler_4"), P = /* @__PURE__ */ f(({ target: D }) => se(n, `system.skills.${u}.minRoll`, Number(D.value)), "change_handler");
  return i.$$set = (D) => {
    "document" in D && t(8, a = D.document), "appId" in D && t(9, c = D.appId), "skillKey" in D && t(0, u = D.skillKey);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, skillKey*/
    3 && t(2, s = n.system.skills[u]);
  }, [
    u,
    n,
    s,
    d,
    p,
    m,
    g,
    h,
    a,
    c,
    _,
    y,
    k,
    v,
    O,
    P
  ];
}
f(wK, "instance$3K");
const aE = class aE extends ie {
  constructor(e) {
    super(), le(this, e, wK, kK, ne, { document: 8, appId: 9, skillKey: 0 });
  }
};
f(aE, "SkillConfigDialog");
let gy = aE;
const cE = class cE extends Ms {
  initialize() {
    this.filters.add((e) => {
      var s, n;
      return ((s = e == null ? void 0 : e.changes) == null ? void 0 : s.find((l) => l.key === "flags.a5e.effects.statusConditions")) ? !0 : ((n = e == null ? void 0 : e.statuses) == null ? void 0 : n.size) === 0;
    }), this.sort.set((e, t) => {
      var s, n, l, r;
      return (((n = (s = e == null ? void 0 : e.flags) == null ? void 0 : s.a5e) == null ? void 0 : n.sort) ?? 0) - (((r = (l = t == null ? void 0 : t.flags) == null ? void 0 : l.a5e) == null ? void 0 : r.sort) ?? 0);
    }), this._types = {
      ongoing: this.derived.create("passive"),
      inactive: this.derived.create("inactive")
    }, this._types.ongoing.filters.add((e) => !e.isSuppressed), this._types.inactive.filters.add((e) => e.isSuppressed);
  }
};
f(cE, "ActorActiveEffectMapReducer");
let by = cE;
const uE = class uE extends Ms {
  initialize() {
    this.sort.set((e, t) => {
      var s, n, l, r;
      return (((n = (s = e == null ? void 0 : e.flags) == null ? void 0 : s.a5e) == null ? void 0 : n.sort) ?? 0) - (((r = (l = t == null ? void 0 : t.flags) == null ? void 0 : l.a5e) == null ? void 0 : r.sort) ?? 0);
    }), this._types = {
      onUse: this.derived.create("onUse"),
      passive: this.derived.create("passive")
    }, this._types.onUse.filters.add((e) => e.getFlag("a5e", "transferType") === "onUse"), this._types.passive.filters.add((e) => e.getFlag("a5e", "transferType") === "passive");
  }
};
f(uE, "ItemActiveEffectMapReducer");
let _y = uE;
var Ou;
const fE = class fE extends Bt {
  constructor(t, s) {
    super(t, s);
    Y(this, Ou, void 0);
    ye(this, Ou, this.embedded.create(ActiveEffect, _y));
  }
  get activeEffects() {
    return M(this, Ou);
  }
};
Ou = new WeakMap(), f(fE, "ItemDocument");
let Kd = fE;
var Du, yy;
const dE = class dE extends Fs {
  constructor(t, s, n, l = {}, r = {}) {
    const o = r.isItemDocument ? new Kd(t) : new Bt(t);
    delete r.isItemDocument;
    super({
      title: s,
      content: {
        class: n,
        props: { document: o, ...l }
      },
      zIndex: null
    }, {
      classes: ["a5e-sheet"],
      width: r.width ?? 420,
      height: r.height ?? "auto",
      resizable: r.resizable ?? !1
    });
    Y(this, Du);
    this.data.content.props.dialog = this, this.promise = new Promise((a) => {
      this.resolve = a;
    });
  }
  /** @inheritdoc */
  close(t) {
    var s;
    return Z(this, Du, yy).call(this, null), (s = this.document) == null || s.destroy(), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    var s;
    return Z(this, Du, yy).call(this, t), (s = this.document) == null || s.destroy(), super.close();
  }
};
Du = new WeakSet(), yy = /* @__PURE__ */ f(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), f(dE, "GenericConfigDialog");
let gn = dE;
var Iu, vy;
const pE = class pE extends Fs {
  constructor(t, s, n, l = {}, r = {}, o = {}) {
    super({
      title: s,
      content: {
        class: n,
        props: { document: t, ...l, options: r }
      },
      zIndex: null
    }, {
      classes: ["a5e-sheet"],
      height: o.height ?? "auto",
      width: o.width ?? 420,
      resizable: o.resizable ?? !1
    });
    Y(this, Iu);
    this.data.content.props.dialog = this, this.promise = new Promise((a) => {
      this.resolve = a;
    });
  }
  /** @inheritdoc */
  close(t) {
    return Z(this, Iu, vy).call(this, null), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    return Z(this, Iu, vy).call(this, t), super.close();
  }
};
Iu = new WeakSet(), vy = /* @__PURE__ */ f(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), f(pE, "GenericRollDialog");
let so = pE;
async function gI(i, e, t, s) {
  var u, d;
  if (game.user.id !== t || (s = i.type === "npc" && s === "unconscious" ? "dead" : s, !((d = (u = e == null ? void 0 : e.system) == null ? void 0 : u.attributes) != null && d.hp)))
    return;
  const { value: n, max: l } = i.system.attributes.hp, r = CONFIG.statusEffects.find((p) => p.id === s);
  if (!r)
    return;
  const o = s === "bloodied" ? n <= l / 2 && n > 0 : n <= 0, a = ["unconscious", "dead"].includes(s), c = i.statuses.has(s);
  if (i.prototypeToken.actorLink && i.parent === null) {
    if (o && !c) {
      const p = foundry.utils.deepClone(r);
      p.label = game.i18n.localize(r.label), p.statuses = [r.id], delete p.id;
      const m = getDocumentClass("ActiveEffect");
      m.migrateDataSafe(p), m.cleanData(p), p.name = game.i18n.localize(p.name), await m.create(p, { parent: i }), Hooks.callAll(`a5e.${s}`, i, !0);
    } else if (!o && c) {
      const p = i.effects.reduce((m, g) => (g.statuses.size === 1 && g.statuses.has(s) && m.push(g.id), m), []);
      p.length && await i.deleteEmbeddedDocuments("ActiveEffect", p);
    }
  } else
    i.type === "npc" && i.token !== null && (o && !c ? (i.token.toggleActiveEffect(r, { overlay: a }), Hooks.callAll(`a5e.${s}`, i, !0)) : !o && c && i.token.toggleActiveEffect(r, { overlay: a }));
}
f(gI, "automateHpConditions");
async function $K(i, e, t) {
  var r;
  if (game.user.id !== t)
    return;
  const s = /* @__PURE__ */ new Set(["fatigue", "exhaustion", "strife"]), n = new Set(Object.keys(((r = e == null ? void 0 : e.system) == null ? void 0 : r.attributes) ?? {})), l = s.intersection(n);
  l != null && l.size && l.forEach((o) => {
    const a = e.system.attributes[o], c = i.getActiveTokens(), u = CONFIG.statusEffects.find((m) => m.id === o);
    if (!(c != null && c.length) || !u)
      return;
    const d = o === "fatigue" && game.settings.get("a5e", "replaceFatigueAndStrife") ? "exhaustion" : o, p = Object.entries(CONFIG.A5E.multiLevelConditions[d] ?? {}).reduce((m, [g, h]) => (g > a || m.push(...h), m), []);
    c.map(async (m) => {
      const g = foundry.utils.deepClone(u);
      g.changes = p, await m.toggleEffect(u, { active: !1 }), a !== 0 && await m.toggleEffect(g, { active: !0 });
    });
  });
}
f($K, "automateMultiLevelConditions");
async function zf(i, e, t, s) {
  var o, a;
  const n = await ((o = i.getActiveTokens()) == null ? void 0 : o[0]);
  if (!n)
    return;
  const l = e === "damage" ? "damageColors" : "healingColors", r = ((a = CONFIG.A5E[l]) == null ? void 0 : a[s]) ?? "#fff";
  canvas.interface.createScrollingText(n == null ? void 0 : n.center, t, { fill: r });
}
f(zf, "displayCascadingNumbers");
var Pu, bh, Y9, _h, X9, yh, J9, Yt, es;
const mE = class mE extends Actor {
  constructor(...t) {
    super(...t);
    Y(this, bh);
    Y(this, _h);
    Y(this, yh);
    Y(this, Yt);
    Y(this, Pu, void 0);
    this.dialogs ?? (this.dialogs = {
      abilities: {},
      bonuses: {},
      genericResources: {},
      skills: {},
      notes: {}
    }), ye(this, Pu, {
      ability: Q_,
      abilityBonus: Gd,
      alignment: ws,
      armor: ws,
      armorClass: ry,
      attackBonus: zd,
      conditionImmunities: ws,
      damageBonus: Hd,
      damageImmunities: ws,
      damageResistances: ws,
      damageVulnerabilities: ws,
      exertionBonus: oy,
      healingBonus: Vd,
      hitPointsBonus: ay,
      health: sy,
      initiative: ny,
      initiativeBonus: Ud,
      languages: ws,
      maneuvers: iy,
      maneuverTraditions: ws,
      movement: uy,
      movementBonus: cy,
      senses: my,
      sensesBonus: py,
      size: ws,
      skill: gy,
      skillBonus: Wd,
      spells: ly,
      terrain: ws,
      tools: ws,
      types: ws,
      weapons: ws
    });
  }
  /**
   * @returns {Array<ActiveEffectA5e>}
   */
  get actorEffects() {
    return this.effects.map((t) => t);
  }
  /**
   * @returns {Number}
   */
  get isBloodied() {
    const { max: t, value: s } = this.system.attributes.hp;
    return s / t * 100 <= 50;
  }
  /**
   * @override
   * An array of ActiveEffect instances which are present on the
   * Actor which have a limited duration.
   * @type {ActiveEffect[]}
   */
  get temporaryEffects() {
    var s, n;
    const t = [];
    for (const l of this.allApplicableEffects())
      l.active && (l.isTemporary || ((n = (s = l == null ? void 0 : l.flags) == null ? void 0 : s.a5e) == null ? void 0 : n.transferType) === "onUse") && t.push(l);
    return t.sort((l, r) => l.name.localeCompare(r.name));
  }
  get visionData() {
    const { senses: t } = this.system.attributes;
    return {
      hasBlindsight: t.blindsight.distance > 0,
      hasDarkvision: t.darkvision.distance > 0,
      hasTremorsense: t.tremorsense.distance > 0,
      hasTruesight: t.truesight.distance > 0,
      senses: t
    };
  }
  // -------------------------------------------------------------
  // Data Preparation Methods
  // -------------------------------------------------------------
  /**
   * Sets the order of when to prepare data.
   * @override
   */
  prepareData() {
    var t, s;
    this.BonusesManager = null, this.HitDiceManager = null, this.grants = null, this.spellBooks = null, this.RollOverrideManager = null, this.prepareBaseData(), super.prepareEmbeddedDocuments(), this.prepareDerivedData(), this.afterDerivedData(), !((((t = this.system.schemaVersion) == null ? void 0 : t.version) ?? ((s = this.system.schema) == null ? void 0 : s.version)) < 5e-3) && (this.prepareArmorClass(), this.RollOverrideManager.initialize(), this.spellBooks = new Y_(this), this.spellBooks.forEach((n) => n.prepareBaseData()));
  }
  /**
   * Prepare base data for the actor.
   * @override
   */
  prepareBaseData() {
    var t, s;
    this.BonusesManager = new W_(this), this.RollOverrideManager = new X_(this), this.grants = new U_(this), (((t = this.system.schemaVersion) == null ? void 0 : t.version) ?? ((s = this.system.schema) == null ? void 0 : s.version)) >= 5e-3 && (typeof this.system.attributes.ac != "object" && (this.system.attributes.ac = { baseFormula: `${this.system.attributes.ac}` }), this.system.attributes.ac.changes = {
      override: null,
      bonuses: { components: [], value: 0 }
    });
  }
  /**
     * Apply activeEffects to the actor with the phase 'applyAEs'.
     * @override
     */
  applyActiveEffects() {
    this.overrides = {}, this.statuses ?? (this.statuses = /* @__PURE__ */ new Set());
    const t = /* @__PURE__ */ new Map();
    Object.values(CONFIG.specialStatusEffects).forEach((n) => {
      t.set(n, this.statuses.has(n));
    }), this.statuses.clear(), this.effectPhases ?? (this.effectPhases = {
      beforeDerived: [],
      afterDerived: []
    }), da.applyEffects(
      this,
      this.actorEffects,
      "applyAEs",
      "afterDerived",
      (n) => {
        var l;
        return ((l = game.a5e.activeEffects.options[this.type].allOptions[n.key]) == null ? void 0 : l.phase) === "applyAEs";
      }
    );
    let s;
    for (const [n, l] of t) {
      const r = this.statuses.has(n);
      if (r === l)
        return;
      s ?? (s = this.getActiveTokens()), s.forEach((o) => o._onApplyStatusEffect(n, r));
    }
  }
  /**
     * Prepares derived data for the actor.
     * @override
     */
  prepareDerivedData() {
    var s, n, l;
    const t = this.system;
    Object.entries(t.abilities).forEach(([r, o]) => {
      const a = at(
        [
          o.value,
          this.BonusesManager.getAbilityBonusesFormula(r, "base").trim()
        ].filter(Boolean).join(" + ")
      );
      o.value = a ?? o.value;
    }), Object.values(t.abilities).forEach((r) => {
      const o = Math.floor((r.value - 10) / 2);
      r.check.mod = o, r.save.mod = o + (r.save.proficient ? t.attributes.prof : 0);
    }), Object.entries(t.abilities).forEach(([r, o]) => {
      ["check", "save"].forEach((a) => {
        let c;
        try {
          c = at(
            [
              o[a].mod,
              this.BonusesManager.getAbilityBonusesFormula(r, a).trim()
            ].filter(Boolean).join(" + "),
            this.getRollData()
          );
        } finally {
          o[a].deterministicBonus = c ?? o[a].mod;
        }
      });
    });
    try {
      t.attributes.maneuverDC = at([
        8,
        t.attributes.prof,
        t.bonuses.maneuverDC,
        Math.max(t.abilities.str.check.mod, t.abilities.dex.check.mod)
      ].join(" + "), this.getRollData());
    } catch {
      console.error(`Failed to calculate a maneuver DC for ${this.name}`), t.attributes.maneuverDC = null;
    }
    try {
      t.attributes.spellDC = at([
        8,
        t.attributes.prof,
        ((s = t.bonuses) == null ? void 0 : s.spellDC) || 0,
        t.abilities[t.attributes.spellcasting || "int"].check.mod
      ].join(" + "), this.getRollData());
    } catch {
      console.error(`Failed to calculate a spell DC for ${this.name}`), t.attributes.spellDC = null;
    }
    this.prepareHitPointBonuses(), this.prepareSkills(), this.prepareMovement(), this.prepareSenses(), !((((n = this.system.schemaVersion) == null ? void 0 : n.version) ?? ((l = this.system.schema) == null ? void 0 : l.version)) < 5e-3) && foundry.utils.setProperty(this, "system.attributes.ac.changes", this.prepareArmorChanges());
  }
  prepareArmorClass() {
    var a, c, u;
    const t = this.system.attributes.ac.changes ?? {};
    let s = "Natural Armor";
    const n = at(
      `${this.system.attributes.ac.baseFormula}` || "10 + @dex.mod",
      this.getRollData()
    ), l = foundry.utils.getProperty(this.overrides, "system.attributes.ac.value");
    if (l != null) {
      const d = this.actorEffects.findLast((h) => h.changes.some((_) => _.key.includes("ac.value")) && !h.isSuppressed), p = (((a = t.override) == null ? void 0 : a.value) ?? n) + t.bonuses.value;
      foundry.utils.mergeObject(this.system.attributes.ac, {
        changes: t,
        value: parseInt(p, 10) || 10
      });
      const m = d.apply(
        this,
        d.changes.find((h) => h.key.includes("ac.value")),
        "afterDerived"
      ), g = ((c = Object.values(m)) == null ? void 0 : c[0]) ?? l;
      s = (d == null ? void 0 : d.name) ?? s, t.override = { name: s, mode: CONFIG.A5E.ARMOR_MODES.OVERRIDE, value: g }, t.bonuses = {
        components: [],
        value: 0
      };
    }
    if (foundry.utils.getProperty(this.overrides, "system.attributes.ac.baseFormula") && !l) {
      const d = this.actorEffects.findLast((p) => p.changes.some((m) => m.key.includes("ac.baseFormula")) && !p.isSuppressed);
      s = (d == null ? void 0 : d.name) ?? s, t.override = { name: s, mode: CONFIG.A5E.ARMOR_MODES.OVERRIDE, value: n };
    }
    t.override ?? (t.override = {
      name: "Natural Armor",
      mode: CONFIG.A5E.ARMOR_MODES.OVERRIDE,
      formula: this.system.attributes.ac.baseFormula,
      value: n
    });
    const o = (((u = t.override) == null ? void 0 : u.value) ?? n) + t.bonuses.value;
    foundry.utils.mergeObject(this.system.attributes.ac, {
      changes: t,
      value: parseInt(o, 10) || 10
    });
  }
  determineDefenseConfiguration() {
    return this.items.reduce((t, s) => {
      if (s.system.equippedState !== CONFIG.A5E.EQUIPPED_STATES.EQUIPPED)
        return t;
      const { formula: n } = s.system.ac ?? {};
      return n && (s.system.objectType === "armor" ? t.hasArmor = !0 : s.system.objectType === "shield" && (t.hasShield = !0)), t;
    }, { hasArmor: !1, hasShield: !1 });
  }
  prepareArmorChanges() {
    const { hasArmor: t, hasShield: s } = this.determineDefenseConfiguration(), n = this.items.reduce((r, o) => {
      var g;
      const {
        formula: a,
        mode: c,
        requiresUnarmored: u,
        requiresNoShield: d
      } = o.system.ac ?? {};
      if (!a || o.type === "feature" && c === CONFIG.A5E.ARMOR_MODES.OVERRIDE && t || u && t || d && s || o.type === "object" && o.system.equippedState !== CONFIG.A5E.EQUIPPED_STATES.EQUIPPED || o.system.objectType === "armor" && o.system.materialProperties.includes("underarmor") && r.override)
        return r;
      const p = at(a, this.getRollData()) ?? 0, m = {
        name: o.name,
        id: o.uuid,
        mode: c,
        value: p
      };
      return c === CONFIG.A5E.ARMOR_MODES.OVERRIDE ? r.override = m : o.system.objectType === "shield" && p > (((g = r.shield) == null ? void 0 : g.value) ?? 0) ? r.shield = m : r.bonuses.push(m), r;
    }, { override: null, shield: null, bonuses: [] });
    n.shield && n.bonuses.unshift(n.shield), delete n.shield;
    const l = n.bonuses.reduce((r, { value: o }) => r + o, 0);
    return n.bonuses = { components: n.bonuses, value: l }, n;
  }
  /**
  * Prepare hit point bonuses for the actor.
  */
  prepareHitPointBonuses() {
    const { max: t } = this.system.attributes.hp, s = at(
      this.BonusesManager.getHitPointsBonusFormula(),
      this.getRollData()
    );
    foundry.utils.setProperty(
      this,
      "system.attributes.hp.max",
      (t || 0) + s
    );
  }
  /**
  * Prepare skill data for the actor.
  */
  prepareSkills() {
    var l;
    const t = this.system, s = t.attributes.prof, n = (l = this.flags.a5e) == null ? void 0 : l.jackOfAllTrades;
    Object.values(t.skills).forEach((r) => {
      r.proficient === 2 ? r.mod = s * 2 : r.proficient ? r.mod = s : n ? r.mod = Math.floor(s / 2) : r.mod = 0, r.ability.startsWith("@attributes.spellcasting") && (r.ability = t.attributes.spellcasting);
    }), Object.entries(t.skills).forEach(([r, o]) => {
      const a = K(CONFIG.A5E.skills[r]);
      let c;
      try {
        c = at(
          [
            o.mod,
            this.BonusesManager.getSkillBonusesFormula(r, o.ability, "check", !0)
          ].filter(Boolean).join(" + "),
          this.getRollData()
        );
      } catch {
        console.error(`Couldn't calculate a ${a} modifier for ${this.name}`);
      }
      o.deterministicBonus = c ?? o.mod;
      try {
        o.passive = this._calculatePassiveScore(r, o);
      } catch {
        console.error(`Couldn't calculate a ${a} passive score for ${this.name}`), o.passive = null;
      }
    });
  }
  /**
  * Calculate passive score for this actor.
  * @param {String} skillKey - The key of the skill to calculate the passive score for.
  * @param {Object} skill    - The skill object to calculate the passive score for.
  */
  _calculatePassiveScore(t, s) {
    var l, r;
    const n = this.getRollData();
    return at([
      10,
      s.mod,
      ((r = (l = n.abilities[s.ability]) == null ? void 0 : l.check) == null ? void 0 : r.deterministicBonus) ?? 0,
      this.BonusesManager.getSkillBonusesFormula(t, s.ability, "passive", !1)
    ].filter(Boolean).join(" + "), n);
  }
  /**
  * Prepare movement data taking into account any bonuses.
  */
  prepareMovement() {
    const { movement: t } = this.system.attributes;
    for (const [s, { distance: n }] of Object.entries(t)) {
      const l = this.BonusesManager.getMovementBonusFormula(s);
      if (!l)
        continue;
      const r = at(l, this.getRollData());
      r && (this.system.attributes.movement[s].distance = n + r);
    }
  }
  /**
  * Prepare senses data taking into account any bonuses.
  */
  prepareSenses() {
    const { senses: t } = this.system.attributes;
    for (const [s, { distance: n }] of Object.entries(t)) {
      const l = this.BonusesManager.getSensesBonusFormula(s);
      if (!l)
        continue;
      if (l === "unlimited") {
        this.system.attributes.senses[s].distance = 0, this.system.attributes.senses[s].unit = "unlimited";
        continue;
      }
      const r = at(l, this.getRollData());
      r && (this.system.attributes.senses[s].distance = n + r);
    }
  }
  /**
  * Prepare active effects for the actor with the phase 'afterDerived'.
  */
  afterDerivedData() {
    da.applyEffects(
      this,
      this.actorEffects,
      "afterDerived",
      null,
      (t) => {
        var s;
        return ((s = game.a5e.activeEffects.options[this.type].allOptions[t.key]) == null ? void 0 : s.phase) === "afterDerived";
      }
    );
  }
  // -------------------------------------------------------------
  // Data Update Helpers
  // -------------------------------------------------------------
  async applyBulkDamage(t) {
    const s = {}, { value: n, temp: l } = this.system.attributes.hp, r = t.reduce(
      (o, [a]) => o + Math.floor(a),
      0
    );
    if (l ? s["system.attributes.hp"] = {
      temp: Math.clamped(l - r, 0, l),
      value: Math.clamped(n + l - r, 0, n)
    } : s["system.attributes.hp.value"] = Math.clamped(n - r, 0, n), game.settings.get("a5e", "enableCascadingDamageAndHealing")) {
      const o = this, a = game.settings.get("a5e", "cascadingDamageAndHealingDelay");
      let c = 0;
      t.forEach(([u, d]) => {
        setTimeout(async () => {
          await zf(o, "damage", `-${u}`, d);
        }, c), c += a;
      });
    }
    return Hooks.callAll("a5e.actorDamaged", this, { prevHp: { value: n, temp: l }, damageRolls: t }), this.update(s);
  }
  /**
    * Apply a certain amount of damage to the health pool for Actor, prioritizing temporary hp.
    * Negative damage values will have no effect.
    *
    * @param {number} damage  An amount of damage to apply to the actor.
    * @param {string} damageType A key indicating the type of damage the actor is taking.
    *
    * @returns {Promise<Actor5e>}  A Promise which resolves once the damage has been applied
  */
  async applyDamage(t, s = null) {
    const n = {}, { value: l, temp: r } = this.system.attributes.hp;
    return t = Math.floor(t), r ? n["system.attributes.hp"] = {
      temp: Math.clamped(r - t, 0, r),
      value: Math.clamped(l + r - t, 0, l)
    } : n["system.attributes.hp.value"] = Math.clamped(l - t, 0, l), game.settings.get("a5e", "enableCascadingDamageAndHealing") && zf(this, "damage", `-${t}`, s), Hooks.callAll("a5e.actorDamaged", this, { prevHp: { value: l, temp: r }, damage: t, damageType: s }), this.update(n);
  }
  async applyBulkHealing(t) {
    const s = {}, { value: n, max: l, temp: r } = this.system.attributes.hp;
    let o = !0;
    const { healing: a, temp: c } = t.reduce(
      (u, [d, p]) => (p === "temporaryHealing" ? u.temp += d : u.healing += d, u),
      { healing: 0, temp: 0 }
    );
    if (c && c <= r ? (ui.notifications.warn("A5E.ActionWarningTempHpNotOverwritten", { localize: !0 }), o = !1) : s["system.attributes.hp.temp"] = c, s["system.attributes.hp.value"] = Math.clamped(n + a, n, l), game.settings.get("a5e", "enableCascadingDamageAndHealing")) {
      const u = this, d = game.settings.get("a5e", "cascadingDamageAndHealingDelay");
      let p = 0;
      t.forEach(([m, g]) => {
        !o && g === "temporaryHealing" || (setTimeout(async () => {
          await zf(u, "healing", `+${m}`, g);
        }, p), p += d);
      });
    }
    return Hooks.callAll("a5e.actorHealed", this, { prevHp: { value: n, temp: r }, healingRolls: t }), this.update(s);
  }
  /**
   * Apply a certain amount of healing to the health pool for Actor. Temporary healing can be set
   * using a flag in the options object.
   *
   * When dealing with temporary hp, providing a value below the current temp hp of the target will
   * trigger a warning and abort the update of the actor.
   *
   * Negative healing value are ignored.
   *
   * @param {number} healing        An amount of damage to apply to the actor.
   * @param {string} healingType    A flag for indicating whether the healing being applied is
   *                                temporary.
   *
   * @returns {Promise<Actor5e>}  A Promise which resolves once the damage has been applied
  */
  async applyHealing(t, s) {
    const n = {}, { value: l, max: r, temp: o } = this.system.attributes.hp;
    if (t = Math.floor(t), s === "temporaryHealing") {
      if (t <= o)
        return ui.notifications.warn("A5E.ActionWarningTempHpNotOverwritten", { localize: !0 }), this;
      n["system.attributes.hp.temp"] = t;
    } else
      n["system.attributes.hp.value"] = Math.clamped(l + t, l, r);
    return game.settings.get("a5e", "enableCascadingDamageAndHealing") && zf(this, "healing", `+${t}`, s), Hooks.callAll("a5e.actorHealed", this, { prevHp: { value: l, temp: o }, healing: t, healingType: s }), this.update(n);
  }
  /** @inheritdoc */
  getRollData(t = null) {
    const s = { ...super.getRollData() }, { abilities: n, skills: l } = this.system;
    if (s.prof = this.system.attributes.prof || 0, Object.entries(n).reduce((r, [o, a]) => (r.abilities ?? (r.abilities = {}), r.abilities[o] = { ...a, mod: a.check.mod }, r[o] = { ...a, mod: a.check.mod }, r), s), Object.entries(l).reduce((r, [o, a]) => (r.skills ?? (r.skills = {}), r.skills[o] = a, r[o] = a, r), s), s.finesse = {
      mod: Math.max(s.dex.mod, s.str.mod)
    }, s.level = this.system.details.level, s.maneuverDC = this.system.attributes.maneuverDC, t && (s.item = t.getRollData()), t && t.type === "spell") {
      const r = this.spellBooks.get(t.system.spellBook);
      r && (s.spell = { mod: r.stats.mod }, s.spellcasting = { mod: r.stats.mod }, s.spellDC = r.stats.dc);
    }
    return (!s.spell || !s.spellDC) && (s.spell = { mod: this._calculateSpellcastingMod() }, s.spellcasting = { mod: s.spell.mod }, s.spellDC = this.system.attributes.spellDC), s;
  }
  _calculateSpellcastingMod() {
    const { abilities: t, attributes: s } = this.system, n = s.spellcasting || "int";
    return t[n].check.mod;
  }
  async modifyTokenAttribute(t, s, n, l) {
    if (t === "attributes.hp") {
      const r = getProperty(this.system, t), a = r.value + r.temp - s;
      return n ? s <= 0 ? this.applyDamage(-1 * s) : this.applyHealing(s) : a <= 0 ? this.applyHealing(-1 * a) : this.applyDamage(a);
    }
    return super.modifyTokenAttribute(t, s, n, l);
  }
  // -------------------------------------------------------------
  // Resources Reset Handlers
  // -------------------------------------------------------------
  /**
   *
   * @param {Object} restOptions
   * @param {Boolean} restOptions.consumeSupply
   * @param {Boolean} restOptions.haven
   * @param {Boolean} restOptions.recoverStrifeAndFatigue
   * @param {'long' | 'short'} restOptions.restType
   * @returns
   */
  async triggerRest(t = {}) {
    let s;
    if (foundry.utils.isEmpty(t)) {
      const l = K("A5E.RestConfigurationPrompt", { name: this.name }), r = new gn(this, l, fy);
      await r.render(!0), s = await (r == null ? void 0 : r.promise);
    } else
      s = foundry.utils.mergeObject({
        consumeSupply: !1,
        haven: !0,
        recoverStrifeAndFatigue: !0,
        restType: "short"
      }, t);
    if (!s)
      return;
    await new qd(this, s).restoreResources();
  }
  async updateDeathSavingThrowFigures(t) {
    const { death: s, fatigue: n, strife: l } = this.system.attributes, { success: r, failure: o } = s, a = t.dice[0].total, c = {
      "system.attributes.death": { success: r, failure: o }
    };
    a === 1 ? game.settings.get("a5e", "5eStyleDeathSaves") ? c["system.attributes.death"].failure += 2 : (c["system.attributes.death"].failure += 1, c["system.attributes.fatigue"] = n + 1, c["system.attributes.strife"] = l + 1) : a === 20 ? c["system.attributes.hp.value"] = 1 : a < (this.getFlag("a5e", "deathSaveThreshold") || 10) ? c["system.attributes.death"].failure += 1 : c["system.attributes.death"].success += 1, await this.update(c);
  }
  async rechargeGenericResource(t) {
    var d, p, m, g, h, _, y, k;
    if (!this.system.resources[t])
      return;
    const s = at(this.system.resources[t].max, this.getRollData()), n = this.system.resources[t].value, l = ((p = (d = this.system.resources[t]) == null ? void 0 : d.recharge) == null ? void 0 : p.formula) || "1d6", r = ((g = (m = this.system.resources[t]) == null ? void 0 : m.recharge) == null ? void 0 : g.threshold) || 6, o = ((_ = (h = this.system.resources[t]) == null ? void 0 : h.recharge) == null ? void 0 : _.rechargeType) || "custom", a = ((k = (y = this.system.resources[t]) == null ? void 0 : y.recharge) == null ? void 0 : k.rechargeAmount) || "1", c = `system.resources.${t}.value`, u = await new Roll(l, this.getRollData()).evaluate({ async: !0 });
    if (u.toMessage(), !(u.total < r))
      if (o === "min")
        await this.update({ [c]: 0 });
      else if (o === "max")
        await this.update({ [c]: s });
      else {
        const v = await new Roll(
          a,
          this.getRollData()
        ).evaluate({ async: !0 });
        await this.update({ [c]: Math.min(s, n + v.total) });
      }
  }
  // -------------------------------------------------------------
  // Sheet Toggles
  // -------------------------------------------------------------
  // -------------------------------------------------------------
  // Roll Handlers
  // -------------------------------------------------------------
  /**
   * Rolls an ability check for a given skill. A dialog is presented to the user so that they can
   * perform choose the size of the expertise die to use for the check.
   *
   * @async
   * @method
   * @param {string} abilityKey A key that can be used to reference a given ability score.
   * @returns {Object}
   */
  async rollAbilityCheck(t, s = {}) {
    var g, h;
    let n;
    if (s.skipRollDialog ? n = this.getDefaultAbilityCheckData(t, s) : n = await Z(this, bh, Y9).call(this, t, s), !n)
      return null;
    const {
      expertiseDie: l,
      rollFormula: r,
      rollMode: o,
      visibilityMode: a
    } = n, u = await new $r({
      actor: this,
      rolls: [
        {
          ability: t,
          expertiseDie: l,
          rollFormula: r,
          rollMode: o,
          type: "abilityCheck"
        }
      ]
    }).prepareRolls(), d = {
      user: (g = game.user) == null ? void 0 : g.id,
      speaker: ChatMessage.getSpeaker({ actor: this }),
      type: CONST.CHAT_MESSAGE_TYPES.ROLL,
      sound: CONFIG.sounds.dice,
      rolls: u.map(({ roll: _ }) => _),
      rollMode: a ?? game.settings.get("core", "rollMode"),
      flags: {
        a5e: {
          actorId: this.uuid,
          cardType: "abilityCheck",
          img: ((h = this.token) == null ? void 0 : h.img) ?? this.img,
          name: this.name,
          rollData: u.map(({ roll: _, ...y }) => y)
        }
      },
      content: "<article></article>"
    }, p = {
      abilityKey: t,
      expertiseDie: l,
      rollFormula: r,
      rollMode: o
    };
    return Hooks.callAll("a5e.rollAbilityCheck", this, p, u), await ChatMessage.create(d);
  }
  getDefaultAbilityCheckData(t, s = {}) {
    const n = (s == null ? void 0 : s.rollMode) ?? CONFIG.A5E.ROLL_MODE.NORMAL, l = s.expertiseDice ?? 0, r = this.RollOverrideManager.getExpertiseDice(
      `system.abilities.${t}.check`,
      l
    ), o = this.RollOverrideManager.getRollOverride(
      `system.abilities.${t}.check`,
      n
    ), a = si(this, {
      ability: t,
      expertiseDie: r,
      rollMode: o,
      situationalMods: s.situationalMods,
      selectedAbilityBonuses: this.BonusesManager.getDefaultSelections(
        "abilities",
        { abilityKey: t, abilityType: "check" }
      ),
      type: "abilityCheck"
    });
    return { expertiseDie: r, rollFormula: a, visibilityMode: s.visibilityMode ?? null };
  }
  async rollDeathSavingThrow(t = {}) {
    t.saveType = "death", t.expertiseDice ?? (t.expertiseDice = 0), t.visibilityMode ?? (t.visibilityMode = "gmroll"), game.settings.get("a5e", "blindDeathSaves") && (t.visibilityMode = "blindroll"), this.rollSavingThrow(null, t);
  }
  async rollHitDice(t, s = 1) {
    return await this.HitDiceManager.rollHitDice(t, s);
  }
  async rollSavingThrow(t, s = {}) {
    var h, _;
    let n;
    if (s.skipRollDialog ? n = this.getDefaultSavingThrowData(t, s) : n = await Z(this, _h, X9).call(this, t, s), n === null)
      return null;
    const {
      expertiseDie: l,
      rollFormula: r,
      rollMode: o,
      saveType: a,
      visibilityMode: c
    } = n, d = await new $r({
      actor: this,
      rolls: [
        {
          ability: t,
          expertiseDie: l,
          rollFormula: r,
          rollMode: o,
          saveType: a,
          type: "savingThrow"
        }
      ]
    }).prepareRolls(), p = {
      user: (h = game.user) == null ? void 0 : h.id,
      speaker: ChatMessage.getSpeaker({ actor: this }),
      type: CONST.CHAT_MESSAGE_TYPES.ROLL,
      sound: CONFIG.sounds.dice,
      rolls: d.map(({ roll: y }) => y),
      rollMode: c ?? game.settings.get("core", "rollMode"),
      flags: {
        a5e: {
          actorId: this.uuid,
          cardType: "savingThrow",
          img: ((_ = this.token) == null ? void 0 : _.img) ?? this.img,
          name: this.name,
          rollData: d.map(({ roll: y, ...k }) => k)
        }
      },
      content: "<article></article>"
    }, m = {
      abilityKey: t,
      expertiseDie: l,
      rollFormula: r,
      rollMode: o
    };
    return (s == null ? void 0 : s.saveType) === "death" ? (Hooks.callAll("a5e.rollDeathSavingThrow", this, m, d), this.updateDeathSavingThrowFigures(d.map(({ roll: y }) => y)[0])) : Hooks.callAll("a5e.rollSavingThrow", this, m, d), await ChatMessage.create(p);
  }
  getDefaultSavingThrowData(t, s = {}) {
    const n = (s == null ? void 0 : s.rollMode) ?? CONFIG.A5E.ROLL_MODE.NORMAL, l = s.expertiseDice ?? 0, r = t ? `system.abilities.${t}.save` : "deathSave", o = this.RollOverrideManager.getRollOverride(r, n), a = this.RollOverrideManager.getExpertiseDice(r, l), c = si(this, {
      ability: t,
      expertiseDie: a,
      rollMode: o,
      saveType: s.saveType,
      situationalMods: s.situationalMods,
      selectedAbilityBonuses: this.BonusesManager.getDefaultSelections(
        "abilities",
        { abilityKey: t, abilityType: "save" }
      ),
      type: "savingThrow"
    });
    return { expertiseDie: a, rollFormula: c, visibilityMode: s.visibilityMode ?? null };
  }
  /**
   * Rolls a skill check for a given skill. A dialog is presented to the user so that they can
   * perform additional configuration, such as choosing an ability score for the check.
   *
   * @async
   * @method
   * @param {string} skillKey A key that can be used to reference a given skill.
   * @param {object}
   *
   * @returns {Promise<undefined>}
   */
  async rollSkillCheck(t, s = {}) {
    var h, _;
    let n;
    if (s.skipRollDialog ? n = this.getDefaultSkillCheckData(t, s) : n = await Z(this, yh, J9).call(this, t, s), !n)
      return null;
    const {
      abilityKey: l,
      expertiseDie: r,
      rollFormula: o,
      rollMode: a,
      visibilityMode: c
    } = n, d = await new $r({
      actor: this,
      rolls: [
        {
          ability: l,
          expertiseDie: r,
          rollFormula: o,
          rollMode: a,
          skill: t,
          type: "skillCheck"
        }
      ]
    }).prepareRolls(), p = {
      user: (h = game.user) == null ? void 0 : h.id,
      speaker: ChatMessage.getSpeaker({ actor: this }),
      type: CONST.CHAT_MESSAGE_TYPES.ROLL,
      sound: CONFIG.sounds.dice,
      rolls: d.map(({ roll: y }) => y),
      rollMode: c ?? game.settings.get("core", "rollMode"),
      flags: {
        a5e: {
          actorId: this.uuid,
          cardType: "skillCheck",
          img: ((_ = this.token) == null ? void 0 : _.img) ?? this.img,
          name: this.name,
          rollData: d.map(({ roll: y, ...k }) => k)
        }
      },
      content: "<article></article>"
    }, m = {
      abilityKey: l,
      expertiseDie: r,
      rollFormula: o,
      rollMode: a,
      skillKey: t
    };
    return Hooks.callAll("a5e.rollSkillCheck", this, m, d), await ChatMessage.create(p);
  }
  getDefaultSkillCheckData(t, s = {}) {
    const n = this.system.skills[t], l = (s == null ? void 0 : s.abilityKey) ?? n.ability, r = (s == null ? void 0 : s.rollMode) ?? CONFIG.A5E.ROLL_MODE.NORMAL, o = s.expertiseDice ?? 0, a = this.RollOverrideManager.getExpertiseDice(`system.skills.${t}`, o, { ability: l }), c = this.RollOverrideManager.getRollOverride(`system.skills.${t}`, r, { ability: l }), u = si(this, {
      ability: l,
      expertiseDie: a,
      minRoll: s.minRoll ?? n.minRoll,
      proficient: n.proficient,
      type: "skillCheck",
      rollMode: c,
      skill: t,
      selectedAbilityBonuses: this.BonusesManager.getDefaultSelections(
        "abilities",
        { abilityKey: l, abilityType: "check" }
      ),
      selectedSkillBonuses: this.BonusesManager.getDefaultSelections(
        "skills",
        { skillKey: t, abilityKey: l }
      ),
      situationalMods: s.situationalMods
    });
    return {
      abilityKey: l,
      expertiseDie: a,
      rollFormula: u,
      visibilityMode: s.visibilityMode ?? null
    };
  }
  // -------------------------------------------------------------
  // Config Handlers
  // -------------------------------------------------------------
  addBonus(t = "damage") {
    var n;
    const s = foundry.utils.duplicate(this._source.system.bonuses[t] ?? {});
    (n = Object.keys(CONFIG.A5E.bonusTypes)) != null && n.includes(t) && this.update({
      [`system.bonuses.${t}`]: {
        ...s,
        [foundry.utils.randomID()]: {}
      }
    });
  }
  configureAbilityScore(t = {}, s = {}) {
    const n = K(
      "A5E.AbilityCheckPromptTitle",
      { name: this.name, ability: K(CONFIG.A5E.abilities[t.abilityKey]) }
    );
    Z(this, Yt, es).call(this, "ability", n, t, s);
  }
  configureAlignment(t = {}, s = {}) {
    const n = K("A5E.AlignmentConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.Alignments"), t.propertyKey ?? (t.propertyKey = "system.traits.alignment"), t.configObject ?? (t.configObject = CONFIG.A5E.alignments), t.type ?? (t.type = "alignment"), Z(this, Yt, es).call(this, "alignment", n, t, s);
  }
  configureArmorClass(t = {}, s = {}) {
    const n = K("A5E.ACConfigurationPrompt", { name: this.name });
    Z(this, Yt, es).call(this, "armorClass", n, t, s);
  }
  configureArmorProficiencies(t = {}, s = {}) {
    const n = K("A5E.ArmorProficienciesConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.ArmorProficiencies"), t.propertyKey ?? (t.propertyKey = "system.proficiencies.armor"), t.configObject ?? (t.configObject = CONFIG.A5E.armor), t.type ?? (t.type = "armorTypes"), Z(this, Yt, es).call(this, "armor", n, t, s);
  }
  configureConditionImmunities(t = {}, s = {}) {
    const n = K("A5E.ConditionImmunitiesConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.ConditionImmunities"), t.configObject ?? (t.configObject = CONFIG.A5E.conditions), t.propertyKey ?? (t.propertyKey = "system.traits.conditionImmunities"), t.type ?? (t.type = "conditionImmunities"), Z(this, Yt, es).call(this, "conditionImmunities", n, t, s);
  }
  configureCreatureTypes(t = {}, s = {}) {
    const n = K("A5E.CreatureTypesConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.CreatureTypePlural"), t.configObject ?? (t.configObject = CONFIG.A5E.creatureTypes), t.propertyKey ?? (t.propertyKey = "system.details.creatureTypes"), t.type ?? (t.type = "creatureTypes"), Z(this, Yt, es).call(this, "types", n, t, s);
  }
  configureBonus(t, s = "damage") {
    var r;
    const n = CONFIG.A5E.bonusDialogKeys[s];
    if (!n)
      return;
    const l = `${this.name} ${K(((r = CONFIG.A5E.bonusLabels[s]) == null ? void 0 : r.dialogName) ?? s)}`;
    Z(this, Yt, es).call(this, n, l, { bonusID: t });
  }
  configureCreatureTerrains(t = {}, s = {}) {
    t.heading ?? (t.heading = "A5E.CreatureTerrainsLabel"), t.configObject ?? (t.configObject = CONFIG.A5E.terrainTypes), t.propertyKey ?? (t.propertyKey = "system.details.terrain"), t.type ?? (t.type = "creatureTerrains"), Z(this, Yt, es).call(this, "terrain", `${this.name}: Configure Creature Terrains`, t, s);
  }
  configureDamageImmunities(t = {}, s = {}) {
    const n = K("A5E.DamageImmunitiesConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.DamageTypePlural"), t.configObject ?? (t.configObject = CONFIG.A5E.damageTypes), t.propertyKey ?? (t.propertyKey = "system.traits.damageImmunities"), t.type ?? (t.type = "damageImmunities"), Z(this, Yt, es).call(this, "damageImmunities", n, t, s);
  }
  configureDamageResistances(t = {}, s = {}) {
    const n = K("A5E.DamageResistancesConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.DamageTypePlural"), t.configObject ?? (t.configObject = CONFIG.A5E.damageTypes), t.propertyKey ?? (t.propertyKey = "system.traits.damageResistances"), t.type ?? (t.type = "damageResistances"), Z(this, Yt, es).call(this, "damageResistances", n, t, s);
  }
  configureDamageVulnerabilities(t = {}, s = {}) {
    const n = K("A5E.DamageVulnerabilitiesConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.DamageTypePlural"), t.configObject ?? (t.configObject = CONFIG.A5E.damageTypes), t.propertyKey ?? (t.propertyKey = "system.traits.damageVulnerabilities"), t.type ?? (t.type = "damageVulnerabilities"), Z(this, Yt, es).call(this, "damageVulnerabilities", n, t, s);
  }
  configureHealth(t = {}, s = {}) {
    const n = K("A5E.HitPointsConfigurationPrompt", { name: this.name });
    s.width ?? (s.width = 380), Z(this, Yt, es).call(this, "health", n, t, s);
  }
  configureInitiative(t = {}, s = {}) {
    const n = K("A5E.InitiativeConfigurationPrompt", { name: this.name });
    Z(this, Yt, es).call(this, "initiative", n, t, { ...s, width: s.width ?? 432 });
  }
  configureLanguages(t = {}, s = {}) {
    const n = K("A5E.LanguagesConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.Languages"), t.configObject ?? (t.configObject = CONFIG.A5E.languages), t.propertyKey ?? (t.propertyKey = "system.proficiencies.languages"), t.type ?? (t.type = "languages"), Z(this, Yt, es).call(this, "languages", n, t, s);
  }
  configureMovement(t = {}, s = {}) {
    const n = K("A5E.MovementConfigurationPrompt", { name: this.name });
    Z(this, Yt, es).call(this, "movement", n, t, s);
  }
  configureManeuverTraditions(t = {}, s = {}) {
    const n = K("A5E.ManeuverTraditionsConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.ManeuverTraditionPlural"), t.configObject ?? (t.configObject = CONFIG.A5E.maneuverTraditions), t.propertyKey ?? (t.propertyKey = "system.proficiencies.traditions"), t.type ?? (t.type = "maneuverTraditions"), Z(this, Yt, es).call(this, "maneuverTraditions", n, t, s);
  }
  configureSenses(t = {}, s = {}) {
    const n = K("A5E.SensesConfigurationPrompt", { name: this.name });
    Z(this, Yt, es).call(this, "senses", n, t, s);
  }
  configureSizeCategory(t = {}, s = {}) {
    const n = K("A5E.SizeCategoryConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.SizeCategory"), t.configObject ?? (t.configObject = CONFIG.A5E.actorSizes), t.propertyKey ?? (t.propertyKey = "system.traits.size"), t.type ?? (t.type = "size"), Z(this, Yt, es).call(this, "size", n, t, s);
  }
  configureSkill(t = {}, s = { width: 440 }) {
    const n = K(
      "A5E.SkillConfigurationPrompt",
      { name: this.name, skill: K(CONFIG.A5E.skills[t.skillKey]) }
    );
    Z(this, Yt, es).call(this, "skill", n, t, s);
  }
  configureToolProficiencies(t = {}, s = {}) {
    const n = K("A5E.ToolProficienciesConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.ToolProficiencies"), t.configObject ?? (t.configObject = CONFIG.A5E.tools), t.propertyKey ?? (t.propertyKey = "system.proficiencies.tools"), t.type ?? (t.type = "tools"), Z(this, Yt, es).call(this, "tools", n, t, s);
  }
  configureWeaponProficiencies(t = {}, s = {}) {
    const n = K("A5E.WeaponProficienciesConfigurationPrompt", { name: this.name });
    t.heading ?? (t.heading = "A5E.WeaponPlural"), t.configObject ?? (t.configObject = CONFIG.A5E.weapons), t.propertyKey ?? (t.propertyKey = "system.proficiencies.weapons"), t.type ?? (t.type = "weapons"), Z(this, Yt, es).call(this, "weapons", n, t, s);
  }
  async deleteBonus(t, s = "damage") {
    const n = this.dialogs.bonuses[t];
    await (n == null ? void 0 : n.close()), delete this.dialogs.bonuses[t], await this.update({
      [`system.bonuses.${s}`]: {
        [`-=${t}`]: null
      }
    });
  }
  duplicateBonus(t, s = "damage") {
    let n;
    const l = foundry.utils.duplicate(this._source.system.bonuses[s] ?? {});
    if (foundry.utils.isEmpty(l))
      return;
    const r = foundry.utils.duplicate(
      this.system.bonuses[s][t]
    );
    s === "damage" ? n = K("A5E.NewDamageBonus") : s === "healing" ? n = K("A5E.NewHealingBonus") : n = "New Bonus", r.label = `${r.label || n} (Copy)`, this.update({
      [`system.bonuses.${s}`]: {
        ...l,
        [foundry.utils.randomID()]: r
      }
    });
  }
  // -------------------------------------------------------------
  // Document Update Hooks
  // -------------------------------------------------------------
  /** @inheritdoc */
  async _preCreate(t, s, n) {
    var r, o, a, c;
    await super._preCreate(t, s, n);
    const l = [...this.items];
    if (!((r = this.system.schemaVersion) != null && r.version) && !((o = this.system.schema) != null && o.version)) {
      let u = null;
      ["number", "string"].includes(typeof this.system.ac) ? u = 4e-3 : l.some((d) => {
        var p;
        return typeof ((p = d.system) == null ? void 0 : p.equipped) == "boolean";
      }) ? u = 3e-3 : l.some((d) => {
        var p;
        return typeof ((p = d.system) == null ? void 0 : p.recharge) == "string";
      }) ? u = 2e-3 : l.some((d) => {
        var p, m;
        return typeof ((m = (p = d.system) == null ? void 0 : p.uses) == null ? void 0 : m.max) == "number";
      }) ? u = 1e-3 : typeof ((c = (a = this.system.attributes.movement) == null ? void 0 : a.walk) == null ? void 0 : c.unit) != "string" ? u = null : u = wr.LATEST_SCHEMA_VERSION, this.updateSource({
        "system.schemaVersion.version": u
      });
    }
    if (this.type === "character") {
      const u = { vision: !0, actorLink: !0, disposition: 1 };
      this.updateSource({ prototypeToken: u });
    }
  }
  /** @inheritdoc */
  async _preUpdate(t, s, n) {
    var d, p, m, g, h, _;
    const l = Object.keys(((d = this.flags) == null ? void 0 : d.a5e) ?? {}).includes("-=autoApplyFSConditions"), r = Object.keys(((p = t == null ? void 0 : t.flags) == null ? void 0 : p.a5e) ?? {}).includes("-=-=autoApplyFSConditions");
    l && !r && await this.unsetFlag("a5e", "-=autoApplyFSConditions"), (((g = (m = t == null ? void 0 : t.flags) == null ? void 0 : m.a5e) == null ? void 0 : g.autoApplyFSConditions) ?? !0) && $K(this, foundry.utils.deepClone(t), n.id), foundry.utils.setProperty(t, "flags.a5e.-=autoApplyFSConditions", null), await super._preUpdate(t, s, n), foundry.utils.getProperty(t, "system.attributes.hp.value") < 0 && foundry.utils.setProperty(t, "system.attributes.hp.value", 0), foundry.utils.getProperty(t, "system.attributes.hp.temp") <= 0 && foundry.utils.setProperty(t, "system.attributes.hp.temp", 0);
    const a = this.system.attributes.hp.value === 0, c = foundry.utils.getProperty(t, "system.attributes.hp.value") > 0;
    if (a && c && (foundry.utils.setProperty(t, "system.attributes.death.success", 0), foundry.utils.setProperty(t, "system.attributes.death.failure", 0)), (((_ = (h = this.flags) == null ? void 0 : h.a5e) == null ? void 0 : _.automatePrototypeTokenSize) ?? game.settings.get("a5e", "automatePrototypeTokenSize") ?? !0) && foundry.utils.getProperty(t, "system.traits.size")) {
      const y = t.system.traits.size;
      (y !== "titan" || this.prototypeToken.width < 5) && (foundry.utils.setProperty(t, "prototypeToken.height", CONFIG.A5E.tokenDimensions[y]), foundry.utils.setProperty(t, "prototypeToken.width", CONFIG.A5E.tokenDimensions[y]));
    }
  }
  /** @inheritdoc */
  _onUpdate(t, s, n) {
    super._onUpdate(t, s, n);
    const l = game.settings.get("a5e", "automateBloodiedApplication") ?? !0, r = game.settings.get("a5e", "automateUnconsciousApplication") ?? !0;
    l && gI(this, t, n, "bloodied"), r && gI(this, t, n, "unconscious");
  }
};
Pu = new WeakMap(), bh = new WeakSet(), Y9 = /* @__PURE__ */ f(async function(t, s = {}, n = {}) {
  const l = K(
    "A5E.AbilityCheckPromptTitle",
    { name: this.name, ability: K(CONFIG.A5E.abilities[t]) }
  ), r = new so(
    this,
    l,
    ty,
    { abilityKey: t },
    s,
    n
  );
  return await r.render(!0), await r.promise;
}, "#showAbilityCheckPrompt"), _h = new WeakSet(), X9 = /* @__PURE__ */ f(async function(t, s = {}, n = {}) {
  let l;
  s.saveType === "death" ? l = K(
    "A5E.DeathSavingThrowPromptTitle",
    { name: this.name }
  ) : l = K(
    "A5E.SavingThrowPromptTitle",
    { name: this.name, ability: K(CONFIG.A5E.abilities[t]) }
  );
  const r = new so(
    this,
    l,
    dy,
    { abilityKey: t },
    s,
    n
  );
  return await r.render(!0), await r.promise;
}, "#showSavingThrowPrompt"), yh = new WeakSet(), J9 = /* @__PURE__ */ f(async function(t, s = {}, n = {}) {
  const l = K(
    "A5E.SkillPromptTitle",
    { name: this.name, skill: K(CONFIG.A5E.skills[t]) }
  ), r = new so(
    this,
    l,
    hy,
    { skillKey: t },
    s,
    n
  );
  return await r.render(!0), await r.promise;
}, "#showSkillCheckPrompt"), Yt = new WeakSet(), es = /* @__PURE__ */ f(function(t, s, n, l) {
  if (!this.isOwner)
    return;
  const r = M(this, Pu)[t];
  let o = null;
  t === "ability" ? o = this.dialogs.abilities[n.abilityKey] : t === "skill" ? o = this.dialogs.skills[n.skillKey] : Object.values(CONFIG.A5E.bonusDialogKeys).includes(t) ? o = this.dialogs.bonuses[n.bonusID] : o = this.dialogs[t], o || (o = new gn(this, s, r, n, l), t === "ability" ? this.dialogs.abilities[n.abilityKey] = o : t === "skill" ? this.dialogs.skills[n.skillKey] = o : Object.values(CONFIG.A5E.bonusDialogKeys).includes(t) ? this.dialogs.bonuses[n.bonusID] = o : this.dialogs[t] = o), o.render(!0);
}, "#configure"), f(mE, "BaseActorA5e");
let ga = mE;
var qt, gr, Yo, Xo, Mu, ky;
const hE = class hE {
  constructor(e, t = !0) {
    Y(this, Mu);
    Y(this, qt, void 0);
    Y(this, gr, void 0);
    Y(this, Yo, 0);
    Y(this, Xo, 0);
    Ge(this, "dieSizes", /* @__PURE__ */ new Set());
    if (ye(this, qt, e), ye(this, gr, t), M(this, qt).type === "character" && t) {
      Object.values(M(this, qt).classes).forEach((s) => {
        ye(this, Yo, M(this, Yo) + s.hitDice.total), ye(this, Xo, M(this, Xo) + (s.hitDice.total - s.hitDice.current)), this.dieSizes.add(s.hitDice.size);
      });
      return;
    }
    Object.entries(M(this, qt).system.attributes.hitDice ?? {}).forEach(([s, { current: n, total: l }]) => {
      const r = parseInt(s.slice(1), 10);
      ye(this, Xo, M(this, Xo) + (l - n)), ye(this, Yo, M(this, Yo) + l), this.dieSizes.add(r);
    });
  }
  get max() {
    return M(this, Yo);
  }
  get value() {
    return M(this, Xo);
  }
  get smallest() {
    return this.dieSizes.size ? Math.min(...this.dieSizes) : 0;
  }
  get largest() {
    return this.dieSizes.size ? Math.max(...this.dieSizes) : 0;
  }
  get bySize() {
    return M(this, qt).type === "character" && M(this, gr) ? Object.values(M(this, qt).classes ?? {}).reduce((t, s) => {
      var o;
      const { current: n, total: l, size: r } = s.hitDice;
      return t[o = `d${r}`] ?? (t[o] = { current: 0, total: 0 }), t[`d${r}`].current += n, t[`d${r}`].total += l, t;
    }, {}) : M(this, qt).system.attributes.hitDice ?? {};
  }
  async rollHitDice(e = null, t = 1) {
    const s = M(this, qt).system, n = parseInt(s.abilities.con.check.mod, 10) || 0;
    if (M(this, qt).type === "npc" || !M(this, gr)) {
      const { attributes: p } = s;
      if (!e || p.hitDice[e].current - t < 0)
        return null;
      const m = `${t}${e} + ${t * n}`, { hookData: g, chatData: h } = await Z(this, Mu, ky).call(this, e, p.hitDice[e].current, t, m);
      M(this, qt).update({
        "data.attributes": {
          [`hitDice.${e}.current`]: p.hitDice[e].current - t
        }
      });
      const _ = await ChatMessage.create(h);
      return Hooks.callAll("a5e.rollHitDice", M(this, qt), g), _;
    }
    const l = M(this, qt).classes ?? {};
    let r;
    if (e) {
      if (r = Object.values(l).find((p) => p.hitDice.size === parseInt(e.slice(1), 10) && p.hitDice.current - t >= 0), !r)
        return null;
    } else {
      const p = this.largest;
      if (!p || (r = Object.values(l).find((m) => m.hitDice.size === p && m.hitDice.current - t >= 0), !r))
        return null;
    }
    const { size: o } = r.hitDice, a = `${t}d${o} + ${t * n}`, { hookData: c, chatData: u } = await Z(this, Mu, ky).call(this, `d${o}`, r.hitDice.current, t, a);
    r.update({
      "system.hp.hitDiceUsed": Math.min(r.system.hp.hitDiceUsed + t, r.classLevels)
    });
    const d = await ChatMessage.create(u);
    return Hooks.callAll("a5e.rollHitDice", M(this, qt), c), d;
  }
  getUpdateData({ upperLimit: e, restoreLargest: t } = { upperLimit: 0, restoreLargest: !0 }) {
    if (e || (e = Math.max(Math.floor(this.max / 2), 1) || 1), M(this, qt).type === "character" && M(this, gr)) {
      const r = [];
      let o = 0;
      return Object.values(M(this, qt).classes ?? {}).sort((c, u) => t ? u.hitDice.size - c.hitDice.size : c.hitDice.size - u.hitDice.size).forEach((c) => {
        const u = c.system.hp.hitDiceUsed;
        if (u === 0 || o >= e)
          return;
        const d = Math.min(u, e - o);
        o += d, r.push({ _id: c.id, "system.hp.hitDiceUsed": u - d });
      }), { updates: r, recovered: o, type: "embedded" };
    }
    const s = {};
    let n = 0;
    return Object.entries(
      M(this, qt).system.attributes.hitDice ?? {}
    ).sort(([r], [o]) => t ? parseInt(o.slice(1), 10) - parseInt(r.slice(1), 10) : parseInt(r.slice(1), 10) - parseInt(o.slice(1), 10)).forEach(
      ([r, { current: o, total: a }]) => {
        const c = a - o;
        if (c === 0 || n >= e)
          return;
        const u = Math.min(c, e - n);
        n += u, s[`system.attributes.hitDice.${r}.current`] = o + u;
      }
    ), { updates: s, recovered: n, type: "actor" };
  }
};
qt = new WeakMap(), gr = new WeakMap(), Yo = new WeakMap(), Xo = new WeakMap(), Mu = new WeakSet(), ky = /* @__PURE__ */ f(async function(e, t, s, n) {
  var p, m;
  const { attributes: l } = M(this, qt).system, r = await new Roll(n).roll({ async: !0 }), o = K("A5E.HitDiceChatHeader", { dieSize: e.toUpperCase() }), a = {
    user: (p = game.user) == null ? void 0 : p.id,
    speaker: ChatMessage.getSpeaker({ actor: M(this, qt) }),
    type: CONST.CHAT_MESSAGE_TYPES.ROLL,
    sound: CONFIG.sounds.dice,
    rolls: [r],
    flags: {
      a5e: {
        actorId: M(this, qt).uuid,
        img: ((m = M(this, qt).token) == null ? void 0 : m.img) ?? M(this, qt).img,
        name: M(this, qt).name,
        title: o
      }
    }
  }, c = Math.max(r.total, 0), u = l.hp.max;
  return M(this, qt).applyHealing(c), { hookData: {
    dieSize: e,
    dieCount: t - s,
    formula: n,
    newHp: Math.min(l.hp.value + c, u),
    roll: r,
    quantity: s
  }, chatData: a };
}, "#rollHitDice"), f(hE, "HitDiceManager");
let Ic = hE;
const gE = class gE extends ga {
  constructor() {
    super(...arguments);
    /**
     * @type {Record<string, ClassItemA5e>}
     */
    Ge(this, "_classes");
    /**
     * @type {Record<string, any>}
     */
    Ge(this, "classAutomationFlags");
  }
  get classes() {
    return this._classes !== void 0 ? this._classes : (this._classes = this.items.reduce((t, s) => (s.type !== "class" || (t[s.slug] = s), t), {}), this._classes);
  }
  // -------------------------------------------------------------
  // Data Preparation Methods
  // -------------------------------------------------------------
  /**
   * Sets the order of when to prepare data.
   * @override
   */
  prepareData() {
    this._classes = void 0, this.classAutomationFlags = {}, super.prepareData();
  }
  /**
   * Prepare base data for the actor.
   * @override
   */
  prepareBaseData() {
    super.prepareBaseData();
    const t = Object.keys(this.classes ?? {}).length > 0;
    this.automationAvailable = t, this.classAutomationFlags = {
      classes: this.getFlag("a5e", "automateClasses") ?? t ?? !0,
      hitDice: this.getFlag("a5e", "automateHitDice") ?? t ?? !0,
      hitPoints: this.getFlag("a5e", "automateHitPoints") ?? t ?? !0,
      spellResources: this.getFlag("a5e", "automateSpellResources") ?? t ?? !0
    }, this.prepareLevelData(), this.system.attributes.prof = Math.max(2, Math.floor((this.levels.character + 7) / 4));
  }
  /**
   * Prepares derived data for the actor.
   * @override
   */
  prepareDerivedData() {
    this.HitDiceManager = new Ic(this, this.classAutomationFlags.hitDice), super.prepareDerivedData();
    const t = this.system;
    t.attributes.attunement.current = this.items.reduce((s, n) => {
      const { requiresAttunement: l, attuned: r } = n.system;
      return l && r ? s + 1 : s;
    }, 0), this.system.attributes.hitDice = foundry.utils.mergeObject(
      this.system.attributes.hitDice,
      this.HitDiceManager.bySize
    ), foundry.utils.setProperty(t, "attributes.exertion.max", this.prepareMaxExertion()), this.prepareHitPoints(), this.prepareSpellResources();
  }
  prepareMaxExertion() {
    const { max: t } = this.system.attributes.exertion;
    if (!this.automationAvailable)
      return t;
    let s = 0;
    const n = this.grants.byType("exertion").reduce((r, { exertionData: o }) => (o && o.exertionType === "pool" && r.push(o.poolType), r), []);
    n.length === 0 ? s = t : n.includes("doubleProf") ? s = this.system.attributes.prof * 2 : n.includes("prof") ? s = this.system.attributes.prof : s = t;
    const l = at(
      this.BonusesManager.getExertionBonusFormula(),
      this.getRollData()
    ) ?? 0;
    return s + l;
  }
  prepareHitPoints() {
    if (!this.classAutomationFlags.hitPoints) {
      const { baseMax: r, bonus: o } = this.system.attributes.hp;
      this.system.attributes.hp.max = r + o, this.prepareHitPointBonuses();
      return;
    }
    const { classes: t } = this, s = this.system.attributes.hp.bonus ?? 0, n = Object.values(t ?? {}).reduce((r, o) => r + o.maxHP, 0), l = (this.system.abilities.con.check.mod ?? 0) * this.levels.character;
    this.system.attributes.hp.max = n + l + s, super.prepareHitPointBonuses();
  }
  /**
   * Prepares detailed level data for the actor.
   */
  prepareLevelData() {
    const t = this.items.filter((n) => n.type === "class");
    if (!this.classAutomationFlags.classes) {
      this.levels = {
        character: this.system.details.level,
        classes: {}
      };
      return;
    }
    const s = Object.values(t ?? {}).reduce((n, l) => {
      const r = l.system.classLevels;
      return r && (n.classes[l.system.slug || l.name.slugify()] = r, n.character += r), n;
    }, { character: 0, classes: {} });
    this.levels = s;
  }
  prepareSpellResources() {
    const t = this.system, { classes: s } = this, { spellResources: n } = t;
    if (!this.classAutomationFlags.spellResources) {
      Object.entries(n.slots).forEach(([r, { override: o }]) => {
        t.spellResources.slots[r].max = o || 0;
      }), t.spellResources.points.max = n.points.override || 0, t.spellResources.inventions.max = n.inventions.override || 0, t.spellResources.artifactCharges.max = n.artifactCharges.override || 0;
      return;
    }
    Object.entries(n.slots).forEach(([r]) => {
      t.spellResources.slots[r].max = 0;
    }), t.spellResources.points.max = 0, t.spellResources.inventions.max = 0, t.spellResources.artifactCharges.max = 0;
    const l = {
      slots: [],
      additionalSlots: [],
      points: [],
      inventions: [],
      artifactCharges: []
    };
    if (Object.values(s).forEach((r) => {
      const { progressionType: o, resource: a } = (r == null ? void 0 : r.casting) ?? {};
      o && (o === "multiplier" ? l.slots.push(r) : a === "artifactCharges" ? l.artifactCharges.push(r) : a === "inventions" ? l.inventions.push(r) : a === "points" ? l.points.push(r) : a === "slots" && l.additionalSlots.push(r));
    }), l.slots.length === 1) {
      const r = l.slots[0], { slots: o } = r.casting;
      Object.entries(o).forEach(([a, c]) => {
        const { max: u, override: d } = t.spellResources.slots[a];
        t.spellResources.slots[a].max = d || (u || 0) + (c || 0);
      });
    }
    if (l.points.length === 1) {
      const r = l.points[0], { points: o } = r.casting, { max: a, override: c } = t.spellResources.points;
      t.spellResources.points.max = c || (a || 0) + (o || 0);
    }
    if (l.inventions.length === 1) {
      const r = l.inventions[0], { inventions: o } = r.casting, { max: a, override: c } = t.spellResources.inventions;
      t.spellResources.inventions.max = c || (a || 0) + (o || 0);
    }
    if (l.artifactCharges.length === 1) {
      const r = l.artifactCharges[0], { charges: o } = r.casting, { max: a, override: c } = t.spellResources.artifactCharges;
      t.spellResources.artifactCharges.max = c || (a || 0) + (o || 0);
    }
    if (l.slots.length > 1) {
      const r = l.slots.reduce((o, a) => {
        const { classLevels: c } = a, u = CONFIG.A5E.casterProgression[a.casting.casterType];
        if (!u)
          return o;
        const d = u.roundUp ? Math.ceil : Math.floor;
        return o + d(c * u.multiplier);
      }, 0);
      CONFIG.A5E.SPELL_SLOT_TABLE[r].forEach((o, a) => {
        const { max: c, override: u } = t.spellResources.slots[a + 1];
        t.spellResources.slots[a + 1].max = u || (c || 0) + (o || 0);
      });
    }
    l.points.length > 1 && l.points.forEach((r) => {
      const { points: o, multiClassMode: a } = r.casting;
      if (a !== "ADD")
        return;
      const { max: c, override: u } = t.spellResources.points;
      t.spellResources.points.max = u || (c || 0) + (o || 0);
    }), l.additionalSlots.forEach((r) => {
      const { slots: o } = r.casting;
      Object.entries(o).forEach(([a, c]) => {
        const { max: u, override: d } = t.spellResources.slots[a];
        t.spellResources.slots[a].max = d || (u || 0) + (c || 0);
      });
    }), Object.values(t.spellResources.slots).forEach((r) => {
      r.max === void 0 && (r.max = 0);
    }), t.spellResources.points.max = n.points.max ?? 0, t.spellResources.inventions.max = n.inventions.max ?? 0, t.spellResources.artifactCharges.max = n.artifactCharges.max ?? 0, t.spellResources.knownSpells = Object.values(s).reduce((r, o) => {
      const { knownSpells: a } = (o == null ? void 0 : o.casting) ?? {};
      return a && (r[o.slug] = a), r;
    }, {}), t.spellResources.knownCantrips = Object.values(s).reduce((r, o) => {
      const { knownCantrips: a } = (o == null ? void 0 : o.casting) ?? {};
      return a && (r[o.slug] = a), r;
    }, {}), t.spellResources.maxSpellLevel = Object.values(s).reduce((r, o) => {
      const { maxLevel: a } = (o == null ? void 0 : o.casting) ?? {};
      return a && (r[o.slug] = a), r;
    }, {});
  }
  /**
   * @inheritdoc
   */
  getRollData(t = null) {
    var n;
    const s = { ...super.getRollData(t) };
    return s.level = ((n = this.levels) == null ? void 0 : n.character) ?? s.level ?? this.system.details.level, s.classes = Object.entries(this.classes ?? {}).reduce((l, [r, o]) => {
      var a;
      return l[r] = (a = o.getRollData(t) ?? {}) == null ? void 0 : a.actorTransfer, l;
    }, {}), s;
  }
  // -------------------------------------------------------------
  // Resources Reset Handlers
  // -------------------------------------------------------------
  // TODO: Resource Manager - Move to resource manager
  async recoverExertionUsingHitDice() {
    const { current: t, max: s } = this.system.attributes.exertion, [n] = Object.entries(this.system.attributes.hitDice).find(
      ([, { current: a, total: c }]) => a > 0 && c > 0
    );
    if (!n) {
      ui.notifications.warn(`${this.name} has no hit dice remaining.`);
      return;
    }
    const l = await new Roll("1d4");
    await l.toMessage();
    const r = Math.min((t ?? 0) + l.total, s), o = this.system.attributes.hitDice[n].current - 1;
    await this.update({
      "system.attributes": {
        "exertion.current": r,
        [`hitDice.${n}.current`]: o
      }
    });
  }
  // -------------------------------------------------------------
  // Sheet Toggles
  // -------------------------------------------------------------
  toggleInspiration() {
    const t = this.system.attributes.inspiration;
    this.update({ "system.attributes.inspiration": !t }), t ? Hooks.callAll("a5e.inspirationUsed", this) : Hooks.callAll("a5e.inspirationGained", this);
  }
  // -------------------------------------------------------------
  // Document Update Hooks
  // -------------------------------------------------------------
  /** @inheritdoc */
  async _preCreate(t, s, n) {
    await super._preCreate(t, s, n);
  }
  /** @inheritdoc */
  async _preUpdate(t, s, n) {
    await super._preUpdate(t, s, n);
  }
  /** @inheritdoc */
  async _onCreate(t, s, n) {
    await super._onCreate(t, s, n);
  }
  /** @inheritdoc */
  _onUpdate(t, s, n) {
    super._onUpdate(t, s, n);
  }
};
f(gE, "CharacterActorA5E");
let wy = gE;
const bE = class bE extends ga {
  // -------------------------------------------------------------
  // Data Preparation Methods
  // -------------------------------------------------------------
  /**
   * @returns {String} hitPointFormula
   */
  get hitPointFormula() {
    const { hitDice: e } = this.system.attributes, { mod: t } = this.system.abilities.con;
    let s = 0;
    const n = [];
    return Object.entries(e).forEach(([l, { total: r }]) => {
      r && (n.push(`${r}${l}`), s += r);
    }), s === 0 ? null : `${n.join(" + ")} + ${s * t}`;
  }
  /**
   * Prepare base data for the actor.
   * @override
   */
  prepareBaseData() {
    super.prepareBaseData(), this.system.attributes.prof = Math.max(2, Math.floor((this.system.details.cr + 7) / 4));
  }
  /**
   * Prepares derived data for the actor.
   * @override
   */
  prepareDerivedData() {
    this.HitDiceManager = new Ic(this, !1), super.prepareDerivedData();
    const { baseMax: e, bonus: t } = this.system.attributes.hp;
    this.system.attributes.hp.max = e + t, super.prepareHitPointBonuses();
  }
  // -------------------------------------------------------------
  // Sheet Toggles
  // -------------------------------------------------------------
  toggleElite() {
    this.update({ "system.details.elite": !this.system.details.elite });
  }
  // -------------------------------------------------------------
  // Document Update Hooks
  // -------------------------------------------------------------
  /** @inheritdoc */
  async _preCreate(e, t, s) {
    await super._preCreate(e, t, s);
  }
  /** @inheritdoc */
  async _preUpdate(e, t, s) {
    await super._preUpdate(e, t, s);
  }
  /** @inheritdoc */
  async _onCreate(e, t, s) {
    await super._onCreate(e, t, s);
  }
  /** @inheritdoc */
  _onUpdate(e, t, s) {
    super._onUpdate(e, t, s);
  }
};
f(bE, "NPCActorA5E");
let $y = bE;
function AK(i, e) {
  var n;
  if (foundry.utils.isEmpty(e))
    return null;
  const { activation: t } = e;
  let s = "";
  return foundry.utils.isEmpty(t) || !t.type ? null : (t.type === "reaction" ? t.reactionTrigger ? s = `${K("A5E.ActionActivationReaction")} (${t.reactionTrigger})` : s = K("A5E.ActionActivationReaction") : t.cost === 0 || t.cost > 1 ? s = `${t.cost} ${CONFIG.A5E.abilityActivationTypesPlural[t.type]}` : ["none", "special"].includes(t.type) ? s = CONFIG.A5E.abilityActivationTypes[t == null ? void 0 : t.type] : s = `${t.cost ?? 1} ${CONFIG.A5E.abilityActivationTypes[t.type]}`, (n = i == null ? void 0 : i.system) != null && n.ritual && (s += " (Ritual)"), s);
}
f(AK, "getActivationCostLabel$1");
function Ay(i) {
  if (foundry.utils.isEmpty(i) || (i.quantity ?? (i.quantity = 1), !(i != null && i.shape)) || i.quantity <= 0)
    return !1;
  if (i.shape === "cone" || i.shape === "wall") {
    let e = i == null ? void 0 : i.length;
    if (typeof e == "string" && (e = parseInt(e, 10)), !e || e <= 0)
      return !1;
  } else if (i.shape === "cube" || i.shape === "square") {
    let e = i == null ? void 0 : i.width;
    if (typeof e == "string" && (e = parseInt(e, 10)), !e || e <= 0)
      return !1;
  } else if (["circle", "cylinder", "emanation", "sphere"].includes(i.shape)) {
    let e = i == null ? void 0 : i.radius;
    if (typeof e == "string" && (e = parseInt(e, 10)), !e || e <= 0)
      return !1;
  } else if (i.shape === "line") {
    let e = i == null ? void 0 : i.length, t = i == null ? void 0 : i.width;
    if (typeof e == "string" && (e = parseInt(e, 10)), typeof t == "string" && (t = parseInt(t, 10)), !e || !t || e <= 0 || t <= 0)
      return !1;
  }
  return !0;
}
f(Ay, "validateTemplateData");
function EK(i) {
  const e = i == null ? void 0 : i.area;
  let t;
  if (!Ay(i.area))
    return null;
  if (e.shape === "circle")
    t = K("A5E.AreaCircleSpecific", { radius: e.radius });
  else if (e.shape === "cone")
    t = K("A5E.AreaConeSpecific", { length: e.length });
  else if (e.shape === "cube")
    t = K("A5E.AreaCubeSpecific", { width: e.width });
  else if (e.shape === "cylinder" && e.height)
    t = K("A5E.AreaCylinderSpecific", { height: e.height, radius: e.radius });
  else if (e.shape === "cylinder")
    t = K("A5E.AreaCylinderSpecificNoHeight", { radius: e.radius });
  else if (e.shape === "emanation")
    t = K("A5E.AreaEmanationSpecific", { radius: e.radius });
  else if (e.shape === "line")
    t = K("A5E.AreaLineSpecific", { width: e.width ?? 5, length: e.length });
  else if (e.shape === "sphere")
    t = K("A5E.AreaSphereSpecific", { radius: e.radius });
  else if (e.shape === "square")
    t = K("A5E.AreaSquareSpecific", { width: e.width });
  else if (e.shape === "wall" && e.height && e.width)
    t = K("A5E.AreaWallSpecific", { height: e.height, length: e.length, width: e.width });
  else if (e.shape === "wall" && e.height)
    t = K("A5E.AreaWallSpecificNoWidth", { height: e.height, length: e.length });
  else if (e.shape === "wall" && e.width)
    t = K("A5E.AreaWallSpecificNoHeight", { length: e.length, width: e.width });
  else if (e.shape === "wall")
    t = K("A5E.AreaWallSpecificNoWidthOrHeight", { length: e.length });
  else
    return null;
  return e.quantity > 1 && (t += `(× ${e == null ? void 0 : e.quantity})`), t;
}
f(EK, "getAreaLabel");
function SK(i, e) {
  var n;
  const t = e == null ? void 0 : e.duration;
  let s = "";
  return foundry.utils.isEmpty(t) || !t.unit ? null : (["instantaneous", "permanent", "special"].includes(t.unit) ? s = CONFIG.A5E.timePeriods[t.unit] : t.value === 0 || t.value > 1 ? s = `${t.value} ${CONFIG.A5E.timePeriodsPlural[t.unit]}` : s = `${t.value ?? 1} ${CONFIG.A5E.timePeriods[t.unit]}`, (n = i == null ? void 0 : i.system) != null && n.concentration && (s += ` (${K("A5E.SpellConcentration")})`), s.trim());
}
f(SK, "getDurationLabel");
function TK(i) {
  const e = i == null ? void 0 : i.ranges, { distanceAbbreviations: t, rangeValues: s, rangeDescriptors: n } = CONFIG.A5E;
  return foundry.utils.isEmpty(e) ? null : Object.values(e).map(({ range: l, unit: r }) => ["short", "medium", "long"].includes(l) ? `${n[l]} (${s[l]} ${t.feet})` : ["fiveFeet", "self", "touch"].includes(l) ? n[l] : r ? `${l} ${t[r]}` : l).join(", ");
}
f(TK, "getRangeLabels");
function CK(i) {
  const e = i == null ? void 0 : i.target;
  return foundry.utils.isEmpty(e) || !e.type || e.type === "none" ? null : (e == null ? void 0 : e.type) === "self" ? K("A5E.TargetSelf") : (e == null ? void 0 : e.type) === "other" ? K("A5E.TargetOther") : (e == null ? void 0 : e.quantity) === 0 || (e == null ? void 0 : e.quantity) > 1 ? `${e.quantity} ${CONFIG.A5E.targetTypesPlural[e.type]}` : `${(e == null ? void 0 : e.quantity) || 1} ${CONFIG.A5E.targetTypes[e == null ? void 0 : e.type]}`;
}
f(CK, "getTargetLabel");
function OK(i, e) {
  return {
    activationCost: AK(i, e),
    area: EK(e),
    duration: SK(i, e),
    ranges: TK(e),
    targets: CK(e)
  };
}
f(OK, "getBaseActionSummaryData");
function DK(i, e, t) {
  return {};
}
f(DK, "getFeatureSummaryData");
function IK(i, e) {
  const t = CONFIG.A5E.maneuverDegrees[parseInt(i.system.degree, 10)], s = CONFIG.A5E.maneuverTraditions[i.system.tradition] ?? "", n = i.system.isStance ? "Stance" : "", l = i.system.exertionCost ? `(${i.system.exertionCost}
    ${K(i.system.exertionCost > 1 ? "A5E.ExertionPointPlural" : "A5E.ExertionPoint")})` : "";
  return { maneuverProperties: [
    t,
    s,
    n,
    l
  ].filter(Boolean).join(" ") };
}
f(IK, "getManeuverSummaryData");
function PK(i) {
  const { armorProperties: e } = CONFIG.A5E;
  return i.system.armorProperties.map(
    (t) => e[t] ?? t
  );
}
f(PK, "getArmorProperties");
function MK(i) {
  var e;
  return ((e = i == null ? void 0 : i.system) == null ? void 0 : e.craftingComponents) ?? null;
}
f(MK, "getCraftingComponentsLabel");
function Z9(i) {
  const { flaws: e, materialProperties: t } = CONFIG.A5E;
  return i.system.materialProperties.map((s) => {
    var n, l, r;
    if (s === "flaw") {
      const o = (r = (l = (n = i.system.flaws) == null ? void 0 : n.map((a) => K(e[a]) ?? null)) == null ? void 0 : l.filter(Boolean)) == null ? void 0 : r.sort((a, c) => a.localeCompare(c));
      return o.length ? K(
        "A5E.MaterialPropertyFlawSpecific",
        { type: o.join(", ") }
      ) : t.flaw;
    }
    return t[s] ?? s;
  });
}
f(Z9, "getMaterialPropertiesSummary");
function RK(i) {
  const { requiresAttunement: e, attuned: t } = i.system;
  return e ? t ? K("A5E.Attuned") : i.actor ? `${K("A5E.AttunementRequiredPrompt")} - ${K("A5E.AttunedNot")}` : K("A5E.AttunementRequiredPrompt") : null;
}
f(RK, "getAttunementLabel");
function FK(i) {
  const { unidentified: e, rarity: t } = (i == null ? void 0 : i.system) ?? {};
  return !game.user.isGM && e || !t || t === "mundane" ? null : CONFIG.A5E.itemRarity[t] ?? t;
}
f(FK, "getRarityLabel$1");
function NK(i, e) {
  const t = RK(i), { price: s } = i.system, n = FK(i), l = t && !(e != null && e.hideAttunementData), r = s && !(e != null && e.hidePrice);
  return n && !(e != null && e.hideRarity) ? r && l ? `${n} (${t}; Cost ${s})` : r ? `${n} (Cost ${s})` : l ? `${n} (${t})` : n : r && l ? `${t}; Cost ${s}` : r ? `Cost ${s}` : l ? t : null;
}
f(NK, "getObjectMechanicsLabel");
function jK(i) {
  const { shieldProperties: e } = CONFIG.A5E;
  return i.system.shieldProperties.map(
    (t) => e[t] ?? t
  );
}
f(jK, "getShieldProperties");
function LK(i) {
  var n, l, r;
  const { breakerProperties: e, weaponProperties: t } = CONFIG.A5E, s = (r = (l = (n = i.system.breakerProperties) == null ? void 0 : n.map((o) => e[o] ?? null)) == null ? void 0 : l.filter(Boolean)) == null ? void 0 : r.sort((o, a) => o.localeCompare(a));
  return s.length ? K(
    "A5E.weaponProperties.breakerSpecific",
    { type: s.join(", ") }
  ) : t.breaker;
}
f(LK, "getBreakerProperties");
function BK(i) {
  const { defensiveProperties: e, weaponProperties: t } = CONFIG.A5E;
  if (i.system.defensiveProperties) {
    const s = e[i.system.defensiveProperties];
    return K(
      "A5E.weaponProperties.defensiveSpecific",
      { type: s }
    );
  }
  return t.defensive;
}
f(BK, "getDefensiveProperties");
function qK(i) {
  var n, l, r;
  const { versatileOptions: e, weaponProperties: t } = CONFIG.A5E, s = (r = (l = (n = i.system.mounted) == null ? void 0 : n.map((o) => e[o] ?? null)) == null ? void 0 : l.filter(Boolean)) == null ? void 0 : r.sort((o, a) => {
    const c = /d(?<die>\d+)/;
    return o.match(c).groups.die - a.match(c).groups.die;
  });
  return s.length ? K(
    "A5E.weaponProperties.mountedSpecific",
    { dice: s.join(" / ") }
  ) : t.mounted;
}
f(qK, "getMountedProperties");
function GK(i) {
  const { versatileOptions: e, weaponProperties: t } = CONFIG.A5E;
  if (i.system.versatile) {
    const s = e[i.system.versatile];
    return K(
      "A5E.weaponProperties.versatileSpecific",
      { die: s }
    );
  }
  return t.versatile;
}
f(GK, "getVersatileProperties");
function Q9(i) {
  const { weaponProperties: e } = CONFIG.A5E;
  return i.system.weaponProperties.map((t) => {
    switch (t) {
      case "defensive":
        return BK(i);
      case "breaker":
        return LK(i);
      case "mounted":
        return qK(i);
      case "versatile":
        return GK(i);
      default:
        return e[t] ?? null;
    }
  }).filter(Boolean);
}
f(Q9, "getWeaponProperties");
function zK(i, e) {
  const t = {}, { objectType: s } = i.system, n = Z9(i);
  return s === "armor" ? n.push(...PK(i)) : s === "shield" ? n.push(...jK(i)) : s === "weapon" && n.push(...Q9(i)), n.sort((l, r) => l.localeCompare(r)), t.objectProperties = n.join(", "), e != null && e.hideCraftingComponents || (t.craftingComponents = MK(i)), t.objectMechanics = NK(i, e), t;
}
f(zK, "getObjectSummaryData");
function HK(i) {
  const { classSpellLists: e } = CONFIG.A5E, t = [...i.system.classes ?? []], s = [];
  return [
    ["elementalistAir", "Air"],
    ["elementalistEarth", "Earth"],
    ["elementalistFire", "Fire"],
    ["elementalistWater", "Water"]
  ].forEach(([l, r]) => {
    t.includes(l) && (s.push(r), t.splice(t.indexOf(l), 1));
  }), s.length === 4 ? t.push(K("A5E.characterClasses.elementalistCustom", { elements: "All" })) : s.length && t.push(K("A5E.characterClasses.elementalistCustom", { elements: s.join(", ") })), t.map((l) => e[l] ?? l).sort((l, r) => l.localeCompare(r)).join(", ");
}
f(HK, "getClassesLabel");
function UK(i) {
  var t, s, n, l;
  const e = Object.entries(i.system.components).reduce(
    (r, [o, a]) => (a && r.push(CONFIG.A5E.spellComponentAbbreviations[o]), r),
    []
  ).join(", ");
  return typeof ((t = i == null ? void 0 : i.system) == null ? void 0 : t.materials) == "string" && ((n = (s = i == null ? void 0 : i.system) == null ? void 0 : s.materials) != null && n.trim()) ? `${e} (${(l = i == null ? void 0 : i.system) == null ? void 0 : l.materials})` : e;
}
f(UK, "getSpellComponentsLabel");
function VK(i) {
  const { spellSchools: e } = CONFIG.A5E, { schools: t } = i.system, s = e.primary[t.primary] ?? t.primary, n = t.secondary.map((l) => e.secondary[l] ?? l);
  return n.sort((l, r) => l.localeCompare(r)), [s, ...n];
}
f(VK, "getSpellSchools");
function WK(i, e) {
  const t = HK(i), s = UK(i), n = CONFIG.A5E.spellLevels[i.system.level] ?? "", l = VK(i), r = [];
  return e != null && e.hideSpellLevel || r.push(n), r.push(...l), {
    spellClasses: e != null && e.hideSpellClasses ? null : t,
    spellComponents: e != null && e.hideSpellComponents ? null : s,
    spellProperties: r.filter(Boolean).join(", ")
  };
}
f(WK, "getSpellSummaryData");
function Of(i, e, t) {
  var l;
  const s = {}, { mergeObject: n } = foundry.utils;
  return !e && !i.actions ? "" : ((!foundry.utils.isEmpty(e) || ((l = i.actions) == null ? void 0 : l.count) === 1) && n(
    s,
    OK(i, e ?? i.actions.values()[0])
  ), foundry.utils.isEmpty(e) && (i.type === "feature" ? n(s, DK()) : i.type === "maneuver" ? n(s, IK(i)) : i.type === "object" ? n(s, zK(i, e)) : i.type === "spell" && n(s, WK(i, t))), s);
}
f(Of, "getSummaryData");
const _E = class _E extends Item {
  constructor(...e) {
    super(...e), this.dialogs ?? (this.dialogs = {
      actions: {},
      areaScaling: {},
      rollScaling: {},
      targetScaling: {}
    });
  }
  // *****************************************************************************************
  prepareBaseData() {
  }
  prepareDerivedData() {
  }
  /** @inheritdoc */
  getRollData() {
    return { ...super.getRollData() };
  }
  // *****************************************************************************************
  /**
   * A handler for activating an item. An actionId can be passed to this method to use a specific
   * action defined on the item. If there are no actions defined, this method defaults to
   * outputting the item's description.
   *
  //  * This method accepts an options object to further customize the activation process.
   *
   * @param {string} actionId
   * @param {object options
   * @returns
   */
  async activate() {
    !this.actor || !(this != null && this.actor.isOwner) || this.shareItemDescription();
  }
  async shareItemDescription(e) {
    var n, l, r, o, a, c, u;
    const t = {
      user: (n = game.user) == null ? void 0 : n.id,
      speaker: ChatMessage.getSpeaker({ actor: this }),
      flags: {
        a5e: {
          actorId: this.actor.uuid,
          itemId: this.uuid,
          cardType: "item",
          actionName: e == null ? void 0 : e.name,
          actionDescription: (l = e == null ? void 0 : e.descriptionOutputs) != null && l.includes("action") ? await TextEditor.enrichHTML(e.description, {
            async: !0,
            secrets: this.isOwner,
            relativeTo: this,
            rollData: ((r = this == null ? void 0 : this.actor) == null ? void 0 : r.getRollData(this)) ?? {}
          }) : null,
          itemDescription: ((o = e == null ? void 0 : e.descriptionOutputs) == null ? void 0 : o.includes("item")) ?? !0 ? await TextEditor.enrichHTML(this.system.description, {
            async: !0,
            secrets: this.isOwner,
            relativeTo: this,
            rollData: ((a = this == null ? void 0 : this.actor) == null ? void 0 : a.getRollData(this)) ?? {}
          }) : null,
          unidentifiedDescription: ((c = e == null ? void 0 : e.descriptionOutputs) == null ? void 0 : c.includes("item")) ?? !0 ? await TextEditor.enrichHTML(this.system.unidentifiedDescription, {
            async: !0,
            secrets: this.isOwner,
            relativeTo: this,
            rollData: ((u = this == null ? void 0 : this.actor) == null ? void 0 : u.getRollData(this)) ?? {}
          }) : null,
          img: (e == null ? void 0 : e.img) ?? this.img,
          name: this.name,
          summaryData: Of(this, e, {
            hideSpellClasses: !0,
            hideSpellComponents: !0,
            hideSpellLevel: !0
          })
        }
      },
      content: "<article></article>"
    };
    ChatMessage.applyRollMode(t, game.settings.get("core", "rollMode"));
    const s = ChatMessage.create(t);
    return Hooks.callAll("a5e.itemActivate", this, { action: e }), s;
  }
  async configureItem() {
    await this.sheet.render(!0);
  }
  async duplicateItem() {
    const e = this.actor, t = foundry.utils.duplicate(this);
    t.name = `${t.name} (Copy)`, t.type === "object" && (t.system.containerId = null), e ? e.createEmbeddedDocuments("Item", [t]) : Item.createDocuments([t]);
  }
  async toggleFavorite() {
    this.actor && await this.update({
      "system.favorite": !this.system.favorite
    });
  }
  /** @inheritdoc */
  async _preCreate(e, t, s) {
    var n, l, r, o, a, c, u;
    if (await super._preCreate(e, t, s), !((n = this.system.schemaVersion) != null && n.version) && !((l = this.system.schema) != null && l.version)) {
      let d = null;
      typeof ((r = this.system) == null ? void 0 : r.equipped) == "boolean" ? d = 3e-3 : typeof ((o = this.system) == null ? void 0 : o.recharge) == "string" ? d = 2e-3 : typeof ((c = (a = this.system) == null ? void 0 : a.uses) == null ? void 0 : c.max) == "string" ? d = 1e-3 : (u = this.system) != null && u.actionOptions ? d = null : d = wr.LATEST_SCHEMA_VERSION, this.updateSource({
        "this.system.schemaVersion.version": d
      });
    }
  }
  async _preUpdate(e, t, s) {
    super._onUpdate(e, t, s);
  }
  async _onCreate(e, t, s) {
    if (super._onCreate(e, t, s), s !== game.userId)
      return;
    const l = this.effects.contents.map((r) => ({ _id: r._id, origin: this.uuid }));
    this.updateEmbeddedDocuments("ActiveEffect", l);
  }
  async _onDelete(e, t, s) {
    super._onDelete(e, t, s);
  }
  static async _onCreateDocuments(e, t) {
    if (!(t.parent instanceof Actor))
      return Item._onCreateDocuments(e, t);
    const s = [];
    return e.forEach((l) => {
      l.effects.forEach((r) => {
        var c, u;
        if (!(((u = (c = r.flags) == null ? void 0 : c.a5e) == null ? void 0 : u.transferType) === "passive"))
          return;
        const a = r.toJSON();
        a.origin = l.uuid, s.push(a);
      });
    }), s.length ? (getDocumentClass("ActiveEffect").createDocuments(s, t), Item._onCreateDocuments(e, t)) : [];
  }
};
f(_E, "BaseItemA5e");
let Pc = _E;
var vh, D5;
const yE = class yE extends ys {
  constructor(t, s = {}) {
    super(t, s);
    Y(this, vh, null);
    Y(this, D5, null);
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return {
      _id: new t.DocumentIdField({ initial: () => foundry.utils.randomID() }),
      img: new t.StringField({ required: !0, initial: "" }),
      grantType: new t.StringField({ required: !0, initial: "" }),
      label: new t.StringField({ required: !0, initial: "" }),
      level: new t.NumberField({ nullable: !1, initial: 1, min: 1 }),
      levelType: new t.StringField({ required: !0, initial: "character" }),
      optional: new t.BooleanField({ required: !0, initial: !1 })
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getApplyData(t, s) {
    return {};
  }
  getSelectionComponent() {
    return M(this, vh);
  }
  getSelectionComponentProps(t) {
    return { ...t };
  }
  requiresConfig() {
    return !1;
  }
  async configureGrant(t, s, n, l = {}) {
    const r = new pa(
      t,
      n,
      s,
      l
    );
    await r.render(!0);
    const o = await r.promise;
    return o || {};
  }
  async deleteGrant() {
    var n;
    await this.parent.update({
      [`system.grants.-=${this._id}`]: null
    });
    const s = (n = this.parent) == null ? void 0 : n.parent;
    !s || s.documentName !== "Actor" || s.grants.removeGrant(this._id);
  }
};
vh = new WeakMap(), D5 = new WeakMap(), f(yE, "BaseGrant");
let rs = yE;
function KK(i, e) {
  const t = [];
  return e === "abilities" && (i === "bonus" ? t.push(
    {
      heading: "A5E.contexts.abilities",
      options: Object.entries(CONFIG.A5E.abilities),
      selectedProperty: "context.abilities",
      component: "TagGroup"
    }
  ) : t.push(
    {
      heading: "Base Abilities",
      options: Object.entries(CONFIG.A5E.abilities),
      selectedProperty: "abilities.base",
      component: "TagGroup"
    },
    {
      heading: "Ability Choices",
      options: Object.entries(CONFIG.A5E.abilities),
      selectedProperty: "abilities.options",
      component: "TagGroup"
    },
    {
      heading: "Select Ability Bonus Automatically in Roll Prompt",
      selectedProperty: "context.default",
      component: "Checkbox"
    }
  ), t.push(
    {
      heading: "Selectable Options Count",
      selectedProperty: "abilities.total",
      component: "Number"
    },
    {
      heading: "A5E.contexts.bonusTypes",
      options: Object.entries(CONFIG.A5E.abilityBonusContexts),
      selectedProperty: "context.types",
      component: "TagGroup"
    },
    {
      heading: "A5E.contexts.requiresProficiency",
      selectedProperty: "context.requiresProficiency",
      component: "Checkbox"
    }
  )), e === "attacks" && (i === "bonus" ? t.push(
    {
      heading: "A5E.contexts.attackType",
      options: Object.entries(CONFIG.A5E.attackTypes),
      selectedProperty: "context.attackTypes",
      component: "TagGroup"
    }
  ) : t.push(
    {
      heading: "Base Attack Types",
      options: Object.entries(CONFIG.A5E.attackTypes),
      selectedProperty: "attackTypes.base",
      component: "TagGroup"
    },
    {
      heading: "Attack Type Choices",
      options: Object.entries(CONFIG.A5E.attackTypes),
      selectedProperty: "attackTypes.options",
      component: "TagGroup"
    },
    {
      heading: "Select Attack Bonus Automatically in Roll Prompt",
      selectedProperty: "context.default",
      component: "Checkbox"
    }
  ), t.push(
    {
      heading: "Selectable Options Count",
      selectedProperty: "attackTypes.total",
      component: "Number"
    },
    {
      heading: "A5E.contexts.spellLevel",
      options: Object.entries(CONFIG.A5E.spellLevels),
      selectedProperty: "context.spellLevels",
      component: "TagGroup"
    },
    {
      heading: "A5E.contexts.requiresProficiency",
      selectedProperty: "context.requiresProficiency",
      component: "Checkbox"
    }
  )), e === "damage" && (t.push(
    {
      heading: "A5E.contexts.attackType",
      options: Object.entries(CONFIG.A5E.damageBonusContexts),
      selectedProperty: "context.attackTypes",
      component: "TagGroup"
    },
    {
      heading: "A5E.contexts.damageType",
      options: Object.entries(CONFIG.A5E.damageTypes),
      selectedProperty: "context.damageTypes",
      component: "TagGroup"
    },
    {
      heading: "A5E.contexts.spellLevel",
      options: Object.entries(CONFIG.A5E.spellLevels),
      selectedProperty: "context.spellLevels",
      component: "TagGroup"
    },
    {
      heading: "This bonus only applies to critical hits.",
      selectedProperty: "context.isCritBonus",
      component: "Checkbox"
    }
  ), i === "grant" && t.push(
    {
      heading: "Select Damage Bonus Automatically in Roll Prompt",
      selectedProperty: "context.default",
      component: "Checkbox"
    }
  )), e === "healing" && (t.push(
    {
      heading: "A5E.contexts.healingType",
      options: Object.entries(CONFIG.A5E.healingBonusContexts),
      selectedProperty: "context.healingTypes",
      component: "TagGroup"
    },
    {
      heading: "A5E.contexts.spellLevel",
      options: Object.entries(CONFIG.A5E.spellLevels),
      selectedProperty: "context.spellLevels",
      component: "TagGroup"
    }
  ), i === "grant" && t.push(
    {
      heading: "Select Healing Bonus Automatically in Roll Prompt",
      selectedProperty: "context.default",
      component: "Checkbox"
    }
  )), e === "hitPoint" && t.push(
    {
      heading: "A5E.contexts.perLevel",
      selectedProperty: "context.perLevel",
      component: "Checkbox"
    }
  ), e === "initiative" && (t.push(
    {
      heading: "A5E.contexts.abilities",
      options: Object.entries(CONFIG.A5E.abilities),
      selectedProperty: "context.abilities",
      component: "TagGroup"
    },
    {
      heading: "A5E.contexts.skills",
      options: Object.entries(CONFIG.A5E.skills),
      selectedProperty: "context.skills",
      component: "TagGroup"
    }
  ), i === "grant" && t.push(
    {
      heading: "Select Initiative Bonus Automatically in Roll Prompt",
      selectedProperty: "context.default",
      component: "Checkbox"
    }
  )), e === "movement" && (i === "bonus" ? t.push(
    {
      heading: "A5E.contexts.movementType",
      options: Object.entries(CONFIG.A5E.movementAbbreviations),
      selectedProperty: "context.movementTypes",
      component: "TagGroup"
    }
  ) : t.push(
    {
      heading: "Base Movement Types",
      options: Object.entries(CONFIG.A5E.movementAbbreviations),
      selectedProperty: "movementTypes.base",
      component: "TagGroup"
    },
    {
      heading: "Movement Type Choices",
      options: Object.entries(CONFIG.A5E.movementAbbreviations),
      selectedProperty: "movementTypes.options",
      component: "TagGroup"
    }
  ), t.push(
    {
      heading: "Selectable Options Count",
      selectedProperty: "movementTypes.total",
      component: "Number"
    },
    // {
    //   heading: 'Value If Original Is Zero',
    //   selectedProperty: 'context.valueIfOriginalIsZero',
    //   component: 'String'
    // },
    {
      heading: "Is Hover For Flying Speed",
      selectedProperty: "context.isHover",
      component: "Checkbox"
    }
  )), e === "senses" && (i === "bonus" ? t.push(
    {
      heading: "A5E.contexts.senses",
      options: Object.entries(CONFIG.A5E.senses),
      selectedProperty: "context.senses",
      component: "TagGroup"
    }
  ) : t.push(
    {
      heading: "Base Senses",
      options: Object.entries(CONFIG.A5E.senses),
      selectedProperty: "senses.base",
      component: "TagGroup"
    },
    {
      heading: "Senses Type Choices",
      options: Object.entries(CONFIG.A5E.senses),
      selectedProperty: "senses.options",
      component: "TagGroup"
    }
  ), t.push(
    {
      heading: "Selectable Options Count",
      selectedProperty: "senses.total",
      component: "Number"
    },
    // {
    //   heading: 'Value If Original Is Zero',
    //   selectedProperty: 'context.valueIfOriginalIsZero',
    //   component: 'String'
    // },
    {
      heading: "Is Blind Beyond Vision Range",
      selectedProperty: "context.otherwiseBlind",
      component: "Checkbox"
    }
  )), e === "skills" && (i === "bonus" ? t.push(
    {
      heading: "A5E.contexts.skills",
      options: Object.entries(CONFIG.A5E.skills),
      selectedProperty: "context.skills",
      component: "TagGroup"
    }
  ) : t.push(
    {
      heading: "Base Skills",
      options: Object.entries(CONFIG.A5E.skills),
      selectedProperty: "skills.base",
      component: "TagGroup"
    },
    {
      heading: "Skill Choices",
      options: Object.entries(CONFIG.A5E.skills),
      selectedProperty: "skills.options",
      component: "TagGroup"
    },
    {
      heading: "Select Skill Bonus Automatically in Roll Prompt",
      selectedProperty: "context.default",
      component: "Checkbox"
    }
  ), t.push(
    {
      heading: "Selectable Options Count",
      selectedProperty: "skills.total",
      component: "Number"
    },
    {
      heading: "A5E.contexts.requiresProficiency",
      selectedProperty: "context.requiresProficiency",
      component: "Checkbox"
    },
    {
      heading: "A5E.contexts.passiveOnly",
      selectedProperty: "context.passiveOnly",
      component: "Checkbox"
    }
  )), t;
}
f(KK, "getContextsMap");
function bI(i, e, t) {
  const s = i.slice();
  return s[12] = e[t], s;
}
f(bI, "get_each_context$1v");
function YK(i) {
  let e, t, s;
  return e = new de({
    props: {
      heading: (
        /*context*/
        i[12].heading
      ),
      $$slots: { default: [QK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--background", "none"), z(t, "--padding", "0"), z(t, "--margin", "0 0 0.5rem 0 ");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, grant*/
      32769 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(YK, "create_if_block_3$y");
function XK(i) {
  let e, t, s;
  return e = new de({
    props: {
      heading: (
        /*context*/
        i[12].heading
      ),
      $$slots: { default: [xK] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--background", "none"), z(t, "--padding", "0"), z(t, "--margin", "0 0 0.5rem 0 ");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, grant*/
      32769 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(XK, "create_if_block_2$R");
function JK(i) {
  let e, t;
  function s(...n) {
    return (
      /*updateSelection_handler_1*/
      i[7](
        /*context*/
        i[12],
        ...n
      )
    );
  }
  return f(s, "updateSelection_handler_1"), e = new De({
    props: {
      label: (
        /*context*/
        i[12].heading
      ),
      checked: (
        /*getProperty*/
        i[2](
          /*grant*/
          i[0],
          /*context*/
          i[12].selectedProperty
        )
      )
    }
  }), e.$on("updateSelection", s), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      i = n;
      const r = {};
      l & /*grant*/
      1 && (r.checked = /*getProperty*/
      i[2](
        /*grant*/
        i[0],
        /*context*/
        i[12].selectedProperty
      )), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(JK, "create_if_block_1$1m");
function ZK(i) {
  let e, t;
  function s(...n) {
    return (
      /*updateSelection_handler*/
      i[6](
        /*context*/
        i[12],
        ...n
      )
    );
  }
  return f(s, "updateSelection_handler"), e = new Ze({
    props: {
      heading: (
        /*context*/
        i[12].heading
      ),
      options: (
        /*context*/
        i[12].options
      ),
      selected: (
        /*getProperty*/
        i[2](
          /*grant*/
          i[0],
          /*context*/
          i[12].selectedProperty
        )
      ),
      showToggleAllButton: !0
    }
  }), e.$on("updateSelection", s), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      i = n;
      const r = {};
      l & /*grant*/
      1 && (r.selected = /*getProperty*/
      i[2](
        /*grant*/
        i[0],
        /*context*/
        i[12].selectedProperty
      )), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(ZK, "create_if_block$26");
function QK(i) {
  let e, t, s, n, l;
  function r(...o) {
    return (
      /*change_handler_1*/
      i[9](
        /*context*/
        i[12],
        ...o
      )
    );
  }
  return f(r, "change_handler_1"), {
    c() {
      e = E("input"), s = R(), b(e, "type", "text"), e.value = t = /*getProperty*/
      i[2](
        /*grant*/
        i[0],
        /*context*/
        i[12].selectedProperty
      ) || "";
    },
    m(o, a) {
      T(o, e, a), T(o, s, a), n || (l = V(e, "change", r), n = !0);
    },
    p(o, a) {
      i = o, a & /*grant*/
      1 && t !== (t = /*getProperty*/
      i[2](
        /*grant*/
        i[0],
        /*context*/
        i[12].selectedProperty
      ) || "") && e.value !== t && (e.value = t);
    },
    d(o) {
      o && (S(e), S(s)), n = !1, l();
    }
  };
}
f(QK, "create_default_slot_2$O");
function xK(i) {
  let e, t, s, n, l;
  function r(...o) {
    return (
      /*change_handler*/
      i[8](
        /*context*/
        i[12],
        ...o
      )
    );
  }
  return f(r, "change_handler"), {
    c() {
      e = E("input"), s = R(), b(e, "type", "number"), e.value = t = /*getProperty*/
      i[2](
        /*grant*/
        i[0],
        /*context*/
        i[12].selectedProperty
      ) ?? 0;
    },
    m(o, a) {
      T(o, e, a), T(o, s, a), n || (l = V(e, "change", r), n = !0);
    },
    p(o, a) {
      i = o, a & /*grant*/
      1 && t !== (t = /*getProperty*/
      i[2](
        /*grant*/
        i[0],
        /*context*/
        i[12].selectedProperty
      ) ?? 0) && e.value !== t && (e.value = t);
    },
    d(o) {
      o && (S(e), S(s)), n = !1, l();
    }
  };
}
f(xK, "create_default_slot_1$1a");
function _I(i) {
  let e, t, s, n;
  const l = [ZK, JK, XK, YK], r = [];
  function o(a, c) {
    return (
      /*context*/
      a[12].component === "TagGroup" ? 0 : (
        /*context*/
        a[12].component === "Checkbox" ? 1 : (
          /*context*/
          a[12].component === "Number" ? 2 : (
            /*context*/
            a[12].component === "String" ? 3 : -1
          )
        )
      )
    );
  }
  return f(o, "select_block_type"), ~(e = o(i)) && (t = r[e] = l[e](i)), {
    c() {
      t && t.c(), s = $e();
    },
    m(a, c) {
      ~e && r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      t && t.p(a, c);
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), ~e && r[e].d(a);
    }
  };
}
f(_I, "create_each_block$1v");
function eY(i) {
  let e, t, s = oe(
    /*contextMap*/
    i[3]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = _I(bI(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, o) {
      if (o & /*contextMap, getProperty, grant, onUpdateValue, Number*/
      29) {
        s = oe(
          /*contextMap*/
          r[3]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = bI(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = _I(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f(eY, "create_default_slot$1_");
function tY(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Contexts",
      hint: "The context determines when the bonus applies",
      $$slots: { default: [eY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, grant*/
      32769 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(tY, "create_fragment$3S");
function sY(i, e, t) {
  let s, n;
  const l = fe("item");
  pe(i, l, (h) => t(5, n = h));
  const r = fe("grantId"), o = fe("grantType"), a = foundry.utils.getProperty, c = KK("grant", o);
  function u(h, _) {
    h = `system.grants.${r}.${h}`, se(n, h, _);
  }
  f(u, "onUpdateValue");
  const d = /* @__PURE__ */ f((h, { detail: _ }) => {
    u(h.selectedProperty, _);
  }, "updateSelection_handler"), p = /* @__PURE__ */ f((h, { detail: _ }) => {
    u(h.selectedProperty, _);
  }, "updateSelection_handler_1"), m = /* @__PURE__ */ f((h, { target: _ }) => {
    u(h.selectedProperty, Number(_.value));
  }, "change_handler"), g = /* @__PURE__ */ f((h, { target: _ }) => {
    u(h.selectedProperty, _.value);
  }, "change_handler_1");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    32 && t(0, s = n.system.grants[r]);
  }, [
    s,
    l,
    a,
    c,
    u,
    n,
    d,
    p,
    m,
    g
  ];
}
f(sY, "instance$3J");
const vE = class vE extends ie {
  constructor(e) {
    super(), le(this, e, sY, tY, ne, {});
  }
};
f(vE, "NumericalGrantContexts");
let Ey = vE;
function nY(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), e.value = t = /*grant*/
      i[0].level ?? 1, b(e, "min", "1");
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[6]
      ), s = !0);
    },
    p(l, r) {
      r & /*grant*/
      1 && t !== (t = /*grant*/
      l[0].level ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(nY, "create_default_slot_1$19");
function iY(i) {
  let e, t, s, n, l, r, o;
  const a = (
    /*#slots*/
    i[5].default
  ), c = Pt(
    a,
    i,
    /*$$scope*/
    i[9],
    null
  );
  return t = new de({
    props: {
      heading: "A5E.Level",
      $$slots: { default: [nY] },
      $$scope: { ctx: i }
    }
  }), n = new Ye({
    props: {
      heading: "A5E.classes.levelType",
      options: Object.entries(
        /*levelTypes*/
        i[2]
      ),
      selected: (
        /*grant*/
        i[0].levelType
      ),
      allowDeselect: !1
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  ), r = new De({
    props: {
      label: "Mark grant as optional",
      checked: (
        /*grant*/
        i[0].optional ?? !1
      )
    }
  }), r.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[8]
  ), {
    c() {
      c && c.c(), e = R(), L(t.$$.fragment), s = R(), L(n.$$.fragment), l = R(), L(r.$$.fragment);
    },
    m(u, d) {
      c && c.m(u, d), T(u, e, d), N(t, u, d), T(u, s, d), N(n, u, d), T(u, l, d), N(r, u, d), o = !0;
    },
    p(u, d) {
      c && c.p && (!o || d & /*$$scope*/
      512) && Rt(
        c,
        a,
        u,
        /*$$scope*/
        u[9],
        o ? Mt(
          a,
          /*$$scope*/
          u[9],
          d,
          null
        ) : Ft(
          /*$$scope*/
          u[9]
        ),
        null
      );
      const p = {};
      d & /*$$scope, grant*/
      513 && (p.$$scope = { dirty: d, ctx: u }), t.$set(p);
      const m = {};
      d & /*grant*/
      1 && (m.selected = /*grant*/
      u[0].levelType), n.$set(m);
      const g = {};
      d & /*grant*/
      1 && (g.checked = /*grant*/
      u[0].optional ?? !1), r.$set(g);
    },
    i(u) {
      o || (w(c, u), w(t.$$.fragment, u), w(n.$$.fragment, u), w(r.$$.fragment, u), o = !0);
    },
    o(u) {
      C(c, u), C(t.$$.fragment, u), C(n.$$.fragment, u), C(r.$$.fragment, u), o = !1;
    },
    d(u) {
      u && (S(e), S(s), S(l)), c && c.d(u), j(t, u), j(n, u), j(r, u);
    }
  };
}
f(iY, "create_default_slot$1Z");
function lY(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Grant Config",
      $$slots: { default: [iY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, grant*/
      513 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(lY, "create_fragment$3R");
function rY(i, e, t) {
  let s, n, { $$slots: l = {}, $$scope: r } = e;
  const o = fe("item");
  pe(i, o, (g) => t(4, n = g));
  const a = fe("grantId"), c = CONFIG.A5E.classLevelTypes;
  function u(g, h) {
    g = `system.grants.${a}.${g}`, se(n, g, h);
  }
  f(u, "onUpdateValue");
  const d = /* @__PURE__ */ f(({ target: g }) => {
    u("level", Math.max(Number(g.value), 1));
  }, "change_handler"), p = /* @__PURE__ */ f(({ detail: g }) => u("levelType", g), "updateSelection_handler"), m = /* @__PURE__ */ f(({ detail: g }) => u("optional", g), "updateSelection_handler_1");
  return i.$$set = (g) => {
    "$$scope" in g && t(9, r = g.$$scope);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item*/
    16 && t(0, s = n.system.grants[a]);
  }, [
    s,
    o,
    c,
    u,
    n,
    l,
    d,
    p,
    m,
    r
  ];
}
f(rY, "instance$3I");
const kE = class kE extends ie {
  constructor(e) {
    super(), le(this, e, rY, lY, ne, {});
  }
};
f(kE, "GrantConfig");
let In = kE;
function yI(i, e, t) {
  const s = i.slice();
  return s[14] = e[t][0], s[15] = e[t][1], s;
}
f(yI, "get_each_context$1u");
function oY(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*grant*/
      i[3].bonus ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[12]
      ), s = !0);
    },
    p(l, r) {
      r & /*grant*/
      8 && t !== (t = /*grant*/
      l[3].bonus ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(oY, "create_default_slot_2$N");
function aY(i) {
  var n;
  let e, t, s;
  return e = new de({
    props: {
      heading: (
        /*configObject*/
        ((n = i[7][
          /*grantType*/
          i[0]
        ]) == null ? void 0 : n.selectHeading) ?? ""
      ),
      $$slots: { default: [cY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--background", "none"), z(t, "--direction", "column"), z(t, "--padding", "0");
    },
    m(l, r) {
      T(l, t, r), N(e, t, null), s = !0;
    },
    p(l, r) {
      var a;
      const o = {};
      r & /*grantType*/
      1 && (o.heading = /*configObject*/
      ((a = l[7][
        /*grantType*/
        l[0]
      ]) == null ? void 0 : a.selectHeading) ?? ""), r & /*$$scope, grantType, grant, selectProperty*/
      262157 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
    },
    i(l) {
      s || (w(e.$$.fragment, l), s = !0);
    },
    o(l) {
      C(e.$$.fragment, l), s = !1;
    },
    d(l) {
      l && e && S(t), j(e, l);
    }
  };
}
f(aY, "create_if_block$25");
function vI(i, e) {
  let t, s = K(
    /*name*/
    e[15]
  ) + "", n, l, r, o;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = x(s), l = R(), t.__value = r = /*key*/
      e[14], qe(t, t.__value), t.selected = o = /*grant*/
      e[3][
        /*selectProperty*/
        e[2]
      ] === /*key*/
      e[14], this.first = t;
    },
    m(a, c) {
      T(a, t, c), A(t, n), A(t, l);
    },
    p(a, c) {
      e = a, c & /*grantType*/
      1 && s !== (s = K(
        /*name*/
        e[15]
      ) + "") && _e(n, s), c & /*grantType*/
      1 && r !== (r = /*key*/
      e[14]) && (t.__value = r, qe(t, t.__value)), c & /*grant, selectProperty, grantType*/
      13 && o !== (o = /*grant*/
      e[3][
        /*selectProperty*/
        e[2]
      ] === /*key*/
      e[14]) && (t.selected = o);
    },
    d(a) {
      a && S(t);
    }
  };
}
f(vI, "create_each_block$1u");
function cY(i) {
  let e, t, s = K("A5E.None") + "", n, l, r, o = [], a = /* @__PURE__ */ new Map(), c, u, d = oe(Object.entries(
    /*configObject*/
    i[7][
      /*grantType*/
      i[0]
    ].selectTypes
  ));
  const p = /* @__PURE__ */ f((m) => (
    /*key*/
    m[14]
  ), "get_key");
  for (let m = 0; m < d.length; m += 1) {
    let g = yI(i, d, m), h = p(g);
    a.set(h, o[m] = vI(h, g));
  }
  return {
    c() {
      e = E("select"), t = E("option"), n = x(s), l = R();
      for (let m = 0; m < o.length; m += 1)
        o[m].c();
      t.__value = null, qe(t, t.__value), t.selected = r = /*grant*/
      i[3][
        /*selectProperty*/
        i[2]
      ] === "null" || /*grant*/
      i[3][
        /*selectProperty*/
        i[2]
      ] === null, b(e, "class", "u-w-fit damage-type-select");
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(t, n), A(t, l);
      for (let h = 0; h < o.length; h += 1)
        o[h] && o[h].m(e, null);
      c || (u = V(
        e,
        "change",
        /*change_handler_2*/
        i[13]
      ), c = !0);
    },
    p(m, g) {
      g & /*grant, selectProperty*/
      12 && r !== (r = /*grant*/
      m[3][
        /*selectProperty*/
        m[2]
      ] === "null" || /*grant*/
      m[3][
        /*selectProperty*/
        m[2]
      ] === null) && (t.selected = r), g & /*Object, configObject, grantType, grant, selectProperty*/
      141 && (d = oe(Object.entries(
        /*configObject*/
        m[7][
          /*grantType*/
          m[0]
        ].selectTypes
      )), o = kt(o, g, p, 1, m, d, a, e, vs, vI, null, yI));
    },
    d(m) {
      m && S(e);
      for (let g = 0; g < o.length; g += 1)
        o[g].d();
      c = !1, u();
    }
  };
}
f(cY, "create_default_slot_1$18");
function uY(i) {
  let e, t, s, n, l;
  e = new de({
    props: {
      heading: "A5E.Formula",
      $$slots: { default: [oY] },
      $$scope: { ctx: i }
    }
  });
  let r = (
    /*hasSelectDialog*/
    i[8] && aY(i)
  );
  return {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), r && r.c(), n = $e(), z(t, "display", "contents"), z(
        t,
        "--a5e-field-wrapper-grow",
        /*hasSelectDialog*/
        i[8] ? "1" : "0"
      );
    },
    m(o, a) {
      T(o, t, a), N(e, t, null), T(o, s, a), r && r.m(o, a), T(o, n, a), l = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$$scope, grant*/
      262152 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c), /*hasSelectDialog*/
      o[8] && r.p(o, a);
    },
    i(o) {
      l || (w(e.$$.fragment, o), w(r), l = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(r), l = !1;
    },
    d(o) {
      o && (S(s), S(n)), o && e && S(t), j(e, o), r && r.d(o);
    }
  };
}
f(uY, "create_default_slot$1Y");
function fY(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k, v;
  return d = new Me({
    props: {
      $$slots: { default: [uY] },
      $$scope: { ctx: i }
    }
  }), g = new Ey({}), _ = new In({}), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), p = E("div"), L(d.$$.fragment), m = R(), L(g.$$.fragment), h = R(), L(_.$$.fragment), b(s, "class", "grant-image svelte-r6yl7x"), ze(s.src, n = /*grant*/
      i[3].img || /*$item*/
      i[1].img || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[3].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*grant*/
      i[3].label ?? "", b(a, "class", "grant-name svelte-r6yl7x"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-r6yl7x"), b(t, "class", "sheet-header svelte-r6yl7x"), z(p, "display", "contents"), z(p, "--a5e-section-margin", "0.25rem 0"), z(
        p,
        "--a5e-section-body-direction",
        /*hasSelectDialog*/
        i[8] ? "row" : "column"
      ), b(e, "class", "svelte-r6yl7x");
    },
    m(O, P) {
      T(O, e, P), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, u), A(e, p), N(d, p, null), A(e, m), N(g, e, null), A(e, h), N(_, e, null), y = !0, k || (v = [
        V(
          s,
          "click",
          /*updateImage*/
          i[4]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[11]
        )
      ], k = !0);
    },
    p(O, [P]) {
      (!y || P & /*grant, $item*/
      10 && !ze(s.src, n = /*grant*/
      O[3].img || /*$item*/
      O[1].img || "icons/svg/upgrade.svg")) && b(s, "src", n), (!y || P & /*grant*/
      8 && l !== (l = /*grant*/
      O[3].label)) && b(s, "alt", l), (!y || P & /*grant*/
      8 && c !== (c = /*grant*/
      O[3].label ?? "") && a.value !== c) && (a.value = c);
      const D = {};
      P & /*$$scope, grantType, grant, selectProperty*/
      262157 && (D.$$scope = { dirty: P, ctx: O }), d.$set(D);
    },
    i(O) {
      y || (w(d.$$.fragment, O), w(g.$$.fragment, O), w(_.$$.fragment, O), y = !0);
    },
    o(O) {
      C(d.$$.fragment, O), C(g.$$.fragment, O), C(_.$$.fragment, O), y = !1;
    },
    d(O) {
      O && S(e), j(d), j(g), j(_), k = !1, Ne(v);
    }
  };
}
f(fY, "create_fragment$3Q");
function dY(i, e, t) {
  let s, n, l, { document: r, grantId: o, grantType: a } = fe("#external").application, { document: c = r, grantId: u = o, grantType: d = a } = e;
  function p() {
    const O = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: O,
      callback: (D) => {
        m("img", D);
      }
    }).browse();
  }
  f(p, "updateImage");
  function m(O, P) {
    O = `system.grants.${u}.${O}`, se(l, O, P);
  }
  f(m, "onUpdateValue"), Nt(() => {
    g.destroy();
  });
  const g = new Bt(c);
  pe(i, g, (O) => t(1, l = O));
  const h = {
    abilities: {},
    damage: {
      selectHeading: "A5E.DamageType",
      selectTypes: CONFIG.A5E.damageTypes,
      selectProperty: "damageType"
    },
    healing: {
      selectHeading: "A5E.HealingType",
      selectTypes: CONFIG.A5E.healingTypes,
      selectProperty: "healingType"
    },
    movement: {
      selectHeading: "A5E.Unit",
      selectTypes: CONFIG.A5E.distanceUnits,
      selectProperty: "unit"
    },
    senses: {
      selectHeading: "A5E.Unit",
      selectTypes: CONFIG.A5E.visionUnits,
      selectProperty: "unit"
    },
    skills: {}
  }, _ = ["damage", "healing", "movement", "senses"].includes(d);
  et("item", g), et("grantId", u), et("grantType", d);
  const y = /* @__PURE__ */ f(({ target: O }) => m("label", O.value), "change_handler"), k = /* @__PURE__ */ f(({ target: O }) => m("bonus", O.value), "change_handler_1"), v = /* @__PURE__ */ f(({ target: O }) => {
    var P;
    return m((P = h[d]) == null ? void 0 : P.selectProperty, O.value);
  }, "change_handler_2");
  return i.$$set = (O) => {
    "document" in O && t(9, c = O.document), "grantId" in O && t(10, u = O.grantId), "grantType" in O && t(0, d = O.grantType);
  }, i.$$.update = () => {
    var O;
    i.$$.dirty & /*$item, grantId*/
    1026 && t(3, s = l.system.grants[u]), i.$$.dirty & /*grantType*/
    1 && t(2, n = (O = h[d]) == null ? void 0 : O.selectProperty);
  }, [
    d,
    l,
    n,
    s,
    p,
    m,
    g,
    h,
    _,
    c,
    u,
    y,
    k,
    v
  ];
}
f(dY, "instance$3H");
const wE = class wE extends ie {
  constructor(e) {
    super(), le(this, e, dY, fY, ne, { document: 9, grantId: 10, grantType: 0 });
  }
};
f(wE, "NumericalGrantConfig");
let Pn = wE;
function pY(i) {
  let e, t;
  return e = new Ze({
    props: {
      options: (
        /*getOptions*/
        i[9](
          /*choicesLocked*/
          i[5]
        )
      ),
      selected: (
        /*selected*/
        i[0]
      ),
      orange: (
        /*choices*/
        i[3]
      ),
      disabled: (
        /*selected*/
        i[0].length >= /*totalCount*/
        i[4]
      )
    }
  }), e.$on(
    "updateSelection",
    /*onUpdateSelection*/
    i[8]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*choicesLocked*/
      32 && (l.options = /*getOptions*/
      s[9](
        /*choicesLocked*/
        s[5]
      )), n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), n & /*choices*/
      8 && (l.orange = /*choices*/
      s[3]), n & /*selected, totalCount*/
      17 && (l.disabled = /*selected*/
      s[0].length >= /*totalCount*/
      s[4]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(pY, "create_default_slot_2$M");
function mY(i) {
  let e;
  return {
    c() {
      e = x(
        /*summary*/
        i[6]
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*summary*/
      64 && _e(
        e,
        /*summary*/
        t[6]
      );
    },
    d(t) {
      t && S(e);
    }
  };
}
f(mY, "create_default_slot_1$17");
function hY(i) {
  let e, t, s, n, l;
  return e = new de({
    props: {
      warning: (
        /*remainingSelections*/
        i[7] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
        i[7]} choices remaining.`
      ),
      showWarning: (
        /*selected*/
        i[0].length < /*totalCount*/
        i[4]
      ),
      $$slots: { default: [pY] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      $$slots: { default: [mY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--direction", "column");
    },
    m(r, o) {
      T(r, t, o), N(e, t, null), T(r, s, o), N(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*remainingSelections*/
      128 && (a.warning = /*remainingSelections*/
      r[7] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
      r[7]} choices remaining.`), o & /*selected, totalCount*/
      17 && (a.showWarning = /*selected*/
      r[0].length < /*totalCount*/
      r[4]), o & /*$$scope, choicesLocked, selected, choices, totalCount*/
      131129 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, summary*/
      131136 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && S(s), r && e && S(t), j(e, r), j(n, r);
    }
  };
}
f(hY, "create_default_slot$1X");
function gY(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: (
        /*heading*/
        i[2] + " - " + /*grant*/
        i[1].label
      ),
      headerButtons: [
        {
          classes: "add-button",
          handler: (
            /*func*/
            i[14]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          i[5] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            i[5] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ],
      $$slots: { default: [hY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*heading, grant*/
      6 && (r.heading = /*heading*/
      n[2] + " - " + /*grant*/
      n[1].label), l & /*choicesLocked*/
      32 && (r.headerButtons = [
        {
          classes: "add-button",
          handler: (
            /*func*/
            n[14]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          n[5] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            n[5] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ]), l & /*$$scope, summary, remainingSelections, selected, totalCount, choicesLocked, choices*/
      131321 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(gY, "create_fragment$3P");
function bY(i, e, t) {
  let s, n, l, { grant: r } = e, { heading: o } = e, { base: a } = e, { choices: c } = e, { configObject: u = {} } = e, { count: d } = e, { bonus: p } = e, { selected: m } = e;
  function g(O, P) {
    return ` This grant provides a bonus of ${O} to ${P.map((D) => u[D]).join(", ")}.`;
  }
  f(g, "getGrantSummary");
  function h({ detail: O }) {
    t(0, m = O), y("updateSelection", { selected: m, summary: l });
  }
  f(h, "onUpdateSelection");
  function _(O) {
    if (!O)
      return Object.entries(u);
    const P = [];
    for (const [D, I] of Object.entries(u))
      c.includes(D) && P.push([D, I]);
    return P;
  }
  f(_, "getOptions");
  const y = it();
  let k = !0;
  const v = /* @__PURE__ */ f(() => t(5, k = !k), "func");
  return i.$$set = (O) => {
    "grant" in O && t(1, r = O.grant), "heading" in O && t(2, o = O.heading), "base" in O && t(10, a = O.base), "choices" in O && t(3, c = O.choices), "configObject" in O && t(11, u = O.configObject), "count" in O && t(12, d = O.count), "bonus" in O && t(13, p = O.bonus), "selected" in O && t(0, m = O.selected);
  }, i.$$.update = () => {
    i.$$.dirty & /*base, count*/
    5120 && t(4, s = a.length + d), i.$$.dirty & /*base, selected*/
    1025 && t(0, m = [...a, ...m]), i.$$.dirty & /*totalCount, selected*/
    17 && t(7, n = s - m.length), i.$$.dirty & /*bonus, selected*/
    8193 && t(6, l = g(p, m));
  }, [
    m,
    r,
    o,
    c,
    s,
    k,
    l,
    n,
    h,
    _,
    a,
    u,
    d,
    p,
    v
  ];
}
f(bY, "instance$3G");
const $E = class $E extends ie {
  constructor(e) {
    super(), le(this, e, bY, gY, ne, {
      grant: 1,
      heading: 2,
      base: 10,
      choices: 3,
      configObject: 11,
      count: 12,
      bonus: 13,
      selected: 0
    });
  }
};
f($E, "NumericalGrantSelectionDialog");
let Or = $E;
function x9(i) {
  const { fields: e } = foundry.data, t = {
    types: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
      initial: ["check", "save"]
    }),
    requiresProficiency: new e.BooleanField({ required: !0, initial: !1 })
  };
  return i === "bonus" && (t.abilities = new e.ArrayField(
    new e.StringField({ required: !0, initial: "" }),
    { initial: [] }
  )), i === "grant" && (t.default = new e.BooleanField({ required: !0, initial: !0 })), t;
}
f(x9, "getAbilitiesBonusContext");
function eB(i) {
  const { fields: e } = foundry.data, t = {
    spellLevels: new e.ArrayField(
      new e.StringField({ required: !0, initial: "" }),
      { initial: [] }
    ),
    requiresProficiency: new e.BooleanField({ required: !0, initial: !1 })
  };
  return i === "bonus" && (t.attackTypes = new e.ArrayField(
    new e.StringField({ required: !0, initial: "" }),
    { initial: [] }
  )), i === "grant" && (t.default = new e.BooleanField({ required: !0, initial: !0 })), t;
}
f(eB, "getAttackBonusContext");
function tB(i) {
  const { fields: e } = foundry.data, t = {
    attackTypes: new e.ArrayField(
      new e.StringField({ required: !0, initial: "" }),
      { initial: [] }
    ),
    damageTypes: new e.ArrayField(
      new e.StringField({ required: !0, initial: "" }),
      { initial: [] }
    ),
    isCritBonus: new e.BooleanField({ required: !0, initial: !1 }),
    spellLevels: new e.ArrayField(
      new e.StringField({ required: !0, initial: "" }),
      { initial: [] }
    )
  };
  return i === "grant" && (t.default = new e.BooleanField({ required: !0, initial: !0 })), t;
}
f(tB, "getDamageBonusContext");
function sB(i) {
  const { fields: e } = foundry.data, t = {
    healingTypes: new e.ArrayField(
      new e.StringField({ required: !0, initial: "" }),
      { initial: ["healing"] }
    ),
    spellLevels: new e.ArrayField(
      new e.StringField({ required: !0, initial: "" }),
      { initial: [] }
    )
  };
  return i === "grant" && (t.default = new e.BooleanField({ required: !0, initial: !0 })), t;
}
f(sB, "getHealingBonusContext");
function nB() {
  const { fields: i } = foundry.data;
  return {
    perLevel: new i.BooleanField({ required: !0, initial: !1 })
  };
}
f(nB, "getHitPointsBonusContext");
function iB(i) {
  const { fields: e } = foundry.data, t = {
    abilities: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
      initial: Object.keys(CONFIG.A5E.abilities)
    }),
    skills: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), {
      initial: Object.keys(CONFIG.A5E.skills)
    })
  };
  return i === "grant" && (t.default = new e.BooleanField({ required: !0, initial: !0 })), t;
}
f(iB, "getInitiativeBonusContext");
function lB(i) {
  const { fields: e } = foundry.data, t = {
    isHover: new e.BooleanField({ required: !0, initial: !1 })
    // valueIfOriginalIsZero: new fields.StringField({ required: true, initial: '' })
  };
  return i === "bonus" && (t.movementTypes = new e.ArrayField(
    new e.StringField({ required: !0, initial: "" }),
    { initial: [] }
  )), t;
}
f(lB, "getMovementBonusContext");
function rB(i) {
  const { fields: e } = foundry.data, t = {
    otherwiseBlind: new e.BooleanField({ required: !0, initial: !1 })
    // valueIfOriginalIsZero: new fields.StringField({ required: true, initial: '' })
  };
  return i === "bonus" && (t.senses = new e.ArrayField(
    new e.StringField({ required: !0, initial: "" }),
    { initial: [] }
  )), t;
}
f(rB, "getSensesBonusContext");
function oB(i) {
  const { fields: e } = foundry.data, t = {
    passiveOnly: new e.BooleanField({ required: !0, initial: !1 }),
    requiresProficiency: new e.BooleanField({ required: !0, initial: !1 })
  };
  return i === "bonus" && (t.skills = new e.ArrayField(
    new e.StringField({ required: !0, initial: "" }),
    { initial: [] }
  )), i === "grant" && (t.default = new e.BooleanField({ required: !0, initial: !0 })), t;
}
f(oB, "getSkillBonusContext");
var kh, wh, I5;
const AE = class AE extends rs {
  constructor() {
    super(...arguments);
    Y(this, kh, Or);
    Y(this, wh, Pn);
    Y(this, I5, "ability");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "ability" }),
      abilities: new t.SchemaField({
        base: new t.ArrayField(
          new t.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        options: new t.ArrayField(
          new t.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      context: new t.SchemaField(x9("grant")),
      label: new t.StringField({ required: !0, initial: "New Ability Grant" })
    });
  }
  getApplyData(t, s) {
    var a, c;
    if (!t)
      return {};
    const n = (s == null ? void 0 : s.selected) ?? this.abilities.base ?? [], l = foundry.utils.randomID(), r = {
      context: {
        abilities: n,
        ...this.context
      },
      formula: this.bonus,
      label: this.label || ((a = this.parent) == null ? void 0 : a.name) || "Ability Grant",
      default: this.context.default ?? !0,
      img: this.img || ((c = this == null ? void 0 : this.parent) == null ? void 0 : c.img)
    };
    delete r.context.default;
    const o = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      bonusId: l,
      type: "abilities",
      grantType: "bonus",
      level: this.level
    };
    return {
      [`system.bonuses.abilities.${l}`]: r,
      "system.grants": {
        ...t.system.grants,
        [this._id]: o
      }
    };
  }
  getSelectionComponent() {
    return M(this, kh);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.abilities.base,
      bonus: this.bonus,
      choices: this.abilities.options,
      configObject: CONFIG.A5E.abilities,
      count: this.abilities.total,
      heading: "Ability Grant Selection",
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return this.abilities.options.length;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: "abilities"
    };
    super.configureGrant(
      "Configure Ability Grant",
      t,
      M(this, wh),
      { width: 400 }
    );
  }
};
kh = new WeakMap(), wh = new WeakMap(), I5 = new WeakMap(), f(AE, "AbilityGrant");
let Sy = AE;
var $h, Ah, P5;
const EE = class EE extends rs {
  constructor() {
    super(...arguments);
    Y(this, $h, Or);
    Y(this, Ah, Pn);
    Y(this, P5, "attack");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "attack" }),
      attackTypes: new t.SchemaField({
        base: new t.ArrayField(
          new t.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        options: new t.ArrayField(
          new t.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      context: new t.SchemaField(eB("grant")),
      label: new t.StringField({ required: !0, initial: "New Attack Grant" })
    });
  }
  getApplyData(t, s) {
    var a, c;
    if (!t)
      return {};
    const n = (s == null ? void 0 : s.selected) ?? this.attackTypes.base ?? [], l = foundry.utils.randomID(), r = {
      context: {
        attackTypes: n,
        ...this.context
      },
      formula: this.bonus,
      label: this.label || ((a = this.parent) == null ? void 0 : a.name) || "Attack Grant",
      default: this.context.default ?? !0,
      img: this.img || ((c = this == null ? void 0 : this.parent) == null ? void 0 : c.img)
    };
    delete r.context.default;
    const o = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      bonusId: l,
      type: "attacks",
      grantType: "bonus",
      level: this.level
    };
    return {
      [`system.bonuses.attacks.${l}`]: r,
      "system.grants": {
        ...t.system.grants,
        [this._id]: o
      }
    };
  }
  getSelectionComponent() {
    return M(this, $h);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.attackTypes.base ?? [],
      bonus: this.bonus,
      choices: this.attackTypes.options,
      configObject: CONFIG.A5E.attackTypes,
      count: this.attackTypes.total,
      heading: "Attack Grant Selection",
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return this.attackTypes.options.length;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: "attacks"
    };
    super.configureGrant(
      "Configure Attack Grant",
      t,
      M(this, Ah),
      { width: 400 }
    );
  }
};
$h = new WeakMap(), Ah = new WeakMap(), P5 = new WeakMap(), f(EE, "AttackGrant");
let Ty = EE;
var Eh, Sh;
const SE = class SE extends rs {
  constructor() {
    super(...arguments);
    Y(this, Eh, Pn);
    Y(this, Sh, "damage");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "damage" }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      damageType: new t.StringField({ required: !0, initial: "" }),
      context: new t.SchemaField(tB("grant")),
      label: new t.StringField({ required: !0, initial: "New Damage Grant" })
    });
  }
  getApplyData(t) {
    var r, o;
    if (!t)
      return {};
    const s = foundry.utils.randomID(), n = {
      context: this.context,
      formula: this.bonus,
      label: this.label || ((r = this.parent) == null ? void 0 : r.name) || "Damage Grant",
      default: this.context.default ?? !0,
      img: this.img || ((o = this == null ? void 0 : this.parent) == null ? void 0 : o.img)
    };
    delete n.context.default;
    const l = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      bonusId: s,
      type: "damage",
      grantType: "bonus",
      level: this.level
    };
    return {
      [`system.bonuses.damage.${s}`]: n,
      "system.grants": {
        ...t.system.grants,
        [this._id]: l
      }
    };
  }
  getSelectionComponent() {
    return null;
  }
  getSelectionComponentProps() {
    return null;
  }
  requiresConfig() {
    return !1;
  }
  async configureGrant() {
    const t = {
      document: this.parent,
      grantId: this._id,
      grantType: M(this, Sh)
    };
    super.configureGrant(
      "Configure Damage Grant",
      t,
      M(this, Eh),
      { width: 500 }
    );
  }
};
Eh = new WeakMap(), Sh = new WeakMap(), f(SE, "DamageGrant");
let Cy = SE;
function _Y(i) {
  let e, t;
  return e = new de({
    props: {
      heading: "A5E.Formula",
      $$slots: { default: [vY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, grant*/
      16385 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(_Y, "create_else_block$C");
function yY(i) {
  let e, t;
  return e = new Ye({
    props: {
      heading: "Exertion Pool Type",
      options: Object.entries(
        /*exertionPoolTypes*/
        i[6]
      ),
      selected: (
        /*grant*/
        i[0].poolType
      ),
      allowDeselect: !1
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[12]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*grant*/
      1 && (l.selected = /*grant*/
      s[0].poolType), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(yY, "create_if_block$24");
function vY(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*grant*/
      i[0].bonus ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[13]
      ), s = !0);
    },
    p(l, r) {
      r & /*grant*/
      1 && t !== (t = /*grant*/
      l[0].bonus ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(vY, "create_default_slot_1$16");
function kY(i) {
  let e, t, s, n, l, r;
  e = new Ye({
    props: {
      heading: "Exertion Bonus Mode",
      options: [["bonus", "Bonus"], ["pool", "Pool"]],
      selected: (
        /*exertionType*/
        i[2]
      ),
      allowDeselect: !1
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[11]
  );
  const o = [yY, _Y], a = [];
  function c(u, d) {
    return (
      /*exertionType*/
      u[2] === "pool" ? 0 : 1
    );
  }
  return f(c, "select_block_type"), s = c(i), n = a[s] = o[s](i), {
    c() {
      L(e.$$.fragment), t = R(), n.c(), l = $e();
    },
    m(u, d) {
      N(e, u, d), T(u, t, d), a[s].m(u, d), T(u, l, d), r = !0;
    },
    p(u, d) {
      const p = {};
      d & /*exertionType*/
      4 && (p.selected = /*exertionType*/
      u[2]), e.$set(p);
      let m = s;
      s = c(u), s === m ? a[s].p(u, d) : (ce(), C(a[m], 1, 1, () => {
        a[m] = null;
      }), ue(), n = a[s], n ? n.p(u, d) : (n = a[s] = o[s](u), n.c()), w(n, 1), n.m(l.parentNode, l));
    },
    i(u) {
      r || (w(e.$$.fragment, u), w(n), r = !0);
    },
    o(u) {
      C(e.$$.fragment, u), C(n), r = !1;
    },
    d(u) {
      u && (S(t), S(l)), j(e, u), a[s].d(u);
    }
  };
}
f(kY, "create_default_slot$1W");
function wY(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y;
  return d = new Me({
    props: {
      heading: "Exertion Bonus Configuration",
      $$slots: { default: [kY] },
      $$scope: { ctx: i }
    }
  }), g = new In({}), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), p = E("div"), L(d.$$.fragment), m = R(), L(g.$$.fragment), b(s, "class", "grant-image svelte-r6yl7x"), ze(s.src, n = /*grant*/
      i[0].img || /*$item*/
      i[1].img || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*grant*/
      i[0].label ?? "", b(a, "class", "grant-name svelte-r6yl7x"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-r6yl7x"), b(t, "class", "sheet-header svelte-r6yl7x"), z(p, "display", "contents"), z(p, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-r6yl7x");
    },
    m(k, v) {
      T(k, e, v), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, u), A(e, p), N(d, p, null), A(e, m), N(g, e, null), h = !0, _ || (y = [
        V(
          s,
          "click",
          /*updateImage*/
          i[3]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[10]
        )
      ], _ = !0);
    },
    p(k, [v]) {
      (!h || v & /*grant, $item*/
      3 && !ze(s.src, n = /*grant*/
      k[0].img || /*$item*/
      k[1].img || "icons/svg/upgrade.svg")) && b(s, "src", n), (!h || v & /*grant*/
      1 && l !== (l = /*grant*/
      k[0].label)) && b(s, "alt", l), (!h || v & /*grant*/
      1 && c !== (c = /*grant*/
      k[0].label ?? "") && a.value !== c) && (a.value = c);
      const O = {};
      v & /*$$scope, grant, exertionType*/
      16389 && (O.$$scope = { dirty: v, ctx: k }), d.$set(O);
    },
    i(k) {
      h || (w(d.$$.fragment, k), w(g.$$.fragment, k), h = !0);
    },
    o(k) {
      C(d.$$.fragment, k), C(g.$$.fragment, k), h = !1;
    },
    d(k) {
      k && S(e), j(d), j(g), _ = !1, Ne(y);
    }
  };
}
f(wY, "create_fragment$3O");
function $Y(i, e, t) {
  let s, n, l, { document: r, grantId: o, grantType: a } = fe("#external").application, { document: c = r, grantId: u = o, grantType: d = a } = e;
  function p() {
    const O = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: O,
      callback: (D) => {
        m("img", D);
      }
    }).browse();
  }
  f(p, "updateImage");
  function m(O, P) {
    O = `system.grants.${u}.${O}`, se(l, O, P);
  }
  f(m, "onUpdateValue"), Nt(() => {
    g.destroy();
  });
  const g = new Bt(c);
  pe(i, g, (O) => t(1, l = O));
  const { exertionPoolTypes: h } = CONFIG.A5E;
  et("item", g), et("grantId", u), et("grantType", d);
  const _ = /* @__PURE__ */ f(({ target: O }) => m("label", O.value), "change_handler"), y = /* @__PURE__ */ f(({ detail: O }) => m("exertionType", O), "updateSelection_handler"), k = /* @__PURE__ */ f(({ detail: O }) => m("poolType", O), "updateSelection_handler_1"), v = /* @__PURE__ */ f(({ target: O }) => m("bonus", O.value), "change_handler_1");
  return i.$$set = (O) => {
    "document" in O && t(7, c = O.document), "grantId" in O && t(8, u = O.grantId), "grantType" in O && t(9, d = O.grantType);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item, grantId*/
    258 && t(0, s = l.system.grants[u]), i.$$.dirty & /*grant*/
    1 && t(2, n = s == null ? void 0 : s.exertionType);
  }, [
    s,
    l,
    n,
    p,
    m,
    g,
    h,
    c,
    u,
    d,
    _,
    y,
    k,
    v
  ];
}
f($Y, "instance$3F");
const TE = class TE extends ie {
  constructor(e) {
    super(), le(this, e, $Y, wY, ne, { document: 7, grantId: 8, grantType: 9 });
  }
};
f(TE, "ExertionGrantConfig");
let Oy = TE;
var M5, Th, Ru;
const CE = class CE extends rs {
  constructor() {
    super(...arguments);
    Y(this, M5, null);
    Y(this, Th, Oy);
    Y(this, Ru, "exertion");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "exertion" }),
      exertionType: new t.StringField({ required: !0, initial: "bonus", choices: ["bonus", "pool"] }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      poolType: new t.StringField({ required: !0, initial: "none", choices: ["none", "prof", "doubleProf"] }),
      label: new t.StringField({ required: !0, initial: "New Exertion Grant" })
    });
  }
  getApplyData(t) {
    var r, o;
    if (!t)
      return {};
    const s = {}, n = foundry.utils.randomID();
    if (this.exertionType === "bonus") {
      const a = {
        formula: this.bonus,
        label: this.label || ((r = this.parent) == null ? void 0 : r.name) || "Exertion Grant",
        img: this.img || ((o = this == null ? void 0 : this.parent) == null ? void 0 : o.img)
      };
      s[`system.bonuses.exertion.${n}`] = a;
    }
    const l = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      exertionData: {
        exertionType: this.exertionType,
        bonusId: this.exertionType === "bonus" ? n : void 0,
        poolType: this.poolType
      },
      grantType: M(this, Ru),
      level: this.level
    };
    return s["system.grants"] = {
      ...t.system.grants,
      [this._id]: l
    }, s;
  }
  getSelectionComponent() {
    return null;
  }
  getSelectionComponentProps() {
    return null;
  }
  requiresConfig() {
    return !1;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: M(this, Ru)
    };
    super.configureGrant(
      "Configure Exertion Grant",
      t,
      M(this, Th),
      { width: 400 }
    );
  }
};
M5 = new WeakMap(), Th = new WeakMap(), Ru = new WeakMap(), f(CE, "ExertionGrant");
let Dy = CE;
function kI(i) {
  var o, a, c, u, d, p, m, g, h, _;
  let e, t, s, n, l, r;
  return e = new Ze({
    props: {
      heading: "Base Options",
      options: (
        /*configObject*/
        (o = i[6][
          /*expertiseType*/
          i[2]
        ]) == null ? void 0 : o.options
      ),
      selected: (
        /*grant*/
        (c = (a = i[0]) == null ? void 0 : a.keys) == null ? void 0 : c.base
      ),
      showToggleAllButton: !0,
      disabledOptions: (
        /*grant*/
        (d = (u = i[0]) == null ? void 0 : u.keys) == null ? void 0 : d.options
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[13]
  ), s = new Ze({
    props: {
      heading: "Optional Choices",
      options: (
        /*configObject*/
        (p = i[6][
          /*expertiseType*/
          i[2]
        ]) == null ? void 0 : p.options
      ),
      selected: (
        /*grant*/
        (g = (m = i[0]) == null ? void 0 : m.keys) == null ? void 0 : g.options
      ),
      disabledOptions: (
        /*grant*/
        (_ = (h = i[0]) == null ? void 0 : h.keys) == null ? void 0 : _.base
      ),
      showToggleAllButton: !0
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[14]
  ), l = new de({
    props: {
      heading: "Selectable Options Count",
      $$slots: { default: [AY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment);
    },
    m(y, k) {
      N(e, y, k), T(y, t, k), N(s, y, k), T(y, n, k), N(l, y, k), r = !0;
    },
    p(y, k) {
      var D, I, B, F, H, G, U, q, W, X;
      const v = {};
      k & /*expertiseType*/
      4 && (v.options = /*configObject*/
      (D = y[6][
        /*expertiseType*/
        y[2]
      ]) == null ? void 0 : D.options), k & /*grant*/
      1 && (v.selected = /*grant*/
      (B = (I = y[0]) == null ? void 0 : I.keys) == null ? void 0 : B.base), k & /*grant*/
      1 && (v.disabledOptions = /*grant*/
      (H = (F = y[0]) == null ? void 0 : F.keys) == null ? void 0 : H.options), e.$set(v);
      const O = {};
      k & /*expertiseType*/
      4 && (O.options = /*configObject*/
      (G = y[6][
        /*expertiseType*/
        y[2]
      ]) == null ? void 0 : G.options), k & /*grant*/
      1 && (O.selected = /*grant*/
      (q = (U = y[0]) == null ? void 0 : U.keys) == null ? void 0 : q.options), k & /*grant*/
      1 && (O.disabledOptions = /*grant*/
      (X = (W = y[0]) == null ? void 0 : W.keys) == null ? void 0 : X.base), s.$set(O);
      const P = {};
      k & /*$$scope, grant*/
      131073 && (P.$$scope = { dirty: k, ctx: y }), l.$set(P);
    },
    i(y) {
      r || (w(e.$$.fragment, y), w(s.$$.fragment, y), w(l.$$.fragment, y), r = !0);
    },
    o(y) {
      C(e.$$.fragment, y), C(s.$$.fragment, y), C(l.$$.fragment, y), r = !1;
    },
    d(y) {
      y && (S(t), S(n)), j(e, y), j(s, y), j(l, y);
    }
  };
}
f(kI, "create_if_block$23");
function AY(i) {
  let e, t, s, n;
  return {
    c() {
      var l, r;
      e = E("input"), b(e, "type", "number"), e.value = t = /*grant*/
      ((r = (l = i[0]) == null ? void 0 : l.keys) == null ? void 0 : r.total) ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      var o, a;
      r & /*grant*/
      1 && t !== (t = /*grant*/
      ((a = (o = l[0]) == null ? void 0 : o.keys) == null ? void 0 : a.total) ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(AY, "create_default_slot_1$15");
function EY(i) {
  var o, a, c;
  let e, t, s, n, l;
  e = new Ye({
    props: {
      heading: "Expertise Type",
      options: Object.entries(
        /*configObject*/
        i[6]
      ).map(TY),
      selected: (
        /*expertiseType*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[12]
  );
  let r = (
    /*configObject*/
    ((a = (o = i[6][
      /*expertiseType*/
      i[2]
    ]) == null ? void 0 : o.options) == null ? void 0 : a.length) && kI(i)
  );
  return n = new Ye({
    props: {
      heading: "Expertise Die Size",
      options: (
        /*expertiseDiceOptions*/
        i[7]
      ),
      selected: (
        /*grant*/
        ((c = i[0]) == null ? void 0 : c.expertiseCount) ?? 1
      )
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[16]
  ), {
    c() {
      L(e.$$.fragment), t = R(), r && r.c(), s = R(), L(n.$$.fragment);
    },
    m(u, d) {
      N(e, u, d), T(u, t, d), r && r.m(u, d), T(u, s, d), N(n, u, d), l = !0;
    },
    p(u, d) {
      var g, h, _;
      const p = {};
      d & /*expertiseType*/
      4 && (p.selected = /*expertiseType*/
      u[2]), e.$set(p), /*configObject*/
      (h = (g = u[6][
        /*expertiseType*/
        u[2]
      ]) == null ? void 0 : g.options) != null && h.length ? r ? (r.p(u, d), d & /*expertiseType*/
      4 && w(r, 1)) : (r = kI(u), r.c(), w(r, 1), r.m(s.parentNode, s)) : r && (ce(), C(r, 1, 1, () => {
        r = null;
      }), ue());
      const m = {};
      d & /*grant*/
      1 && (m.selected = /*grant*/
      ((_ = u[0]) == null ? void 0 : _.expertiseCount) ?? 1), n.$set(m);
    },
    i(u) {
      l || (w(e.$$.fragment, u), w(r), w(n.$$.fragment, u), l = !0);
    },
    o(u) {
      C(e.$$.fragment, u), C(r), C(n.$$.fragment, u), l = !1;
    },
    d(u) {
      u && (S(t), S(s)), j(e, u), r && r.d(u), j(n, u);
    }
  };
}
f(EY, "create_default_slot$1V");
function SY(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y;
  return d = new Me({
    props: {
      heading: "Expertise Configuration",
      $$slots: { default: [EY] },
      $$scope: { ctx: i }
    }
  }), g = new In({}), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), p = E("div"), L(d.$$.fragment), m = R(), L(g.$$.fragment), b(s, "class", "grant-image svelte-r6yl7x"), ze(s.src, n = /*grant*/
      i[0].img || /*$item*/
      i[1].img || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*grant*/
      i[0].label ?? "", b(a, "class", "grant-name svelte-r6yl7x"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-r6yl7x"), b(t, "class", "sheet-header svelte-r6yl7x"), z(p, "display", "contents"), z(p, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-r6yl7x");
    },
    m(k, v) {
      T(k, e, v), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, u), A(e, p), N(d, p, null), A(e, m), N(g, e, null), h = !0, _ || (y = [
        V(
          s,
          "click",
          /*updateImage*/
          i[3]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[11]
        )
      ], _ = !0);
    },
    p(k, [v]) {
      (!h || v & /*grant, $item*/
      3 && !ze(s.src, n = /*grant*/
      k[0].img || /*$item*/
      k[1].img || "icons/svg/upgrade.svg")) && b(s, "src", n), (!h || v & /*grant*/
      1 && l !== (l = /*grant*/
      k[0].label)) && b(s, "alt", l), (!h || v & /*grant*/
      1 && c !== (c = /*grant*/
      k[0].label ?? "") && a.value !== c) && (a.value = c);
      const O = {};
      v & /*$$scope, grant, expertiseType*/
      131077 && (O.$$scope = { dirty: v, ctx: k }), d.$set(O);
    },
    i(k) {
      h || (w(d.$$.fragment, k), w(g.$$.fragment, k), h = !0);
    },
    o(k) {
      C(d.$$.fragment, k), C(g.$$.fragment, k), h = !1;
    },
    d(k) {
      k && S(e), j(d), j(g), _ = !1, Ne(y);
    }
  };
}
f(SY, "create_fragment$3N");
const TY = /* @__PURE__ */ f(([i, { label: e }]) => [i, e], "func$c");
function CY(i, e, t) {
  let s, n, l, { document: r, grantId: o, grantType: a } = fe("#external").application, { document: c = r, grantId: u = o, grantType: d = a } = e;
  function p() {
    const I = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: I,
      callback: (F) => {
        m("img", F);
      }
    }).browse();
  }
  f(p, "updateImage");
  function m(I, B) {
    I === "expertiseType" && se(l, `system.grants.${u}.keys`, { base: [], options: [], total: 0 }), I = `system.grants.${u}.${I}`, se(l, I, B);
  }
  f(m, "onUpdateValue"), Nt(() => {
    g.destroy();
  });
  const g = new Bt(c);
  pe(i, g, (I) => t(1, l = I));
  const h = {
    abilityCheck: {
      label: "A5E.AbilityCheck",
      options: Object.entries(CONFIG.A5E.abilities)
    },
    abilitySave: {
      label: "A5E.SavingThrow",
      options: Object.entries(CONFIG.A5E.abilities)
    },
    attack: {
      label: "A5E.ActionOptionAttack",
      options: Object.entries(CONFIG.A5E.attackTypes)
    },
    initiative: { label: "A5E.Initiative", options: [] },
    skill: {
      label: "A5E.Skill",
      options: Object.entries(CONFIG.A5E.skills)
    }
  }, _ = M9();
  et("item", g), et("grantId", u), et("grantType", d);
  const y = /* @__PURE__ */ f(({ target: I }) => m("label", I.value), "change_handler"), k = /* @__PURE__ */ f(({ detail: I }) => {
    m("expertiseType", I);
  }, "updateSelection_handler"), v = /* @__PURE__ */ f(({ detail: I }) => {
    m("keys.base", I);
  }, "updateSelection_handler_1"), O = /* @__PURE__ */ f(({ detail: I }) => {
    m("keys.options", I);
  }, "updateSelection_handler_2"), P = /* @__PURE__ */ f(({ target: I }) => m("keys.total", Number(I.value)), "change_handler_1"), D = /* @__PURE__ */ f(({ detail: I }) => {
    m("expertiseCount", I);
  }, "updateSelection_handler_3");
  return i.$$set = (I) => {
    "document" in I && t(8, c = I.document), "grantId" in I && t(9, u = I.grantId), "grantType" in I && t(10, d = I.grantType);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item, grantId*/
    514 && t(0, s = l.system.grants[u]), i.$$.dirty & /*grant*/
    1 && t(2, n = (s == null ? void 0 : s.expertiseType) || "abilityCheck");
  }, [
    s,
    l,
    n,
    p,
    m,
    g,
    h,
    _,
    c,
    u,
    d,
    y,
    k,
    v,
    O,
    P,
    D
  ];
}
f(CY, "instance$3E");
const OE = class OE extends ie {
  constructor(e) {
    super(), le(this, e, CY, SY, ne, { document: 8, grantId: 9, grantType: 10 });
  }
};
f(OE, "ExpertiseDiceGrantConfig");
let Iy = OE;
function OY(i) {
  let e, t;
  return e = new Ze({
    props: {
      options: (
        /*getOptions*/
        i[8](
          /*choicesLocked*/
          i[4]
        )
      ),
      selected: (
        /*selected*/
        i[0]
      ),
      orange: (
        /*choices*/
        i[2]
      ),
      disabled: (
        /*selected*/
        i[0].length >= /*totalCount*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*onUpdateSelection*/
    i[7]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*choicesLocked*/
      16 && (l.options = /*getOptions*/
      s[8](
        /*choicesLocked*/
        s[4]
      )), n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), n & /*choices*/
      4 && (l.orange = /*choices*/
      s[2]), n & /*selected, totalCount*/
      9 && (l.disabled = /*selected*/
      s[0].length >= /*totalCount*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(OY, "create_default_slot_2$L");
function DY(i) {
  let e;
  return {
    c() {
      e = x(
        /*summary*/
        i[5]
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*summary*/
      32 && _e(
        e,
        /*summary*/
        t[5]
      );
    },
    d(t) {
      t && S(e);
    }
  };
}
f(DY, "create_default_slot_1$14");
function IY(i) {
  let e, t, s, n, l;
  return e = new de({
    props: {
      warning: (
        /*remainingSelections*/
        i[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
        i[6]} choices remaining.`
      ),
      showWarning: (
        /*selected*/
        i[0].length < /*totalCount*/
        i[3]
      ),
      $$slots: { default: [OY] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      $$slots: { default: [DY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--direction", "column");
    },
    m(r, o) {
      T(r, t, o), N(e, t, null), T(r, s, o), N(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*remainingSelections*/
      64 && (a.warning = /*remainingSelections*/
      r[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
      r[6]} choices remaining.`), o & /*selected, totalCount*/
      9 && (a.showWarning = /*selected*/
      r[0].length < /*totalCount*/
      r[3]), o & /*$$scope, choicesLocked, selected, choices, totalCount*/
      65565 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, summary*/
      65568 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && S(s), r && e && S(t), j(e, r), j(n, r);
    }
  };
}
f(IY, "create_default_slot$1U");
function PY(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Expertise Dice Grant - " + /*grant*/
      i[1].label,
      headerButtons: [
        {
          classes: "add-button",
          handler: (
            /*func*/
            i[12]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          i[4] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            i[4] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ],
      $$slots: { default: [IY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*grant*/
      2 && (r.heading = "Expertise Dice Grant - " + /*grant*/
      n[1].label), l & /*choicesLocked*/
      16 && (r.headerButtons = [
        {
          classes: "add-button",
          handler: (
            /*func*/
            n[12]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          n[4] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            n[4] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ]), l & /*$$scope, summary, remainingSelections, selected, totalCount, choicesLocked, choices*/
      65661 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(PY, "create_fragment$3M");
function MY(i, e, t) {
  let s, n, l, { grant: r } = e, { base: o } = e, { choices: a } = e, { count: c } = e, { expertiseType: u } = e, { selected: d } = e;
  function p(v) {
    return "";
  }
  f(p, "getGrantSummary");
  function m({ detail: v }) {
    t(0, d = v), h("updateSelection", { selected: d, summary: l });
  }
  f(m, "onUpdateSelection");
  function g(v) {
    var P, D;
    if (!v)
      return ((P = _[u]) == null ? void 0 : P.options) ?? [];
    const O = [];
    for (const [I, B] of ((D = _[u]) == null ? void 0 : D.options) ?? [])
      a.includes(I) && O.push([I, B]);
    return O;
  }
  f(g, "getOptions");
  const h = it(), _ = {
    abilityCheck: {
      label: "A5E.AbilityCheck",
      options: Object.entries(CONFIG.A5E.abilities)
    },
    abilitySave: {
      label: "A5E.SavingThrow",
      options: Object.entries(CONFIG.A5E.abilities)
    },
    attack: {
      label: "A5E.ActionOptionAttack",
      options: Object.entries(CONFIG.A5E.attackTypes)
    },
    initiative: { label: "A5E.Initiative", options: [] },
    skill: {
      label: "A5E.Skill",
      options: Object.entries(CONFIG.A5E.skills)
    }
  };
  let y = !0;
  const k = /* @__PURE__ */ f(() => t(4, y = !y), "func");
  return i.$$set = (v) => {
    "grant" in v && t(1, r = v.grant), "base" in v && t(9, o = v.base), "choices" in v && t(2, a = v.choices), "count" in v && t(10, c = v.count), "expertiseType" in v && t(11, u = v.expertiseType), "selected" in v && t(0, d = v.selected);
  }, i.$$.update = () => {
    i.$$.dirty & /*base, selected*/
    513 && t(0, d = [...o, ...d]), i.$$.dirty & /*base, count*/
    1536 && t(3, s = o.length + c), i.$$.dirty & /*totalCount, selected*/
    9 && t(6, n = s - d.length), i.$$.dirty & /*selected*/
    1 && t(5, l = p());
  }, [
    d,
    r,
    a,
    s,
    y,
    l,
    n,
    m,
    g,
    o,
    c,
    u,
    k
  ];
}
f(MY, "instance$3D");
const DE = class DE extends ie {
  constructor(e) {
    super(), le(this, e, MY, PY, ne, {
      grant: 1,
      base: 9,
      choices: 2,
      count: 10,
      expertiseType: 11,
      selected: 0
    });
  }
};
f(DE, "ExpertiseDiceSelectionDialog");
let Py = DE;
var Ch, Oh, Dh;
const IE = class IE extends rs {
  constructor() {
    super(...arguments);
    Y(this, Ch, Py);
    Y(this, Oh, Iy);
    Y(this, Dh, "expertiseDice");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "expertiseDice" }),
      keys: new t.SchemaField({
        base: new t.ArrayField(
          new t.StringField({ nullable: !1, initial: "" }),
          { required: !0, initial: [] }
        ),
        options: new t.ArrayField(
          new t.StringField({ nullable: !1, initial: "" }),
          { required: !0, initial: [] }
        ),
        total: new t.NumberField({ nullable: !1, initial: 0, integer: !0 })
      }),
      expertiseCount: new t.NumberField({ nullable: !1, initial: 1, integer: !0 }),
      expertiseType: new t.StringField({ required: !1, initial: "abilityCheck" }),
      label: new t.StringField({ required: !0, initial: "New Expertise Dice Grant" })
    });
  }
  getApplyData(t, s) {
    if (!t)
      return {};
    const n = (s == null ? void 0 : s.selected) ?? this.keys.base ?? [], l = this.keys.total, r = {}, o = {
      expertiseDiceData: {
        keys: n,
        total: l,
        expertiseType: this.expertiseType,
        expertiseCount: this.expertiseCount
      },
      itemUuid: this.parent.uuid,
      grantId: this._id,
      grantType: M(this, Dh),
      level: this.level
    };
    return r["system.grants"] = {
      ...t.system.grants,
      [this._id]: o
    }, r;
  }
  getSelectionComponent() {
    return M(this, Ch);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.keys.base ?? [],
      choices: this.keys.options,
      count: this.keys.total,
      expertiseType: this.expertiseType,
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return !!this.keys.options.length;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: "expertiseDice"
    };
    super.configureGrant(
      "Configure Expertise Grant",
      t,
      M(this, Oh),
      { width: 400 }
    );
  }
};
Ch = new WeakMap(), Oh = new WeakMap(), Dh = new WeakMap(), f(IE, "ExpertiseDiceGrant");
let My = IE;
function RY(i) {
  let e, t;
  return e = new Ze({
    props: {
      options: (
        /*getOptions*/
        i[8](
          /*choicesLocked*/
          i[4]
        )
      ),
      selected: (
        /*selectedOptions*/
        i[2]
      ),
      orange: (
        /*choices*/
        i[1].map(wI)
      ),
      disabled: (
        /*selectedOptions*/
        i[2].length >= /*totalCount*/
        i[3]
      ),
      disabledOptions: (
        /*disabledOptions*/
        i[9]
      )
    }
  }), e.$on(
    "updateSelection",
    /*onUpdateSelection*/
    i[7]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*choicesLocked*/
      16 && (l.options = /*getOptions*/
      s[8](
        /*choicesLocked*/
        s[4]
      )), n & /*selectedOptions*/
      4 && (l.selected = /*selectedOptions*/
      s[2]), n & /*choices*/
      2 && (l.orange = /*choices*/
      s[1].map(wI)), n & /*selectedOptions, totalCount*/
      12 && (l.disabled = /*selectedOptions*/
      s[2].length >= /*totalCount*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(RY, "create_default_slot_2$K");
function FY(i) {
  let e;
  return {
    c() {
      e = x(
        /*summary*/
        i[5]
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*summary*/
      32 && _e(
        e,
        /*summary*/
        t[5]
      );
    },
    d(t) {
      t && S(e);
    }
  };
}
f(FY, "create_default_slot_1$13");
function NY(i) {
  let e, t, s, n, l;
  return e = new de({
    props: {
      warning: (
        /*remainingSelections*/
        i[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
        i[6]} choices remaining.`
      ),
      showWarning: (
        /*selectedOptions*/
        i[2].length < /*totalCount*/
        i[3]
      ),
      $$slots: { default: [RY] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      $$slots: { default: [FY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--direction", "column");
    },
    m(r, o) {
      T(r, t, o), N(e, t, null), T(r, s, o), N(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*remainingSelections*/
      64 && (a.warning = /*remainingSelections*/
      r[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
      r[6]} choices remaining.`), o & /*selectedOptions, totalCount*/
      12 && (a.showWarning = /*selectedOptions*/
      r[2].length < /*totalCount*/
      r[3]), o & /*$$scope, choicesLocked, selectedOptions, choices, totalCount*/
      4194334 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, summary*/
      4194336 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && S(s), r && e && S(t), j(e, r), j(n, r);
    }
  };
}
f(NY, "create_default_slot$1T");
function jY(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Feature Grant - " + /*grant*/
      i[0].label,
      headerButtons: [
        {
          classes: "add-button",
          handler: (
            /*func_1*/
            i[13]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          i[4] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            i[4] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ],
      $$slots: { default: [NY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*grant*/
      1 && (r.heading = "Feature Grant - " + /*grant*/
      n[0].label), l & /*choicesLocked*/
      16 && (r.headerButtons = [
        {
          classes: "add-button",
          handler: (
            /*func_1*/
            n[13]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          n[4] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            n[4] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ]), l & /*$$scope, summary, remainingSelections, selectedOptions, totalCount, choicesLocked, choices*/
      4194430 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(jY, "create_fragment$3L");
function LY(i) {
  return "";
}
f(LY, "getGrantSummary");
const wI = /* @__PURE__ */ f((i) => i.uuid, "func$b");
function BY(i, e, t) {
  let s, n, l, r, { grant: o } = e, { base: a } = e, { choices: c } = e, { count: u } = e, { selected: d } = e;
  const p = it(), m = fe("actor");
  function g({ detail: F }) {
    t(2, s = F), p("updateSelection", { uuids: s, summary: r });
  }
  f(g, "onUpdateSelection");
  function h() {
    const F = [];
    return [...m.grants.grantedFeatureDocuments.entries()].forEach(([H, G]) => {
      const U = v.get(H);
      if (!U)
        return F.push(H);
      const q = G.length;
      !U.limitedReselection || U.selectionLimit > q || F.push(H);
    }), new Set(F);
  }
  f(h, "getExistingSelections");
  function _() {
    const F = [];
    for (const [H] of k) {
      const G = H.split(".").pop();
      D.has(G || "") && F.push(H);
    }
    return F;
  }
  f(_, "getDisabledOptions");
  function y(F) {
    if (!F)
      return k;
    const H = [];
    for (const [G, U] of k) {
      const q = G.split(".").pop(), W = D.has(q || "");
      O.includes(G) && !W && H.push([G, U]);
    }
    return H;
  }
  f(y, "getOptions");
  const k = [...a, ...c].map((F) => {
    const H = fromUuidSync(F.uuid);
    return [F.uuid, H.name];
  }), v = a.concat(c).reduce(
    (F, H) => {
      const G = H.uuid.split(".").pop();
      return G && F.set(G, H), F;
    },
    /* @__PURE__ */ new Map()
  ), O = c.map((F) => F.uuid);
  let P = !0, D = h(), I = _();
  const B = /* @__PURE__ */ f(() => t(4, P = !P), "func_1");
  return i.$$set = (F) => {
    "grant" in F && t(0, o = F.grant), "base" in F && t(10, a = F.base), "choices" in F && t(1, c = F.choices), "count" in F && t(11, u = F.count), "selected" in F && t(12, d = F.selected);
  }, i.$$.update = () => {
    i.$$.dirty & /*base, selected*/
    5120 && t(2, s = [...a.map((F) => F.uuid), ...d]), i.$$.dirty & /*base, count*/
    3072 && t(3, n = a.length + u), i.$$.dirty & /*totalCount, selectedOptions*/
    12 && t(6, l = n - s.length), i.$$.dirty & /*selectedOptions*/
    4 && t(5, r = LY());
  }, [
    o,
    c,
    s,
    n,
    P,
    r,
    l,
    g,
    y,
    I,
    a,
    u,
    d,
    B
  ];
}
f(BY, "instance$3C");
const PE = class PE extends ie {
  constructor(e) {
    super(), le(this, e, BY, jY, ne, {
      grant: 0,
      base: 10,
      choices: 1,
      count: 11,
      selected: 12
    });
  }
};
f(PE, "FeatureGrantSelectionDialog");
let Ry = PE;
function qY(i) {
  let e, t, s;
  return {
    c() {
      e = E("div"), e.innerHTML = '<i class="drop-icon fa-sold fa-plus svelte-f3gkux"></i>', b(e, "class", "drop-area svelte-f3gkux");
    },
    m(n, l) {
      T(n, e, l), t || (s = V(e, "drop", We(tt(
        /*onDrop*/
        i[0]
      ))), t = !0);
    },
    p: ee,
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(qY, "create_default_slot$1S");
function GY(i) {
  let e, t;
  return e = new de({
    props: {
      $$slots: { default: [qY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*$$scope*/
      16 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(GY, "create_fragment$3K");
function zY(i, e, t) {
  let { type: s = "" } = e, { documentType: n = "" } = e;
  function l(o) {
    if (s || r("document-dropped", o), s === "uuid")
      try {
        const a = o.dataTransfer;
        if (!a)
          return;
        const { uuid: c, type: u } = JSON.parse(a.getData("text/plain"));
        if (u !== n)
          return;
        r("document-dropped", { dragEvent: o, uuid: c });
      } catch (a) {
        console.error(a);
      }
  }
  f(l, "onDrop");
  const r = it();
  return i.$$set = (o) => {
    "type" in o && t(1, s = o.type), "documentType" in o && t(2, n = o.documentType);
  }, [l, s, n];
}
f(zY, "instance$3B");
const ME = class ME extends ie {
  constructor(e) {
    super(), le(this, e, zY, GY, ne, { type: 1, documentType: 2 });
  }
};
f(ME, "DropArea");
let ba = ME;
function $I(i, e, t) {
  const s = i.slice();
  return s[24] = e[t], s[26] = t, s;
}
f($I, "get_each_context$1t");
function AI(i, e, t) {
  const s = i.slice();
  return s[24] = e[t], s[26] = t, s;
}
f(AI, "get_each_context_1$k");
function EI(i) {
  let e, t, s, n, l, r = oe(
    /*baseFeatures*/
    i[3]
  ), o = [];
  for (let a = 0; a < r.length; a += 1)
    o[a] = SI(AI(i, r, a));
  return {
    c() {
      e = E("div"), t = E("header"), t.innerHTML = '<span class="feature-table__heading svelte-iyq5rz"></span> <span class="feature-table__heading svelte-iyq5rz"></span> <span class="feature-table__heading svelte-iyq5rz">Limited Reselection</span> <span class="feature-table__heading svelte-iyq5rz">Selection Limit</span> <span class="feature-table__heading svelte-iyq5rz"></span>', s = R(), n = E("hr"), l = R();
      for (let a = 0; a < o.length; a += 1)
        o[a].c();
      b(t, "class", "feature-table__header svelte-iyq5rz"), b(n, "class", "feature-table__rule svelte-iyq5rz"), b(e, "class", "feature-table svelte-iyq5rz");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(e, s), A(e, n), A(e, l);
      for (let u = 0; u < o.length; u += 1)
        o[u] && o[u].m(e, null);
    },
    p(a, c) {
      if (c & /*onUpdateValue, baseFeatures, updateFeature, Number, openDocument*/
      104) {
        r = oe(
          /*baseFeatures*/
          a[3]
        );
        let u;
        for (u = 0; u < r.length; u += 1) {
          const d = AI(a, r, u);
          o[u] ? o[u].p(d, c) : (o[u] = SI(d), o[u].c(), o[u].m(e, null));
        }
        for (; u < o.length; u += 1)
          o[u].d(1);
        o.length = r.length;
      }
    },
    d(a) {
      a && S(e), Le(o, a);
    }
  };
}
f(EI, "create_if_block_2$Q");
function HY(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "fa-solid fa-infinity");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: ee,
    d(t) {
      t && S(e);
    }
  };
}
f(HY, "create_else_block_1$7");
function UY(i) {
  let e, t, s, n;
  function l(...r) {
    return (
      /*change_handler_2*/
      i[16](
        /*idx*/
        i[26],
        ...r
      )
    );
  }
  return f(l, "change_handler_2"), {
    c() {
      e = E("input"), b(e, "class", "a5e-input a5e-input--slim a5e-input--small"), b(e, "type", "number"), e.value = t = /*feature*/
      i[24].selectionLimit ?? 1;
    },
    m(r, o) {
      T(r, e, o), s || (n = V(e, "change", l), s = !0);
    },
    p(r, o) {
      i = r, o & /*baseFeatures*/
      8 && t !== (t = /*feature*/
      i[24].selectionLimit ?? 1) && e.value !== t && (e.value = t);
    },
    d(r) {
      r && S(e), s = !1, n();
    }
  };
}
f(UY, "create_if_block_3$x");
function SI(i) {
  let e, t, s, n, l, r = (
    /*feature*/
    i[24].name + ""
  ), o, a, c, u, d, p, m, g, h, _;
  function y() {
    return (
      /*click_handler*/
      i[14](
        /*feature*/
        i[24]
      )
    );
  }
  f(y, "click_handler");
  function k(...I) {
    return (
      /*change_handler_1*/
      i[15](
        /*idx*/
        i[26],
        ...I
      )
    );
  }
  f(k, "change_handler_1");
  function v(I, B) {
    return (
      /*feature*/
      I[24].limitedReselection ? UY : HY
    );
  }
  f(v, "select_block_type");
  let O = v(i), P = O(i);
  function D() {
    return (
      /*click_handler_1*/
      i[17](
        /*idx*/
        i[26]
      )
    );
  }
  return f(D, "click_handler_1"), {
    c() {
      e = E("img"), n = R(), l = E("span"), o = x(r), a = R(), c = E("input"), d = R(), p = E("span"), P.c(), m = R(), g = E("button"), g.innerHTML = '<i class="fa-solid fa-trash"></i> ', b(e, "class", "feature-table__img svelte-iyq5rz"), ze(e.src, t = /*feature*/
      i[24].img) || b(e, "src", t), b(e, "alt", s = /*feature*/
      i[24].name), b(l, "class", "feature-table__name svelte-iyq5rz"), b(c, "class", "feature-table__limited-reselection svelte-iyq5rz"), b(c, "type", "checkbox"), c.checked = u = /*feature*/
      i[24].limitedReselection ?? !0, b(p, "class", "feature-table__selection-limit svelte-iyq5rz"), b(g, "class", "feature-table__delete-button svelte-iyq5rz");
    },
    m(I, B) {
      T(I, e, B), T(I, n, B), T(I, l, B), A(l, o), T(I, a, B), T(I, c, B), T(I, d, B), T(I, p, B), P.m(p, null), T(I, m, B), T(I, g, B), h || (_ = [
        V(l, "click", y),
        V(c, "change", k),
        V(g, "click", We(tt(D)))
      ], h = !0);
    },
    p(I, B) {
      i = I, B & /*baseFeatures*/
      8 && !ze(e.src, t = /*feature*/
      i[24].img) && b(e, "src", t), B & /*baseFeatures*/
      8 && s !== (s = /*feature*/
      i[24].name) && b(e, "alt", s), B & /*baseFeatures*/
      8 && r !== (r = /*feature*/
      i[24].name + "") && _e(o, r), B & /*baseFeatures*/
      8 && u !== (u = /*feature*/
      i[24].limitedReselection ?? !0) && (c.checked = u), O === (O = v(i)) && P ? P.p(i, B) : (P.d(1), P = O(i), P && (P.c(), P.m(p, null)));
    },
    d(I) {
      I && (S(e), S(n), S(l), S(a), S(c), S(d), S(p), S(m), S(g)), P.d(), h = !1, Ne(_);
    }
  };
}
f(SI, "create_each_block_1$k");
function VY(i) {
  let e, t, s, n;
  e = new ba({
    props: { type: "uuid", documentType: "Item" }
  }), e.$on(
    "document-dropped",
    /*document_dropped_handler*/
    i[13]
  );
  let l = (
    /*baseFeatures*/
    i[3].length > 0 && EI(i)
  );
  return {
    c() {
      L(e.$$.fragment), t = R(), l && l.c(), s = $e();
    },
    m(r, o) {
      N(e, r, o), T(r, t, o), l && l.m(r, o), T(r, s, o), n = !0;
    },
    p(r, o) {
      /*baseFeatures*/
      r[3].length > 0 ? l ? l.p(r, o) : (l = EI(r), l.c(), l.m(s.parentNode, s)) : l && (l.d(1), l = null);
    },
    i(r) {
      n || (w(e.$$.fragment, r), n = !0);
    },
    o(r) {
      C(e.$$.fragment, r), n = !1;
    },
    d(r) {
      r && (S(t), S(s)), j(e, r), l && l.d(r);
    }
  };
}
f(VY, "create_default_slot_3$x");
function TI(i) {
  let e, t, s, n, l, r = oe(
    /*optionalFeatures*/
    i[2]
  ), o = [];
  for (let a = 0; a < r.length; a += 1)
    o[a] = CI($I(i, r, a));
  return {
    c() {
      e = E("div"), t = E("header"), t.innerHTML = '<span class="feature-table__heading svelte-iyq5rz"></span> <span class="feature-table__heading svelte-iyq5rz"></span> <span class="feature-table__heading svelte-iyq5rz">Limited Reselection</span> <span class="feature-table__heading svelte-iyq5rz">Selection Limit</span> <span class="feature-table__heading svelte-iyq5rz"></span>', s = R(), n = E("hr"), l = R();
      for (let a = 0; a < o.length; a += 1)
        o[a].c();
      b(t, "class", "feature-table__header svelte-iyq5rz"), b(n, "class", "feature-table__rule svelte-iyq5rz"), b(e, "class", "feature-table svelte-iyq5rz");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(e, s), A(e, n), A(e, l);
      for (let u = 0; u < o.length; u += 1)
        o[u] && o[u].m(e, null);
    },
    p(a, c) {
      if (c & /*onUpdateValue, optionalFeatures, updateFeature, Number, openDocument*/
      100) {
        r = oe(
          /*optionalFeatures*/
          a[2]
        );
        let u;
        for (u = 0; u < r.length; u += 1) {
          const d = $I(a, r, u);
          o[u] ? o[u].p(d, c) : (o[u] = CI(d), o[u].c(), o[u].m(e, null));
        }
        for (; u < o.length; u += 1)
          o[u].d(1);
        o.length = r.length;
      }
    },
    d(a) {
      a && S(e), Le(o, a);
    }
  };
}
f(TI, "create_if_block$22");
function WY(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "fa-solid fa-infinity");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: ee,
    d(t) {
      t && S(e);
    }
  };
}
f(WY, "create_else_block$B");
function KY(i) {
  let e, t, s, n;
  function l(...r) {
    return (
      /*change_handler_4*/
      i[21](
        /*idx*/
        i[26],
        ...r
      )
    );
  }
  return f(l, "change_handler_4"), {
    c() {
      e = E("input"), b(e, "class", "a5e-input a5e-input--slim a5e-input--small"), b(e, "type", "number"), e.value = t = /*feature*/
      i[24].selectionLimit ?? 1;
    },
    m(r, o) {
      T(r, e, o), s || (n = V(e, "change", l), s = !0);
    },
    p(r, o) {
      i = r, o & /*optionalFeatures*/
      4 && t !== (t = /*feature*/
      i[24].selectionLimit ?? 1) && e.value !== t && (e.value = t);
    },
    d(r) {
      r && S(e), s = !1, n();
    }
  };
}
f(KY, "create_if_block_1$1l");
function CI(i) {
  let e, t, s, n, l, r = (
    /*feature*/
    i[24].name + ""
  ), o, a, c, u, d, p, m, g, h, _;
  function y() {
    return (
      /*click_handler_2*/
      i[19](
        /*feature*/
        i[24]
      )
    );
  }
  f(y, "click_handler_2");
  function k(...I) {
    return (
      /*change_handler_3*/
      i[20](
        /*idx*/
        i[26],
        ...I
      )
    );
  }
  f(k, "change_handler_3");
  function v(I, B) {
    return (
      /*feature*/
      I[24].limitedReselection ? KY : WY
    );
  }
  f(v, "select_block_type_1");
  let O = v(i), P = O(i);
  function D() {
    return (
      /*click_handler_3*/
      i[22](
        /*idx*/
        i[26]
      )
    );
  }
  return f(D, "click_handler_3"), {
    c() {
      e = E("img"), n = R(), l = E("span"), o = x(r), a = R(), c = E("input"), d = R(), p = E("span"), P.c(), m = R(), g = E("button"), g.innerHTML = '<i class="fa-solid fa-trash"></i> ', b(e, "class", "feature-table__img svelte-iyq5rz"), ze(e.src, t = /*feature*/
      i[24].img) || b(e, "src", t), b(e, "alt", s = /*feature*/
      i[24].name), b(l, "class", "feature-table__name svelte-iyq5rz"), b(c, "class", "feature-table__limited-reselection svelte-iyq5rz"), b(c, "type", "checkbox"), c.checked = u = /*feature*/
      i[24].limitedReselection ?? !0, b(p, "class", "feature-table__selection-limit svelte-iyq5rz"), b(g, "class", "feature-table__delete-button svelte-iyq5rz");
    },
    m(I, B) {
      T(I, e, B), T(I, n, B), T(I, l, B), A(l, o), T(I, a, B), T(I, c, B), T(I, d, B), T(I, p, B), P.m(p, null), T(I, m, B), T(I, g, B), h || (_ = [
        V(l, "click", y),
        V(c, "change", k),
        V(g, "click", We(tt(D)))
      ], h = !0);
    },
    p(I, B) {
      i = I, B & /*optionalFeatures*/
      4 && !ze(e.src, t = /*feature*/
      i[24].img) && b(e, "src", t), B & /*optionalFeatures*/
      4 && s !== (s = /*feature*/
      i[24].name) && b(e, "alt", s), B & /*optionalFeatures*/
      4 && r !== (r = /*feature*/
      i[24].name + "") && _e(o, r), B & /*optionalFeatures*/
      4 && u !== (u = /*feature*/
      i[24].limitedReselection ?? !0) && (c.checked = u), O === (O = v(i)) && P ? P.p(i, B) : (P.d(1), P = O(i), P && (P.c(), P.m(p, null)));
    },
    d(I) {
      I && (S(e), S(n), S(l), S(a), S(c), S(d), S(p), S(m), S(g)), P.d(), h = !1, Ne(_);
    }
  };
}
f(CI, "create_each_block$1t");
function YY(i) {
  let e, t, s, n;
  e = new ba({
    props: { type: "uuid", documentType: "Item" }
  }), e.$on(
    "document-dropped",
    /*document_dropped_handler_1*/
    i[18]
  );
  let l = (
    /*optionalFeatures*/
    i[2].length > 0 && TI(i)
  );
  return {
    c() {
      L(e.$$.fragment), t = R(), l && l.c(), s = $e();
    },
    m(r, o) {
      N(e, r, o), T(r, t, o), l && l.m(r, o), T(r, s, o), n = !0;
    },
    p(r, o) {
      /*optionalFeatures*/
      r[2].length > 0 ? l ? l.p(r, o) : (l = TI(r), l.c(), l.m(s.parentNode, s)) : l && (l.d(1), l = null);
    },
    i(r) {
      n || (w(e.$$.fragment, r), n = !0);
    },
    o(r) {
      C(e.$$.fragment, r), n = !1;
    },
    d(r) {
      r && (S(t), S(s)), j(e, r), l && l.d(r);
    }
  };
}
f(YY, "create_default_slot_2$J");
function XY(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), e.value = t = /*grant*/
      i[0].features.total ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_5*/
        i[23]
      ), s = !0);
    },
    p(l, r) {
      r & /*grant*/
      1 && t !== (t = /*grant*/
      l[0].features.total ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(XY, "create_default_slot_1$12");
function JY(i) {
  let e, t;
  return e = new de({
    props: {
      heading: "Selectable Options Count",
      $$slots: { default: [XY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, grant*/
      268435457 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(JY, "create_default_slot$1R");
function ZY(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k, v, O;
  return d = new Me({
    props: {
      heading: "Base Features",
      $$slots: { default: [VY] },
      $$scope: { ctx: i }
    }
  }), g = new Me({
    props: {
      heading: "Optional Features",
      $$slots: { default: [YY] },
      $$scope: { ctx: i }
    }
  }), y = new In({
    props: {
      $$slots: { default: [JY] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), p = E("div"), L(d.$$.fragment), m = R(), h = E("div"), L(g.$$.fragment), _ = R(), L(y.$$.fragment), b(s, "class", "grant-image svelte-iyq5rz"), ze(s.src, n = /*grant*/
      i[0].img || /*$item*/
      i[1].img || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*grant*/
      i[0].label ?? "", b(a, "class", "grant-name svelte-iyq5rz"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-iyq5rz"), b(t, "class", "sheet-header svelte-iyq5rz"), z(p, "display", "contents"), z(p, "--a5e-section-margin", "0.25rem 0"), z(h, "display", "contents"), z(h, "--a5e-section-margin", "0.25rem 0"), b(e, "class", "svelte-iyq5rz");
    },
    m(P, D) {
      T(P, e, D), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, u), A(e, p), N(d, p, null), A(e, m), A(e, h), N(g, h, null), A(e, _), N(y, e, null), k = !0, v || (O = [
        V(
          s,
          "click",
          /*updateImage*/
          i[4]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[12]
        )
      ], v = !0);
    },
    p(P, [D]) {
      (!k || D & /*grant, $item*/
      3 && !ze(s.src, n = /*grant*/
      P[0].img || /*$item*/
      P[1].img || "icons/svg/upgrade.svg")) && b(s, "src", n), (!k || D & /*grant*/
      1 && l !== (l = /*grant*/
      P[0].label)) && b(s, "alt", l), (!k || D & /*grant*/
      1 && c !== (c = /*grant*/
      P[0].label ?? "") && a.value !== c) && (a.value = c);
      const I = {};
      D & /*$$scope, baseFeatures*/
      268435464 && (I.$$scope = { dirty: D, ctx: P }), d.$set(I);
      const B = {};
      D & /*$$scope, optionalFeatures*/
      268435460 && (B.$$scope = { dirty: D, ctx: P }), g.$set(B);
      const F = {};
      D & /*$$scope, grant*/
      268435457 && (F.$$scope = { dirty: D, ctx: P }), y.$set(F);
    },
    i(P) {
      k || (w(d.$$.fragment, P), w(g.$$.fragment, P), w(y.$$.fragment, P), k = !0);
    },
    o(P) {
      C(d.$$.fragment, P), C(g.$$.fragment, P), C(y.$$.fragment, P), k = !1;
    },
    d(P) {
      P && S(e), j(d), j(g), j(y), v = !1, Ne(O);
    }
  };
}
f(ZY, "create_fragment$3J");
async function OI(i) {
  (await fromUuid(i)).sheet.render(!0);
}
f(OI, "openDocument");
function DI(i) {
  return i.map((e) => {
    const t = fromUuidSync(e.uuid);
    return {
      uuid: e.uuid,
      name: (t == null ? void 0 : t.name) || "Unknown Feature",
      img: (t == null ? void 0 : t.img) || "",
      limitedReselection: e.limitedReselection,
      selectionLimit: e.selectionLimit
    };
  });
}
f(DI, "getFeatureData");
function QY(i, e, t) {
  let s, n, l, r, { document: o, grantId: a, grantType: c } = fe("#external").application, { document: u = o, grantId: d = a, grantType: p = c } = e;
  function m() {
    const W = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: W,
      callback: (te) => {
        g("img", te);
      }
    }).browse();
  }
  f(m, "updateImage");
  function g(W, X) {
    W = `system.grants.${d}.${W}`, se(r, W, X);
  }
  f(g, "onUpdateValue");
  function h(W, X, te, J) {
    const re = W === "base" ? n : l, ae = re[X];
    ae[te] = J, g(`features.${W}`, re);
  }
  f(h, "updateFeature");
  function _(W, X) {
    const te = fromUuidSync(X);
    if (!te)
      return;
    if (te.type !== "feature")
      return ui.notifications.error("Invalid Document - Must be a Feature.");
    const J = {
      uuid: X,
      limitedReselection: !0,
      selectionLimit: 1
    };
    W === "features.base" && g(W, [...n, J]), W === "features.options" && g(W, [...l, J]);
  }
  f(_, "onDropUpdate"), Nt(() => {
    y.destroy();
  });
  const y = new Bt(u);
  pe(i, y, (W) => t(1, r = W)), et("item", y), et("grantId", d), et("grantType", p);
  const k = /* @__PURE__ */ f(({ target: W }) => g("label", W.value), "change_handler"), v = /* @__PURE__ */ f(({ detail: W }) => _("features.base", W.uuid), "document_dropped_handler"), O = /* @__PURE__ */ f((W) => OI(W.uuid), "click_handler"), P = /* @__PURE__ */ f((W, { target: X }) => h("base", W, "limitedReselection", X.checked), "change_handler_1"), D = /* @__PURE__ */ f((W, { target: X }) => h("base", W, "selectionLimit", Number(X.value)), "change_handler_2"), I = /* @__PURE__ */ f((W) => g("features.base", n.filter((X, te) => te !== W)), "click_handler_1"), B = /* @__PURE__ */ f(({ detail: W }) => _("features.options", W.uuid), "document_dropped_handler_1"), F = /* @__PURE__ */ f((W) => OI(W.uuid), "click_handler_2"), H = /* @__PURE__ */ f((W, { target: X }) => h("options", W, "limitedReselection", X.checked), "change_handler_3"), G = /* @__PURE__ */ f((W, { target: X }) => h("options", W, "selectionLimit", Number(X.value)), "change_handler_4"), U = /* @__PURE__ */ f((W) => g("features.options", l.filter((X, te) => te !== W)), "click_handler_3"), q = /* @__PURE__ */ f(({ target: W }) => g("features.total", Number(W.value)), "change_handler_5");
  return i.$$set = (W) => {
    "document" in W && t(9, u = W.document), "grantId" in W && t(10, d = W.grantId), "grantType" in W && t(11, p = W.grantType);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item, grantId*/
    1026 && t(0, s = r.system.grants[d]), i.$$.dirty & /*grant*/
    1 && t(3, n = DI(s.features.base ?? [])), i.$$.dirty & /*grant*/
    1 && t(2, l = DI(s.features.options ?? []));
  }, [
    s,
    r,
    l,
    n,
    m,
    g,
    h,
    _,
    y,
    u,
    d,
    p,
    k,
    v,
    O,
    P,
    D,
    I,
    B,
    F,
    H,
    G,
    U,
    q
  ];
}
f(QY, "instance$3A");
const RE = class RE extends ie {
  constructor(e) {
    super(), le(this, e, QY, ZY, ne, { document: 9, grantId: 10, grantType: 11 });
  }
};
f(RE, "FeatureGrantConfig");
let Fy = RE;
var Ih, Ph, Mh;
const FE = class FE extends rs {
  constructor() {
    super(...arguments);
    Y(this, Ih, Ry);
    Y(this, Ph, Fy);
    Y(this, Mh, "feature");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "feature" }),
      features: new t.SchemaField({
        base: new t.ArrayField(
          new t.SchemaField({
            uuid: new t.StringField({ required: !0, initial: "" }),
            limitedReselection: new t.BooleanField({ required: !0, initial: !0 }),
            selectionLimit: new t.NumberField({ nullable: !1, initial: 1 })
          }),
          { required: !0, default: [] }
        ),
        options: new t.ArrayField(
          new t.SchemaField({
            uuid: new t.StringField({ required: !0, initial: "" }),
            limitedReselection: new t.BooleanField({ required: !0, initial: !0 }),
            selectionLimit: new t.NumberField({ nullable: !1, initial: 1 })
          }),
          { required: !0, default: [] }
        ),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      label: new t.StringField({ required: !0, initial: "New Feature Grant" })
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getApplyData(t, s) {
    if (!t)
      return {};
    const n = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      grantType: "feature",
      level: this.level
    };
    return {
      "system.grants": {
        ...t.system.grants,
        [this._id]: n
      }
    };
  }
  getSelectionComponent() {
    return M(this, Ih);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.features.base,
      choices: this.features.options,
      count: this.features.total,
      selected: (t == null ? void 0 : t.uuids) ?? []
    };
  }
  requiresConfig() {
    return !!this.features.options.length;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: M(this, Mh)
    };
    super.configureGrant(
      "Configure Feature Grant",
      t,
      M(this, Ph),
      { width: 550 }
    );
  }
};
Ih = new WeakMap(), Ph = new WeakMap(), Mh = new WeakMap(), f(FE, "FeatureGrant");
let Ny = FE;
var Rh, Fh;
const NE = class NE extends rs {
  constructor() {
    super(...arguments);
    Y(this, Rh, Pn);
    Y(this, Fh, "healing");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "healing" }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      context: new t.SchemaField(sB("grant")),
      healingType: new t.StringField({ required: !0, initial: "healing" }),
      label: new t.StringField({ required: !0, initial: "New Healing Grant" })
    });
  }
  getApplyData(t) {
    var r, o;
    if (!t)
      return {};
    const s = foundry.utils.randomID(), n = {
      context: this.context,
      formula: this.bonus,
      label: this.label || ((r = this.parent) == null ? void 0 : r.name) || "Healing Grant",
      default: this.context.default ?? !0,
      img: this.img || ((o = this == null ? void 0 : this.parent) == null ? void 0 : o.img)
    };
    delete n.context.default;
    const l = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      bonusId: s,
      type: "healing",
      grantType: "bonus",
      level: this.level
    };
    return {
      [`system.bonuses.healing.${s}`]: n,
      "system.grants": {
        ...t.system.grants,
        [this._id]: l
      }
    };
  }
  getSelectionComponent() {
    return null;
  }
  getSelectionComponentProps() {
    return null;
  }
  requiresConfig() {
    return !1;
  }
  async configureGrant() {
    const t = {
      document: this.parent,
      grantId: this._id,
      grantType: M(this, Fh)
    };
    super.configureGrant(
      "Configure Healing Grant",
      t,
      M(this, Rh),
      { width: 400 }
    );
  }
};
Rh = new WeakMap(), Fh = new WeakMap(), f(NE, "HealingGrant");
let jy = NE;
var Nh, Fu;
const jE = class jE extends rs {
  constructor() {
    super(...arguments);
    Y(this, Nh, Pn);
    Y(this, Fu, "hitPoint");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "hitPoint" }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      context: new t.SchemaField(nB()),
      label: new t.StringField({ required: !0, initial: "New Hit Point Grant" })
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getApplyData(t, s = {}) {
    var o, a;
    if (!t)
      return {};
    const n = foundry.utils.randomID(), l = {
      context: { ...this.context },
      formula: this.bonus,
      label: this.label || ((o = this.parent) == null ? void 0 : o.name) || "HitPoint Grant",
      img: this.img || ((a = this == null ? void 0 : this.parent) == null ? void 0 : a.img)
    }, r = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      bonusId: n,
      type: M(this, Fu),
      grantType: "bonus",
      level: this.level
    };
    return {
      [`system.bonuses.hitPoint.${n}`]: l,
      "system.grants": {
        ...t.system.grants,
        [this._id]: r
      }
    };
  }
  getSelectionComponent() {
    return null;
  }
  getSelectionComponentProps() {
    return {};
  }
  requiresConfig() {
    return !1;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: M(this, Fu)
    };
    super.configureGrant(
      "Configure Hit Points Grant",
      t,
      M(this, Nh),
      { width: 400 }
    );
  }
};
Nh = new WeakMap(), Fu = new WeakMap(), f(jE, "HitPointGrant");
let Ly = jE;
var jh, Lh;
const LE = class LE extends rs {
  constructor() {
    super(...arguments);
    Y(this, jh, Pn);
    Y(this, Lh, "initiative");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "initiative" }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      context: new t.SchemaField(iB("grant")),
      label: new t.StringField({ required: !0, initial: "New Initiative Grant" })
    });
  }
  getApplyData(t) {
    var r, o;
    if (!t)
      return {};
    const s = foundry.utils.randomID(), n = {
      context: this.context,
      formula: this.bonus,
      label: this.label || ((r = this.parent) == null ? void 0 : r.name) || "Initiative Grant",
      default: this.context.default ?? !0,
      img: this.img || ((o = this == null ? void 0 : this.parent) == null ? void 0 : o.img)
    };
    delete n.context.default;
    const l = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      bonusId: s,
      type: "initiative",
      grantType: "bonus",
      level: this.level
    };
    return {
      [`system.bonuses.initiative.${s}`]: n,
      "system.grants": {
        ...t.system.grants,
        [this._id]: l
      }
    };
  }
  getSelectionComponent() {
    return null;
  }
  getSelectionComponentProps() {
    return null;
  }
  requiresConfig() {
    return !1;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: M(this, Lh)
    };
    super.configureGrant(
      "Configure Initiative Grant",
      t,
      M(this, jh),
      { width: 500 }
    );
  }
};
jh = new WeakMap(), Lh = new WeakMap(), f(LE, "InitiativeGrant");
let By = LE;
function xY(i) {
  let e, t;
  return e = new Ze({
    props: {
      options: (
        /*options*/
        i[7]
      ),
      selected: (
        /*selected*/
        i[0]
      ),
      orange: (
        /*choices*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*onUpdateSelection*/
    i[6]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), n & /*choices*/
      4 && (l.orange = /*choices*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(xY, "create_default_slot_2$I");
function eX(i) {
  let e;
  return {
    c() {
      e = x(
        /*summary*/
        i[4]
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*summary*/
      16 && _e(
        e,
        /*summary*/
        t[4]
      );
    },
    d(t) {
      t && S(e);
    }
  };
}
f(eX, "create_default_slot_1$11");
function tX(i) {
  let e, t, s, n;
  return e = new de({
    props: {
      warning: (
        /*remainingSelections*/
        i[5] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
        i[5]} choices remaining.`
      ),
      showWarning: (
        /*selected*/
        i[0].length < /*totalCount*/
        i[3]
      ),
      $$slots: { default: [xY] },
      $$scope: { ctx: i }
    }
  }), s = new de({
    props: {
      $$slots: { default: [eX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*remainingSelections*/
      32 && (o.warning = /*remainingSelections*/
      l[5] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
      l[5]} choices remaining.`), r & /*selected, totalCount*/
      9 && (o.showWarning = /*selected*/
      l[0].length < /*totalCount*/
      l[3]), r & /*$$scope, selected, choices*/
      8197 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$$scope, summary*/
      8208 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(tX, "create_default_slot$1Q");
function sX(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Item Grant - " + /*grant*/
      i[1].label,
      $$slots: { default: [tX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*grant*/
      2 && (r.heading = "Item Grant - " + /*grant*/
      n[1].label), l & /*$$scope, summary, remainingSelections, selected, totalCount, choices*/
      8253 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(sX, "create_fragment$3I");
function nX(i, e, t) {
  let s, n, l, { grant: r } = e, { base: o } = e, { choices: a } = e, { count: c } = e, { selected: u } = e;
  const d = it();
  fe("actor");
  function p(h) {
    return "";
  }
  f(p, "getGrantSummary");
  function m({ detail: h }) {
    t(0, u = h), d("updateSelection", { uuids: u, summary: l });
  }
  f(m, "onUpdateSelection");
  const g = [...o, ...a].map((h) => {
    const _ = fromUuidSync(h);
    return [h, _.name];
  });
  return i.$$set = (h) => {
    "grant" in h && t(1, r = h.grant), "base" in h && t(8, o = h.base), "choices" in h && t(2, a = h.choices), "count" in h && t(9, c = h.count), "selected" in h && t(0, u = h.selected);
  }, i.$$.update = () => {
    i.$$.dirty & /*base, selected*/
    257 && t(0, u = [...o, ...u]), i.$$.dirty & /*base, count*/
    768 && t(3, s = o.length + c), i.$$.dirty & /*totalCount, selected*/
    9 && t(5, n = s - u.length), i.$$.dirty & /*selected*/
    1 && t(4, l = p());
  }, [
    u,
    r,
    a,
    s,
    l,
    n,
    m,
    g,
    o,
    c
  ];
}
f(nX, "instance$3z");
const BE = class BE extends ie {
  constructor(e) {
    super(), le(this, e, nX, sX, ne, {
      grant: 1,
      base: 8,
      choices: 2,
      count: 9,
      selected: 0
    });
  }
};
f(BE, "ItemGrantSelectionDialog");
let qy = BE;
function II(i, e, t) {
  const s = i.slice();
  return s[10] = e[t][0], s[11] = e[t][1], s[12] = e[t][2], s[14] = t, s;
}
f(II, "get_each_context$1s");
function PI(i) {
  let e, t, s, n;
  function l(...r) {
    return (
      /*change_handler*/
      i[6](
        /*idx*/
        i[14],
        ...r
      )
    );
  }
  return f(l, "change_handler"), {
    c() {
      e = E("input"), b(e, "type", "number"), b(e, "class", "tag-count svelte-y6wasb"), e.value = t = /*quantity*/
      i[12];
    },
    m(r, o) {
      T(r, e, o), s || (n = V(e, "change", l), s = !0);
    },
    p(r, o) {
      i = r, o & /*documents*/
      2 && t !== (t = /*quantity*/
      i[12]) && e.value !== t && (e.value = t);
    },
    d(r) {
      r && S(e), s = !1, n();
    }
  };
}
f(PI, "create_if_block$21");
function MI(i) {
  let e, t, s, n, l, r, o = (
    /*name*/
    i[11] + ""
  ), a, c, u, d, p, m, g, h = (
    /*type*/
    i[0] === "item" && PI(i)
  );
  function _() {
    return (
      /*click_handler*/
      i[7](
        /*idx*/
        i[14]
      )
    );
  }
  return f(_, "click_handler"), {
    c() {
      e = E("div"), t = E("img"), l = R(), r = E("span"), a = x(o), c = R(), h && h.c(), u = R(), d = E("button"), d.innerHTML = '<i class="fa-solid fa-x"></i>', p = R(), ze(t.src, s = /*img*/
      i[10]) || b(t, "src", s), b(t, "alt", n = /*name*/
      i[11]), b(t, "class", "tag-img svelte-y6wasb"), b(r, "class", "tag-name"), b(d, "class", "tag-delete-button svelte-y6wasb"), b(e, "class", "tag-wrapper svelte-y6wasb");
    },
    m(y, k) {
      T(y, e, k), A(e, t), A(e, l), A(e, r), A(r, a), A(e, c), h && h.m(e, null), A(e, u), A(e, d), A(e, p), m || (g = V(d, "click", We(tt(_))), m = !0);
    },
    p(y, k) {
      i = y, k & /*documents*/
      2 && !ze(t.src, s = /*img*/
      i[10]) && b(t, "src", s), k & /*documents*/
      2 && n !== (n = /*name*/
      i[11]) && b(t, "alt", n), k & /*documents*/
      2 && o !== (o = /*name*/
      i[11] + "") && _e(a, o), /*type*/
      i[0] === "item" ? h ? h.p(i, k) : (h = PI(i), h.c(), h.m(e, u)) : h && (h.d(1), h = null);
    },
    d(y) {
      y && S(e), h && h.d(), m = !1, g();
    }
  };
}
f(MI, "create_each_block$1s");
function iX(i) {
  let e, t = oe(
    /*documents*/
    i[1]
  ), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = MI(II(i, t, n));
  return {
    c() {
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      e = $e();
    },
    m(n, l) {
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(n, l);
      T(n, e, l);
    },
    p(n, l) {
      if (l & /*onClick, documents, onUpdateQuantity, type*/
      15) {
        t = oe(
          /*documents*/
          n[1]
        );
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = II(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = MI(o), s[r].c(), s[r].m(e.parentNode, e));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && S(e), Le(s, n);
    }
  };
}
f(iX, "create_default_slot$1P");
function lX(i) {
  let e, t, s;
  return e = new de({
    props: {
      $$slots: { default: [iX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-direction", "row");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, documents, type*/
      32771 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(lX, "create_fragment$3H");
function rX(i, e, t) {
  let s, { uuids: n = [] } = e, { embeddedData: l = [] } = e, { type: r = "feature" } = e;
  const o = it();
  function a(m) {
    r === "feature" && (t(4, n = n.filter((g, h) => h !== m)), o("updateSelection", n)), r === "item" && (t(5, l = l.filter((g, h) => h !== m)), o("updateSelection", l));
  }
  f(a, "onClick");
  function c(m, g) {
    r === "item" && (t(5, l[m].quantityOverride = g, l), o("updateSelection", l), t(5, l));
  }
  f(c, "onUpdateQuantity");
  function u(m) {
    return m === "feature" ? n.map((g) => {
      const h = fromUuidSync(g);
      return [h.img, h.name];
    }) : m === "item" ? l.map(({ uuid: g, quantityOverride: h }) => {
      const _ = fromUuidSync(g);
      return [_.img, _.name, h || _.system.quantity || 1];
    }) : [];
  }
  f(u, "getDocuments");
  const d = /* @__PURE__ */ f((m, { target: g }) => {
    c(m, g.value);
  }, "change_handler"), p = /* @__PURE__ */ f((m) => a(m), "click_handler");
  return i.$$set = (m) => {
    "uuids" in m && t(4, n = m.uuids), "embeddedData" in m && t(5, l = m.embeddedData), "type" in m && t(0, r = m.type);
  }, i.$$.update = () => {
    i.$$.dirty & /*type, uuids, embeddedData*/
    49 && t(1, s = u(r));
  }, [
    r,
    s,
    a,
    c,
    n,
    l,
    d,
    p
  ];
}
f(rX, "instance$3y");
const qE = class qE extends ie {
  constructor(e) {
    super(), le(this, e, rX, lX, ne, { uuids: 4, embeddedData: 5, type: 0 });
  }
};
f(qE, "DropTag");
let Yd = qE;
function oX(i) {
  let e, t, s, n;
  return e = new ba({
    props: { type: "uuid", documentType: "Item" }
  }), e.$on(
    "document-dropped",
    /*document_dropped_handler*/
    i[10]
  ), s = new Yd({
    props: {
      embeddedData: (
        /*grant*/
        i[0].items.base
      ),
      type: "item"
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[11]
  ), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*grant*/
      1 && (o.embeddedData = /*grant*/
      l[0].items.base), s.$set(o);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(oX, "create_default_slot_3$w");
function aX(i) {
  let e, t, s, n;
  return e = new ba({
    props: { type: "uuid", documentType: "Item" }
  }), e.$on(
    "document-dropped",
    /*document_dropped_handler_1*/
    i[12]
  ), s = new Yd({
    props: {
      embeddedData: (
        /*grant*/
        i[0].items.options
      ),
      type: "item"
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[13]
  ), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*grant*/
      1 && (o.embeddedData = /*grant*/
      l[0].items.options), s.$set(o);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(aX, "create_default_slot_2$H");
function cX(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), e.value = t = /*grant*/
      i[0].items.total ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[14]
      ), s = !0);
    },
    p(l, r) {
      r & /*grant*/
      1 && t !== (t = /*grant*/
      l[0].items.total ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(cX, "create_default_slot_1$10");
function uX(i) {
  let e, t;
  return e = new de({
    props: {
      heading: "Total Count",
      $$slots: { default: [cX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, grant*/
      131073 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(uX, "create_default_slot$1O");
function fX(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k, v, O;
  return d = new Me({
    props: {
      heading: "Base Items",
      $$slots: { default: [oX] },
      $$scope: { ctx: i }
    }
  }), g = new Me({
    props: {
      heading: "Optional Items",
      $$slots: { default: [aX] },
      $$scope: { ctx: i }
    }
  }), y = new In({
    props: {
      $$slots: { default: [uX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), p = E("div"), L(d.$$.fragment), m = R(), h = E("div"), L(g.$$.fragment), _ = R(), L(y.$$.fragment), b(s, "class", "grant-image svelte-exgcmx"), ze(s.src, n = /*grant*/
      i[0].img || /*$item*/
      i[1].img || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*grant*/
      i[0].label ?? "", b(a, "class", "grant-name svelte-exgcmx"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-exgcmx"), b(t, "class", "sheet-header svelte-exgcmx"), z(p, "display", "contents"), z(p, "--a5e-section-margin", "0.25rem 0"), z(h, "display", "contents"), z(h, "--a5e-section-margin", "0.25rem 0"), b(e, "class", "svelte-exgcmx");
    },
    m(P, D) {
      T(P, e, D), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, u), A(e, p), N(d, p, null), A(e, m), A(e, h), N(g, h, null), A(e, _), N(y, e, null), k = !0, v || (O = [
        V(
          s,
          "click",
          /*updateImage*/
          i[2]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[9]
        )
      ], v = !0);
    },
    p(P, [D]) {
      (!k || D & /*grant, $item*/
      3 && !ze(s.src, n = /*grant*/
      P[0].img || /*$item*/
      P[1].img || "icons/svg/upgrade.svg")) && b(s, "src", n), (!k || D & /*grant*/
      1 && l !== (l = /*grant*/
      P[0].label)) && b(s, "alt", l), (!k || D & /*grant*/
      1 && c !== (c = /*grant*/
      P[0].label ?? "") && a.value !== c) && (a.value = c);
      const I = {};
      D & /*$$scope, grant*/
      131073 && (I.$$scope = { dirty: D, ctx: P }), d.$set(I);
      const B = {};
      D & /*$$scope, grant*/
      131073 && (B.$$scope = { dirty: D, ctx: P }), g.$set(B);
      const F = {};
      D & /*$$scope, grant*/
      131073 && (F.$$scope = { dirty: D, ctx: P }), y.$set(F);
    },
    i(P) {
      k || (w(d.$$.fragment, P), w(g.$$.fragment, P), w(y.$$.fragment, P), k = !0);
    },
    o(P) {
      C(d.$$.fragment, P), C(g.$$.fragment, P), C(y.$$.fragment, P), k = !1;
    },
    d(P) {
      P && S(e), j(d), j(g), j(y), v = !1, Ne(O);
    }
  };
}
f(fX, "create_fragment$3G");
function dX(i, e, t) {
  let s, n, l, r, { document: o, grantId: a, grantType: c } = fe("#external").application, { document: u = o, grantId: d = a, grantType: p = c } = e;
  function m() {
    const I = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: I,
      callback: (F) => {
        g("img", F);
      }
    }).browse();
  }
  f(m, "updateImage");
  function g(I, B) {
    I = `system.grants.${d}.${I}`, se(r, I, B);
  }
  f(g, "onUpdateValue");
  function h(I, B) {
    if (I === "items.base") {
      if (n.includes(B))
        return;
      const F = [...s.items.base ?? []], H = fromUuidSync(B);
      F.push({
        uuid: B,
        quantity: H.system.quantity
      }), g(I, F);
    }
    if (I === "items.options") {
      if (l.includes(B))
        return;
      const F = [...s.items.options ?? []], H = fromUuidSync(B);
      F.push({
        uuid: B,
        quantity: H.system.quantity
      }), g(I, F);
    }
  }
  f(h, "onDropUpdate"), Nt(() => {
    _.destroy();
  });
  const _ = new Bt(u);
  pe(i, _, (I) => t(1, r = I)), et("item", _), et("grantId", d), et("grantType", p);
  const y = /* @__PURE__ */ f(({ target: I }) => g("label", I.value), "change_handler"), k = /* @__PURE__ */ f(({ detail: I }) => h("items.base", I.uuid), "document_dropped_handler"), v = /* @__PURE__ */ f(({ detail: I }) => g("items.base", I), "updateSelection_handler"), O = /* @__PURE__ */ f(({ detail: I }) => h("items.options", I.uuid), "document_dropped_handler_1"), P = /* @__PURE__ */ f(({ detail: I }) => g("items.options", I), "updateSelection_handler_1"), D = /* @__PURE__ */ f(({ target: I }) => g("items.total", Number(I.value)), "change_handler_1");
  return i.$$set = (I) => {
    "document" in I && t(6, u = I.document), "grantId" in I && t(7, d = I.grantId), "grantType" in I && t(8, p = I.grantType);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item, grantId*/
    130 && t(0, s = r.system.grants[d]), i.$$.dirty & /*grant*/
    1 && (n = s.items.base.map((I) => I.uuid) ?? []), i.$$.dirty & /*grant*/
    1 && (l = s.items.options.map((I) => I.uuid) ?? []);
  }, [
    s,
    r,
    m,
    g,
    h,
    _,
    u,
    d,
    p,
    y,
    k,
    v,
    O,
    P,
    D
  ];
}
f(dX, "instance$3x");
const GE = class GE extends ie {
  constructor(e) {
    super(), le(this, e, dX, fX, ne, { document: 6, grantId: 7, grantType: 8 });
  }
};
f(GE, "ItemGrantConfig");
let Gy = GE;
var Bh, qh, Nu;
const zE = class zE extends rs {
  constructor() {
    super(...arguments);
    Y(this, Bh, qy);
    Y(this, qh, Gy);
    Y(this, Nu, "item");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "item" }),
      items: new t.SchemaField({
        base: new t.ArrayField(
          new t.SchemaField({
            uuid: new t.StringField({ required: !0, initial: "" }),
            quantityOverride: new t.NumberField({ required: !0, initial: 0, integer: !0 })
          }),
          { required: !0, default: [] }
        ),
        options: new t.ArrayField(
          new t.SchemaField({
            uuid: new t.StringField({ required: !0, initial: "" }),
            quantityOverride: new t.NumberField({ required: !0, initial: 0, integer: !0 })
          })
        ),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      label: new t.StringField({ required: !0, initial: "New Item Grant" })
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getApplyData(t, s) {
    if (!t)
      return {};
    const n = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      grantType: M(this, Nu),
      level: this.level
    };
    return {
      "system.grants": {
        ...t.system.grants,
        [this._id]: n
      }
    };
  }
  getSelectionComponent() {
    return M(this, Bh);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.items.base.map(({ uuid: s }) => s) ?? [],
      choices: this.items.options.map(({ uuid: s }) => s) ?? [],
      count: this.items.total,
      selected: (t == null ? void 0 : t.uuids) ?? []
    };
  }
  requiresConfig() {
    return !!this.items.options.length;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: M(this, Nu)
    };
    super.configureGrant(
      "Configure Item Grant",
      t,
      M(this, qh),
      { width: 400 }
    );
  }
};
Bh = new WeakMap(), qh = new WeakMap(), Nu = new WeakMap(), f(zE, "ItemGrant");
let zy = zE;
var Gh, zh, Hh;
const HE = class HE extends rs {
  constructor() {
    super(...arguments);
    Y(this, Gh, Or);
    Y(this, zh, Pn);
    Y(this, Hh, "movement");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "movement" }),
      movementTypes: new t.SchemaField({
        base: new t.ArrayField(
          new t.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        options: new t.ArrayField(
          new t.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      unit: new t.StringField({ required: !0, initial: "feet" }),
      context: new t.SchemaField(lB("grant")),
      label: new t.StringField({ required: !0, initial: "New Movement Grant" })
    });
  }
  getApplyData(t, s) {
    var o, a;
    if (!t)
      return {};
    const n = foundry.utils.randomID(), l = {
      context: {
        movementTypes: (s == null ? void 0 : s.selected) ?? this.movementTypes.base ?? [],
        ...this.context
      },
      formula: this.bonus,
      unit: this.unit || "feet",
      label: this.label || ((o = this.parent) == null ? void 0 : o.name) || "Movement Grant",
      img: this.img || ((a = this == null ? void 0 : this.parent) == null ? void 0 : a.img)
    }, r = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      bonusId: n,
      type: M(this, Hh),
      grantType: "bonus",
      level: this.level
    };
    return {
      [`system.bonuses.movement.${n}`]: l,
      "system.grants": {
        ...t.system.grants,
        [this._id]: r
      }
    };
  }
  getSelectionComponent() {
    return M(this, Gh);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.movementTypes.base ?? [],
      bonus: this.bonus,
      choices: this.movementTypes.options ?? [],
      configObject: CONFIG.A5E.movementAbbreviations,
      count: this.movementTypes.total,
      unit: this.unit,
      heading: "Movement Grant Selection",
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return this.movementTypes.options.length;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: "movement"
    };
    super.configureGrant(
      "Configure Movement Grant",
      t,
      M(this, zh),
      { width: 400 }
    );
  }
};
Gh = new WeakMap(), zh = new WeakMap(), Hh = new WeakMap(), f(HE, "MovementGrant");
let Hy = HE;
function pX(i) {
  var l, r, o, a, c, u, d, p, m, g;
  let e, t, s, n;
  return e = new Ze({
    props: {
      heading: "Base Options",
      options: (
        /*configObject*/
        (l = i[6][
          /*proficiencyType*/
          i[2]
        ]) == null ? void 0 : l.config
      ),
      selected: (
        /*grant*/
        (o = (r = i[0]) == null ? void 0 : r.keys) == null ? void 0 : o.base
      ),
      showToggleAllButton: !0,
      disabledOptions: (
        /*grant*/
        (c = (a = i[0]) == null ? void 0 : a.keys) == null ? void 0 : c.options
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[17]
  ), s = new Ze({
    props: {
      heading: "Optional Choices",
      options: (
        /*configObject*/
        (u = i[6][
          /*proficiencyType*/
          i[2]
        ]) == null ? void 0 : u.config
      ),
      selected: (
        /*grant*/
        (p = (d = i[0]) == null ? void 0 : d.keys) == null ? void 0 : p.options
      ),
      disabledOptions: (
        /*grant*/
        (g = (m = i[0]) == null ? void 0 : m.keys) == null ? void 0 : g.base
      ),
      showToggleAllButton: !0
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[18]
  ), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(h, _) {
      N(e, h, _), T(h, t, _), N(s, h, _), n = !0;
    },
    p(h, _) {
      var v, O, P, D, I, B, F, H, G, U;
      const y = {};
      _ & /*proficiencyType*/
      4 && (y.options = /*configObject*/
      (v = h[6][
        /*proficiencyType*/
        h[2]
      ]) == null ? void 0 : v.config), _ & /*grant*/
      1 && (y.selected = /*grant*/
      (P = (O = h[0]) == null ? void 0 : O.keys) == null ? void 0 : P.base), _ & /*grant*/
      1 && (y.disabledOptions = /*grant*/
      (I = (D = h[0]) == null ? void 0 : D.keys) == null ? void 0 : I.options), e.$set(y);
      const k = {};
      _ & /*proficiencyType*/
      4 && (k.options = /*configObject*/
      (B = h[6][
        /*proficiencyType*/
        h[2]
      ]) == null ? void 0 : B.config), _ & /*grant*/
      1 && (k.selected = /*grant*/
      (H = (F = h[0]) == null ? void 0 : F.keys) == null ? void 0 : H.options), _ & /*grant*/
      1 && (k.disabledOptions = /*grant*/
      (U = (G = h[0]) == null ? void 0 : G.keys) == null ? void 0 : U.base), s.$set(k);
    },
    i(h) {
      n || (w(e.$$.fragment, h), w(s.$$.fragment, h), n = !0);
    },
    o(h) {
      C(e.$$.fragment, h), C(s.$$.fragment, h), n = !1;
    },
    d(h) {
      h && S(t), j(e, h), j(s, h);
    }
  };
}
f(pX, "create_else_block$A");
function mX(i) {
  let e, t, s, n;
  return e = new Me({
    props: {
      heading: "Base Options",
      $$slots: { default: [hX] },
      $$scope: { ctx: i }
    }
  }), s = new Me({
    props: {
      heading: "Optional Choices",
      $$slots: { default: [gX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$$scope, proficiencyType, grant*/
      2097157 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$$scope, proficiencyType, grant*/
      2097157 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(mX, "create_if_block_1$1k");
function hX(i) {
  var s, n, l, r, o;
  let e, t;
  return e = new ha({
    props: {
      heading: "Base Options",
      configObject: (
        /*configObject*/
        (s = i[6][
          /*proficiencyType*/
          i[2]
        ]) == null ? void 0 : s.config
      ),
      existingProperties: (
        /*grant*/
        (l = (n = i[0]) == null ? void 0 : n.keys) == null ? void 0 : l.base
      ),
      disabledProperties: (
        /*grant*/
        (o = (r = i[0]) == null ? void 0 : r.keys) == null ? void 0 : o.options
      ),
      headings: (
        /*proficiencyType*/
        i[2] === "tool" ? (
          /*toolCategories*/
          i[8]
        ) : (
          /*weaponCategories*/
          i[7]
        )
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[15]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(a, c) {
      N(e, a, c), t = !0;
    },
    p(a, c) {
      var d, p, m, g, h;
      const u = {};
      c & /*proficiencyType*/
      4 && (u.configObject = /*configObject*/
      (d = a[6][
        /*proficiencyType*/
        a[2]
      ]) == null ? void 0 : d.config), c & /*grant*/
      1 && (u.existingProperties = /*grant*/
      (m = (p = a[0]) == null ? void 0 : p.keys) == null ? void 0 : m.base), c & /*grant*/
      1 && (u.disabledProperties = /*grant*/
      (h = (g = a[0]) == null ? void 0 : g.keys) == null ? void 0 : h.options), c & /*proficiencyType*/
      4 && (u.headings = /*proficiencyType*/
      a[2] === "tool" ? (
        /*toolCategories*/
        a[8]
      ) : (
        /*weaponCategories*/
        a[7]
      )), e.$set(u);
    },
    i(a) {
      t || (w(e.$$.fragment, a), t = !0);
    },
    o(a) {
      C(e.$$.fragment, a), t = !1;
    },
    d(a) {
      j(e, a);
    }
  };
}
f(hX, "create_default_slot_3$v");
function gX(i) {
  var s, n, l, r, o;
  let e, t;
  return e = new ha({
    props: {
      configObject: (
        /*configObject*/
        (s = i[6][
          /*proficiencyType*/
          i[2]
        ]) == null ? void 0 : s.config
      ),
      existingProperties: (
        /*grant*/
        (l = (n = i[0]) == null ? void 0 : n.keys) == null ? void 0 : l.options
      ),
      disabledProperties: (
        /*grant*/
        (o = (r = i[0]) == null ? void 0 : r.keys) == null ? void 0 : o.base
      ),
      headings: (
        /*proficiencyType*/
        i[2] === "tool" ? (
          /*toolCategories*/
          i[8]
        ) : (
          /*weaponCategories*/
          i[7]
        )
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[16]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(a, c) {
      N(e, a, c), t = !0;
    },
    p(a, c) {
      var d, p, m, g, h;
      const u = {};
      c & /*proficiencyType*/
      4 && (u.configObject = /*configObject*/
      (d = a[6][
        /*proficiencyType*/
        a[2]
      ]) == null ? void 0 : d.config), c & /*grant*/
      1 && (u.existingProperties = /*grant*/
      (m = (p = a[0]) == null ? void 0 : p.keys) == null ? void 0 : m.options), c & /*grant*/
      1 && (u.disabledProperties = /*grant*/
      (h = (g = a[0]) == null ? void 0 : g.keys) == null ? void 0 : h.base), c & /*proficiencyType*/
      4 && (u.headings = /*proficiencyType*/
      a[2] === "tool" ? (
        /*toolCategories*/
        a[8]
      ) : (
        /*weaponCategories*/
        a[7]
      )), e.$set(u);
    },
    i(a) {
      t || (w(e.$$.fragment, a), t = !0);
    },
    o(a) {
      C(e.$$.fragment, a), t = !1;
    },
    d(a) {
      j(e, a);
    }
  };
}
f(gX, "create_default_slot_2$G");
function RI(i) {
  let e, t, s, n, l;
  const r = [mX, pX], o = [];
  function a(c, u) {
    return u & /*proficiencyType*/
    4 && (e = null), e == null && (e = !!["tool", "weapon"].includes(
      /*proficiencyType*/
      c[2]
    )), e ? 0 : 1;
  }
  return f(a, "select_block_type"), t = a(i, -1), s = o[t] = r[t](i), {
    c() {
      s.c(), n = $e();
    },
    m(c, u) {
      o[t].m(c, u), T(c, n, u), l = !0;
    },
    p(c, u) {
      let d = t;
      t = a(c, u), t === d ? o[t].p(c, u) : (ce(), C(o[d], 1, 1, () => {
        o[d] = null;
      }), ue(), s = o[t], s ? s.p(c, u) : (s = o[t] = r[t](c), s.c()), w(s, 1), s.m(n.parentNode, n));
    },
    i(c) {
      l || (w(s), l = !0);
    },
    o(c) {
      C(s), l = !1;
    },
    d(c) {
      c && S(n), o[t].d(c);
    }
  };
}
f(RI, "create_key_block$2");
function bX(i) {
  let e, t, s, n;
  return {
    c() {
      var l, r;
      e = E("input"), b(e, "type", "number"), e.value = t = /*grant*/
      ((r = (l = i[0]) == null ? void 0 : l.keys) == null ? void 0 : r.total) ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[19]
      ), s = !0);
    },
    p(l, r) {
      var o, a;
      r & /*grant*/
      1 && t !== (t = /*grant*/
      ((a = (o = l[0]) == null ? void 0 : o.keys) == null ? void 0 : a.total) ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(bX, "create_default_slot_1$$");
function FI(i) {
  let e, t;
  return e = new De({
    props: {
      label: "Grant 5e expertise in these instead of proficiency",
      checked: (
        /*grant*/
        i[0].isExpertise ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[20]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*grant*/
      1 && (l.checked = /*grant*/
      s[0].isExpertise ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(FI, "create_if_block$20");
function _X(i) {
  let e, t, s = (
    /*proficiencyType*/
    i[2]
  ), n, l, r, o, a;
  e = new Ye({
    props: {
      options: Object.entries(
        /*configObject*/
        i[6]
      ).map(
        /*func*/
        i[13]
      ),
      selected: (
        /*proficiencyType*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[14]
  );
  let c = RI(i);
  l = new de({
    props: {
      heading: "Selectable Options Count",
      $$slots: { default: [bX] },
      $$scope: { ctx: i }
    }
  });
  let u = (
    /*proficiencyType*/
    i[2] === "skill" && FI(i)
  );
  return {
    c() {
      L(e.$$.fragment), t = R(), c.c(), n = R(), L(l.$$.fragment), r = R(), u && u.c(), o = $e();
    },
    m(d, p) {
      N(e, d, p), T(d, t, p), c.m(d, p), T(d, n, p), N(l, d, p), T(d, r, p), u && u.m(d, p), T(d, o, p), a = !0;
    },
    p(d, p) {
      const m = {};
      p & /*proficiencyType*/
      4 && (m.selected = /*proficiencyType*/
      d[2]), e.$set(m), p & /*proficiencyType*/
      4 && ne(s, s = /*proficiencyType*/
      d[2]) ? (ce(), C(c, 1, 1, ee), ue(), c = RI(d), c.c(), w(c, 1), c.m(n.parentNode, n)) : c.p(d, p);
      const g = {};
      p & /*$$scope, grant*/
      2097153 && (g.$$scope = { dirty: p, ctx: d }), l.$set(g), /*proficiencyType*/
      d[2] === "skill" ? u ? (u.p(d, p), p & /*proficiencyType*/
      4 && w(u, 1)) : (u = FI(d), u.c(), w(u, 1), u.m(o.parentNode, o)) : u && (ce(), C(u, 1, 1, () => {
        u = null;
      }), ue());
    },
    i(d) {
      a || (w(e.$$.fragment, d), w(c), w(l.$$.fragment, d), w(u), a = !0);
    },
    o(d) {
      C(e.$$.fragment, d), C(c), C(l.$$.fragment, d), C(u), a = !1;
    },
    d(d) {
      d && (S(t), S(n), S(r), S(o)), j(e, d), c.d(d), j(l, d), u && u.d(d);
    }
  };
}
f(_X, "create_default_slot$1N");
function yX(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y;
  return d = new Me({
    props: {
      heading: "Proficiency Config",
      $$slots: { default: [_X] },
      $$scope: { ctx: i }
    }
  }), g = new In({}), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), p = E("div"), L(d.$$.fragment), m = R(), L(g.$$.fragment), b(s, "class", "grant-image svelte-vpjv8o"), ze(s.src, n = /*grant*/
      i[0].img || /*$item*/
      i[1].img || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*grant*/
      i[0].label ?? "", b(a, "class", "grant-name svelte-vpjv8o"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-vpjv8o"), b(t, "class", "sheet-header svelte-vpjv8o"), z(p, "display", "contents"), z(p, "--a5e-section-margin", "0.25rem 0"), z(p, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-vpjv8o");
    },
    m(k, v) {
      T(k, e, v), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, u), A(e, p), N(d, p, null), A(e, m), N(g, e, null), h = !0, _ || (y = [
        V(
          s,
          "click",
          /*updateImage*/
          i[3]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[12]
        )
      ], _ = !0);
    },
    p(k, [v]) {
      (!h || v & /*grant, $item*/
      3 && !ze(s.src, n = /*grant*/
      k[0].img || /*$item*/
      k[1].img || "icons/svg/upgrade.svg")) && b(s, "src", n), (!h || v & /*grant*/
      1 && l !== (l = /*grant*/
      k[0].label)) && b(s, "alt", l), (!h || v & /*grant*/
      1 && c !== (c = /*grant*/
      k[0].label ?? "") && a.value !== c) && (a.value = c);
      const O = {};
      v & /*$$scope, grant, proficiencyType*/
      2097157 && (O.$$scope = { dirty: v, ctx: k }), d.$set(O);
    },
    i(k) {
      h || (w(d.$$.fragment, k), w(g.$$.fragment, k), h = !0);
    },
    o(k) {
      C(d.$$.fragment, k), C(g.$$.fragment, k), h = !1;
    },
    d(k) {
      k && S(e), j(d), j(g), _ = !1, Ne(y);
    }
  };
}
f(yX, "create_fragment$3F");
function vX(i, e, t) {
  let s, n, l, { document: r, grantId: o, grantType: a } = fe("#external").application, { document: c = r, grantId: u = o, grantType: d = a } = e;
  function p() {
    const G = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: G,
      callback: (q) => {
        m("img", q);
      }
    }).browse();
  }
  f(p, "updateImage");
  function m(G, U) {
    G === "proficiencyType" && se(l, `system.grants.${u}.keys`, { base: [], options: [], total: 0 }), G = `system.grants.${u}.${G}`, se(l, G, U);
  }
  f(m, "onUpdateValue"), Nt(() => {
    g.destroy();
  });
  const g = new Bt(c);
  pe(i, g, (G) => t(1, l = G));
  const h = lb(), { weaponCategories: _, toolCategories: y } = CONFIG.A5E;
  et("item", g), et("grantId", u), et("grantType", d);
  const k = /* @__PURE__ */ f(({ target: G }) => m("label", G.value), "change_handler"), v = /* @__PURE__ */ f(([G, { label: U }]) => [G, K(U)], "func"), O = /* @__PURE__ */ f(({ detail: G }) => m("proficiencyType", G), "updateSelection_handler"), P = /* @__PURE__ */ f(({ detail: G }) => {
    m("keys.base", G);
  }, "updateSelection_handler_1"), D = /* @__PURE__ */ f(({ detail: G }) => {
    m("keys.options", G);
  }, "updateSelection_handler_2"), I = /* @__PURE__ */ f(({ detail: G }) => {
    m("keys.base", G);
  }, "updateSelection_handler_3"), B = /* @__PURE__ */ f(({ detail: G }) => {
    m("keys.options", G);
  }, "updateSelection_handler_4"), F = /* @__PURE__ */ f(({ target: G }) => m("keys.total", Number(G.value)), "change_handler_1"), H = /* @__PURE__ */ f(({ detail: G }) => m("isExpertise", G), "updateSelection_handler_5");
  return i.$$set = (G) => {
    "document" in G && t(9, c = G.document), "grantId" in G && t(10, u = G.grantId), "grantType" in G && t(11, d = G.grantType);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item, grantId*/
    1026 && t(0, s = l.system.grants[u]), i.$$.dirty & /*grant*/
    1 && t(2, n = (s == null ? void 0 : s.proficiencyType) || "armor");
  }, [
    s,
    l,
    n,
    p,
    m,
    g,
    h,
    _,
    y,
    c,
    u,
    d,
    k,
    v,
    O,
    P,
    D,
    I,
    B,
    F,
    H
  ];
}
f(vX, "instance$3w");
const UE = class UE extends ie {
  constructor(e) {
    super(), le(this, e, vX, yX, ne, { document: 9, grantId: 10, grantType: 11 });
  }
};
f(UE, "ProficiencyGrantConfig");
let Uy = UE;
function kX(i) {
  let e, t;
  return e = new Ze({
    props: {
      options: (
        /*getOptions*/
        i[9](
          /*choicesLocked*/
          i[5]
        )
      ),
      selected: (
        /*selected*/
        i[0]
      ),
      orange: (
        /*choices*/
        i[2]
      ),
      disabled: (
        /*selected*/
        i[0].length >= /*totalCount*/
        i[4]
      )
    }
  }), e.$on(
    "updateSelection",
    /*onUpdateSelection*/
    i[8]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*choicesLocked*/
      32 && (l.options = /*getOptions*/
      s[9](
        /*choicesLocked*/
        s[5]
      )), n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), n & /*choices*/
      4 && (l.orange = /*choices*/
      s[2]), n & /*selected, totalCount*/
      17 && (l.disabled = /*selected*/
      s[0].length >= /*totalCount*/
      s[4]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(kX, "create_default_slot_2$F");
function wX(i) {
  let e;
  return {
    c() {
      e = x(
        /*summary*/
        i[6]
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*summary*/
      64 && _e(
        e,
        /*summary*/
        t[6]
      );
    },
    d(t) {
      t && S(e);
    }
  };
}
f(wX, "create_default_slot_1$_");
function $X(i) {
  let e, t, s, n, l;
  return e = new de({
    props: {
      warning: (
        /*remainingSelections*/
        i[7] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
        i[7]} choices remaining.`
      ),
      showWarning: (
        /*selected*/
        i[0].length < /*totalCount*/
        i[4]
      ),
      $$slots: { default: [kX] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      $$slots: { default: [wX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--direction", "column");
    },
    m(r, o) {
      T(r, t, o), N(e, t, null), T(r, s, o), N(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*remainingSelections*/
      128 && (a.warning = /*remainingSelections*/
      r[7] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
      r[7]} choices remaining.`), o & /*selected, totalCount*/
      17 && (a.showWarning = /*selected*/
      r[0].length < /*totalCount*/
      r[4]), o & /*$$scope, choicesLocked, selected, choices, totalCount*/
      65589 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, summary*/
      65600 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && S(s), r && e && S(t), j(e, r), j(n, r);
    }
  };
}
f($X, "create_default_slot$1M");
function AX(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Proficiency Grant - " + /*grant*/
      i[1].label,
      headerButtons: ["tools", "weapons"].includes(
        /*proficiencyType*/
        i[3]
      ) ? [] : [
        {
          classes: "add-button",
          handler: (
            /*func*/
            i[12]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          i[5] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            i[5] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ],
      $$slots: { default: [$X] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*grant*/
      2 && (r.heading = "Proficiency Grant - " + /*grant*/
      n[1].label), l & /*proficiencyType, choicesLocked*/
      40 && (r.headerButtons = ["tools", "weapons"].includes(
        /*proficiencyType*/
        n[3]
      ) ? [] : [
        {
          classes: "add-button",
          handler: (
            /*func*/
            n[12]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          n[5] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            n[5] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ]), l & /*$$scope, summary, remainingSelections, selected, totalCount, choicesLocked, choices*/
      65781 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(AX, "create_fragment$3E");
function EX(i, e, t) {
  let s, n, l, { grant: r } = e, { base: o } = e, { choices: a } = e, { count: c } = e, { proficiencyType: u } = e, { selected: d } = e;
  function p(v) {
    return "";
  }
  f(p, "getGrantSummary");
  function m({ detail: v }) {
    t(0, d = v), h("updateSelection", { selected: d, summary: l });
  }
  f(m, "onUpdateSelection");
  function g(v) {
    var P, D, I;
    const O = [];
    if (["weapon", "tool"].includes(u))
      return Object.values(((P = _[u]) == null ? void 0 : P.config) ?? {}).forEach((F) => {
        for (const [H, G] of Object.entries(F))
          a.includes(H) && O.push([H, G]);
      }), O;
    if (!v)
      return ((D = _[u]) == null ? void 0 : D.config) ?? [];
    for (const [B, F] of ((I = _[u]) == null ? void 0 : I.config) ?? [])
      a.includes(B) && O.push([B, F]);
    return O;
  }
  f(g, "getOptions");
  const h = it(), _ = lb();
  let y = !0;
  const k = /* @__PURE__ */ f(() => t(5, y = !y), "func");
  return i.$$set = (v) => {
    "grant" in v && t(1, r = v.grant), "base" in v && t(10, o = v.base), "choices" in v && t(2, a = v.choices), "count" in v && t(11, c = v.count), "proficiencyType" in v && t(3, u = v.proficiencyType), "selected" in v && t(0, d = v.selected);
  }, i.$$.update = () => {
    i.$$.dirty & /*base, selected*/
    1025 && t(0, d = [...o, ...d]), i.$$.dirty & /*base, count*/
    3072 && t(4, s = o.length + c), i.$$.dirty & /*totalCount, selected*/
    17 && t(7, n = s - d.length), i.$$.dirty & /*selected*/
    1 && t(6, l = p());
  }, [
    d,
    r,
    a,
    u,
    s,
    y,
    l,
    n,
    m,
    g,
    o,
    c,
    k
  ];
}
f(EX, "instance$3v");
const VE = class VE extends ie {
  constructor(e) {
    super(), le(this, e, EX, AX, ne, {
      grant: 1,
      base: 10,
      choices: 2,
      count: 11,
      proficiencyType: 3,
      selected: 0
    });
  }
};
f(VE, "ProficiencyGrantSelection");
let Vy = VE;
var Uh, Vh, Wh;
const WE = class WE extends rs {
  constructor() {
    super(...arguments);
    Y(this, Uh, Vy);
    Y(this, Vh, Uy);
    Y(this, Wh, "proficiency");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "proficiency" }),
      keys: new t.SchemaField({
        base: new t.ArrayField(
          new t.StringField({ nullable: !1, initial: "" }),
          { required: !0, initial: [] }
        ),
        options: new t.ArrayField(
          new t.StringField({ nullable: !1, initial: "" }),
          { required: !0, initial: [] }
        ),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      proficiencyType: new t.StringField({ required: !1, initial: "armor" }),
      isExpertise: new t.BooleanField({ required: !1, initial: !1 }),
      label: new t.StringField({ required: !0, initial: "New Proficiency Grant" })
    });
  }
  getApplyData(t, s) {
    if (!t)
      return {};
    const n = (s == null ? void 0 : s.selected) ?? this.keys.base ?? [], l = this.keys.total, r = {}, o = {
      proficiencyData: {
        keys: n,
        total: l,
        proficiencyType: this.proficiencyType
      },
      itemUuid: this.parent.uuid,
      grantId: this._id,
      grantType: M(this, Wh),
      level: this.level
    };
    if (r["system.grants"] = {
      ...t.system.grants,
      [this._id]: o
    }, this.proficiencyType === "savingThrow")
      n.forEach((a) => {
        r[`system.abilities.${a}.save.proficient`] = !0;
      });
    else if (this.proficiencyType === "skill")
      n.forEach((a) => {
        r[`system.skills.${a}.proficient`] = this.isExpertise ? 2 : 1;
      });
    else {
      const a = lb(), { propertyKey: c } = a[this.proficiencyType] ?? {};
      if (!c)
        return {};
      if (!n.length)
        return {};
      const u = /* @__PURE__ */ new Set([
        ...n,
        ...foundry.utils.getProperty(t, c) ?? []
      ]);
      r[c] = [...u];
    }
    return r;
  }
  getSelectionComponent() {
    return M(this, Uh);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.keys.base ?? [],
      choices: this.keys.options,
      count: this.keys.total,
      proficiencyType: this.proficiencyType,
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return !!this.keys.options.length;
  }
  async configureGrant() {
    const t = {
      document: this.parent,
      grantId: this._id
    };
    super.configureGrant(
      "Configure Proficiency Grant",
      t,
      M(this, Vh),
      { width: 400 }
    );
  }
};
Uh = new WeakMap(), Vh = new WeakMap(), Wh = new WeakMap(), f(WE, "ProficiencyGrant");
let Wy = WE;
function NI(i) {
  var o, a, c, u, d, p, m, g, h, _;
  let e, t, s, n, l, r;
  return e = new Ze({
    props: {
      heading: "Base Options",
      options: (
        /*configObject*/
        (o = i[6][
          /*rollOverrideType*/
          i[2]
        ]) == null ? void 0 : o.options
      ),
      selected: (
        /*grant*/
        (c = (a = i[0]) == null ? void 0 : a.keys) == null ? void 0 : c.base
      ),
      showToggleAllButton: !0,
      disabledOptions: (
        /*grant*/
        (d = (u = i[0]) == null ? void 0 : u.keys) == null ? void 0 : d.options
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[13]
  ), s = new Ze({
    props: {
      heading: "Optional Choices",
      options: (
        /*configObject*/
        (p = i[6][
          /*rollOverrideType*/
          i[2]
        ]) == null ? void 0 : p.options
      ),
      selected: (
        /*grant*/
        (g = (m = i[0]) == null ? void 0 : m.keys) == null ? void 0 : g.options
      ),
      disabledOptions: (
        /*grant*/
        (_ = (h = i[0]) == null ? void 0 : h.keys) == null ? void 0 : _.base
      ),
      showToggleAllButton: !0
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[14]
  ), l = new de({
    props: {
      heading: "Selectable Options Count",
      $$slots: { default: [SX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment);
    },
    m(y, k) {
      N(e, y, k), T(y, t, k), N(s, y, k), T(y, n, k), N(l, y, k), r = !0;
    },
    p(y, k) {
      var D, I, B, F, H, G, U, q, W, X;
      const v = {};
      k & /*rollOverrideType*/
      4 && (v.options = /*configObject*/
      (D = y[6][
        /*rollOverrideType*/
        y[2]
      ]) == null ? void 0 : D.options), k & /*grant*/
      1 && (v.selected = /*grant*/
      (B = (I = y[0]) == null ? void 0 : I.keys) == null ? void 0 : B.base), k & /*grant*/
      1 && (v.disabledOptions = /*grant*/
      (H = (F = y[0]) == null ? void 0 : F.keys) == null ? void 0 : H.options), e.$set(v);
      const O = {};
      k & /*rollOverrideType*/
      4 && (O.options = /*configObject*/
      (G = y[6][
        /*rollOverrideType*/
        y[2]
      ]) == null ? void 0 : G.options), k & /*grant*/
      1 && (O.selected = /*grant*/
      (q = (U = y[0]) == null ? void 0 : U.keys) == null ? void 0 : q.options), k & /*grant*/
      1 && (O.disabledOptions = /*grant*/
      (X = (W = y[0]) == null ? void 0 : W.keys) == null ? void 0 : X.base), s.$set(O);
      const P = {};
      k & /*$$scope, grant*/
      131073 && (P.$$scope = { dirty: k, ctx: y }), l.$set(P);
    },
    i(y) {
      r || (w(e.$$.fragment, y), w(s.$$.fragment, y), w(l.$$.fragment, y), r = !0);
    },
    o(y) {
      C(e.$$.fragment, y), C(s.$$.fragment, y), C(l.$$.fragment, y), r = !1;
    },
    d(y) {
      y && (S(t), S(n)), j(e, y), j(s, y), j(l, y);
    }
  };
}
f(NI, "create_if_block$1$");
function SX(i) {
  let e, t, s, n;
  return {
    c() {
      var l, r;
      e = E("input"), b(e, "type", "number"), e.value = t = /*grant*/
      ((r = (l = i[0]) == null ? void 0 : l.keys) == null ? void 0 : r.total) ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      var o, a;
      r & /*grant*/
      1 && t !== (t = /*grant*/
      ((a = (o = l[0]) == null ? void 0 : o.keys) == null ? void 0 : a.total) ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(SX, "create_default_slot_1$Z");
function TX(i) {
  var o, a, c;
  let e, t, s, n, l;
  e = new Ye({
    props: {
      heading: "Override Type",
      options: Object.entries(
        /*configObject*/
        i[6]
      ).map(OX),
      selected: (
        /*rollOverrideType*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[12]
  );
  let r = (
    /*configObject*/
    ((a = (o = i[6][
      /*rollOverrideType*/
      i[2]
    ]) == null ? void 0 : o.options) == null ? void 0 : a.length) && NI(i)
  );
  return n = new Ye({
    props: {
      heading: "Roll Mode",
      options: (
        /*rollModes*/
        i[7]
      ),
      selected: (
        /*grant*/
        ((c = i[0]) == null ? void 0 : c.rollMode) ?? 0
      )
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[16]
  ), {
    c() {
      L(e.$$.fragment), t = R(), r && r.c(), s = R(), L(n.$$.fragment);
    },
    m(u, d) {
      N(e, u, d), T(u, t, d), r && r.m(u, d), T(u, s, d), N(n, u, d), l = !0;
    },
    p(u, d) {
      var g, h, _;
      const p = {};
      d & /*rollOverrideType*/
      4 && (p.selected = /*rollOverrideType*/
      u[2]), e.$set(p), /*configObject*/
      (h = (g = u[6][
        /*rollOverrideType*/
        u[2]
      ]) == null ? void 0 : g.options) != null && h.length ? r ? (r.p(u, d), d & /*rollOverrideType*/
      4 && w(r, 1)) : (r = NI(u), r.c(), w(r, 1), r.m(s.parentNode, s)) : r && (ce(), C(r, 1, 1, () => {
        r = null;
      }), ue());
      const m = {};
      d & /*grant*/
      1 && (m.selected = /*grant*/
      ((_ = u[0]) == null ? void 0 : _.rollMode) ?? 0), n.$set(m);
    },
    i(u) {
      l || (w(e.$$.fragment, u), w(r), w(n.$$.fragment, u), l = !0);
    },
    o(u) {
      C(e.$$.fragment, u), C(r), C(n.$$.fragment, u), l = !1;
    },
    d(u) {
      u && (S(t), S(s)), j(e, u), r && r.d(u), j(n, u);
    }
  };
}
f(TX, "create_default_slot$1L");
function CX(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y;
  return d = new Me({
    props: {
      heading: "Roll Override Configuration",
      $$slots: { default: [TX] },
      $$scope: { ctx: i }
    }
  }), g = new In({}), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), p = E("div"), L(d.$$.fragment), m = R(), L(g.$$.fragment), b(s, "class", "grant-image svelte-r6yl7x"), ze(s.src, n = /*grant*/
      i[0].img || /*$item*/
      i[1].img || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*grant*/
      i[0].label ?? "", b(a, "class", "grant-name svelte-r6yl7x"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-r6yl7x"), b(t, "class", "sheet-header svelte-r6yl7x"), z(p, "display", "contents"), z(p, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-r6yl7x");
    },
    m(k, v) {
      T(k, e, v), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, u), A(e, p), N(d, p, null), A(e, m), N(g, e, null), h = !0, _ || (y = [
        V(
          s,
          "click",
          /*updateImage*/
          i[3]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[11]
        )
      ], _ = !0);
    },
    p(k, [v]) {
      (!h || v & /*grant, $item*/
      3 && !ze(s.src, n = /*grant*/
      k[0].img || /*$item*/
      k[1].img || "icons/svg/upgrade.svg")) && b(s, "src", n), (!h || v & /*grant*/
      1 && l !== (l = /*grant*/
      k[0].label)) && b(s, "alt", l), (!h || v & /*grant*/
      1 && c !== (c = /*grant*/
      k[0].label ?? "") && a.value !== c) && (a.value = c);
      const O = {};
      v & /*$$scope, grant, rollOverrideType*/
      131077 && (O.$$scope = { dirty: v, ctx: k }), d.$set(O);
    },
    i(k) {
      h || (w(d.$$.fragment, k), w(g.$$.fragment, k), h = !0);
    },
    o(k) {
      C(d.$$.fragment, k), C(g.$$.fragment, k), h = !1;
    },
    d(k) {
      k && S(e), j(d), j(g), _ = !1, Ne(y);
    }
  };
}
f(CX, "create_fragment$3D");
const OX = /* @__PURE__ */ f(([i, { label: e }]) => [i, e], "func$a");
function DX(i, e, t) {
  let s, n, l, { document: r, grantId: o, grantType: a } = fe("#external").application, { document: c = r, grantId: u = o, grantType: d = a } = e;
  function p() {
    const I = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: I,
      callback: (F) => {
        m("img", F);
      }
    }).browse();
  }
  f(p, "updateImage");
  function m(I, B) {
    I === "expertiseType" && se(l, `system.grants.${u}.keys`, { base: [], options: [], total: 0 }), I = `system.grants.${u}.${I}`, se(l, I, B);
  }
  f(m, "onUpdateValue"), Nt(() => {
    g.destroy();
  });
  const g = new Bt(c);
  pe(i, g, (I) => t(1, l = I));
  const h = {
    abilityCheck: {
      label: "A5E.AbilityCheck",
      options: Object.entries(CONFIG.A5E.abilities)
    },
    abilitySave: {
      label: "A5E.SavingThrow",
      options: Object.entries(CONFIG.A5E.abilities)
    },
    attack: {
      label: "A5E.ActionOptionAttack",
      options: Object.entries(CONFIG.A5E.attackTypes)
    },
    initiative: { label: "A5E.Initiative", options: [] },
    concentration: {
      label: "A5E.ConditionConcentration",
      options: []
    },
    deathSave: { label: "Death Save", options: [] },
    skill: {
      label: "A5E.Skill",
      options: Object.entries(CONFIG.A5E.skills)
    }
  }, _ = Object.entries(CONFIG.A5E.rollModes ?? {}).map(([I, B]) => [CONFIG.A5E.ROLL_MODE[I.toUpperCase()], K(B)]);
  et("item", g), et("grantId", u), et("grantType", d);
  const y = /* @__PURE__ */ f(({ target: I }) => m("label", I.value), "change_handler"), k = /* @__PURE__ */ f(({ detail: I }) => {
    m("rollOverrideType", I);
  }, "updateSelection_handler"), v = /* @__PURE__ */ f(({ detail: I }) => {
    m("keys.base", I);
  }, "updateSelection_handler_1"), O = /* @__PURE__ */ f(({ detail: I }) => {
    m("keys.options", I);
  }, "updateSelection_handler_2"), P = /* @__PURE__ */ f(({ target: I }) => m("keys.total", Number(I.value)), "change_handler_1"), D = /* @__PURE__ */ f(({ detail: I }) => {
    m("rollMode", I);
  }, "updateSelection_handler_3");
  return i.$$set = (I) => {
    "document" in I && t(8, c = I.document), "grantId" in I && t(9, u = I.grantId), "grantType" in I && t(10, d = I.grantType);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item, grantId*/
    514 && t(0, s = l.system.grants[u]), i.$$.dirty & /*grant*/
    1 && t(2, n = (s == null ? void 0 : s.rollOverrideType) || "ability");
  }, [
    s,
    l,
    n,
    p,
    m,
    g,
    h,
    _,
    c,
    u,
    d,
    y,
    k,
    v,
    O,
    P,
    D
  ];
}
f(DX, "instance$3u");
const KE = class KE extends ie {
  constructor(e) {
    super(), le(this, e, DX, CX, ne, { document: 8, grantId: 9, grantType: 10 });
  }
};
f(KE, "RollOverrideGrantConfig");
let Ky = KE;
function IX(i) {
  let e, t;
  return e = new Ze({
    props: {
      options: (
        /*getOptions*/
        i[8](
          /*choicesLocked*/
          i[4]
        )
      ),
      selected: (
        /*selected*/
        i[0]
      ),
      orange: (
        /*choices*/
        i[2]
      ),
      disabled: (
        /*selected*/
        i[0].length >= /*totalCount*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*onUpdateSelection*/
    i[7]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*choicesLocked*/
      16 && (l.options = /*getOptions*/
      s[8](
        /*choicesLocked*/
        s[4]
      )), n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), n & /*choices*/
      4 && (l.orange = /*choices*/
      s[2]), n & /*selected, totalCount*/
      9 && (l.disabled = /*selected*/
      s[0].length >= /*totalCount*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(IX, "create_default_slot_2$E");
function PX(i) {
  let e;
  return {
    c() {
      e = x(
        /*summary*/
        i[5]
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*summary*/
      32 && _e(
        e,
        /*summary*/
        t[5]
      );
    },
    d(t) {
      t && S(e);
    }
  };
}
f(PX, "create_default_slot_1$Y");
function MX(i) {
  let e, t, s, n, l;
  return e = new de({
    props: {
      warning: (
        /*remainingSelections*/
        i[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
        i[6]} choices remaining.`
      ),
      showWarning: (
        /*selected*/
        i[0].length < /*totalCount*/
        i[3]
      ),
      $$slots: { default: [IX] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      $$slots: { default: [PX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--direction", "column");
    },
    m(r, o) {
      T(r, t, o), N(e, t, null), T(r, s, o), N(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*remainingSelections*/
      64 && (a.warning = /*remainingSelections*/
      r[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
      r[6]} choices remaining.`), o & /*selected, totalCount*/
      9 && (a.showWarning = /*selected*/
      r[0].length < /*totalCount*/
      r[3]), o & /*$$scope, choicesLocked, selected, choices, totalCount*/
      65565 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, summary*/
      65568 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && S(s), r && e && S(t), j(e, r), j(n, r);
    }
  };
}
f(MX, "create_default_slot$1K");
function RX(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Roll Override Grant - " + /*grant*/
      i[1].label,
      headerButtons: [
        {
          classes: "add-button",
          handler: (
            /*func*/
            i[12]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          i[4] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            i[4] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ],
      $$slots: { default: [MX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*grant*/
      2 && (r.heading = "Roll Override Grant - " + /*grant*/
      n[1].label), l & /*choicesLocked*/
      16 && (r.headerButtons = [
        {
          classes: "add-button",
          handler: (
            /*func*/
            n[12]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          n[4] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            n[4] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ]), l & /*$$scope, summary, remainingSelections, selected, totalCount, choicesLocked, choices*/
      65661 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(RX, "create_fragment$3C");
function FX(i, e, t) {
  let s, n, l, { grant: r } = e, { base: o } = e, { choices: a } = e, { count: c } = e, { rollOverrideType: u } = e, { selected: d } = e;
  function p(v) {
    return "";
  }
  f(p, "getGrantSummary");
  function m({ detail: v }) {
    t(0, d = v), h("updateSelection", { selected: d, summary: l });
  }
  f(m, "onUpdateSelection");
  function g(v) {
    var P, D;
    if (!v)
      return ((P = _[u]) == null ? void 0 : P.options) ?? [];
    const O = [];
    for (const [I, B] of ((D = _[u]) == null ? void 0 : D.options) ?? [])
      a.includes(I) && O.push([I, B]);
    return O;
  }
  f(g, "getOptions");
  const h = it(), _ = {
    abilityCheck: {
      label: "A5E.AbilityCheck",
      options: Object.entries(CONFIG.A5E.abilities)
    },
    abilitySave: {
      label: "A5E.SavingThrow",
      options: Object.entries(CONFIG.A5E.abilities)
    },
    attack: {
      label: "A5E.ActionOptionAttack",
      options: Object.entries(CONFIG.A5E.attackTypes)
    },
    initiative: { label: "A5E.Initiative", options: [] },
    concentration: {
      label: "A5E.ConditionConcentration",
      options: []
    },
    deathSave: { label: "Death Save", options: [] },
    skill: {
      label: "A5E.Skill",
      options: Object.entries(CONFIG.A5E.skills)
    }
  };
  let y = !0;
  const k = /* @__PURE__ */ f(() => t(4, y = !y), "func");
  return i.$$set = (v) => {
    "grant" in v && t(1, r = v.grant), "base" in v && t(9, o = v.base), "choices" in v && t(2, a = v.choices), "count" in v && t(10, c = v.count), "rollOverrideType" in v && t(11, u = v.rollOverrideType), "selected" in v && t(0, d = v.selected);
  }, i.$$.update = () => {
    i.$$.dirty & /*base, selected*/
    513 && t(0, d = [...o, ...d]), i.$$.dirty & /*base, count*/
    1536 && t(3, s = o.length + c), i.$$.dirty & /*totalCount, selected*/
    9 && t(6, n = s - d.length), i.$$.dirty & /*selected*/
    1 && t(5, l = p());
  }, [
    d,
    r,
    a,
    s,
    y,
    l,
    n,
    m,
    g,
    o,
    c,
    u,
    k
  ];
}
f(FX, "instance$3t");
const YE = class YE extends ie {
  constructor(e) {
    super(), le(this, e, FX, RX, ne, {
      grant: 1,
      base: 9,
      choices: 2,
      count: 10,
      rollOverrideType: 11,
      selected: 0
    });
  }
};
f(YE, "RollOverrideGrantSelectionDialog");
let Yy = YE;
var Kh, Yh, ju;
const XE = class XE extends rs {
  constructor() {
    super(...arguments);
    Y(this, Kh, Yy);
    Y(this, Yh, Ky);
    Y(this, ju, "rollOverride");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "rollOverride" }),
      keys: new t.SchemaField({
        base: new t.ArrayField(
          new t.StringField({ nullable: !1, initial: "" }),
          { required: !0, initial: [] }
        ),
        options: new t.ArrayField(
          new t.StringField({ nullable: !1, initial: "" }),
          { required: !0, initial: [] }
        ),
        total: new t.NumberField({ nullable: !1, initial: 0, integer: !0 })
      }),
      rollMode: new t.NumberField({ nullable: !1, initial: 0 }),
      rollOverrideType: new t.StringField({ required: !1, initial: "abilityCheck" }),
      label: new t.StringField({ required: !0, initial: "New Roll Override Grant" })
    });
  }
  getApplyData(t, s) {
    if (!t)
      return {};
    const n = (s == null ? void 0 : s.selected) ?? this.keys.base ?? [], l = this.keys.total, r = {}, o = {
      rollOverrideData: {
        keys: n,
        total: l,
        rollOverrideType: this.rollOverrideType,
        rollMode: this.rollMode
      },
      itemUuid: this.parent.uuid,
      grantId: this._id,
      grantType: M(this, ju),
      level: this.level
    };
    return r["system.grants"] = {
      ...t.system.grants,
      [this._id]: o
    }, r;
  }
  getSelectionComponent() {
    return M(this, Kh);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.keys.base ?? [],
      choices: this.keys.options ?? [],
      count: this.keys.total,
      rollOverrideType: this.rollOverrideType,
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return !!this.keys.options.length;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: M(this, ju)
    };
    super.configureGrant(
      "Configure Roll Override Grant",
      t,
      M(this, Yh),
      { width: 400 }
    );
  }
};
Kh = new WeakMap(), Yh = new WeakMap(), ju = new WeakMap(), f(XE, "RollOverrideGrant");
let Xy = XE;
var Xh, Jh, Zh;
const JE = class JE extends rs {
  constructor() {
    super(...arguments);
    Y(this, Xh, Or);
    Y(this, Jh, Pn);
    Y(this, Zh, "senses");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "senses" }),
      senses: new t.SchemaField({
        base: new t.ArrayField(
          new t.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        options: new t.ArrayField(
          new t.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      unit: new t.StringField({ required: !0, initial: "feet" }),
      context: new t.SchemaField(rB("grant")),
      label: new t.StringField({ required: !0, initial: "New Senses Grant" })
    });
  }
  getApplyData(t, s) {
    var o, a;
    if (!t)
      return {};
    const n = foundry.utils.randomID(), l = {
      context: {
        senses: (s == null ? void 0 : s.selected) ?? this.senses.base ?? [],
        ...this.context
      },
      formula: this.bonus,
      unit: this.unit || "feet",
      label: this.label || ((o = this.parent) == null ? void 0 : o.name) || "Senses Grant",
      img: this.img || ((a = this == null ? void 0 : this.parent) == null ? void 0 : a.img)
    }, r = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      bonusId: n,
      type: M(this, Zh),
      grantType: "bonus",
      level: this.level
    };
    return {
      [`system.bonuses.senses.${n}`]: l,
      "system.grants": {
        ...t.system.grants,
        [this._id]: r
      }
    };
  }
  getSelectionComponent() {
    return M(this, Xh);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.senses.base ?? [],
      bonus: this.bonus,
      choices: this.senses.options ?? [],
      configObject: CONFIG.A5E.senses,
      count: this.senses.total,
      unit: this.unit,
      heading: "Senses Grant Selection",
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return this.senses.options.length;
  }
  async configureGrant() {
    const t = {
      document: this == null ? void 0 : this.parent,
      grantId: this._id,
      grantType: "senses"
    };
    super.configureGrant(
      "Configure Senses Grant",
      t,
      M(this, Jh),
      { width: 400 }
    );
  }
};
Xh = new WeakMap(), Jh = new WeakMap(), Zh = new WeakMap(), f(JE, "SensesGrant");
let Jy = JE;
var Qh, xh, R5;
const ZE = class ZE extends rs {
  constructor() {
    super(...arguments);
    Y(this, Qh, Or);
    Y(this, xh, Pn);
    Y(this, R5, "skill");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "skill" }),
      skills: new t.SchemaField({
        base: new t.ArrayField(
          new t.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        options: new t.ArrayField(
          new t.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      bonus: new t.StringField({ required: !0, initial: "" }),
      context: new t.SchemaField(oB("grant")),
      label: new t.StringField({ required: !0, initial: "New Skill Grant" })
    });
  }
  getApplyData(t, s = {}) {
    var a, c;
    if (!t)
      return {};
    const n = (s == null ? void 0 : s.selected) ?? this.skills.base ?? [], l = foundry.utils.randomID(), r = {
      context: {
        skills: n,
        ...this.context
      },
      formula: this.bonus,
      label: this.label || ((a = this.parent) == null ? void 0 : a.name) || "Skill Grant",
      default: this.context.default ?? !0,
      img: this.img || ((c = this == null ? void 0 : this.parent) == null ? void 0 : c.img)
    };
    delete r.context.default;
    const o = {
      itemUuid: this.parent.uuid,
      grantId: this._id,
      bonusId: l,
      type: "skills",
      grantType: "bonus",
      level: this.level
    };
    return {
      [`system.bonuses.skills.${l}`]: r,
      "system.grants": {
        ...t.system.grants,
        [this._id]: o
      }
    };
  }
  getSelectionComponent() {
    return M(this, Qh);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.skills.base,
      bonus: this.bonus,
      choices: this.skills.options,
      configObject: CONFIG.A5E.skills,
      count: this.skills.total,
      heading: "Skill Grant Selection",
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return this.skills.options.length;
  }
  async configureGrant() {
    const t = {
      document: this.parent,
      grantId: this._id,
      grantType: "skills"
    };
    super.configureGrant("Configure Skill Grant", t, M(this, xh), { width: 400 });
  }
};
Qh = new WeakMap(), xh = new WeakMap(), R5 = new WeakMap(), f(ZE, "SkillGrant");
let Zy = ZE;
function NX(i) {
  let e, t;
  return e = new Ye({
    props: {
      options: Object.entries(
        /*skills*/
        i[7]
      ),
      selected: (
        /*skill*/
        i[0]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[12]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*skill*/
      1 && (l.selected = /*skill*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(NX, "create_default_slot_1$X");
function jX(i) {
  let e, t, s, n;
  return {
    c() {
      var l, r;
      e = E("input"), b(e, "type", "number"), e.value = t = /*grant*/
      ((r = (l = i[1]) == null ? void 0 : l.specialties) == null ? void 0 : r.total) ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      var o, a;
      r & /*grant*/
      2 && t !== (t = /*grant*/
      ((a = (o = l[1]) == null ? void 0 : o.specialties) == null ? void 0 : a.total) ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(jX, "create_default_slot$1J");
function jI(i) {
  var o, a, c, u, d, p, m, g;
  let e, t, s, n, l, r;
  return e = new Ze({
    props: {
      heading: "Base Options",
      options: Object.entries(
        /*specialties*/
        i[3]
      ),
      selected: (
        /*grant*/
        (a = (o = i[1]) == null ? void 0 : o.specialties) == null ? void 0 : a.base
      ),
      disabledOptions: (
        /*grant*/
        (u = (c = i[1]) == null ? void 0 : c.specialties) == null ? void 0 : u.options
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[13]
  ), s = new Ze({
    props: {
      heading: "Optional Choices",
      options: Object.entries(
        /*specialties*/
        i[3]
      ),
      selected: (
        /*grant*/
        (p = (d = i[1]) == null ? void 0 : d.specialties) == null ? void 0 : p.options
      ),
      disabledOptions: (
        /*grant*/
        (g = (m = i[1]) == null ? void 0 : m.specialties) == null ? void 0 : g.base
      ),
      showToggleAllButton: !0
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[14]
  ), l = new de({
    props: {
      heading: "Selectable Options Count",
      $$slots: { default: [jX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment);
    },
    m(h, _) {
      N(e, h, _), T(h, t, _), N(s, h, _), T(h, n, _), N(l, h, _), r = !0;
    },
    p(h, _) {
      var O, P, D, I, B, F, H, G;
      const y = {};
      _ & /*specialties*/
      8 && (y.options = Object.entries(
        /*specialties*/
        h[3]
      )), _ & /*grant*/
      2 && (y.selected = /*grant*/
      (P = (O = h[1]) == null ? void 0 : O.specialties) == null ? void 0 : P.base), _ & /*grant*/
      2 && (y.disabledOptions = /*grant*/
      (I = (D = h[1]) == null ? void 0 : D.specialties) == null ? void 0 : I.options), e.$set(y);
      const k = {};
      _ & /*specialties*/
      8 && (k.options = Object.entries(
        /*specialties*/
        h[3]
      )), _ & /*grant*/
      2 && (k.selected = /*grant*/
      (F = (B = h[1]) == null ? void 0 : B.specialties) == null ? void 0 : F.options), _ & /*grant*/
      2 && (k.disabledOptions = /*grant*/
      (G = (H = h[1]) == null ? void 0 : H.specialties) == null ? void 0 : G.base), s.$set(k);
      const v = {};
      _ & /*$$scope, grant*/
      131074 && (v.$$scope = { dirty: _, ctx: h }), l.$set(v);
    },
    i(h) {
      r || (w(e.$$.fragment, h), w(s.$$.fragment, h), w(l.$$.fragment, h), r = !0);
    },
    o(h) {
      C(e.$$.fragment, h), C(s.$$.fragment, h), C(l.$$.fragment, h), r = !1;
    },
    d(h) {
      h && (S(t), S(n)), j(e, h), j(s, h), j(l, h);
    }
  };
}
f(jI, "create_key_block$1");
function LX(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g = (
    /*skill*/
    i[0]
  ), h, _, y, k, v;
  d = new Me({
    props: {
      heading: "Skill Specialty Selection",
      $$slots: { default: [NX] },
      $$scope: { ctx: i }
    }
  });
  let O = jI(i);
  return _ = new In({}), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), p = E("div"), L(d.$$.fragment), m = R(), O.c(), h = R(), L(_.$$.fragment), b(s, "class", "grant-image svelte-vpjv8o"), ze(s.src, n = /*grant*/
      i[1].img || /*$item*/
      i[2].img || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[1].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*grant*/
      i[1].label ?? "", b(a, "class", "grant-name svelte-vpjv8o"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-vpjv8o"), b(t, "class", "sheet-header svelte-vpjv8o"), z(p, "display", "contents"), z(p, "--a5e-section-margin", "0.25rem 0"), z(p, "--a5e-section-body-direction", "row"), b(e, "class", "svelte-vpjv8o");
    },
    m(P, D) {
      T(P, e, D), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, u), A(e, p), N(d, p, null), A(e, m), O.m(e, null), A(e, h), N(_, e, null), y = !0, k || (v = [
        V(
          s,
          "click",
          /*updateImage*/
          i[4]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[11]
        )
      ], k = !0);
    },
    p(P, [D]) {
      (!y || D & /*grant, $item*/
      6 && !ze(s.src, n = /*grant*/
      P[1].img || /*$item*/
      P[2].img || "icons/svg/upgrade.svg")) && b(s, "src", n), (!y || D & /*grant*/
      2 && l !== (l = /*grant*/
      P[1].label)) && b(s, "alt", l), (!y || D & /*grant*/
      2 && c !== (c = /*grant*/
      P[1].label ?? "") && a.value !== c) && (a.value = c);
      const I = {};
      D & /*$$scope, skill*/
      131073 && (I.$$scope = { dirty: D, ctx: P }), d.$set(I), D & /*skill*/
      1 && ne(g, g = /*skill*/
      P[0]) ? (ce(), C(O, 1, 1, ee), ue(), O = jI(P), O.c(), w(O, 1), O.m(e, h)) : O.p(P, D);
    },
    i(P) {
      y || (w(d.$$.fragment, P), w(O), w(_.$$.fragment, P), y = !0);
    },
    o(P) {
      C(d.$$.fragment, P), C(O), C(_.$$.fragment, P), y = !1;
    },
    d(P) {
      P && S(e), j(d), O.d(P), j(_), k = !1, Ne(v);
    }
  };
}
f(LX, "create_fragment$3B");
function BX(i, e, t) {
  let s, n, l, r, { document: o, grantId: a, grantType: c } = fe("#external").application, { document: u = o, grantId: d = a, grantType: p = c } = e;
  function m() {
    const I = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: I,
      callback: (F) => {
        g("img", F);
      }
    }).browse();
  }
  f(m, "updateImage");
  function g(I, B) {
    I === "skill" && se(r, `system.grants.${d}.specialties`, { base: [], options: [], total: 0 }), I = `system.grants.${d}.${I}`, se(r, I, B);
  }
  f(g, "onUpdateValue"), Nt(() => {
    h.destroy();
  });
  const h = new Bt(u);
  pe(i, h, (I) => t(2, r = I));
  const { skills: _, skillSpecialties: y } = CONFIG.A5E;
  et("item", h), et("grantId", d), et("grantType", p);
  const k = /* @__PURE__ */ f(({ target: I }) => g("label", I.value), "change_handler"), v = /* @__PURE__ */ f(({ detail: I }) => {
    g("skill", I);
  }, "updateSelection_handler"), O = /* @__PURE__ */ f(({ detail: I }) => {
    g("specialties.base", I);
  }, "updateSelection_handler_1"), P = /* @__PURE__ */ f(({ detail: I }) => {
    g("specialties.options", I);
  }, "updateSelection_handler_2"), D = /* @__PURE__ */ f(({ target: I }) => g("specialties.total", Number(I.value)), "change_handler_1");
  return i.$$set = (I) => {
    "document" in I && t(8, u = I.document), "grantId" in I && t(9, d = I.grantId), "grantType" in I && t(10, p = I.grantType);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item, grantId*/
    516 && t(1, s = r.system.grants[d]), i.$$.dirty & /*grant*/
    2 && t(0, n = (s == null ? void 0 : s.skill) || "acr"), i.$$.dirty & /*skill*/
    1 && t(3, l = y[n]);
  }, [
    n,
    s,
    r,
    l,
    m,
    g,
    h,
    _,
    u,
    d,
    p,
    k,
    v,
    O,
    P,
    D
  ];
}
f(BX, "instance$3s");
const QE = class QE extends ie {
  constructor(e) {
    super(), le(this, e, BX, LX, ne, { document: 8, grantId: 9, grantType: 10 });
  }
};
f(QE, "SkillSpecialtyConfig");
let Qy = QE;
function qX(i) {
  let e, t;
  return e = new Ze({
    props: {
      options: Object.entries(
        /*skillSpecialties*/
        i[8][
          /*skill*/
          i[3]
        ]
      ),
      selected: (
        /*selected*/
        i[0]
      ),
      orange: (
        /*choices*/
        i[2]
      ),
      disabled: (
        /*selected*/
        i[0].length >= /*totalCount*/
        i[4]
      )
    }
  }), e.$on(
    "updateSelection",
    /*onUpdateSelection*/
    i[7]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*skill*/
      8 && (l.options = Object.entries(
        /*skillSpecialties*/
        s[8][
          /*skill*/
          s[3]
        ]
      )), n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), n & /*choices*/
      4 && (l.orange = /*choices*/
      s[2]), n & /*selected, totalCount*/
      17 && (l.disabled = /*selected*/
      s[0].length >= /*totalCount*/
      s[4]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(qX, "create_default_slot_1$W");
function GX(i) {
  let e, t;
  return e = new de({
    props: {
      warning: (
        /*remainingSelections*/
        i[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
        i[6]} choices remaining.`
      ),
      showWarning: (
        /*selected*/
        i[0].length < /*totalCount*/
        i[4]
      ),
      $$slots: { default: [qX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*remainingSelections*/
      64 && (l.warning = /*remainingSelections*/
      s[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
      s[6]} choices remaining.`), n & /*selected, totalCount*/
      17 && (l.showWarning = /*selected*/
      s[0].length < /*totalCount*/
      s[4]), n & /*$$scope, skill, selected, choices, totalCount*/
      32797 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(GX, "create_default_slot$1I");
function zX(i) {
  let e, t;
  return e = new Me({
    props: {
      heading: "Skill Specialty Grant - " + /*grant*/
      i[1].label,
      headerButtons: [
        {
          classes: "add-button",
          handler: (
            /*func*/
            i[11]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          i[5] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            i[5] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ],
      $$slots: { default: [GX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*grant*/
      2 && (l.heading = "Skill Specialty Grant - " + /*grant*/
      s[1].label), n & /*choicesLocked*/
      32 && (l.headerButtons = [
        {
          classes: "add-button",
          handler: (
            /*func*/
            s[11]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          s[5] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            s[5] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ]), n & /*$$scope, remainingSelections, selected, totalCount, skill, choices*/
      32861 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(zX, "create_fragment$3A");
function HX(i, e, t) {
  let s, n, l, { grant: r } = e, { base: o } = e, { choices: a } = e, { count: c } = e, { skill: u } = e, { selected: d } = e;
  function p(k) {
    return "";
  }
  f(p, "getGrantSummary");
  function m({ detail: k }) {
    t(0, d = k), g("updateSelection", { selected: d, summary: l });
  }
  f(m, "onUpdateSelection");
  const g = it(), { skillSpecialties: h } = CONFIG.A5E;
  let _ = !0;
  const y = /* @__PURE__ */ f(() => t(5, _ = !_), "func");
  return i.$$set = (k) => {
    "grant" in k && t(1, r = k.grant), "base" in k && t(9, o = k.base), "choices" in k && t(2, a = k.choices), "count" in k && t(10, c = k.count), "skill" in k && t(3, u = k.skill), "selected" in k && t(0, d = k.selected);
  }, i.$$.update = () => {
    i.$$.dirty & /*base, selected*/
    513 && t(0, d = [...o, ...d]), i.$$.dirty & /*count, base*/
    1536 && t(4, s = c + o.length), i.$$.dirty & /*totalCount, selected*/
    17 && t(6, n = s - d.length), i.$$.dirty & /*selected*/
    1 && (l = p());
  }, [
    d,
    r,
    a,
    u,
    s,
    _,
    n,
    m,
    h,
    o,
    c,
    y
  ];
}
f(HX, "instance$3r");
const xE = class xE extends ie {
  constructor(e) {
    super(), le(this, e, HX, zX, ne, {
      grant: 1,
      base: 9,
      choices: 2,
      count: 10,
      skill: 3,
      selected: 0
    });
  }
};
f(xE, "SkillSpecialtyGrantSelectionDialog");
let xy = xE;
var eg, tg, Lu;
const e2 = class e2 extends rs {
  constructor() {
    super(...arguments);
    Y(this, eg, xy);
    Y(this, tg, Qy);
    Y(this, Lu, "skillSpecialty");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "skillSpecialty" }),
      skill: new t.StringField({ required: !0, initial: "acr" }),
      specialties: new t.SchemaField({
        base: new t.ArrayField(
          new t.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        options: new t.ArrayField(
          new t.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      label: new t.StringField({ required: !0, initial: "New Skill Specialty Grant" })
    });
  }
  getApplyData(t, s) {
    if (!t)
      return {};
    const n = (s == null ? void 0 : s.selected) ?? this.specialties.base ?? [], l = (s == null ? void 0 : s.skill) ?? this.skill ?? "acr", r = this.specialties.total;
    if (!l)
      return {};
    const o = {
      specialtyData: {
        specialties: n,
        skill: l,
        total: r
      },
      itemUuid: this.parent.uuid,
      grantId: this._id,
      grantType: M(this, Lu),
      level: this.level
    }, a = `system.skills.${l}.specialties`, c = foundry.utils.getProperty(t, a) ?? [], u = /* @__PURE__ */ new Set([
      ...n,
      ...c
    ]);
    return {
      [a]: [...u],
      "system.grants": {
        ...t.system.grants,
        [this._id]: o
      }
    };
  }
  getSelectionComponent() {
    return M(this, eg);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.specialties.base ?? [],
      choices: this.specialties.options,
      count: this.specialties.total,
      skill: this.skill,
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return this.specialties.options.length;
  }
  async configureGrant() {
    const t = {
      document: this.parent,
      grantId: this._id,
      grantType: M(this, Lu)
    };
    super.configureGrant(
      "Configure Skill Specialty Grant",
      t,
      M(this, tg),
      { width: 400 }
    );
  }
};
eg = new WeakMap(), tg = new WeakMap(), Lu = new WeakMap(), f(e2, "SkillSpecialtyGrant");
let e0 = e2;
function LI(i, e, t) {
  const s = i.slice();
  return s[15] = e[t][0], s[16] = e[t][1].label, s;
}
f(LI, "get_each_context$1r");
function BI(i) {
  let e, t = K(
    /*label*/
    i[16]
  ) + "", s, n, l;
  return {
    c() {
      e = E("option"), s = x(t), n = R(), e.__value = /*key*/
      i[15], qe(e, e.__value), e.selected = l = /*traitType*/
      i[2] === /*key*/
      i[15];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      o & /*traitType*/
      4 && l !== (l = /*traitType*/
      r[2] === /*key*/
      r[15]) && (e.selected = l);
    },
    d(r) {
      r && S(e);
    }
  };
}
f(BI, "create_each_block$1r");
function UX(i) {
  let e, t, s, n = oe(Object.entries(
    /*configObject*/
    i[6]
  )), l = [];
  for (let r = 0; r < n.length; r += 1)
    l[r] = BI(LI(i, n, r));
  return {
    c() {
      e = E("select");
      for (let r = 0; r < l.length; r += 1)
        l[r].c();
      b(e, "class", "u-w-fit damage-type-select");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < l.length; a += 1)
        l[a] && l[a].m(e, null);
      t || (s = V(
        e,
        "change",
        /*change_handler_1*/
        i[11]
      ), t = !0);
    },
    p(r, o) {
      if (o & /*Object, configObject, traitType*/
      68) {
        n = oe(Object.entries(
          /*configObject*/
          r[6]
        ));
        let a;
        for (a = 0; a < n.length; a += 1) {
          const c = LI(r, n, a);
          l[a] ? l[a].p(c, o) : (l[a] = BI(c), l[a].c(), l[a].m(e, null));
        }
        for (; a < l.length; a += 1)
          l[a].d(1);
        l.length = n.length;
      }
    },
    d(r) {
      r && S(e), Le(l, r), t = !1, s();
    }
  };
}
f(UX, "create_default_slot_3$u");
function VX(i) {
  let e, t;
  return e = new de({
    props: {
      $$slots: { default: [UX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, traitType*/
      524292 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(VX, "create_default_slot_2$D");
function WX(i) {
  let e, t, s, n;
  return {
    c() {
      var l, r;
      e = E("input"), b(e, "type", "number"), e.value = t = /*grant*/
      ((r = (l = i[0]) == null ? void 0 : l.traits) == null ? void 0 : r.total) ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_2*/
        i[14]
      ), s = !0);
    },
    p(l, r) {
      var o, a;
      r & /*grant*/
      1 && t !== (t = /*grant*/
      ((a = (o = l[0]) == null ? void 0 : o.traits) == null ? void 0 : a.total) ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(WX, "create_default_slot_1$V");
function KX(i) {
  var o, a, c, u, d, p, m, g, h, _;
  let e, t, s, n, l, r;
  return e = new Ze({
    props: {
      heading: "Base Options",
      options: (
        /*configObject*/
        (o = i[6][
          /*traitType*/
          i[2]
        ]) == null ? void 0 : o.config
      ),
      selected: (
        /*grant*/
        (c = (a = i[0]) == null ? void 0 : a.traits) == null ? void 0 : c.base
      ),
      disabledOptions: (
        /*grant*/
        (d = (u = i[0]) == null ? void 0 : u.traits) == null ? void 0 : d.options
      ),
      showToggleAllButton: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[12]
  ), s = new Ze({
    props: {
      heading: "Optional Choices",
      options: (
        /*configObject*/
        (p = i[6][
          /*traitType*/
          i[2]
        ]) == null ? void 0 : p.config
      ),
      selected: (
        /*grant*/
        (g = (m = i[0]) == null ? void 0 : m.traits) == null ? void 0 : g.options
      ),
      disabledOptions: (
        /*grant*/
        (_ = (h = i[0]) == null ? void 0 : h.traits) == null ? void 0 : _.base
      ),
      showToggleAllButton: !0
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[13]
  ), l = new de({
    props: {
      heading: "Selectable Options Count",
      $$slots: { default: [WX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment);
    },
    m(y, k) {
      N(e, y, k), T(y, t, k), N(s, y, k), T(y, n, k), N(l, y, k), r = !0;
    },
    p(y, k) {
      var D, I, B, F, H, G, U, q, W, X;
      const v = {};
      k & /*traitType*/
      4 && (v.options = /*configObject*/
      (D = y[6][
        /*traitType*/
        y[2]
      ]) == null ? void 0 : D.config), k & /*grant*/
      1 && (v.selected = /*grant*/
      (B = (I = y[0]) == null ? void 0 : I.traits) == null ? void 0 : B.base), k & /*grant*/
      1 && (v.disabledOptions = /*grant*/
      (H = (F = y[0]) == null ? void 0 : F.traits) == null ? void 0 : H.options), e.$set(v);
      const O = {};
      k & /*traitType*/
      4 && (O.options = /*configObject*/
      (G = y[6][
        /*traitType*/
        y[2]
      ]) == null ? void 0 : G.config), k & /*grant*/
      1 && (O.selected = /*grant*/
      (q = (U = y[0]) == null ? void 0 : U.traits) == null ? void 0 : q.options), k & /*grant*/
      1 && (O.disabledOptions = /*grant*/
      (X = (W = y[0]) == null ? void 0 : W.traits) == null ? void 0 : X.base), s.$set(O);
      const P = {};
      k & /*$$scope, grant*/
      524289 && (P.$$scope = { dirty: k, ctx: y }), l.$set(P);
    },
    i(y) {
      r || (w(e.$$.fragment, y), w(s.$$.fragment, y), w(l.$$.fragment, y), r = !0);
    },
    o(y) {
      C(e.$$.fragment, y), C(s.$$.fragment, y), C(l.$$.fragment, y), r = !1;
    },
    d(y) {
      y && (S(t), S(n)), j(e, y), j(s, y), j(l, y);
    }
  };
}
f(KX, "create_default_slot$1H");
function YX(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y;
  return d = new Me({
    props: {
      heading: "Trait Type",
      $$slots: { default: [VX] },
      $$scope: { ctx: i }
    }
  }), g = new In({
    props: {
      $$slots: { default: [KX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), t = E("header"), s = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), p = E("div"), L(d.$$.fragment), m = R(), L(g.$$.fragment), b(s, "class", "grant-image svelte-vpjv8o"), ze(s.src, n = /*grant*/
      i[0].img || /*$item*/
      i[1].img || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[0].label), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*grant*/
      i[0].label ?? "", b(a, "class", "grant-name svelte-vpjv8o"), b(a, "placeholder", "Bonus Name"), b(o, "class", "name-wrapper svelte-vpjv8o"), b(t, "class", "sheet-header svelte-vpjv8o"), z(p, "display", "contents"), z(p, "--a5e-section-margin", "0.25rem 0"), z(p, "--a5e-section-body-direction", "row"), b(e, "class", "svelte-vpjv8o");
    },
    m(k, v) {
      T(k, e, v), A(e, t), A(t, s), A(t, r), A(t, o), A(o, a), A(e, u), A(e, p), N(d, p, null), A(e, m), N(g, e, null), h = !0, _ || (y = [
        V(
          s,
          "click",
          /*updateImage*/
          i[3]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[10]
        )
      ], _ = !0);
    },
    p(k, [v]) {
      (!h || v & /*grant, $item*/
      3 && !ze(s.src, n = /*grant*/
      k[0].img || /*$item*/
      k[1].img || "icons/svg/upgrade.svg")) && b(s, "src", n), (!h || v & /*grant*/
      1 && l !== (l = /*grant*/
      k[0].label)) && b(s, "alt", l), (!h || v & /*grant*/
      1 && c !== (c = /*grant*/
      k[0].label ?? "") && a.value !== c) && (a.value = c);
      const O = {};
      v & /*$$scope, traitType*/
      524292 && (O.$$scope = { dirty: v, ctx: k }), d.$set(O);
      const P = {};
      v & /*$$scope, grant, traitType*/
      524293 && (P.$$scope = { dirty: v, ctx: k }), g.$set(P);
    },
    i(k) {
      h || (w(d.$$.fragment, k), w(g.$$.fragment, k), h = !0);
    },
    o(k) {
      C(d.$$.fragment, k), C(g.$$.fragment, k), h = !1;
    },
    d(k) {
      k && S(e), j(d), j(g), _ = !1, Ne(y);
    }
  };
}
f(YX, "create_fragment$3z");
function XX(i, e, t) {
  let s, n, l, { document: r, grantId: o, grantType: a } = fe("#external").application, { document: c = r, grantId: u = o, grantType: d = a } = e;
  function p() {
    const P = s == null ? void 0 : s.img;
    return new FilePicker({
      type: "image",
      current: P,
      callback: (I) => {
        m("img", I);
      }
    }).browse();
  }
  f(p, "updateImage");
  function m(P, D) {
    P === "traits.traitType" && se(l, `system.grants.${u}.traits`, { base: [], options: [], total: 0 }), P = `system.grants.${u}.${P}`, se(l, P, D);
  }
  f(m, "onUpdateValue"), Nt(() => {
    g.destroy();
  });
  const g = new Bt(c);
  pe(i, g, (P) => t(1, l = P));
  const h = rb();
  et("item", g), et("grantId", u), et("grantType", d);
  const _ = /* @__PURE__ */ f(({ target: P }) => m("label", P.value), "change_handler"), y = /* @__PURE__ */ f(({ target: P }) => m("traits.traitType", P.value), "change_handler_1"), k = /* @__PURE__ */ f(({ detail: P }) => {
    m("traits.base", P);
  }, "updateSelection_handler"), v = /* @__PURE__ */ f(({ detail: P }) => {
    m("traits.options", P);
  }, "updateSelection_handler_1"), O = /* @__PURE__ */ f(({ target: P }) => m("traits.total", Number(P.value)), "change_handler_2");
  return i.$$set = (P) => {
    "document" in P && t(7, c = P.document), "grantId" in P && t(8, u = P.grantId), "grantType" in P && t(9, d = P.grantType);
  }, i.$$.update = () => {
    var P;
    i.$$.dirty & /*$item, grantId*/
    258 && t(0, s = l.system.grants[u]), i.$$.dirty & /*grant*/
    1 && t(2, n = ((P = s == null ? void 0 : s.traits) == null ? void 0 : P.traitType) || "armorTypes");
  }, [
    s,
    l,
    n,
    p,
    m,
    g,
    h,
    c,
    u,
    d,
    _,
    y,
    k,
    v,
    O
  ];
}
f(XX, "instance$3q");
const t2 = class t2 extends ie {
  constructor(e) {
    super(), le(this, e, XX, YX, ne, { document: 7, grantId: 8, grantType: 9 });
  }
};
f(t2, "TraitGrantConfig");
let t0 = t2;
function JX(i) {
  let e, t;
  return e = new Ze({
    props: {
      options: (
        /*getOptions*/
        i[8](
          /*choicesLocked*/
          i[4]
        )
      ),
      selected: (
        /*selected*/
        i[0]
      ),
      orange: (
        /*choices*/
        i[2]
      ),
      disabled: (
        /*selected*/
        i[0].length >= /*totalCount*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*onUpdateSelection*/
    i[7]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*choicesLocked*/
      16 && (l.options = /*getOptions*/
      s[8](
        /*choicesLocked*/
        s[4]
      )), n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), n & /*choices*/
      4 && (l.orange = /*choices*/
      s[2]), n & /*selected, totalCount*/
      9 && (l.disabled = /*selected*/
      s[0].length >= /*totalCount*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(JX, "create_default_slot_2$C");
function ZX(i) {
  let e;
  return {
    c() {
      e = x(
        /*summary*/
        i[5]
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*summary*/
      32 && _e(
        e,
        /*summary*/
        t[5]
      );
    },
    d(t) {
      t && S(e);
    }
  };
}
f(ZX, "create_default_slot_1$U");
function QX(i) {
  let e, t, s, n, l;
  return e = new de({
    props: {
      warning: (
        /*remainingSelections*/
        i[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
        i[6]} choices remaining.`
      ),
      showWarning: (
        /*selected*/
        i[0].length < /*totalCount*/
        i[3]
      ),
      $$slots: { default: [JX] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      $$slots: { default: [ZX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--direction", "column");
    },
    m(r, o) {
      T(r, t, o), N(e, t, null), T(r, s, o), N(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*remainingSelections*/
      64 && (a.warning = /*remainingSelections*/
      r[6] === 1 ? "1 choice remaining" : `${/*remainingSelections*/
      r[6]} choices remaining.`), o & /*selected, totalCount*/
      9 && (a.showWarning = /*selected*/
      r[0].length < /*totalCount*/
      r[3]), o & /*$$scope, choicesLocked, selected, choices, totalCount*/
      65565 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, summary*/
      65568 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && S(s), r && e && S(t), j(e, r), j(n, r);
    }
  };
}
f(QX, "create_default_slot$1G");
function xX(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Trait Grant - " + /*grant*/
      i[1].label,
      headerButtons: [
        {
          classes: "add-button",
          handler: (
            /*func*/
            i[12]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          i[4] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            i[4] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ],
      $$slots: { default: [QX] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*grant*/
      2 && (r.heading = "Trait Grant - " + /*grant*/
      n[1].label), l & /*choicesLocked*/
      16 && (r.headerButtons = [
        {
          classes: "add-button",
          handler: (
            /*func*/
            n[12]
          ),
          htmlString: `<i class="fa-solid ${/*choicesLocked*/
          n[4] ? "fa-plus" : "fa-minus"}" />`,
          tooltip: (
            /*choicesLocked*/
            n[4] ? "Locked to Grant Options" : "Free Selection Mode"
          )
        }
      ]), l & /*$$scope, summary, remainingSelections, selected, totalCount, choicesLocked, choices*/
      65661 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(xX, "create_fragment$3y");
function eJ(i, e, t) {
  let s, n, l, { grant: r } = e, { base: o } = e, { choices: a } = e, { count: c } = e, { selected: u } = e, { traitType: d } = e;
  function p(v) {
    return "";
  }
  f(p, "getGrantSummary");
  function m({ detail: v }) {
    t(0, u = v), h("updateSelection", { selected: u, summary: l });
  }
  f(m, "onUpdateSelection");
  function g(v) {
    var P, D;
    const O = [];
    if (!v)
      return ((P = _[d]) == null ? void 0 : P.config) ?? [];
    for (const [I, B] of ((D = _[d]) == null ? void 0 : D.config) ?? [])
      a.includes(I) && O.push([I, B]);
    return O;
  }
  f(g, "getOptions");
  const h = it(), _ = rb();
  let y = !0;
  const k = /* @__PURE__ */ f(() => t(4, y = !y), "func");
  return i.$$set = (v) => {
    "grant" in v && t(1, r = v.grant), "base" in v && t(9, o = v.base), "choices" in v && t(2, a = v.choices), "count" in v && t(10, c = v.count), "selected" in v && t(0, u = v.selected), "traitType" in v && t(11, d = v.traitType);
  }, i.$$.update = () => {
    i.$$.dirty & /*base, selected*/
    513 && t(0, u = [...o, ...u]), i.$$.dirty & /*base, count*/
    1536 && t(3, s = o.length + c), i.$$.dirty & /*totalCount, selected*/
    9 && t(6, n = s - u.length), i.$$.dirty & /*selected*/
    1 && t(5, l = p());
  }, [
    u,
    r,
    a,
    s,
    y,
    l,
    n,
    m,
    g,
    o,
    c,
    d,
    k
  ];
}
f(eJ, "instance$3p");
const s2 = class s2 extends ie {
  constructor(e) {
    super(), le(this, e, eJ, xX, ne, {
      grant: 1,
      base: 9,
      choices: 2,
      count: 10,
      selected: 0,
      traitType: 11
    });
  }
};
f(s2, "TraitGrantSelectionDialog");
let s0 = s2;
var sg, ng, ig;
const n2 = class n2 extends rs {
  constructor() {
    super(...arguments);
    Y(this, sg, s0);
    Y(this, ng, t0);
    Y(this, ig, "trait");
  }
  static defineSchema() {
    const { fields: t } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      grantType: new t.StringField({ required: !0, initial: "trait" }),
      traits: new t.SchemaField({
        base: new t.ArrayField(
          new t.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        options: new t.ArrayField(
          new t.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        total: new t.NumberField({ required: !0, initial: 0, integer: !0 }),
        traitType: new t.StringField({ required: !0, initial: "conditionImmunities" })
      }),
      label: new t.StringField({ required: !0, initial: "New Trait Grant" })
    });
  }
  getApplyData(t, s) {
    if (!t)
      return {};
    const n = (s == null ? void 0 : s.selected) ?? this.traits.base ?? [], l = this.traits.total, r = {
      traitData: {
        traits: n,
        total: l,
        traitType: this.traits.traitType
      },
      itemUuid: this.parent.uuid,
      grantId: this._id,
      grantType: M(this, ig),
      level: this.level
    }, o = rb(), { propertyKey: a } = o[this.traits.traitType] ?? {};
    if (!a)
      return {};
    if (!n.length)
      return {};
    let c;
    return this.traits.traitType === "size" ? c = /* @__PURE__ */ new Set([n[0]]) : c = /* @__PURE__ */ new Set([
      ...n,
      ...foundry.utils.getProperty(t, a) ?? []
    ]), {
      [a]: [...c],
      "system.grants": {
        ...t.system.grants,
        [this._id]: r
      }
    };
  }
  getSelectionComponent() {
    return M(this, sg);
  }
  getSelectionComponentProps(t) {
    return {
      base: this.traits.base ?? [],
      choices: this.traits.options,
      count: this.traits.total,
      traitType: this.traits.traitType,
      selected: (t == null ? void 0 : t.selected) ?? []
    };
  }
  requiresConfig() {
    return this.traits.options.length;
  }
  async configureGrant() {
    const t = {
      document: this.parent,
      grantId: this._id
    };
    super.configureGrant(
      "Configure Trait Grant",
      t,
      M(this, ng),
      { width: 400 }
    );
  }
};
sg = new WeakMap(), ng = new WeakMap(), ig = new WeakMap(), f(n2, "TraitGrant");
let n0 = n2;
const qI = {
  base: rs,
  ability: Sy,
  attack: Ty,
  damage: Cy,
  exertion: Dy,
  expertiseDice: My,
  feature: Ny,
  healing: jy,
  hitPoint: Ly,
  initiative: By,
  item: zy,
  movement: Hy,
  proficiency: Wy,
  rollOverride: Xy,
  senses: Jy,
  skill: Zy,
  skillSpecialty: e0,
  trait: n0
};
var Us;
const lg = class lg extends Map {
  constructor(t) {
    super();
    Y(this, Us, void 0);
    ye(this, Us, t), Object.entries(M(this, Us).system.grants ?? {}).forEach(([s, n]) => {
      n._id = s;
      let l = qI[n.grantType];
      l || console.warn(`Grant ${s} has no class mapping.`), l ?? (l = qI.base);
      const r = new l(n, { parent: t });
      this.set(s, r);
    });
  }
  get optionalGrants() {
    return [...this.values()].filter((t) => t.optional);
  }
  /**
   * @param {String} type
   * @returns
   */
  byType(t) {
    return [...this.values()].filter((s) => s.grantType === t);
  }
  byLevel(t) {
    return [...this.values()].filter((s) => s.level === t);
  }
  byLevelType(t) {
    return [...this.values()].filter((s) => s.levelType === t);
  }
  byLevelAndType(t, s) {
    return [...this.values()].filter((n) => n.level === t && n.grantType === s);
  }
  /** ************************************************
  *               External methods
  * ************************************************ */
  async add(t = {}) {
    await lg.addGrant(M(this, Us), t);
  }
  // configure(id: string): void {
  //   const grant = this.get(id);
  //   if (!grant) return;
  //   grant.configureDialog();
  // }
  async clear() {
    await M(this, Us).update({
      "system.-=grants": null
    }), await M(this, Us).update({ "system.grants": {} });
  }
  async duplicate(t) {
    const s = foundry.utils.duplicate(M(this, Us).system.grants[t]);
    s.name = `${s.name} (Copy)`, await M(this, Us).update({
      "system.grants": {
        ...M(this, Us).system.grants,
        // @ts-ignore
        [foundry.utils.randomID()]: s
      }
    });
  }
  // @ts-ignore
  async delete(t) {
    super.delete(t), await M(this, Us).update({
      "system.grants": {
        [`-=${t}`]: null
      }
    });
    const s = M(this, Us).parent;
    !s || s.documentName !== "Actor" || s.grants.removeGrant(t);
  }
  /** ************************************************
  *                Static methods
  * ************************************************ */
  static async addGrant(t, s = {}, n = !0, l = !1) {
    const r = foundry.utils.mergeObject({
      grantType: "skill",
      level: 1,
      levelType: ["class", "archetype"].includes(t.type) ? "class" : "character"
    }, s), o = foundry.utils.randomID();
    r._id = o;
    const a = {
      "system.grants": {
        ...t.system.grants,
        // @ts-ignore
        [o]: r
      }
    };
    return n && await t.update(a), l ? [o, a] : a;
  }
};
Us = new WeakMap(), f(lg, "ItemGrantsManager");
let _a = lg;
const i2 = class i2 extends Pc {
  prepareBaseData() {
    super.prepareBaseData(), this.grants = new _a(this);
  }
  _preCreate(e, t, s) {
    if (s._id !== game.userId) {
      super._preCreate(e, t, s);
      return;
    }
    if (this.parent && this.parent.documentName === "Actor") {
      const n = this.parent;
      t.keepId = !0, n.grants.createInitialGrants(this, !0);
    }
    super._preCreate(e, t, s);
  }
  async _onCreate(e, t, s) {
    super._onCreate(e, t, s);
  }
  async _onDelete(e, t, s) {
    var l;
    if (super._onDelete(e, t, s), !this.parent || ((l = this.parent) == null ? void 0 : l.documentName) !== "Actor")
      return;
    await this.parent.grants.removeGrantsByItem(this.uuid);
  }
};
f(i2, "OriginItemA5e");
let Ml = i2;
const l2 = class l2 extends Map {
  constructor(t) {
    super();
    Ge(this, "item");
    this.item = t, (this.item.system.resources ?? []).forEach((n) => {
      const l = n, r = l.name.slugify();
      this.set(r, l);
    });
  }
  validateResource(t) {
    const s = [];
    return Object.values(t.reference ?? {}).forEach((n) => {
      t.type === "number" && typeof n != "number" && s.push(`Resource ${t.name} reference value must be a number`), t.type === "dice" && typeof n != "number" && s.push(`Resource ${t.name} reference value must be a number`), t.type === "string" && typeof n != "string" && s.push(`Resource ${t.name} reference value must be a string`);
    }), s.length > 0 ? (ui.notifications.warn(s.join("<br>")), !1) : !0;
  }
  async add(t) {
    delete t.slug, await this.item.update({
      "system.resources": [
        ...this.item.system.resources,
        t
      ]
    });
  }
  async remove(t) {
    await this.item.update({
      "system.resources": this.item.system.resources.filter((s) => s.name.slugify() !== t)
    });
  }
  async removeAll() {
    await this.item.update({
      "system.resources": []
    });
  }
};
f(l2, "ClassResourceManager");
let i0 = l2;
const r2 = class r2 extends Ml {
  get associatedLevels() {
    const { levels: e } = this.system.hp;
    return Object.entries(e ?? {}).reduce((t, [s, n]) => (n && t.push(s), t), []);
  }
  get averageHP() {
    return Math.floor(this.hitDice.size / 2) + 1;
  }
  get isStartingClass() {
    return this.isEmbedded ? this.parent.system.classes.startingClass === this.slug : !1;
  }
  get classLevels() {
    return this.system.classLevels;
  }
  get subclass() {
    return null;
  }
  get slug() {
    return this.system.slug || this.name.slugify();
  }
  get totalHitDice() {
    return this.classLevels;
  }
  prepareBaseData() {
    super.prepareBaseData(), this.resources = new i0(this), this.maxHP = this.prepareMaxHitPoints(), this.hitDice = {
      current: this.totalHitDice - this.system.hp.hitDiceUsed,
      total: this.totalHitDice,
      size: this.system.hp.hitDiceSize
    }, this.casting = this.prepareCasterData();
  }
  prepareMaxHitPoints() {
    const { levels: e } = this.system.hp;
    return Object.entries(e ?? {}).reduce((t, [s, n]) => s > this.classLevels ? t : t + n, 0);
  }
  prepareCasterData() {
    const { casterType: e } = this.system.spellcasting;
    if (!e || e === "none" || !this.classLevels)
      return null;
    const t = CONFIG.A5E.casterProgression[e] ?? null;
    if (!t)
      return null;
    const {
      type: s,
      config: n,
      resource: l,
      multiplier: r,
      roundUp: o,
      multiclassMode: a
    } = t, c = { casterType: e, resource: l, progressionType: s };
    if (s === "multiplier" && l === "slots") {
      const p = Math.ceil, m = n[p(this.classLevels * (r ?? 1))] ?? [];
      c.slots = Object.fromEntries(m.map((g, h) => {
        const _ = Math.round(1 / r) > this.classLevels;
        return r < 1 && _ && !o ? [h + 1, 0] : [h + 1, g];
      }));
    }
    if (s === "reference") {
      const p = n[this.classLevels];
      c.multiclassMode = a, l === "slots" ? c.slots = { [p.level]: p.slots } : l === "points" ? (c.points = p.points, c.maxLevel = p.level) : l === "inventions" ? (c.inventions = p.count, c.maxLevel = p.level) : l === "artifactCharges" && (c.charges = p.charges, c.maxLevel = p.level);
    }
    const u = this.system.spellcasting.knownCantrips[this.classLevels] ?? 0, d = this.system.spellcasting.knownSpells[this.classLevels] ?? 0;
    return u && (c.knownCantrips = u), d && (c.knownSpells = d), c;
  }
  getRollData() {
    const e = { ...super.getRollData() };
    return e.actorTransfer = {
      level: this.classLevels,
      hitDiceSize: this.system.hp.hitDiceSize,
      hitDiceUsed: this.system.hp.hitDiceUsed
    }, e;
  }
  _preCreate(e, t, s) {
    var n;
    if (foundry.utils.setProperty(e, "system.classLevels", 1), foundry.utils.setProperty(e, "system.hp.hitDiceUsed", 0), !foundry.utils.getProperty(e, "system.hp.levels.1")) {
      const l = foundry.utils.getProperty(e, "system.hp.hitDiceSize") ?? 6;
      foundry.utils.setProperty(e, "system.hp.levels.1", l);
    }
    if (Array.from({ length: 19 }, (l, r) => r + 2).forEach((l) => {
      foundry.utils.setProperty(e, `system.hp.levels.${l}`, 0);
    }), ((n = this.parent) == null ? void 0 : n.documentName) === "Actor") {
      const l = this.parent, { classes: r } = l;
      Object.keys(r).length || l.update({ "system.classes.startingClass": this.slug });
      const o = r[this.slug];
      if (o)
        return o.update({ "system.classLevels": Math.min(o.system.classLevels + 1, 20) }), !1;
    }
    return this.updateSource(e), super._preCreate(e, t, s), !0;
  }
  // eslint-disable-next-line consistent-return
  async _preUpdate(e, t, s) {
    var l, r;
    super._preUpdate(e, t, s);
    const n = Object.keys(foundry.utils.flattenObject(e));
    if (n.includes("system.hp.hitDiceSize") && (this.isStartingClass || !this.parent)) {
      const o = foundry.utils.getProperty(e, "system.hp.hitDiceSize");
      await this.updateSource({ "system.hp.levels.1": o });
    }
    if (n.includes("system.slug") && this.isStartingClass && ((l = this.parent) == null ? void 0 : l.documentName) === "Actor") {
      const o = foundry.utils.getProperty(e, "system.slug");
      this.parent.update({ "system.classes.startingClass": o });
    }
    if (n.includes("system.hp.hitDiceUsed")) {
      const o = foundry.utils.getProperty(e, "system.hp.hitDiceUsed"), a = this.totalHitDice;
      await this.updateSource({ "system.hp.hitDiceUsed": Math.clamped(o, 0, a) });
    }
    if (((r = this.parent) == null ? void 0 : r.documentName) === "Actor" && n.includes("system.classLevels")) {
      const o = this.parent, a = this.system.classLevels, c = foundry.utils.getProperty(e, "system.classLevels");
      if (!await o.grants.createLeveledGrants(a, c, this))
        return !1;
    }
  }
  async _onCreate(e, t, s) {
    super._onCreate(e, t, s);
  }
  async _onUpdate(e, t, s) {
    super._onUpdate(e, t, s);
  }
  async _onDelete(e, t, s) {
    super._onDelete(e, t, s);
  }
};
f(r2, "ClassItemA5e");
let l0 = r2;
function tJ(i, e) {
  let t;
  const s = i.system;
  return e.system.spellBook && (t = i.spellBooks.get(e.system.spellBook)), t ? t.stats.dc ?? 8 : s.attributes.spellDC ?? 8;
}
f(tJ, "getSpellBookDC");
function W5(i, e, t) {
  if (!i)
    return null;
  const s = i.getRollData(e), n = [];
  return (t == null ? void 0 : t.type) === "spellcasting" ? n.push(tJ(i, e)) : (t == null ? void 0 : t.type) === "maneuver" ? n.push(i.system.attributes.maneuverDC) : Object.keys(CONFIG.A5E.abilities).includes(t == null ? void 0 : t.type) && n.push(8, i.system.attributes.prof, i.system.abilities[t == null ? void 0 : t.type].check.mod), t.bonus && n.push(t == null ? void 0 : t.bonus), at(n.join(" + "), s);
}
f(W5, "computeSaveDC");
function GI(i, e) {
  let t;
  const s = i.system;
  return e.system.spellBook && (t = i.spellBooks.get(e.system.spellBook)), !t || t.stats.ability === "default" ? s.attributes.spellcasting ?? "int" : t.stats.ability || "int";
}
f(GI, "getSpellBookAbility");
function aB(i, e, t) {
  var o, a;
  const s = i.system, n = e.system, l = s.abilities.dex.mod, r = s.abilities.str.mod;
  if (Object.values(t).length && (t.attackType ?? (t.attackType = "meleeWeaponAttack")), t.ability === "spellcasting")
    return GI(i, e);
  if ((t == null ? void 0 : t.ability) === "default") {
    if (["meleeSpellAttack", "rangedSpellAttack"].includes(t.attackType))
      return GI(i, e);
    if (t.attackType === "meleeWeaponAttack")
      return (o = n == null ? void 0 : n.weaponProperties) != null && o.includes("finesse") && l > r ? "dex" : "str";
    if (t.attackType === "rangedWeaponAttack")
      return (a = n == null ? void 0 : n.weaponProperties) != null && a.includes("thrown") ? l > r ? "dex" : "str" : "dex";
  }
  return t.ability;
}
f(aB, "getAttackAbility");
function Cb(i) {
  if (!i.length)
    return [];
  const [e, t] = i[0];
  return [e, t];
}
f(Cb, "prepareUsesConsumer");
function sJ(i) {
  if (!i.length)
    return [];
  const [e, t] = i[0];
  return [[e, t]];
}
f(sJ, "prepareSpellConsumer");
const zI = {
  actionUses: Cb,
  hitDice: Cb,
  itemUses: Cb,
  spell: sJ
};
function cB(i) {
  const e = Object.entries(i ?? {}).reduce((t, [s, n]) => {
    var l;
    return t[l = n.type] ?? (t[l] = []), t[n.type].push([s, n]), t;
  }, {});
  return Object.entries(e).reduce((t, [s, n]) => (typeof zI[s] == "function" && (t[s] = zI[s](n) ?? []), t), {});
}
f(cB, "prepareConsumers");
function nJ(i) {
  const e = {};
  return i.length ? i.map(([t, s]) => {
    var n;
    if (s.ability ?? (s.ability = "str"), !s.label) {
      const l = game.i18n.format("A5E.AbilityCheckSpecific", {
        ability: game.i18n.localize(CONFIG.A5E.abilities[s.ability])
      });
      e[n = s.ability] ?? (e[n] = 0), e[s.ability] += 1, s.defaultLabel = `${l} #${e[s.ability]}`;
    }
    return [t, s];
  }) : [];
}
f(nJ, "prepareAbilityCheckPrompts");
function iJ(i, e) {
  let t = 0;
  return i.length ? i.reduce((s, [n, l]) => {
    var r;
    if (l.effectUuid = (r = e.effects.get(l.effectId)) == null ? void 0 : r.uuid, !l.effectUuid)
      return s;
    if (!l.label) {
      const o = game.i18n.format("A5E.Effect");
      t += 1, l.defaultLabel = `${o} #${t}`;
    }
    return s.push([n, l]), s;
  }, []) : [];
}
f(iJ, "prepareActiveEffectPrompts");
function lJ(i) {
  let e = 0;
  return i.length ? i.map(([t, s]) => {
    if (!s.label) {
      const n = game.i18n.localize("A5E.Other");
      e += 1, s.defaultLabel = `${n} #${e}`;
    }
    return [t, s];
  }) : [];
}
f(lJ, "prepareGenericRollPrompts");
function rJ(i) {
  const e = {};
  return i.length ? i.map(([t, s]) => {
    var n;
    if (s.ability ?? (s.ability = "str"), !i.label) {
      const l = game.i18n.format("A5E.SavingThrowSpecific", {
        ability: game.i18n.localize(CONFIG.A5E.abilities[s.ability])
      });
      e[n = s.ability] ?? (e[n] = 0), e[s.ability] += 1, s.defaultLabel = `${l} #${e[s.ability]}`;
    }
    return [t, s];
  }) : [];
}
f(rJ, "prepareSavingThrowPrompts");
function oJ(i) {
  const e = {};
  return i.length ? i.map(([t, s]) => {
    var n;
    if (s.skill ?? (s.skill = "acr"), !s.label) {
      const l = game.i18n.format("A5E.SkillCheck", {
        skill: game.i18n.localize(CONFIG.A5E.skills[s.skill])
      });
      e[n = s.skill] ?? (e[n] = 0), e[s.skill] += 1, s.defaultLabel = `${l} #${e[s.skill]}`;
    }
    return [t, s];
  }) : [];
}
f(oJ, "prepareSkillCheckPrompts");
const HI = {
  abilityCheck: nJ,
  effect: iJ,
  savingThrow: rJ,
  skillCheck: oJ,
  generic: lJ
};
function uB(i, e) {
  const t = Object.entries(i ?? {}).reduce((s, [n, l]) => {
    var r;
    return s[r = l.type] ?? (s[r] = []), s[l.type].push([n, l]), s;
  }, {});
  return Object.entries(t).reduce((s, [n, l]) => (typeof HI[n] == "function" && (s[n] = HI[n](l, e) ?? []), s), {});
}
f(uB, "preparePrompts$1");
function aJ(i) {
  const e = {};
  return i.length ? i.map(([t, s]) => {
    var n;
    if (s.ability ?? (s.ability = "str"), !s.label) {
      const l = game.i18n.format("A5E.AbilityCheckSpecific", {
        ability: game.i18n.localize(CONFIG.A5E.abilities[s.ability])
      });
      e[n = s.ability] ?? (e[n] = 0), e[s.ability] += 1, s.defaultLabel = `${l} #${e[s.ability]}`;
    }
    return [t, s];
  }) : [];
}
f(aJ, "prepareAbilityChecks");
function cJ(i) {
  if (!i.length)
    return [];
  const [e, t] = i[0];
  return [[e, t]];
}
f(cJ, "prepareAttackRolls");
function uJ(i) {
  const e = {};
  return i.length ? i.map(([t, s]) => {
    var n;
    if (!s.label) {
      const l = game.i18n.format("A5E.DamageSpecific", {
        damageType: game.i18n.localize(CONFIG.A5E.damageTypes[s.damageType] ?? "")
      });
      e[n = s.damageType] ?? (e[n] = 0), e[s.damageType] += 1, s.defaultLabel = `${l} #${e[s.damageType]}`;
    }
    return [t, s];
  }) : [];
}
f(uJ, "prepareDamageRolls");
function fJ(i) {
  let e = 0;
  return i.length ? i.map(([t, s]) => {
    if (!s.label) {
      const n = game.i18n.localize("A5E.Other");
      e += 1, s.defaultLabel = `${n} #${e}`;
    }
    return [t, s];
  }) : [];
}
f(fJ, "prepareGenericRolls");
function dJ(i) {
  const e = {};
  return i.length ? i.map(([t, s]) => {
    var n;
    if (!s.label) {
      s.healingType ?? (s.healingType = "healing");
      const l = game.i18n.localize(CONFIG.A5E.healingTypes[s.healingType] ?? "");
      e[n = s.healingType] ?? (e[n] = 0), e[s.healingType] += 1, s.defaultLabel = `${l} #${e[s.healingType]}`;
    }
    return [t, s];
  }) : [];
}
f(dJ, "prepareHealingRolls");
function pJ(i) {
  const e = {};
  return i.length ? i.map(([t, s]) => {
    var n;
    if (s.ability ?? (s.ability = "str"), !s.label) {
      const l = game.i18n.format("A5E.SavingThrowSpecific", {
        ability: game.i18n.localize(CONFIG.A5E.abilities[s.ability])
      });
      e[n = s.ability] ?? (e[n] = 0), e[s.ability] += 1, s.defaultLabel = `${l} #${e[s.ability]}`;
    }
    return [t, s];
  }) : [];
}
f(pJ, "prepareSavingThrows");
function mJ(i) {
  const e = {};
  return i.length ? i.map(([t, s]) => {
    var n;
    if (s.skill ?? (s.skill = "acr"), !s.label) {
      const l = game.i18n.format("A5E.SkillCheck", {
        skill: game.i18n.localize(CONFIG.A5E.skills[s.skill])
      });
      e[n = s.skill] ?? (e[n] = 0), e[s.skill] += 1, s.defaultLabel = `${l} #${e[s.skill]}`;
    }
    return [t, s];
  }) : [];
}
f(mJ, "prepareSkillChecks");
function hJ(i) {
  const e = {}, t = Object.values(CONFIG.A5E.tools).reduce((s, n) => ({ ...s, ...n }), {});
  return i.length ? i.map(([s, n]) => {
    var l;
    if (n.tool ?? (n.tool = "airVehicles"), !n.label) {
      const r = game.i18n.format("A5E.ToolCheckSpecific", {
        tool: game.i18n.localize(t[n.tool])
      });
      e[l = n.tool] ?? (e[l] = 0), e[n.tool] += 1, n.defaultLabel = `${r} #${e[n.tool]}`;
    }
    return [s, n];
  }) : [];
}
f(hJ, "prepareToolChecks");
const UI = {
  abilityCheck: aJ,
  attack: cJ,
  damage: uJ,
  generic: fJ,
  healing: dJ,
  savingThrow: pJ,
  skillCheck: mJ,
  toolCheck: hJ
};
function fB(i) {
  const e = Object.entries(i ?? {}).reduce((t, [s, n]) => {
    var l;
    return t[l = n.type] ?? (t[l] = []), t[n.type].push([s, n]), t;
  }, {});
  return Object.entries(e).reduce((t, [s, n]) => (typeof UI[s] == "function" && (t[s] = UI[s](n) ?? []), t), {});
}
f(fB, "prepareRolls$1");
var Bu, br, qu, rg, dB, og, pB, Gu, o0, ag, mB, cg, hB;
const o2 = class o2 {
  constructor(e, t, s) {
    Y(this, rg);
    Y(this, og);
    Y(this, Gu);
    Y(this, ag);
    Y(this, cg);
    Y(this, Bu, void 0);
    Y(this, br, void 0);
    Y(this, qu, void 0);
    ye(this, Bu, s), ye(this, br, e), ye(this, qu, t), this.availableConsumers = Object.values((s == null ? void 0 : s.consumers) ?? {}), this.warnings = [];
  }
  get VALIDATE_FUNCTION_MAP() {
    return {
      actionUses: Z(this, rg, dB),
      ammunition: Z(this, Gu, o0),
      hitDice: Z(this, og, pB),
      itemUses: Z(this, ag, mB),
      quantity: Z(this, Gu, o0),
      resource: Z(this, cg, hB)
    };
  }
  validateData(e) {
    return this.warnings.length = 0, this.availableConsumers.forEach((t) => {
      const s = this.VALIDATE_FUNCTION_MAP[t.type];
      s == null || s.call(this, e == null ? void 0 : e[t.type], t);
    }), this.warnings;
  }
};
Bu = new WeakMap(), br = new WeakMap(), qu = new WeakMap(), rg = new WeakSet(), dB = /* @__PURE__ */ f(function(e) {
  const { uses: t } = M(this, Bu) ?? {};
  foundry.utils.isEmpty(t) || t.value >= e.quantity || this.warnings.push(K("A5E.validations.warnings.actionUses"));
}, "#validateActionUses"), og = new WeakSet(), pB = /* @__PURE__ */ f(function(e) {
  const t = M(this, br).system.attributes.hitDice, s = e.selected;
  Object.keys(s ?? {}).every((l) => t[l].current >= s[l]) || this.warnings.push(K("A5E.validations.warnings.hitDice"));
}, "#validateHitDice"), Gu = new WeakSet(), o0 = /* @__PURE__ */ f(function(e, t) {
  const s = M(this, br).items.get(t.itemId);
  s && (s.system.quantity ?? 0) >= t.quantity || (t.type === "ammunition" ? this.warnings.push(K("A5E.validations.warnings.ammunition")) : this.warnings.push(K("A5E.validations.warnings.quantity", { name: s == null ? void 0 : s.name })));
}, "#validateItemQuantity"), ag = new WeakSet(), mB = /* @__PURE__ */ f(function(e) {
  const { uses: t } = M(this, qu).system ?? {};
  foundry.utils.isEmpty(t) || t.value >= e.quantity || this.warnings.push(K("A5E.validations.warnings.itemUses"));
}, "#validateItemUses"), cg = new WeakSet(), hB = /* @__PURE__ */ f(function(e, t) {
  var o;
  const s = (o = CONFIG.A5E.resourceConsumerConfig) == null ? void 0 : o[t.resource];
  if (!s)
    return;
  const { path: n, type: l } = s;
  if (l !== "value")
    return;
  const r = foundry.utils.getProperty(M(this, br).system, n);
  typeof r == "number" && (r >= t.quantity || this.warnings.push(K("A5E.validations.warnings.resource", { type: t.resource })));
}, "#validateResource"), f(o2, "ConsumptionValidator");
let r0 = o2;
function Jr(i, e = [], t = []) {
  var o, a, c, u, d, p;
  const s = Object.values(i.consumers ?? {}).filter((m) => e.includes(m.type)).length > 0, n = (a = (o = Object.values(i.rolls ?? {})) == null ? void 0 : o.filter((m) => ["damage", "healing"].includes(m.type))) == null ? void 0 : a.some((m) => {
    var g;
    return t.includes((g = m.scaling) == null ? void 0 : g.mode);
  }), l = t.includes((u = (c = i.target) == null ? void 0 : c.scaling) == null ? void 0 : u.mode), r = t.includes((p = (d = i.area) == null ? void 0 : d.scaling) == null ? void 0 : p.mode);
  return s || n || l || r;
}
f(Jr, "showActivationDialogSection");
function gJ(i) {
  let e, t;
  return e = new Ze({
    props: {
      heading: "Attack Bonuses",
      options: (
        /*attackBonuses*/
        i[9].map(yJ)
      ),
      selected: (
        /*selectedAttackBonuses*/
        i[4]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[18]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*selectedAttackBonuses*/
      16 && (l.selected = /*selectedAttackBonuses*/
      s[4]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(gJ, "create_if_block$1_");
function bJ(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), b(e, "id", t = /*$actor*/
      i[5].id + "-" + /*dialog*/
      i[7].id + "-situational-mod");
    },
    m(l, r) {
      T(l, e, r), qe(
        e,
        /*situationalMods*/
        i[0]
      ), s || (n = V(
        e,
        "input",
        /*input_input_handler*/
        i[19]
      ), s = !0);
    },
    p(l, r) {
      r & /*$actor*/
      32 && t !== (t = /*$actor*/
      l[5].id + "-" + /*dialog*/
      l[7].id + "-situational-mod") && b(e, "id", t), r & /*situationalMods*/
      1 && e.value !== /*situationalMods*/
      l[0] && qe(
        e,
        /*situationalMods*/
        l[0]
      );
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(bJ, "create_default_slot$1F");
function _J(i) {
  let e, t, s, n, l, r = Object.values(
    /*attackBonuses*/
    i[9]
  ).flat().length, o, a, c, u, d, p, m;
  e = new ml({
    props: {
      selected: (
        /*rollMode*/
        i[2]
      ),
      source: (
        /*rollModeString*/
        i[11]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[16]
  ), s = new hn({
    props: {
      source: (
        /*expertiseDieSource*/
        i[10]
      ),
      selected: (
        /*expertiseDie*/
        i[1]
      ),
      type: (
        /*$actor*/
        i[5].type
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[17]
  );
  let g = r && gJ(i);
  return a = new de({
    props: {
      heading: "A5E.SituationalMods",
      $$slots: { default: [bJ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), n = E("div"), L(s.$$.fragment), l = R(), g && g.c(), o = R(), c = E("div"), L(a.$$.fragment), u = R(), d = E("section"), p = x(
        /*rollFormula*/
        i[3]
      ), z(n, "display", "contents"), z(n, "--background", "transparent"), z(n, "--padding", "0"), z(c, "display", "contents"), z(c, "--background", "transparent"), z(c, "--gap", "0.25rem"), z(c, "--padding", "0"), b(d, "class", "roll-formula-preview svelte-1xocfwd");
    },
    m(h, _) {
      N(e, h, _), T(h, t, _), T(h, n, _), N(s, n, null), T(h, l, _), g && g.m(h, _), T(h, o, _), T(h, c, _), N(a, c, null), T(h, u, _), T(h, d, _), A(d, p), m = !0;
    },
    p(h, [_]) {
      const y = {};
      _ & /*rollMode*/
      4 && (y.selected = /*rollMode*/
      h[2]), e.$set(y);
      const k = {};
      _ & /*expertiseDie*/
      2 && (k.selected = /*expertiseDie*/
      h[1]), _ & /*$actor*/
      32 && (k.type = /*$actor*/
      h[5].type), s.$set(k), r && g.p(h, _);
      const v = {};
      _ & /*$$scope, $actor, situationalMods*/
      4194337 && (v.$$scope = { dirty: _, ctx: h }), a.$set(v), (!m || _ & /*rollFormula*/
      8) && _e(
        p,
        /*rollFormula*/
        h[3]
      );
    },
    i(h) {
      m || (w(e.$$.fragment, h), w(s.$$.fragment, h), w(g), w(a.$$.fragment, h), m = !0);
    },
    o(h) {
      C(e.$$.fragment, h), C(s.$$.fragment, h), C(g), C(a.$$.fragment, h), m = !1;
    },
    d(h) {
      h && (S(t), S(l), S(o), S(u), S(d)), j(e, h), h && s && S(n), j(s, h), g && g.d(h), h && a && S(c), j(a, h);
    }
  };
}
f(_J, "create_fragment$3x");
const yJ = /* @__PURE__ */ f(([i, e]) => [i, e.label || e.defaultLabel], "func$9");
function vJ(i, e, t) {
  let s, n, l, r, { attackRollData: o } = e, { options: a } = e, { attackRoll: c } = e;
  const u = fe("actor");
  pe(i, u, (F) => t(5, r = F));
  const d = fe("dialog"), p = fe("item");
  pe(i, p, (F) => t(15, l = F));
  const m = r.BonusesManager.prepareAttackBonuses(l, c == null ? void 0 : c.attackType);
  function g() {
    t(12, o = {
      ...c,
      expertiseDie: y,
      rollMode: v,
      formula: n
    });
  }
  f(g, "updateData");
  const h = aB(r, l, c);
  let _ = "", y = r.RollOverrideManager.getExpertiseDice(`attackTypes.${c == null ? void 0 : c.attackType}`, a.expertiseDice ?? 0), k = r.RollOverrideManager.getExpertiseDiceSource(`attackTypes.${c == null ? void 0 : c.attackType}`, a.expertiseDice ?? 0), v = r.RollOverrideManager.getRollOverride(`attackTypes.${c == null ? void 0 : c.attackType}`, a.rollMode ?? CONFIG.A5E.ROLL_MODE.NORMAL), O = r.RollOverrideManager.getRollOverridesSource(`attackTypes.${c == null ? void 0 : c.attackType}`, v);
  g();
  const P = /* @__PURE__ */ f(({ detail: F }) => t(2, v = F), "updateSelection_handler"), D = /* @__PURE__ */ f(({ detail: F }) => t(1, y = F), "updateSelection_handler_1"), I = /* @__PURE__ */ f(({ detail: F }) => t(4, s = F), "updateSelection_handler_2");
  function B() {
    _ = this.value, t(0, _);
  }
  return f(B, "input_input_handler"), i.$$set = (F) => {
    "attackRollData" in F && t(12, o = F.attackRollData), "options" in F && t(13, a = F.options), "attackRoll" in F && t(14, c = F.attackRoll);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, $item, attackRoll*/
    49184 && t(4, s = r.BonusesManager.getDefaultSelections("attacks", {
      item: l,
      attackType: c == null ? void 0 : c.attackType
    })), i.$$.dirty & /*$actor, attackRoll, expertiseDie, $item, situationalMods, rollMode, selectedAttackBonuses*/
    49207 && t(3, n = si(r, {
      ability: h,
      attackBonus: c == null ? void 0 : c.bonus,
      attackType: c == null ? void 0 : c.attackType,
      expertiseDie: y,
      item: l,
      proficient: (c == null ? void 0 : c.proficient) ?? !0,
      situationalMods: _,
      rollMode: v,
      selectedAttackBonuses: s,
      type: "attack"
    })), i.$$.dirty & /*rollFormula*/
    8 && g();
  }, [
    _,
    y,
    v,
    n,
    s,
    r,
    u,
    d,
    p,
    m,
    k,
    O,
    o,
    a,
    c,
    l,
    P,
    D,
    I,
    B
  ];
}
f(vJ, "instance$3o");
const a2 = class a2 extends ie {
  constructor(e) {
    super(), le(this, e, vJ, _J, ne, {
      attackRollData: 12,
      options: 13,
      attackRoll: 14
    });
  }
};
f(a2, "AttackRollSection");
let a0 = a2;
function VI(i, e, t) {
  const s = i.slice();
  return s[11] = e[t], s[12] = e, s[13] = t, s;
}
f(VI, "get_each_context$1q");
function WI(i) {
  let e, t, s, n, l, r, o, a, c, u, d;
  function p() {
    return (
      /*click_handler*/
      i[6](
        /*die*/
        i[11]
      )
    );
  }
  f(p, "click_handler");
  function m() {
    return (
      /*auxclick_handler*/
      i[7](
        /*die*/
        i[11]
      )
    );
  }
  f(m, "auxclick_handler");
  function g() {
    i[8].call(
      r,
      /*die*/
      i[11]
    );
  }
  return f(g, "input0_input_handler"), {
    c() {
      e = E("div"), t = E("button"), s = E("span"), s.textContent = `${/*die*/
      i[11]}`, n = R(), l = E("div"), r = E("input"), o = x(`

                    /

                    `), a = E("input"), c = R(), b(s, "class", "hit-die__button--label"), b(t, "class", "hit-die__button"), t.disabled = /*hitDice*/
      i[4][
        /*die*/
        i[11]
      ].current === 0, Q(
        t,
        "disabled",
        /*hitDice*/
        i[4][
          /*die*/
          i[11]
        ].current === 0
      ), b(r, "type", "number"), b(r, "min", "0"), b(
        r,
        "max",
        /*hitDice*/
        i[4][
          /*die*/
          i[11]
        ].current
      ), b(r, "class", "svelte-fmfqqm"), b(a, "type", "number"), a.value = /*hitDice*/
      i[4][
        /*die*/
        i[11]
      ].current, a.disabled = !0, b(a, "class", "svelte-fmfqqm"), b(l, "class", "quantity__wrapper svelte-fmfqqm"), b(e, "class", "hit-die__wrapper svelte-fmfqqm");
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(t, s), A(e, n), A(e, l), A(l, r), qe(
        r,
        /*hitDiceData*/
        i[0].selected[
          /*die*/
          i[11]
        ]
      ), A(l, o), A(l, a), A(e, c), u || (d = [
        V(t, "click", tt(p)),
        V(t, "auxclick", tt(m)),
        V(r, "input", g)
      ], u = !0);
    },
    p(h, _) {
      i = h, _ & /*hitDiceData, availableHitDice*/
      9 && ii(r.value) !== /*hitDiceData*/
      i[0].selected[
        /*die*/
        i[11]
      ] && qe(
        r,
        /*hitDiceData*/
        i[0].selected[
          /*die*/
          i[11]
        ]
      );
    },
    d(h) {
      h && S(e), u = !1, Ne(d);
    }
  };
}
f(WI, "create_each_block$1q");
function kJ(i) {
  let e, t = oe(
    /*availableHitDice*/
    i[3]
  ), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = WI(VI(i, t, n));
  return {
    c() {
      e = E("div");
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      b(e, "class", "u-flex u-gap-lg u-flex-wrap");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l & /*hitDice, availableHitDice, hitDiceData, updateSelected*/
      29) {
        t = oe(
          /*availableHitDice*/
          n[3]
        );
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = VI(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = WI(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && S(e), Le(s, n);
    }
  };
}
f(kJ, "create_default_slot$1E");
function wJ(i) {
  let e, t;
  return e = new de({
    props: {
      heading: "A5E.HitDiceLabel",
      $$slots: { default: [kJ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*$$scope, hitDiceData*/
      16385 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(wJ, "create_fragment$3w");
function $J(i) {
  if (foundry.utils.isEmpty(i.hitDice))
    return null;
  const [e, t] = Object.values(i.hitDice);
  return t;
}
f($J, "getConsumer");
function AJ(i, e, t) {
  let s, { consumers: n } = e, { hitDiceData: l } = e;
  const r = fe("actor");
  pe(i, r, (g) => t(9, s = g));
  function o(g, h = !1) {
    const _ = l.selected[g], y = h ? _ - 1 : _ + 1;
    t(0, l.selected[g] = Math.max(y, 0), l);
  }
  f(o, "updateSelected");
  const a = ob(s).reduce(
    (g, { die: h, total: _ }) => (_ > 0 && g.push(h), g),
    []
  ), c = $J(n);
  l.selected = Object.fromEntries(a.map((g, h) => [g, h === 0 ? 1 : 0])), l.default = c.default;
  let u = s.system.attributes.hitDice;
  const d = /* @__PURE__ */ f((g) => o(g), "click_handler"), p = /* @__PURE__ */ f((g) => o(g, !0), "auxclick_handler");
  function m(g) {
    l.selected[g] = ii(this.value), t(0, l);
  }
  return f(m, "input0_input_handler"), i.$$set = (g) => {
    "consumers" in g && t(5, n = g.consumers), "hitDiceData" in g && t(0, l = g.hitDiceData);
  }, [
    l,
    r,
    o,
    a,
    u,
    n,
    d,
    p,
    m
  ];
}
f(AJ, "instance$3n");
const c2 = class c2 extends ie {
  constructor(e) {
    super(), le(this, e, AJ, wJ, ne, { consumers: 5, hitDiceData: 0 });
  }
};
f(c2, "HitDiceSection");
let c0 = c2;
function KI(i, e, t) {
  const s = i.slice();
  return s[5] = e[t][0], s[6] = e[t][1], s;
}
f(KI, "get_each_context$1p");
function YI(i) {
  let e, t;
  return e = new Ze({
    props: {
      heading: (
        /*promptHeadingMap*/
        i[2][
          /*promptType*/
          i[5]
        ]
      ),
      options: (
        /*_prompts*/
        i[6].map(JI)
      ),
      disabledOptions: (
        /*disabledPrompts*/
        i[3]
      ),
      selected: (
        /*selectedPrompts*/
        i[0]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[4]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*prompts*/
      2 && (l.heading = /*promptHeadingMap*/
      s[2][
        /*promptType*/
        s[5]
      ]), n & /*prompts*/
      2 && (l.options = /*_prompts*/
      s[6].map(JI)), n & /*selectedPrompts*/
      1 && (l.selected = /*selectedPrompts*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(YI, "create_if_block$1Z");
function XI(i) {
  let e, t, s = (
    /*_prompts*/
    i[6].length && YI(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*_prompts*/
      n[6].length ? s ? (s.p(n, l), l & /*prompts*/
      2 && w(s, 1)) : (s = YI(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ce(), C(s, 1, 1, () => {
        s = null;
      }), ue());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f(XI, "create_each_block$1p");
function EJ(i) {
  let e, t, s = oe(Object.entries(
    /*prompts*/
    i[1]
  )), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = XI(KI(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("div");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "prompt-wrapper svelte-3ht7ty");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, o) {
      if (o & /*promptHeadingMap, Object, prompts, disabledPrompts, selectedPrompts*/
      15) {
        s = oe(Object.entries(
          /*prompts*/
          r[1]
        ));
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = KI(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = XI(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f(EJ, "create_default_slot$1D");
function SJ(i) {
  let e, t, s;
  return e = new bt({
    props: {
      hint: "A5E.PromptsHint",
      $$slots: { default: [EJ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--background", "transparent"), z(t, "--padding", "0");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, prompts, selectedPrompts*/
      515 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(SJ, "create_fragment$3v");
function TJ(i) {
  return Object.values(i ?? {}).flat().reduce(
    (e, [t, s]) => (["generic", "healing", "damage"].includes(s.type) && !s.formula && e.push(t), e),
    []
  );
}
f(TJ, "getInvalidSelections$1");
const JI = /* @__PURE__ */ f(([i, e]) => [i, e.label || e.defaultLabel], "func$8");
function CJ(i, e, t) {
  let { selectedPrompts: s } = e, { prompts: n } = e;
  const l = {
    abilityCheck: "Ability Check Prompts",
    effect: "Effect Prompts",
    savingThrow: "Saving Throw Prompts",
    skillCheck: "Skill Check Prompts",
    generic: "Generic Roll Prompts"
  };
  let r = TJ(n);
  const o = /* @__PURE__ */ f((a) => t(0, s = a.detail), "updateSelection_handler");
  return i.$$set = (a) => {
    "selectedPrompts" in a && t(0, s = a.selectedPrompts), "prompts" in a && t(1, n = a.prompts);
  }, [
    s,
    n,
    l,
    r,
    o
  ];
}
f(CJ, "instance$3m");
const u2 = class u2 extends ie {
  constructor(e) {
    super(), le(this, e, CJ, SJ, ne, { selectedPrompts: 0, prompts: 1 });
  }
};
f(u2, "PromptsSection");
let u0 = u2;
function ZI(i, e, t) {
  const s = i.slice();
  return s[6] = e[t][0], s[7] = e[t][1], s;
}
f(ZI, "get_each_context$1o");
function OJ(i) {
  let e, t;
  return e = new Ze({
    props: {
      heading: (
        /*rollHeadingMap*/
        i[1][
          /*rollType*/
          i[6]
        ]
      ),
      options: (
        /*_rolls*/
        i[7].map(MJ)
      ),
      disabledOptions: (
        /*disabledRolls*/
        i[3]
      ),
      selected: (
        /*selectedRolls*/
        i[0]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[5]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*selectedRolls*/
      1 && (l.selected = /*selectedRolls*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(OJ, "create_if_block$1Y");
function QI(i) {
  let e, t, s = (
    /*_rolls*/
    i[7].length && OJ(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*_rolls*/
      n[7].length && s.p(n, l);
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f(QI, "create_each_block$1o");
function DJ(i) {
  let e, t, s = oe(Object.entries(
    /*otherRolls*/
    i[2]
  )), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = QI(ZI(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("div");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "roll-wrapper svelte-x3t7x9");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, o) {
      if (o & /*rollHeadingMap, Object, otherRolls, disabledRolls, selectedRolls*/
      15) {
        s = oe(Object.entries(
          /*otherRolls*/
          r[2]
        ));
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = ZI(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = QI(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f(DJ, "create_default_slot$1C");
function IJ(i) {
  let e, t, s;
  return e = new bt({
    props: {
      hint: "A5E.RollsHint",
      $$slots: { default: [DJ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--background", "transparent"), z(t, "--padding", "0");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, selectedRolls*/
      1025 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(IJ, "create_fragment$3u");
function PJ(i) {
  return Object.values(i ?? {}).flat().reduce(
    (e, [t, s]) => (["generic", "healing", "damage"].includes(s.type) && !s.formula && e.push(t), e),
    []
  );
}
f(PJ, "getInvalidSelections");
const MJ = /* @__PURE__ */ f(([i, e]) => [i, e.label || e.defaultLabel], "func$7");
function RJ(i, e, t) {
  let { selectedRolls: s } = e, { rolls: n } = e;
  const l = {
    abilityCheck: "Ability Checks",
    damage: "Damage Rolls",
    generic: "Generic Rolls",
    healing: "Healing Rolls",
    savingThrow: "Saving Throws",
    skillCheck: "Skill Checks",
    toolCheck: "Tool Checks"
  }, r = Object.entries(n).reduce(
    (c, [u, d]) => (u === "attack" || (c[u] = d), c),
    {}
  );
  let o = PJ(n);
  const a = /* @__PURE__ */ f((c) => t(0, s = c.detail), "updateSelection_handler");
  return i.$$set = (c) => {
    "selectedRolls" in c && t(0, s = c.selectedRolls), "rolls" in c && t(4, n = c.rolls);
  }, [
    s,
    l,
    r,
    o,
    n,
    a
  ];
}
f(RJ, "instance$3l");
const f2 = class f2 extends ie {
  constructor(e) {
    super(), le(this, e, RJ, IJ, ne, { selectedRolls: 0, rolls: 4 });
  }
};
f(f2, "RollsSection");
let f0 = f2;
function FJ(i) {
  var s, n, l, r, o, a, c, u;
  const t = Object.values(i.rolls ?? {}).filter((d) => ["damage", "healing"].includes(d.type)).reduce((d, p) => {
    var m, g;
    return (m = p.scaling) != null && m.mode && d.add((g = p.scaling) == null ? void 0 : g.mode), d;
  }, /* @__PURE__ */ new Set());
  return (n = (s = i.target) == null ? void 0 : s.scaling) != null && n.mode && t.add((r = (l = i.target) == null ? void 0 : l.scaling) == null ? void 0 : r.mode), (a = (o = i.area) == null ? void 0 : o.scaling) != null && a.mode && t.add((u = (c = i.area) == null ? void 0 : c.scaling) == null ? void 0 : u.mode), t;
}
f(FJ, "getActionScalingModes");
function xI(i) {
  let e, t, s = !/*isEmpty*/
  i[7](
    /*consumer*/
    i[11]
  ), n, l;
  e = new Ye({
    props: {
      heading: (
        /*spellData*/
        i[0].consume === "spellPoint" ? `${K("A5E.SpellLevel")} (${/*spellData*/
        i[0].points} Points)` : K("A5E.SpellLevel")
      ),
      selected: (
        /*spellData*/
        i[0].level
      ),
      options: (
        /*spellLevels*/
        i[8]
      ),
      allowDeselect: !1,
      disabled: (
        /*disabled*/
        i[1]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[13]
  );
  let r = s && NJ(i);
  return {
    c() {
      L(e.$$.fragment), t = R(), r && r.c(), n = $e();
    },
    m(o, a) {
      N(e, o, a), T(o, t, a), r && r.m(o, a), T(o, n, a), l = !0;
    },
    p(o, a) {
      const c = {};
      a & /*spellData*/
      1 && (c.heading = /*spellData*/
      o[0].consume === "spellPoint" ? `${K("A5E.SpellLevel")} (${/*spellData*/
      o[0].points} Points)` : K("A5E.SpellLevel")), a & /*spellData*/
      1 && (c.selected = /*spellData*/
      o[0].level), a & /*disabled*/
      2 && (c.disabled = /*disabled*/
      o[1]), e.$set(c), s && r.p(o, a);
    },
    i(o) {
      l || (w(e.$$.fragment, o), w(r), l = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(r), l = !1;
    },
    d(o) {
      o && (S(t), S(n)), j(e, o), r && r.d(o);
    }
  };
}
f(xI, "create_if_block_2$P");
function NJ(i) {
  let e, t;
  return e = new Ye({
    props: {
      heading: "A5E.ConsumeOptions",
      options: Object.entries(
        /*consumeOptions*/
        i[9]
      ),
      selected: (
        /*spellData*/
        i[0].consume
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[14]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*spellData*/
      1 && (l.selected = /*spellData*/
      s[0].consume), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(NJ, "create_if_block_3$w");
function e4(i) {
  let e, t, s, n, l;
  return e = new de({
    props: {
      heading: "A5E.SpellPoints",
      $$slots: { default: [jJ] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      $$slots: { default: [BJ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--direction", "column");
    },
    m(r, o) {
      T(r, t, o), N(e, t, null), T(r, s, o), N(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*$$scope, spellData*/
      536870913 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, spellData*/
      536870913 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && S(s), r && e && S(t), j(e, r), j(n, r);
    }
  };
}
f(e4, "create_if_block$1X");
function jJ(i) {
  let e, t, s, n, l, r, o, a;
  return {
    c() {
      e = E("div"), t = E("div"), s = E("input"), n = x(`

            /

            `), l = E("div"), r = E("input"), b(s, "class", "number-input svelte-1w2jczi"), b(s, "type", "number"), b(t, "class", "u-flex u-w-10"), b(r, "class", "number-input svelte-1w2jczi"), b(r, "type", "number"), r.value = /*spellResources*/
      i[10].points.current ?? /*spellResources*/
      i[10].points.max, r.disabled = !0, b(l, "class", "u-flex u-w-10"), b(e, "class", "u-flex u-gap-md u-align-center");
    },
    m(c, u) {
      T(c, e, u), A(e, t), A(t, s), qe(
        s,
        /*spellData*/
        i[0].points
      ), A(e, n), A(e, l), A(l, r), o || (a = V(
        s,
        "input",
        /*input0_input_handler*/
        i[15]
      ), o = !0);
    },
    p(c, u) {
      u & /*spellData*/
      1 && ii(s.value) !== /*spellData*/
      c[0].points && qe(
        s,
        /*spellData*/
        c[0].points
      );
    },
    d(c) {
      c && S(e), o = !1, a();
    }
  };
}
f(jJ, "create_default_slot_1$T");
function LJ(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.ConsumeSpellPoints",
      checked: (
        /*spellData*/
        i[0].consume === "spellPoint"
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[16]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*spellData*/
      1 && (l.checked = /*spellData*/
      s[0].consume === "spellPoint"), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(LJ, "create_if_block_1$1j");
function BJ(i) {
  let e = !/*isEmpty*/
  i[7](
    /*consumer*/
    i[11]
  ), t, s, n = e && LJ(i);
  return {
    c() {
      n && n.c(), t = $e();
    },
    m(l, r) {
      n && n.m(l, r), T(l, t, r), s = !0;
    },
    p(l, r) {
      e && n.p(l, r);
    },
    i(l) {
      s || (w(n), s = !0);
    },
    o(l) {
      C(n), s = !1;
    },
    d(l) {
      l && S(t), n && n.d(l);
    }
  };
}
f(BJ, "create_default_slot$1B");
function qJ(i) {
  let e = ["variable", "spellsOnly"].includes(
    /*mode*/
    i[2]
  ), t, s, n, l = e && xI(i), r = (
    /*mode*/
    i[2] === "pointsOnly" && e4(i)
  );
  return {
    c() {
      l && l.c(), t = R(), r && r.c(), s = $e();
    },
    m(o, a) {
      l && l.m(o, a), T(o, t, a), r && r.m(o, a), T(o, s, a), n = !0;
    },
    p(o, [a]) {
      a & /*mode*/
      4 && (e = ["variable", "spellsOnly"].includes(
        /*mode*/
        o[2]
      )), e ? l ? (l.p(o, a), a & /*mode*/
      4 && w(l, 1)) : (l = xI(o), l.c(), w(l, 1), l.m(t.parentNode, t)) : l && (ce(), C(l, 1, 1, () => {
        l = null;
      }), ue()), /*mode*/
      o[2] === "pointsOnly" ? r ? (r.p(o, a), a & /*mode*/
      4 && w(r, 1)) : (r = e4(o), r.c(), w(r, 1), r.m(s.parentNode, s)) : r && (ce(), C(r, 1, 1, () => {
        r = null;
      }), ue());
    },
    i(o) {
      n || (w(l), w(r), n = !0);
    },
    o(o) {
      C(l), C(r), n = !1;
    },
    d(o) {
      o && (S(t), S(s)), l && l.d(o), r && r.d(o);
    }
  };
}
f(qJ, "create_fragment$3t");
function GJ(i, e, t) {
  var te, J, re, ae, be;
  let s, n, { consumers: l } = e, { spellData: r } = e;
  function o(we) {
    t(0, r.level = we, r), t(0, r.points = _.spellLevelCost[r.level], r);
  }
  f(o, "updateLevelAndPoints");
  function a(we) {
    t(0, r.consume = we, r), we === "spellSlot" ? u() : we === "spellPoint" ? d() : we === "noConsume" ? c() : t(1, D = []), t(0, r.level = p(), r);
  }
  f(a, "updateConsumeOption");
  function c() {
    var ve;
    const we = H.spellLevel ?? ((ve = s.system) == null ? void 0 : ve.level) ?? 1;
    t(1, D = v.slice(0, we - 1).map((me) => me[0]));
  }
  f(c, "disableBaseSlotOptions");
  function u() {
    var me;
    const we = new Set(v.map((he) => he[0])), ve = H.spellLevel ?? ((me = s.system) == null ? void 0 : me.level) ?? 1;
    t(1, D = [
      ...we.difference(new Set(F)),
      ...v.slice(0, ve - 1).map((he) => he[0])
    ]);
  }
  f(u, "disableSpellSlotOptions");
  function d() {
    var me;
    const we = H.spellLevel ?? ((me = s.system) == null ? void 0 : me.level) ?? 1, ve = Object.entries(_.spellLevelCost).reduce(
      (he, [Ae, Fe]) => (Number(Fe) <= B && (he = Number(Ae)), he),
      0
    );
    t(1, D = [
      ...v.slice(0, we - 1).map((he) => he[0]),
      ...v.map((he) => he[0]).slice(ve)
    ]);
  }
  f(d, "disableSpellPointOptions");
  function p() {
    var he;
    const we = H.spellLevel ?? ((he = s.system) == null ? void 0 : he.level) ?? 1, ve = Math.min(...F.map(Number));
    return ["noConsume", "spellPoint"].includes(r.consume) ? we : Math.max(we, ve);
  }
  f(p, "getDefaultSpellLevel");
  const m = fe("actionId"), g = fe("actor");
  pe(i, g, (we) => t(18, n = we));
  const h = fe("item");
  pe(i, h, (we) => t(17, s = we));
  const { A5E: _ } = CONFIG, y = s.actions[m], { isEmpty: k } = foundry.utils, v = Object.entries(_.spellLevels).slice(1), O = n.spellBooks.get(s.system.spellBook), P = {
    spellSlot: "A5E.ConsumeSpellSlot",
    spellPoint: "A5E.SpellPoints",
    noConsume: "A5E.ConsumeNothing"
  };
  let D = [], I = n.system.spellResources, B = I.points.current, F = Object.entries(I.slots).reduce(
    (we, [ve, me]) => (me.max > 0 && me.current > 0 && we.push(ve), we),
    []
  );
  const H = ((J = (te = Object.values(l.spell ?? {})) == null ? void 0 : te[0]) == null ? void 0 : J[1]) ?? {};
  let G = H.mode ?? "variable";
  if (r.basePoints = H.points ?? 1, r.baseLevel = H.spellLevel ?? s.system.level ?? 1, k(H)) {
    r.consume = "noConsume";
    const we = FJ(y);
    we.size && (we.has("spellPoints") ? G = "pointsOnly" : we.has("spellSlots") && (G = "spellsOnly"), r.basePoints = 0);
  } else
    r.consume = G === "pointsOnly" ? "spellPoint" : F.length > 0 ? "spellSlot" : "spellPoint";
  (((re = s.system) == null ? void 0 : re.level) === null || ((ae = s.system) == null ? void 0 : ae.level) === void 0) && (r.consume = "noConsume"), O != null && O.disableSpellConsumers && (r.consume = "noConsume"), r.level = p(), r.points = H.points ?? _.spellLevelCost[(be = s.system) == null ? void 0 : be.level] ?? 1, r.consume === "spellSlot" ? u() : r.consume === "noConsume" ? c() : d();
  const U = /* @__PURE__ */ f(({ detail: we }) => o(Number(we)), "updateSelection_handler"), q = /* @__PURE__ */ f(({ detail: we }) => a(we), "updateSelection_handler_1");
  function W() {
    r.points = ii(this.value), t(0, r);
  }
  f(W, "input0_input_handler");
  const X = /* @__PURE__ */ f(({ detail: we }) => {
    t(0, r.consume = we ? "spellPoints" : "noConsume", r);
  }, "updateSelection_handler_2");
  return i.$$set = (we) => {
    "consumers" in we && t(12, l = we.consumers), "spellData" in we && t(0, r = we.spellData);
  }, [
    r,
    D,
    G,
    o,
    a,
    g,
    h,
    k,
    v,
    P,
    I,
    H,
    l,
    U,
    q,
    W,
    X
  ];
}
f(GJ, "instance$3k");
const d2 = class d2 extends ie {
  constructor(e) {
    super(), le(this, e, GJ, qJ, ne, { consumers: 12, spellData: 0 });
  }
};
f(d2, "SpellSection");
let d0 = d2;
function t4(i) {
  let e, t;
  return e = new de({
    props: {
      heading: "A5E.ActionUses",
      $$slots: { default: [zJ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, actionMaxUses, actionUses, actionUsesData*/
      131093 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(t4, "create_if_block_1$1i");
function zJ(i) {
  let e, t, s, n, l, r, o, a = (
    /*actionUses*/
    i[2].value + ""
  ), c, u, d, p, m = K("A5E.UsesRemaining") + "", g, h, _, y;
  return {
    c() {
      e = E("div"), t = E("div"), s = E("input"), l = R(), r = E("p"), o = x("( "), c = x(a), u = x(" / "), d = x(
        /*actionMaxUses*/
        i[4]
      ), p = R(), g = x(m), h = x(")"), b(s, "class", "number-input svelte-506nxq"), b(s, "type", "number"), b(s, "min", "0"), b(s, "max", n = /*actionUses*/
      i[2].max), b(t, "class", "u-flex u-w-10"), b(r, "class", "u-text-xs"), b(e, "class", "u-flex u-gap-md u-align-center");
    },
    m(k, v) {
      T(k, e, v), A(e, t), A(t, s), qe(
        s,
        /*actionUsesData*/
        i[0].quantity
      ), A(e, l), A(e, r), A(r, o), A(r, c), A(r, u), A(r, d), A(r, p), A(r, g), A(r, h), _ || (y = V(
        s,
        "input",
        /*input_input_handler*/
        i[12]
      ), _ = !0);
    },
    p(k, v) {
      v & /*actionUses*/
      4 && n !== (n = /*actionUses*/
      k[2].max) && b(s, "max", n), v & /*actionUsesData*/
      1 && ii(s.value) !== /*actionUsesData*/
      k[0].quantity && qe(
        s,
        /*actionUsesData*/
        k[0].quantity
      ), v & /*actionUses*/
      4 && a !== (a = /*actionUses*/
      k[2].value + "") && _e(c, a), v & /*actionMaxUses*/
      16 && _e(
        d,
        /*actionMaxUses*/
        k[4]
      );
    },
    d(k) {
      k && S(e), _ = !1, y();
    }
  };
}
f(zJ, "create_default_slot_1$S");
function s4(i) {
  let e, t;
  return e = new de({
    props: {
      heading: "A5E.ItemUses",
      $$slots: { default: [HJ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, itemMaxUses, itemUses, itemUsesData*/
      131114 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(s4, "create_if_block$1W");
function HJ(i) {
  let e, t, s, n, l, r, o, a = (
    /*itemUses*/
    i[3].value + ""
  ), c, u, d, p, m = K("A5E.UsesRemaining") + "", g, h, _, y;
  return {
    c() {
      e = E("div"), t = E("div"), s = E("input"), l = R(), r = E("p"), o = x("( "), c = x(a), u = x(" / "), d = x(
        /*itemMaxUses*/
        i[5]
      ), p = R(), g = x(m), h = x(")"), b(s, "class", "number-input svelte-506nxq"), b(s, "type", "number"), b(s, "min", "0"), b(s, "max", n = /*itemUses*/
      i[3].max), b(t, "class", "u-flex u-w-10"), b(r, "class", "u-text-xs"), b(e, "class", "u-flex u-gap-md u-align-center");
    },
    m(k, v) {
      T(k, e, v), A(e, t), A(t, s), qe(
        s,
        /*itemUsesData*/
        i[1].quantity
      ), A(e, l), A(e, r), A(r, o), A(r, c), A(r, u), A(r, d), A(r, p), A(r, g), A(r, h), _ || (y = V(
        s,
        "input",
        /*input_input_handler_1*/
        i[13]
      ), _ = !0);
    },
    p(k, v) {
      v & /*itemUses*/
      8 && n !== (n = /*itemUses*/
      k[3].max) && b(s, "max", n), v & /*itemUsesData*/
      2 && ii(s.value) !== /*itemUsesData*/
      k[1].quantity && qe(
        s,
        /*itemUsesData*/
        k[1].quantity
      ), v & /*itemUses*/
      8 && a !== (a = /*itemUses*/
      k[3].value + "") && _e(c, a), v & /*itemMaxUses*/
      32 && _e(
        d,
        /*itemMaxUses*/
        k[5]
      );
    },
    d(k) {
      k && S(e), _ = !1, y();
    }
  };
}
f(HJ, "create_default_slot$1A");
function UJ(i) {
  var a, c;
  let e, t = Jr(
    /*action*/
    i[8],
    ["actionUses"],
    ["actionUses"]
  ) && /*actionUses*/
  ((a = i[2]) == null ? void 0 : a.max), s, n = Jr(
    /*action*/
    i[8],
    ["itemUses"],
    ["itemUses"]
  ) && /*itemUses*/
  ((c = i[3]) == null ? void 0 : c.max), l, r = t && t4(i), o = n && s4(i);
  return {
    c() {
      e = E("div"), r && r.c(), s = R(), o && o.c(), b(e, "class", "side-by-side svelte-506nxq");
    },
    m(u, d) {
      T(u, e, d), r && r.m(e, null), A(e, s), o && o.m(e, null), l = !0;
    },
    p(u, [d]) {
      var p, m;
      d & /*actionUses*/
      4 && (t = Jr(
        /*action*/
        u[8],
        ["actionUses"],
        ["actionUses"]
      ) && /*actionUses*/
      ((p = u[2]) == null ? void 0 : p.max)), t ? r ? (r.p(u, d), d & /*actionUses*/
      4 && w(r, 1)) : (r = t4(u), r.c(), w(r, 1), r.m(e, s)) : r && (ce(), C(r, 1, 1, () => {
        r = null;
      }), ue()), d & /*itemUses*/
      8 && (n = Jr(
        /*action*/
        u[8],
        ["itemUses"],
        ["itemUses"]
      ) && /*itemUses*/
      ((m = u[3]) == null ? void 0 : m.max)), n ? o ? (o.p(u, d), d & /*itemUses*/
      8 && w(o, 1)) : (o = s4(u), o.c(), w(o, 1), o.m(e, null)) : o && (ce(), C(o, 1, 1, () => {
        o = null;
      }), ue());
    },
    i(u) {
      l || (w(r), w(o), l = !0);
    },
    o(u) {
      C(r), C(o), l = !1;
    },
    d(u) {
      u && S(e), r && r.d(), o && o.d();
    }
  };
}
f(UJ, "create_fragment$3s");
function VJ(i) {
  if (foundry.utils.isEmpty(i.actionUses))
    return null;
  const [e, t] = Object.values(i.actionUses);
  return t;
}
f(VJ, "getActionConsumer");
function WJ(i) {
  if (foundry.utils.isEmpty(i.itemUses))
    return null;
  const [e, t] = Object.values(i.itemUses);
  return t;
}
f(WJ, "getItemConsumer");
function KJ(i, e, t) {
  let s, n, l, r, o, a, { consumers: c } = e, { actionUsesData: u } = e, { itemUsesData: d } = e;
  const p = fe("actor");
  pe(i, p, (O) => t(11, a = O));
  const m = fe("actionId"), g = fe("item");
  pe(i, g, (O) => t(10, o = O));
  const h = o.actions[m], _ = VJ(c), y = WJ(c);
  u.quantity = (_ == null ? void 0 : _.quantity) ?? 1, u.baseUses = (_ == null ? void 0 : _.quantity) ?? 1, d.quantity = (y == null ? void 0 : y.quantity) ?? 1, d.baseUses = (y == null ? void 0 : y.quantity) ?? 1;
  function k() {
    u.quantity = ii(this.value), t(0, u);
  }
  f(k, "input_input_handler");
  function v() {
    d.quantity = ii(this.value), t(1, d);
  }
  return f(v, "input_input_handler_1"), i.$$set = (O) => {
    "consumers" in O && t(9, c = O.consumers), "actionUsesData" in O && t(0, u = O.actionUsesData), "itemUsesData" in O && t(1, d = O.itemUsesData);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1024 && t(2, s = o.actions[m].uses ?? {}), i.$$.dirty & /*$item*/
    1024 && t(3, n = o.system.uses), i.$$.dirty & /*itemUses, $actor, $item*/
    3080 && t(5, l = at(n.max, a.getRollData(o))), i.$$.dirty & /*actionUses, $actor, $item*/
    3076 && t(4, r = at((s == null ? void 0 : s.max) ?? 0, a.getRollData(o)));
  }, [
    u,
    d,
    s,
    n,
    r,
    l,
    p,
    g,
    h,
    c,
    o,
    a,
    k,
    v
  ];
}
f(KJ, "instance$3j");
const p2 = class p2 extends ie {
  constructor(e) {
    super(), le(this, e, KJ, UJ, ne, {
      consumers: 9,
      actionUsesData: 0,
      itemUsesData: 1
    });
  }
};
f(p2, "UsesSection");
let p0 = p2;
function n4(i, e, t) {
  const s = i.slice();
  return s[44] = e[t], s;
}
f(n4, "get_each_context$1n");
function i4(i) {
  let e, t = oe(
    /*warnings*/
    i[13]
  ), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = l4(n4(i, t, n));
  return {
    c() {
      e = E("section");
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      b(e, "class", "warning__wrapper svelte-to5fsu");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l[0] & /*warnings*/
      8192) {
        t = oe(
          /*warnings*/
          n[13]
        );
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = n4(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = l4(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && S(e), Le(s, n);
    }
  };
}
f(i4, "create_if_block_10$5");
function l4(i) {
  let e, t, s, n = (
    /*warning*/
    i[44] + ""
  ), l, r;
  return {
    c() {
      e = E("p"), t = E("i"), s = R(), l = x(n), r = R(), b(t, "class", "fa-solid fa-circle-exclamation"), b(e, "class", "warning svelte-to5fsu"), z(e, "color", "$color-warning");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(e, s), A(e, l), A(e, r);
    },
    p(o, a) {
      a[0] & /*warnings*/
      8192 && n !== (n = /*warning*/
      o[44] + "") && _e(l, n);
    },
    d(o) {
      o && S(e);
    }
  };
}
f(l4, "create_each_block$1n");
function YJ(i) {
  let e, t, s;
  function n(r) {
    i[32](r);
  }
  f(n, "attackrollsection_attackRollData_binding");
  let l = {
    attackRoll: (
      /*attackRoll*/
      i[24]
    ),
    options: (
      /*options*/
      i[1]
    )
  };
  return (
    /*attackRollData*/
    i[5] !== void 0 && (l.attackRollData = /*attackRollData*/
    i[5]), e = new a0({ props: l }), st.push(() => mt(e, "attackRollData", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, o) {
        const a = {};
        o[0] & /*options*/
        2 && (a.options = /*options*/
        r[1]), !t && o[0] & /*attackRollData*/
        32 && (t = !0, a.attackRollData = /*attackRollData*/
        r[5], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(YJ, "create_if_block_9$8");
function r4(i) {
  let e, t;
  return e = new de({
    props: {
      $$slots: { default: [XJ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*placeTemplate*/
      4096 | n[1] & /*$$scope*/
      65536 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(r4, "create_if_block_8$9");
function XJ(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.ItemPlaceTemplate",
      checked: (
        /*placeTemplate*/
        i[12]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[33]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*placeTemplate*/
      4096 && (l.checked = /*placeTemplate*/
      s[12]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(XJ, "create_default_slot$1z");
function JJ(i) {
  let e, t, s;
  function n(r) {
    i[34](r);
  }
  f(n, "rollssection_selectedRolls_binding");
  let l = { rolls: (
    /*rolls*/
    i[21]
  ) };
  return (
    /*selectedRolls*/
    i[10] !== void 0 && (l.selectedRolls = /*selectedRolls*/
    i[10]), e = new f0({ props: l }), st.push(() => mt(e, "selectedRolls", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, o) {
        const a = {};
        !t && o[0] & /*selectedRolls*/
        1024 && (t = !0, a.selectedRolls = /*selectedRolls*/
        r[10], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(JJ, "create_if_block_7$b");
function ZJ(i) {
  let e, t;
  return e = new Ze({
    props: {
      heading: "Damage Bonuses",
      options: (
        /*damageBonuses*/
        i[22].map(rZ)
      ),
      selected: (
        /*selectedDamageBonuses*/
        i[7]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[35]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*selectedDamageBonuses*/
      128 && (l.selected = /*selectedDamageBonuses*/
      s[7]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(ZJ, "create_if_block_6$g");
function QJ(i) {
  let e, t;
  return e = new Ze({
    props: {
      heading: "Healing Bonuses",
      options: (
        /*healingBonuses*/
        i[23].map(oZ)
      ),
      selected: (
        /*selectedHealingBonuses*/
        i[8]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[36]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*selectedHealingBonuses*/
      256 && (l.selected = /*selectedHealingBonuses*/
      s[8]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(QJ, "create_if_block_5$i");
function xJ(i) {
  let e, t, s;
  function n(r) {
    i[37](r);
  }
  f(n, "promptssection_selectedPrompts_binding");
  let l = { prompts: (
    /*prompts*/
    i[20]
  ) };
  return (
    /*selectedPrompts*/
    i[9] !== void 0 && (l.selectedPrompts = /*selectedPrompts*/
    i[9]), e = new u0({ props: l }), st.push(() => mt(e, "selectedPrompts", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, o) {
        const a = {};
        !t && o[0] & /*selectedPrompts*/
        512 && (t = !0, a.selectedPrompts = /*selectedPrompts*/
        r[9], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(xJ, "create_if_block_4$q");
function eZ(i) {
  let e, t, s;
  function n(r) {
    i[38](r);
  }
  f(n, "spellsection_spellData_binding");
  let l = { consumers: (
    /*consumers*/
    i[19]
  ) };
  return (
    /*spellData*/
    i[6] !== void 0 && (l.spellData = /*spellData*/
    i[6]), e = new d0({ props: l }), st.push(() => mt(e, "spellData", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, o) {
        const a = {};
        !t && o[0] & /*spellData*/
        64 && (t = !0, a.spellData = /*spellData*/
        r[6], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(eZ, "create_if_block_3$v");
function tZ(i) {
  let e, t, s, n;
  function l(a) {
    i[39](a);
  }
  f(l, "usessection_actionUsesData_binding");
  function r(a) {
    i[40](a);
  }
  f(r, "usessection_itemUsesData_binding");
  let o = { consumers: (
    /*consumers*/
    i[19]
  ) };
  return (
    /*actionUsesData*/
    i[2] !== void 0 && (o.actionUsesData = /*actionUsesData*/
    i[2]), /*itemUsesData*/
    i[4] !== void 0 && (o.itemUsesData = /*itemUsesData*/
    i[4]), e = new p0({ props: o }), st.push(() => mt(e, "actionUsesData", l)), st.push(() => mt(e, "itemUsesData", r)), {
      c() {
        L(e.$$.fragment);
      },
      m(a, c) {
        N(e, a, c), n = !0;
      },
      p(a, c) {
        const u = {};
        !t && c[0] & /*actionUsesData*/
        4 && (t = !0, u.actionUsesData = /*actionUsesData*/
        a[2], _t(() => t = !1)), !s && c[0] & /*itemUsesData*/
        16 && (s = !0, u.itemUsesData = /*itemUsesData*/
        a[4], _t(() => s = !1)), e.$set(u);
      },
      i(a) {
        n || (w(e.$$.fragment, a), n = !0);
      },
      o(a) {
        C(e.$$.fragment, a), n = !1;
      },
      d(a) {
        j(e, a);
      }
    }
  );
}
f(tZ, "create_if_block_2$O");
function sZ(i) {
  let e, t, s;
  function n(r) {
    i[41](r);
  }
  f(n, "hitdicesection_hitDiceData_binding");
  let l = { consumers: (
    /*consumers*/
    i[19]
  ) };
  return (
    /*hitDiceData*/
    i[3] !== void 0 && (l.hitDiceData = /*hitDiceData*/
    i[3]), e = new c0({ props: l }), st.push(() => mt(e, "hitDiceData", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, o) {
        const a = {};
        !t && o[0] & /*hitDiceData*/
        8 && (t = !0, a.hitDiceData = /*hitDiceData*/
        r[3], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(sZ, "create_if_block_1$1h");
function nZ(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "fa-solid fa-dice");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(nZ, "create_else_block$z");
function iZ(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "fa-solid fa-circle-exclamation"), z(e, "color", "$color-warning");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(iZ, "create_if_block$1V");
function lZ(i) {
  var Ee, Be;
  let e, t, s, n, l, r = !/*isEmpty*/
  i[25](
    /*attackRoll*/
    i[24]
  ), o, a = Ay(
    /*$item*/
    (Ee = i[14].actions.get(
      /*actionId*/
      i[0]
    )) == null ? void 0 : Ee.area
  ), c, u = Object.values(
    /*rolls*/
    i[21]
  ).flat().length, d, p = Object.values(
    /*damageBonuses*/
    i[22]
  ).flat().length, m, g = Object.values(
    /*healingBonuses*/
    i[23]
  ).flat().length, h, _ = Object.values(
    /*prompts*/
    i[20]
  ).flat().length, y, k = Jr(
    /*action*/
    i[18],
    ["spell"],
    ["spellLevel", "spellPoints"]
  ), v, O = Jr(
    /*action*/
    i[18],
    ["actionUses", "itemUses"],
    ["actionUses", "itemUses"]
  ), P, D = Object.values(
    /*consumers*/
    ((Be = i[19]) == null ? void 0 : Be.hitDice) ?? {}
  ).flat().length, I, B, F, H, G = K("A5E.DialogSubmitRoll") + "", U, q, W, X, te, J = (
    /*warnings*/
    i[13].length && i4(i)
  );
  function re(Ce) {
    i[31](Ce);
  }
  f(re, "outputvisibilitysection_visibilityMode_binding");
  let ae = {};
  /*visibilityMode*/
  i[11] !== void 0 && (ae.visibilityMode = /*visibilityMode*/
  i[11]), s = new ma({ props: ae }), st.push(() => mt(s, "visibilityMode", re));
  let be = r && YJ(i), we = a && r4(i), ve = u && JJ(i), me = p && ZJ(i), he = g && QJ(i), Ae = _ && xJ(i), Fe = k && eZ(i), Ve = O && tZ(i), je = D && sZ(i);
  function Pe(Ce, Re) {
    return (
      /*warnings*/
      Ce[13].length ? iZ : nZ
    );
  }
  f(Pe, "select_block_type");
  let rt = Pe(i), Te = rt(i);
  return {
    c() {
      e = E("form"), J && J.c(), t = R(), L(s.$$.fragment), l = R(), be && be.c(), o = R(), we && we.c(), c = R(), ve && ve.c(), d = R(), me && me.c(), m = R(), he && he.c(), h = R(), Ae && Ae.c(), y = R(), Fe && Fe.c(), v = R(), Ve && Ve.c(), P = R(), je && je.c(), I = R(), B = E("section"), F = E("button"), Te.c(), H = R(), U = x(G), F.disabled = q = /*preventActionRollOnWarning*/
      i[26] && /*warnings*/
      i[13].length, b(e, "class", "svelte-to5fsu");
    },
    m(Ce, Re) {
      T(Ce, e, Re), J && J.m(e, null), A(e, t), N(s, e, null), A(e, l), be && be.m(e, null), A(e, o), we && we.m(e, null), A(e, c), ve && ve.m(e, null), A(e, d), me && me.m(e, null), A(e, m), he && he.m(e, null), A(e, h), Ae && Ae.m(e, null), A(e, y), Fe && Fe.m(e, null), A(e, v), Ve && Ve.m(e, null), A(e, P), je && je.m(e, null), A(e, I), A(e, B), A(B, F), Te.m(F, null), A(F, H), A(F, U), W = !0, X || (te = V(F, "click", tt(
        /*onSubmit*/
        i[15]
      )), X = !0);
    },
    p(Ce, Re) {
      var Je;
      /*warnings*/
      Ce[13].length ? J ? J.p(Ce, Re) : (J = i4(Ce), J.c(), J.m(e, t)) : J && (J.d(1), J = null);
      const Oe = {};
      !n && Re[0] & /*visibilityMode*/
      2048 && (n = !0, Oe.visibilityMode = /*visibilityMode*/
      Ce[11], _t(() => n = !1)), s.$set(Oe), r && be.p(Ce, Re), Re[0] & /*$item, actionId*/
      16385 && (a = Ay(
        /*$item*/
        (Je = Ce[14].actions.get(
          /*actionId*/
          Ce[0]
        )) == null ? void 0 : Je.area
      )), a ? we ? (we.p(Ce, Re), Re[0] & /*$item, actionId*/
      16385 && w(we, 1)) : (we = r4(Ce), we.c(), w(we, 1), we.m(e, c)) : we && (ce(), C(we, 1, 1, () => {
        we = null;
      }), ue()), u && ve.p(Ce, Re), p && me.p(Ce, Re), g && he.p(Ce, Re), _ && Ae.p(Ce, Re), k && Fe.p(Ce, Re), O && Ve.p(Ce, Re), D && je.p(Ce, Re), rt !== (rt = Pe(Ce)) && (Te.d(1), Te = rt(Ce), Te && (Te.c(), Te.m(F, H))), (!W || Re[0] & /*warnings*/
      8192 && q !== (q = /*preventActionRollOnWarning*/
      Ce[26] && /*warnings*/
      Ce[13].length)) && (F.disabled = q);
    },
    i(Ce) {
      W || (w(s.$$.fragment, Ce), w(be), w(we), w(ve), w(me), w(he), w(Ae), w(Fe), w(Ve), w(je), W = !0);
    },
    o(Ce) {
      C(s.$$.fragment, Ce), C(be), C(we), C(ve), C(me), C(he), C(Ae), C(Fe), C(Ve), C(je), W = !1;
    },
    d(Ce) {
      Ce && S(e), J && J.d(), j(s), be && be.d(), we && we.d(), ve && ve.d(), me && me.d(), he && he.d(), Ae && Ae.d(), Fe && Fe.d(), Ve && Ve.d(), je && je.d(), Te.d(), X = !1, te();
    }
  };
}
f(lZ, "create_fragment$3r");
function Hf(i) {
  return Object.values(i ?? {}).flat().reduce(
    (e, [t, s]) => (["generic", "healing", "damage"].includes(s.type) && !s.formula || (s.default ?? !0) && e.push(t), e),
    []
  );
}
f(Hf, "getDefaultSelections");
const rZ = /* @__PURE__ */ f(([i, e]) => [i, e.label || e.defaultLabel], "func$6"), oZ = /* @__PURE__ */ f(([i, e]) => [i, e.label || e.defaultLabel], "func_1$3");
function aZ(i, e, t) {
  var Oe, Je;
  let s, n, l, r, { actionId: o, actorDocument: a, dialog: c, itemDocument: u, options: d } = fe("#external").application, { actionId: p = o, actorDocument: m = a, dialog: g = c, itemDocument: h = u, options: _ = d } = e;
  function y() {
    g.submit({
      attack: G,
      consumers: {
        actionUses: U,
        hitDice: q,
        itemUses: W,
        spell: X
      },
      damageBonuses: Object.entries(r.system.bonuses.damage ?? {}).reduce(
        (Xe, [Gt, zt]) => (te.includes(Gt) && Xe.push(zt), Xe),
        []
      ),
      healingBonuses: Object.entries(r.system.bonuses.healing ?? {}).reduce(
        (Xe, [Gt, zt]) => (J.includes(Gt) && Xe.push(zt), Xe),
        []
      ),
      prompts: Object.entries(O.prompts ?? {}).reduce(
        (Xe, [Gt, zt]) => (re.includes(Gt) && (zt.type === "savingThrow" && (zt.dc = W5(r, l, zt.saveDC)), Xe.push(zt)), Xe),
        []
      ),
      rolls: Object.entries(O.rolls ?? {}).reduce(
        (Xe, [Gt, zt]) => (ae.includes(Gt) && zt.type !== "attack" && Xe.push(zt), Xe),
        []
      ),
      placeTemplate: we,
      visibilityMode: be
    });
  }
  f(y, "onSubmit");
  const k = new Bt(m);
  pe(i, k, (Xe) => t(42, r = Xe));
  const v = new Bt(h);
  pe(i, v, (Xe) => t(14, l = Xe));
  const O = l.actions[p], P = cB(O.consumers), D = uB(O.prompts, l), I = fB(O.rolls), B = r.BonusesManager.prepareGlobalDamageBonuses(l, I), F = r.BonusesManager.prepareGlobalHealingBonuses(l, I), H = (Oe = I == null ? void 0 : I.attack) != null && Oe.length ? I.attack[0][1] : {};
  let G = {}, U = {}, q = {}, W = {}, X = {}, te = Hf({ damageBonuses: B }), J = Hf({ healingBonuses: F }), re = Hf(D), ae = Hf(I), be = game.settings.get("core", "rollMode"), we = game.settings.get("a5e", "placeItemTemplateDefault") || ((Je = O == null ? void 0 : O.area) == null ? void 0 : Je.placeTemplate) || !1;
  const ve = new r0(r, l, O, P), { isEmpty: me } = foundry.utils, he = game.settings.get("a5e", "preventActionRollOnWarning");
  et("actionId", p), et("actor", k), et("dialog", g), et("item", v);
  function Ae(Xe) {
    be = Xe, t(11, be);
  }
  f(Ae, "outputvisibilitysection_visibilityMode_binding");
  function Fe(Xe) {
    G = Xe, t(5, G);
  }
  f(Fe, "attackrollsection_attackRollData_binding");
  const Ve = /* @__PURE__ */ f(({ detail: Xe }) => {
    t(12, we = Xe);
  }, "updateSelection_handler");
  function je(Xe) {
    ae = Xe, t(10, ae);
  }
  f(je, "rollssection_selectedRolls_binding");
  const Pe = /* @__PURE__ */ f(({ detail: Xe }) => t(7, te = Xe), "updateSelection_handler_1"), rt = /* @__PURE__ */ f(({ detail: Xe }) => t(8, J = Xe), "updateSelection_handler_2");
  function Te(Xe) {
    re = Xe, t(9, re);
  }
  f(Te, "promptssection_selectedPrompts_binding");
  function Ee(Xe) {
    X = Xe, t(6, X);
  }
  f(Ee, "spellsection_spellData_binding");
  function Be(Xe) {
    U = Xe, t(2, U);
  }
  f(Be, "usessection_actionUsesData_binding");
  function Ce(Xe) {
    W = Xe, t(4, W);
  }
  f(Ce, "usessection_itemUsesData_binding");
  function Re(Xe) {
    q = Xe, t(3, q);
  }
  return f(Re, "hitdicesection_hitDiceData_binding"), i.$$set = (Xe) => {
    "actionId" in Xe && t(0, p = Xe.actionId), "actorDocument" in Xe && t(27, m = Xe.actorDocument), "dialog" in Xe && t(28, g = Xe.dialog), "itemDocument" in Xe && t(29, h = Xe.itemDocument), "options" in Xe && t(1, _ = Xe.options);
  }, i.$$.update = () => {
    i.$$.dirty[0] & /*actionUsesData, hitDiceData, itemUsesData*/
    28 && t(30, s = {
      actionUses: U,
      hitDice: q,
      itemUses: W
    }), i.$$.dirty[0] & /*consumerData*/
    1073741824 && t(13, n = ve.validateData(s));
  }, [
    p,
    _,
    U,
    q,
    W,
    G,
    X,
    te,
    J,
    re,
    ae,
    be,
    we,
    n,
    l,
    y,
    k,
    v,
    O,
    P,
    D,
    I,
    B,
    F,
    H,
    me,
    he,
    m,
    g,
    h,
    s,
    Ae,
    Fe,
    Ve,
    je,
    Pe,
    rt,
    Te,
    Ee,
    Be,
    Ce,
    Re
  ];
}
f(aZ, "instance$3i");
var zu;
let cZ = (zu = class extends ie {
  constructor(e) {
    super(), le(
      this,
      e,
      aZ,
      lZ,
      ne,
      {
        actionId: 0,
        actorDocument: 27,
        dialog: 28,
        itemDocument: 29,
        options: 1
      },
      null,
      [-1, -1]
    );
  }
}, f(zu, "ActionActivationDialog"), zu);
var Hu, h0;
const m2 = class m2 extends Fs {
  constructor({
    actionId: t,
    actorDocument: s,
    itemDocument: n,
    options: l = {}
  }) {
    super({
      title: `${s.name}: Activate ${n.actions[t].name}`,
      content: {
        class: cZ,
        props: {
          actionId: t,
          actorDocument: s,
          itemDocument: n,
          options: l
        }
      },
      zIndex: null
    }, {
      classes: ["a5e-sheet", "a5e-activation-dialog"],
      width: 420
    });
    Y(this, Hu);
    this.data.content.props.dialog = this, this.promise = new Promise((r) => {
      this.resolve = r;
    });
  }
  /** @inheritdoc */
  close(t) {
    return Z(this, Hu, h0).call(this, null), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    return Z(this, Hu, h0).call(this, t), super.close();
  }
};
Hu = new WeakSet(), h0 = /* @__PURE__ */ f(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), f(m2, "ActionActivationDialog");
let m0 = m2;
function uZ(i) {
  let e, t, s, n, l, r, o;
  return t = new Ye({
    props: {
      heading: "Select an Action",
      options: (
        /*item*/
        i[0].actions.entries().map(o4)
      ),
      selected: (
        /*selectedAction*/
        i[1]
      )
    }
  }), t.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[4]
  ), {
    c() {
      e = E("form"), L(t.$$.fragment), s = R(), n = E("button"), n.textContent = "Activate Action", b(e, "class", "svelte-1wbwpaf");
    },
    m(a, c) {
      T(a, e, c), N(t, e, null), A(e, s), A(e, n), l = !0, r || (o = V(n, "click", tt(
        /*onSubmit*/
        i[2]
      )), r = !0);
    },
    p(a, [c]) {
      const u = {};
      c & /*item*/
      1 && (u.options = /*item*/
      a[0].actions.entries().map(o4)), c & /*selectedAction*/
      2 && (u.selected = /*selectedAction*/
      a[1]), t.$set(u);
    },
    i(a) {
      l || (w(t.$$.fragment, a), l = !0);
    },
    o(a) {
      C(t.$$.fragment, a), l = !1;
    },
    d(a) {
      a && S(e), j(t), r = !1, o();
    }
  };
}
f(uZ, "create_fragment$3q");
const o4 = /* @__PURE__ */ f(([i, e]) => [i, e.name], "func$5");
function fZ(i, e, t) {
  let { dialog: s, item: n } = fe("#external").application, { dialog: l = s, item: r = n } = e;
  function o() {
    l.submit({ actionId: a });
  }
  f(o, "onSubmit");
  let a = r.actions.keys()[0];
  const c = /* @__PURE__ */ f(({ detail: u }) => t(1, a = u), "updateSelection_handler");
  return i.$$set = (u) => {
    "dialog" in u && t(3, l = u.dialog), "item" in u && t(0, r = u.item);
  }, [r, a, o, l, c];
}
f(fZ, "instance$3h");
var Uu;
let dZ = (Uu = class extends ie {
  constructor(e) {
    super(), le(this, e, fZ, uZ, ne, { dialog: 3, item: 0 });
  }
}, f(Uu, "ActionSelectionDialog"), Uu);
var Vu, b0;
const h2 = class h2 extends Fs {
  constructor(t) {
    super({
      title: `${t.name}: Select Action`,
      content: {
        class: dZ,
        props: { item: t }
      }
    }, {
      classes: ["a5e-sheet"],
      width: 520
    });
    Y(this, Vu);
    this.data.content.props.dialog = this, this.promise = new Promise((s) => {
      this.resolve = s;
    });
  }
  /** @inheritdoc */
  close(t) {
    return Z(this, Vu, b0).call(this, null), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    return Z(this, Vu, b0).call(this, t), super.close();
  }
};
Vu = new WeakSet(), b0 = /* @__PURE__ */ f(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), f(h2, "ActionSelectionDialog");
let g0 = h2;
const g2 = class g2 {
  constructor(e) {
    return new Proxy(this, {
      get(t, s, n) {
        return s in t ? Reflect.get(t, s, n) : e[s];
      }
    });
  }
};
f(g2, "DataProxy");
let Xd = g2;
function Jd(i, e, t, s, n = null, l = 1) {
  n && !n.includes(t) ? i.update({
    [e]: t,
    [s]: l
  }) : n ? se(i, e, t) : i.update({
    [e]: t,
    [s]: l
  });
}
f(Jd, "updateAssociatedValues");
function a4(i, e, t) {
  const s = i.slice();
  return s[12] = e[t][0], s[13] = e[t][1], s;
}
f(a4, "get_each_context$1m");
function c4(i, e, t) {
  const s = i.slice();
  return s[12] = e[t][0], s[13] = e[t][1], s;
}
f(c4, "get_each_context_1$j");
function u4(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "class", "small-input"), z(e, "width", "5rem"), b(e, "id", `${/*actionId*/
      i[3]}-activation-cost`), b(e, "type", "number"), e.value = t = /*action*/
      ((l = i[1].activation) == null ? void 0 : l.cost) ?? 1;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[7]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r & /*action*/
      2 && t !== (t = /*action*/
      ((o = l[1].activation) == null ? void 0 : o.cost) ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(u4, "create_if_block_2$N");
function f4(i) {
  let e, t = K(
    /*label*/
    i[13]
  ) + "", s, n, l;
  return {
    c() {
      var r;
      e = E("option"), s = x(t), n = R(), b(
        e,
        "key",
        /*value*/
        i[12]
      ), e.__value = /*value*/
      i[12], qe(e, e.__value), e.selected = l = /*action*/
      ((r = i[1].activation) == null ? void 0 : r.type) === /*value*/
      i[12];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      var a;
      o & /*action*/
      2 && l !== (l = /*action*/
      ((a = r[1].activation) == null ? void 0 : a.type) === /*value*/
      r[12]) && (e.selected = l);
    },
    d(r) {
      r && S(e);
    }
  };
}
f(f4, "create_each_block_1$j");
function pZ(i) {
  var u, d;
  let e = (
    /*action*/
    ((u = i[1].activation) == null ? void 0 : u.type) && !/*specialActivationTypes*/
    i[5].includes(
      /*action*/
      (d = i[1].activation) == null ? void 0 : d.type
    )
  ), t, s, n, l, r, o = e && u4(i), a = oe(Object.entries(
    /*A5E*/
    i[4].abilityActivationTypes
  )), c = [];
  for (let p = 0; p < a.length; p += 1)
    c[p] = f4(c4(i, a, p));
  return {
    c() {
      o && o.c(), t = R(), s = E("select"), n = E("option");
      for (let p = 0; p < c.length; p += 1)
        c[p].c();
      n.__value = "", qe(n, n.__value), b(s, "class", "u-w-fit");
    },
    m(p, m) {
      o && o.m(p, m), T(p, t, m), T(p, s, m), A(s, n);
      for (let g = 0; g < c.length; g += 1)
        c[g] && c[g].m(s, null);
      l || (r = V(
        s,
        "change",
        /*change_handler_1*/
        i[8]
      ), l = !0);
    },
    p(p, m) {
      var g, h;
      if (m & /*action*/
      2 && (e = /*action*/
      ((g = p[1].activation) == null ? void 0 : g.type) && !/*specialActivationTypes*/
      p[5].includes(
        /*action*/
        (h = p[1].activation) == null ? void 0 : h.type
      )), e ? o ? o.p(p, m) : (o = u4(p), o.c(), o.m(t.parentNode, t)) : o && (o.d(1), o = null), m & /*Object, A5E, action*/
      18) {
        a = oe(Object.entries(
          /*A5E*/
          p[4].abilityActivationTypes
        ));
        let _;
        for (_ = 0; _ < a.length; _ += 1) {
          const y = c4(p, a, _);
          c[_] ? c[_].p(y, m) : (c[_] = f4(y), c[_].c(), c[_].m(s, null));
        }
        for (; _ < c.length; _ += 1)
          c[_].d(1);
        c.length = a.length;
      }
    },
    d(p) {
      p && (S(t), S(s)), o && o.d(p), Le(c, p), l = !1, r();
    }
  };
}
f(pZ, "create_default_slot_3$t");
function d4(i) {
  let e, t;
  return e = new de({
    props: {
      heading: "A5E.ActionActivationReactionTrigger",
      $$slots: { default: [mZ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, action, $item*/
      262147 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(d4, "create_if_block_1$1g");
function mZ(i) {
  let e, t, s, n, l;
  return {
    c() {
      var r;
      e = E("div"), t = E("input"), b(t, "class", "full-size-input"), b(t, "type", "text"), t.value = s = /*action*/
      ((r = i[1].activation) == null ? void 0 : r.reactionTrigger) ?? "", b(e, "class", "action-config__component");
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = V(
        t,
        "change",
        /*change_handler_2*/
        i[9]
      ), n = !0);
    },
    p(r, o) {
      var a;
      o & /*action*/
      2 && s !== (s = /*action*/
      ((a = r[1].activation) == null ? void 0 : a.reactionTrigger) ?? "") && t.value !== s && (t.value = s);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(mZ, "create_default_slot_2$B");
function p4(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "class", "small-input"), z(e, "width", "5rem"), b(e, "id", `${/*actionId*/
      i[3]}-duration-value`), b(e, "type", "number"), e.value = t = /*action*/
      ((l = i[1].duration) == null ? void 0 : l.value) ?? 1;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_3*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r & /*action*/
      2 && t !== (t = /*action*/
      ((o = l[1].duration) == null ? void 0 : o.value) ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(p4, "create_if_block$1U");
function m4(i) {
  let e, t = K(
    /*label*/
    i[13]
  ) + "", s, n, l;
  return {
    c() {
      var r, o;
      e = E("option"), s = x(t), n = R(), b(
        e,
        "key",
        /*value*/
        i[12]
      ), e.__value = /*value*/
      i[12], qe(e, e.__value), e.selected = l = /*action*/
      ((o = (r = i[1]) == null ? void 0 : r.duration) == null ? void 0 : o.unit) === /*value*/
      i[12];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      var a, c;
      o & /*action*/
      2 && l !== (l = /*action*/
      ((c = (a = r[1]) == null ? void 0 : a.duration) == null ? void 0 : c.unit) === /*value*/
      r[12]) && (e.selected = l);
    },
    d(r) {
      r && S(e);
    }
  };
}
f(m4, "create_each_block$1m");
function hZ(i) {
  var d, p, m, g;
  let e, t = (
    /*action*/
    ((p = (d = i[1]) == null ? void 0 : d.duration) == null ? void 0 : p.unit) && !/*specialTimeTypes*/
    i[6].includes(
      /*action*/
      (g = (m = i[1]) == null ? void 0 : m.duration) == null ? void 0 : g.unit
    )
  ), s, n, l, r, o, a = t && p4(i), c = oe(Object.entries(
    /*A5E*/
    i[4].timePeriods
  )), u = [];
  for (let h = 0; h < c.length; h += 1)
    u[h] = m4(a4(i, c, h));
  return {
    c() {
      e = E("div"), a && a.c(), s = R(), n = E("select"), l = E("option");
      for (let h = 0; h < u.length; h += 1)
        u[h].c();
      l.__value = "", qe(l, l.__value), b(n, "class", "u-w-fit"), b(e, "class", "action-config__component");
    },
    m(h, _) {
      T(h, e, _), a && a.m(e, null), A(e, s), A(e, n), A(n, l);
      for (let y = 0; y < u.length; y += 1)
        u[y] && u[y].m(n, null);
      r || (o = V(
        n,
        "change",
        /*change_handler_4*/
        i[11]
      ), r = !0);
    },
    p(h, _) {
      var y, k, v, O;
      if (_ & /*action*/
      2 && (t = /*action*/
      ((k = (y = h[1]) == null ? void 0 : y.duration) == null ? void 0 : k.unit) && !/*specialTimeTypes*/
      h[6].includes(
        /*action*/
        (O = (v = h[1]) == null ? void 0 : v.duration) == null ? void 0 : O.unit
      )), t ? a ? a.p(h, _) : (a = p4(h), a.c(), a.m(e, s)) : a && (a.d(1), a = null), _ & /*Object, A5E, action*/
      18) {
        c = oe(Object.entries(
          /*A5E*/
          h[4].timePeriods
        ));
        let P;
        for (P = 0; P < c.length; P += 1) {
          const D = a4(h, c, P);
          u[P] ? u[P].p(D, _) : (u[P] = m4(D), u[P].c(), u[P].m(n, null));
        }
        for (; P < u.length; P += 1)
          u[P].d(1);
        u.length = c.length;
      }
    },
    d(h) {
      h && S(e), a && a.d(), Le(u, h), r = !1, o();
    }
  };
}
f(hZ, "create_default_slot_1$R");
function gZ(i) {
  var a;
  let e, t, s, n, l, r;
  e = new de({
    props: {
      heading: "A5E.ItemActivationCost",
      $$slots: { default: [pZ] },
      $$scope: { ctx: i }
    }
  });
  let o = (
    /*action*/
    ((a = i[1].activation) == null ? void 0 : a.type) === "reaction" && d4(i)
  );
  return l = new de({
    props: {
      heading: "A5E.ItemDuration",
      $$slots: { default: [hZ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), o && o.c(), n = R(), L(l.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-direction", "row"), z(t, "--a5e-field-wrapper-header-width", "100%");
    },
    m(c, u) {
      T(c, t, u), N(e, t, null), T(c, s, u), o && o.m(c, u), T(c, n, u), N(l, c, u), r = !0;
    },
    p(c, u) {
      var m;
      const d = {};
      u & /*$$scope, $item, action*/
      262147 && (d.$$scope = { dirty: u, ctx: c }), e.$set(d), /*action*/
      ((m = c[1].activation) == null ? void 0 : m.type) === "reaction" ? o ? (o.p(c, u), u & /*action*/
      2 && w(o, 1)) : (o = d4(c), o.c(), w(o, 1), o.m(n.parentNode, n)) : o && (ce(), C(o, 1, 1, () => {
        o = null;
      }), ue());
      const p = {};
      u & /*$$scope, $item, action*/
      262147 && (p.$$scope = { dirty: u, ctx: c }), l.$set(p);
    },
    i(c) {
      r || (w(e.$$.fragment, c), w(o), w(l.$$.fragment, c), r = !0);
    },
    o(c) {
      C(e.$$.fragment, c), C(o), C(l.$$.fragment, c), r = !1;
    },
    d(c) {
      c && (S(s), S(n)), c && e && S(t), j(e, c), o && o.d(c), j(l, c);
    }
  };
}
f(gZ, "create_default_slot$1y");
function bZ(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "A5E.ActivationConfiguration",
      $$slots: { default: [gZ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, $item, action*/
      262147 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(bZ, "create_fragment$3p");
function _Z(i, e, t) {
  let s, n;
  const l = fe("item");
  pe(i, l, (h) => t(0, n = h));
  const r = fe("actionId"), { A5E: o } = CONFIG, a = ["none", "special"], c = ["instantaneous", "permanent", "special"], u = /* @__PURE__ */ f(({ target: h }) => se(n, `system.actions.${r}.activation.cost`, Number(h.value)), "change_handler"), d = /* @__PURE__ */ f(({ target: h }) => Jd(n, `system.actions.${r}.activation.type`, h.value, `system.actions.${r}.activation.cost`, a), "change_handler_1"), p = /* @__PURE__ */ f(({ target: h }) => se(n, `system.actions.${r}.activation.reactionTrigger`, h.value), "change_handler_2"), m = /* @__PURE__ */ f(({ target: h }) => se(n, `system.actions.${r}.duration.value`, Number(h.value)), "change_handler_3"), g = /* @__PURE__ */ f(({ target: h }) => Jd(n, `system.actions.${r}.duration.unit`, h.value, `system.actions.${r}.duration.value`, c), "change_handler_4");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1 && t(1, s = n.actions[r]);
  }, [
    n,
    s,
    l,
    r,
    o,
    a,
    c,
    u,
    d,
    p,
    m,
    g
  ];
}
f(_Z, "instance$3g");
const b2 = class b2 extends ie {
  constructor(e) {
    super(), le(this, e, _Z, bZ, ne, {});
  }
};
f(b2, "ActionsActivationTab");
let _0 = b2;
var ug;
const fg = class fg {
  /**
   * Returns true when Foundry is at least the specific major version number provided.
   *
   * @param {number}   version - Major version to check against.
   *
   * @returns {boolean} Foundry version is at least the major version specified.
   */
  static isAtLeast(e) {
    var t, s;
    if (!Number.isInteger(e) && e < 9)
      throw new TypeError("'version' is not a positive integer greater than or equals '9'.");
    return !globalThis.foundry.utils.isNewerVersion(e, globalThis.game.version ?? ((s = (t = globalThis.game) == null ? void 0 : t.data) == null ? void 0 : s.version));
  }
  /**
   * Returns true when Foundry is between the min / max major version numbers provided.
   *
   * @param {number}   min - Major minimum version to check against.
   *
   * @param {number}   max - Major maximum version to check against.
   *
   * @returns {boolean} Foundry version is at least the major version specified.
   */
  static isBetween(e, t) {
    var l, r;
    if (!Number.isInteger(e) && e < 9)
      throw new TypeError(
        "FVTTVersion.isBetween error: 'min' is not a positive integer greater than or equals '9'."
      );
    if (!Number.isInteger(t) && t < 9)
      throw new TypeError(
        "FVTTVersion.isBetween error: 'max' is not a positive integer greater than or equals '9'."
      );
    if (e > t)
      throw new TypeError("FVTTVersion.isBetween error: 'min' is greater than 'max'.");
    const s = M(this, ug).exec(globalThis.game.version ?? ((r = (l = globalThis.game) == null ? void 0 : l.data) == null ? void 0 : r.version));
    if (!s)
      throw new Error("FVTTVersion.isBetween error: Could not parse 'globalThis.game.version'.");
    const n = parseInt(s[1], 10);
    return n >= e && n <= t;
  }
};
ug = new WeakMap(), f(fg, "FVTTVersion"), Y(fg, ug, /(\d+)\./);
let Zd = fg;
var dg, gB;
const mc = class mc {
  /**
   * Collect all the font definitions and combine them.
   *
   * @returns { {[key: string]: globalThis.FontFamilyDefinition}[] } Core font definitions.
   */
  static getCoreDefinitions() {
    var t, s, n, l;
    const e = [];
    if (Zd.isAtLeast(10)) {
      let r;
      Array.isArray((t = globalThis.CONFIG) == null ? void 0 : t._fontFamilies) && (r = globalThis.CONFIG._fontFamilies.reduce((a, c) => (a[c] = { editor: !0, fonts: [] }, a), {})), Array.isArray((s = globalThis.CONFIG) == null ? void 0 : s.fontDefinitions) && e.push(globalThis.foundry.utils.duplicate(globalThis.CONFIG.fontDefinitions));
      const o = (n = globalThis.game) == null ? void 0 : n.settings.get("core", "fonts");
      Array.isArray(o) && e.push(globalThis.foundry.utils.duplicate(o)), r && e.push(r);
    } else if (Array.isArray((l = globalThis.CONFIG) == null ? void 0 : l.fontFamilies)) {
      const r = globalThis.CONFIG.fontFamilies.reduce((o, a) => (o[a] = { editor: !0, fonts: [] }, o), {});
      e.push(r);
    }
    return mc.removeDuplicateDefinitions(e), e;
  }
  /**
   * Ensure that fonts have loaded and are ready for use.
   * Enforce a maximum timeout in milliseconds.
   * Proceed after that point even if fonts are not yet available.
   *
   * @param {object} [opts] - Optional parameters.
   *
   * @param {number} [opts.ms=4500] - The maximum time to spend loading fonts before proceeding.
   *
   * @param {Document} [opts.document] - The target document to load the fonts into.
   *
   * @param {boolean} [opts.editor=true] - When true verifies the `editor` field of {@link FontFamilyDefinition}.
   *
   * @param {(
   *    {[key: string]: globalThis.FontFamilyDefinition}[] |
   *    {[key: string]: globalThis.FontFamilyDefinition}
   * )} [opts.fonts] - A custom set of font family definitions to load. If not defined the core font family definitions
   *    are loaded.
   *
   * @returns {Promise<void>}
   */
  static async loadFonts({ ms: e = 4500, document: t = globalThis.document, editor: s = !0, fonts: n } = {}) {
    const l = n ? Array.isArray(n) ? n : [n] : this.getCoreDefinitions(), r = [];
    for (const c of l)
      if (ke(c))
        for (const [u, d] of Object.entries(c)) {
          if (s && (typeof d.editor != "boolean" || !d.editor))
            continue;
          const p = `1rem "${u}"`;
          t.fonts.check(p) || r.push(Z(this, dg, gB).call(this, p, u, d, t));
        }
    const o = new Promise((c) => setTimeout(c, e)), a = Promise.all(r).then(() => t.fonts.ready);
    return Promise.race([a, o]);
  }
  /**
   * Removes duplicate font definitions.
   *
   * @param { {[key: string]: globalThis.FontFamilyDefinition}[] }  fonts - An array of FontFamilyDefinition objects
   *        to process.
   *
   * @returns { {[key: string]: globalThis.FontFamilyDefinition}[] } Filtered font definitions.
   */
  static removeDuplicateDefinitions(e) {
    if (!Array.isArray(e))
      throw new TypeError("FontManager.removeDuplicateDefinitions error: 'fonts' is not an array.");
    const t = /* @__PURE__ */ new Set();
    for (const s of e) {
      if (!ke(s))
        throw new TypeError("FontManager.removeDuplicateDefinitions error: 'definitions' is not an object.");
      for (const n of Object.keys(s))
        t.has(n) ? delete s[n] : t.add(n);
    }
    return e;
  }
};
dg = new WeakSet(), gB = /* @__PURE__ */ f(async function(e, t, s, n) {
  try {
    for (const l of s.fonts) {
      const r = l.urls.map((a) => `url("${a}")`).join(", "), o = new FontFace(t, r, l);
      await o.load(), n.fonts.add(o);
    }
    await n.fonts.load(e);
  } catch (l) {
    return console.warn(`Font family "${t}" failed to load: `, l), !1;
  }
  return n.fonts.check(e) ? !0 : (console.warn(`Font family "${t}" failed to load.`), !1);
}, "#loadFont"), /**
 * Load a font definition.
 *
 * @param {string}               fontSpecification - The font specification.
 *
 * @param {string}               family - The font family name (case-sensitive).
 *
 * @param {globalThis.FontFamilyDefinition} definition - The font family definition.
 *
 * @param {Document}             document - Target Document to load font into.
 *
 * @returns {Promise<boolean>} Returns true if the font was successfully loaded.
 */
Y(mc, dg), f(mc, "FontManager");
let Mc = mc;
var pg, an, Jo, Wu, v0;
const Il = class Il {
  /**
   * Gets the properties object associated with the selector. Try and use a direct match otherwise all keys
   * are iterated to find a selector string that includes the `selector`.
   *
   * @param {string}   selector - Selector to find.
   *
   * @returns { {[key: string]: string} } Properties object.
   */
  static getProperties(e) {
    if (M(this, Jo) || Z(this, Wu, v0).call(this), M(this, an).has(e))
      return M(this, an).get(e);
    for (const t of M(this, an).keys())
      if (t.includes(e))
        return M(this, an).get(t);
  }
  /**
   * Gets a specific property value from the given `selector` and `property` key. Try and use a direct selector
   * match otherwise all keys are iterated to find a selector string that includes `selector`.
   *
   * @param {string}   selector - Selector to find.
   *
   * @param {string}   property - Specific property to locate.
   *
   * @returns {string|undefined} Property value.
   */
  static getProperty(e, t) {
    if (M(this, Jo) || Z(this, Wu, v0).call(this), M(this, an).has(e)) {
      const s = M(this, an).get(e);
      return ke(s) && t in s ? s[t] : void 0;
    }
    for (const s of M(this, an).keys())
      if (s.includes(e)) {
        const n = M(this, an).get(s);
        if (ke(n) && t in n)
          return n[t];
      }
  }
};
pg = new WeakMap(), an = new WeakMap(), Jo = new WeakMap(), Wu = new WeakSet(), v0 = /* @__PURE__ */ f(function() {
  ye(this, Jo, !0);
  const e = Array.from(document.styleSheets).filter((n) => n.href !== null);
  let t;
  const s = globalThis.foundry.utils.getRoute("/css/style.css");
  for (const n of e) {
    let l;
    try {
      l = new URL(n.href);
    } catch {
      continue;
    }
    if (typeof l.pathname == "string" && l.pathname === s) {
      ye(this, pg, t = n);
      break;
    }
  }
  if (t)
    for (const n of t.cssRules) {
      if (!(n instanceof CSSStyleRule))
        continue;
      const l = {};
      for (const r of n.style.cssText.split(";")) {
        const o = r.split(":");
        o.length < 2 || (l[o[0].trim()] = o[1].trim());
      }
      M(this, an).set(n.selectorText, l);
    }
}, "#initialize"), /**
 * Called once on initialization / first usage. Parses the core foundry style sheet.
 */
Y(Il, Wu), f(Il, "FoundryStyles"), Y(Il, pg, void 0), /** @type {Map<string, {[key: string]: string}>} */
Y(Il, an, /* @__PURE__ */ new Map()), Y(Il, Jo, !1);
let y0 = Il;
const Ma = new Pd({ docKey: "#__tjs-root-styles", version: 1 });
function yZ(i) {
  let e, t, s, n, l, r, o, a;
  return {
    c() {
      e = E("div"), t = E("a"), s = E("i"), b(s, "class", n = ni(
        /*icon*/
        i[0]
      ) + " svelte-f8994r"), b(t, "role", "button"), b(t, "tabindex", "0"), b(t, "title", l = K(
        /*title*/
        i[1]
      )), b(t, "class", "svelte-f8994r"), b(e, "class", "tjs-icon-button svelte-f8994r");
    },
    m(c, u) {
      T(c, e, u), A(e, t), A(t, s), o || (a = [
        V(
          t,
          "click",
          /*onClick*/
          i[4]
        ),
        V(
          t,
          "contextmenu",
          /*onContextMenuPress*/
          i[5]
        ),
        V(
          t,
          "keydown",
          /*onKeydown*/
          i[6]
        ),
        V(
          t,
          "keyup",
          /*onKeyup*/
          i[7]
        ),
        V(
          t,
          "click",
          /*click_handler*/
          i[13]
        ),
        V(
          t,
          "contextmenu",
          /*contextmenu_handler*/
          i[14]
        ),
        At(
          /*efx*/
          i[3].call(null, t)
        ),
        At(r = Rs.call(
          null,
          e,
          /*styles*/
          i[2]
        ))
      ], o = !0);
    },
    p(c, [u]) {
      u & /*icon*/
      1 && n !== (n = ni(
        /*icon*/
        c[0]
      ) + " svelte-f8994r") && b(s, "class", n), u & /*title*/
      2 && l !== (l = K(
        /*title*/
        c[1]
      )) && b(t, "title", l), r && $t(r.update) && u & /*styles*/
      4 && r.update.call(
        null,
        /*styles*/
        c[2]
      );
    },
    i: ee,
    o: ee,
    d(c) {
      c && S(e), o = !1, Ne(a);
    }
  };
}
f(yZ, "create_fragment$3o");
function vZ(i, e, t) {
  let { button: s = void 0 } = e, { icon: n = void 0 } = e, { title: l = void 0 } = e, { styles: r = void 0 } = e, { efx: o = void 0 } = e, { keyCode: a = void 0 } = e, { onPress: c = void 0 } = e, { onContextMenu: u = void 0 } = e, { onClickPropagate: d = void 0 } = e;
  const p = it();
  function m(v) {
    typeof c == "function" && c(), p("press"), d || (v.preventDefault(), v.stopPropagation());
  }
  f(m, "onClick");
  function g(v) {
    typeof u == "function" && u(), d || (v.preventDefault(), v.stopPropagation());
  }
  f(g, "onContextMenuPress");
  function h(v) {
    v.code === a && (v.preventDefault(), v.stopPropagation());
  }
  f(h, "onKeydown");
  function _(v) {
    v.code === a && (typeof c == "function" && c(), p("press"), v.preventDefault(), v.stopPropagation());
  }
  f(_, "onKeyup");
  function y(v) {
    gt.call(this, i, v);
  }
  f(y, "click_handler");
  function k(v) {
    gt.call(this, i, v);
  }
  return f(k, "contextmenu_handler"), i.$$set = (v) => {
    "button" in v && t(12, s = v.button), "icon" in v && t(0, n = v.icon), "title" in v && t(1, l = v.title), "styles" in v && t(2, r = v.styles), "efx" in v && t(3, o = v.efx), "keyCode" in v && t(8, a = v.keyCode), "onPress" in v && t(9, c = v.onPress), "onContextMenu" in v && t(10, u = v.onContextMenu), "onClickPropagate" in v && t(11, d = v.onClickPropagate);
  }, i.$$.update = () => {
    i.$$.dirty & /*button, icon*/
    4097 && t(0, n = ke(s) && typeof s.icon == "string" ? s.icon : typeof n == "string" ? n : ""), i.$$.dirty & /*button, title*/
    4098 && t(1, l = ke(s) && typeof s.title == "string" ? s.title : typeof l == "string" ? l : ""), i.$$.dirty & /*button, styles*/
    4100 && t(2, r = ke(s) && ke(s.styles) ? s.styles : ke(r) ? r : void 0), i.$$.dirty & /*button, efx*/
    4104 && t(3, o = ke(s) && typeof s.efx == "function" ? s.efx : typeof o == "function" ? o : () => {
    }), i.$$.dirty & /*button, keyCode*/
    4352 && t(8, a = ke(s) && typeof s.keyCode == "string" ? s.keyCode : typeof a == "string" ? a : "Enter"), i.$$.dirty & /*button, onPress*/
    4608 && t(9, c = ke(s) && typeof s.onPress == "function" ? s.onPress : typeof c == "function" ? c : void 0), i.$$.dirty & /*button, onContextMenu*/
    5120 && t(10, u = ke(s) && typeof s.onContextMenu == "function" ? s.onContextMenu : typeof u == "function" ? u : void 0), i.$$.dirty & /*button, onClickPropagate*/
    6144 && t(11, d = ke(s) && typeof s.onClickPropagate == "boolean" ? s.onClickPropagate : typeof d == "boolean" ? d : !1);
  }, [
    n,
    l,
    r,
    o,
    m,
    g,
    h,
    _,
    a,
    c,
    u,
    d,
    s,
    y,
    k
  ];
}
f(vZ, "instance$3f");
const _2 = class _2 extends ie {
  constructor(e) {
    super(), le(this, e, vZ, yZ, ne, {
      button: 12,
      icon: 0,
      title: 1,
      styles: 2,
      efx: 3,
      keyCode: 8,
      onPress: 9,
      onContextMenu: 10,
      onClickPropagate: 11
    });
  }
};
f(_2, "TJSIconButton");
let ya = _2;
function h4(i) {
  let e;
  const t = (
    /*#slots*/
    i[23].default
  ), s = Pt(
    t,
    i,
    /*$$scope*/
    i[22],
    null
  );
  return {
    c() {
      s && s.c();
    },
    m(n, l) {
      s && s.m(n, l), e = !0;
    },
    p(n, l) {
      s && s.p && (!e || l & /*$$scope*/
      4194304) && Rt(
        s,
        t,
        n,
        /*$$scope*/
        n[22],
        e ? Mt(
          t,
          /*$$scope*/
          n[22],
          l,
          null
        ) : Ft(
          /*$$scope*/
          n[22]
        ),
        null
      );
    },
    i(n) {
      e || (w(s, n), e = !0);
    },
    o(n) {
      C(s, n), e = !1;
    },
    d(n) {
      s && s.d(n);
    }
  };
}
f(h4, "create_if_block$1T");
function kZ(i) {
  let e, t, s, n, l, r, o, a, c, u, d = (
    /*selected*/
    i[4] && h4(i)
  );
  return {
    c() {
      e = E("div"), t = E("a"), s = E("i"), r = R(), d && d.c(), b(s, "class", n = ni(
        /*icon*/
        i[0]
      ) + " svelte-1pmmjvy"), Q(
        s,
        "selected",
        /*selected*/
        i[4]
      ), b(t, "role", "button"), b(t, "tabindex", "0"), b(t, "title", l = K(
        /*titleCurrent*/
        i[6]
      )), b(t, "class", "svelte-1pmmjvy"), Q(
        t,
        "selected",
        /*selected*/
        i[4]
      ), b(e, "class", "tjs-toggle-icon-button svelte-1pmmjvy"), b(e, "role", "button");
    },
    m(p, m) {
      T(p, e, m), A(e, t), A(t, s), i[26](t), A(e, r), d && d.m(e, null), a = !0, c || (u = [
        V(
          t,
          "click",
          /*onClick*/
          i[7]
        ),
        V(
          t,
          "contextmenu",
          /*onContextMenuPress*/
          i[8]
        ),
        V(
          t,
          "keydown",
          /*onKeydown*/
          i[11]
        ),
        V(
          t,
          "keyup",
          /*onKeyup*/
          i[12]
        ),
        V(
          t,
          "click",
          /*click_handler*/
          i[24]
        ),
        V(
          t,
          "contextmenu",
          /*contextmenu_handler*/
          i[25]
        ),
        At(
          /*efx*/
          i[3].call(null, t)
        ),
        V(
          e,
          "click",
          /*onClickDiv*/
          i[9]
        ),
        V(
          e,
          "close:popup",
          /*onClosePopup*/
          i[10]
        ),
        At(o = Rs.call(
          null,
          e,
          /*styles*/
          i[2]
        ))
      ], c = !0);
    },
    p(p, [m]) {
      (!a || m & /*icon*/
      1 && n !== (n = ni(
        /*icon*/
        p[0]
      ) + " svelte-1pmmjvy")) && b(s, "class", n), (!a || m & /*icon, selected*/
      17) && Q(
        s,
        "selected",
        /*selected*/
        p[4]
      ), (!a || m & /*titleCurrent*/
      64 && l !== (l = K(
        /*titleCurrent*/
        p[6]
      ))) && b(t, "title", l), (!a || m & /*selected*/
      16) && Q(
        t,
        "selected",
        /*selected*/
        p[4]
      ), /*selected*/
      p[4] ? d ? (d.p(p, m), m & /*selected*/
      16 && w(d, 1)) : (d = h4(p), d.c(), w(d, 1), d.m(e, null)) : d && (ce(), C(d, 1, 1, () => {
        d = null;
      }), ue()), o && $t(o.update) && m & /*styles*/
      4 && o.update.call(
        null,
        /*styles*/
        p[2]
      );
    },
    i(p) {
      a || (w(d), a = !0);
    },
    o(p) {
      C(d), a = !1;
    },
    d(p) {
      p && S(e), i[26](null), d && d.d(), c = !1, Ne(u);
    }
  };
}
f(kZ, "create_fragment$3n");
function wZ(i, e, t) {
  let s, n, l = ee, r = /* @__PURE__ */ f(() => (l(), l = Et(m, (J) => t(21, n = J)), m), "$$subscribe_store");
  i.$$.on_destroy.push(() => l());
  let { $$slots: o = {}, $$scope: a } = e, { button: c = void 0 } = e, { icon: u = void 0 } = e, { title: d = void 0 } = e, { titleSelected: p = void 0 } = e, { store: m = void 0 } = e;
  r();
  let { styles: g = void 0 } = e, { efx: h = void 0 } = e, { keyCode: _ = void 0 } = e, { onPress: y = void 0 } = e, { onClose: k = void 0 } = e, { onContextMenu: v = void 0 } = e, { onClickPropagate: O = void 0 } = e;
  const P = it();
  let D, I = !1;
  function B(J) {
    t(4, I = !I), m && m.set(I), typeof y == "function" && y(I), P("press", { selected: I }), O || (J.preventDefault(), J.stopPropagation());
  }
  f(B, "onClick");
  function F(J) {
    typeof v == "function" && v(), O || (J.preventDefault(), J.stopPropagation());
  }
  f(F, "onContextMenuPress");
  function H(J) {
    O || (J.preventDefault(), J.stopPropagation());
  }
  f(H, "onClickDiv");
  function G(J) {
    var re;
    t(4, I = !1), m && m.set(!1), typeof k == "function" && k(I), typeof ((re = J == null ? void 0 : J.detail) == null ? void 0 : re.keyboardFocus) == "boolean" && J.detail.keyboardFocus && (D != null && D.isConnected) && (D.focus(), J.stopPropagation(), J.preventDefault());
  }
  f(G, "onClosePopup");
  function U(J) {
    J.code === _ && (J.preventDefault(), J.stopPropagation());
  }
  f(U, "onKeydown");
  function q(J) {
    J.code === _ && (t(4, I = !I), m && m.set(I), typeof y == "function" && y(I), P("press", { selected: I }), J.preventDefault(), J.stopPropagation());
  }
  f(q, "onKeyup");
  function W(J) {
    gt.call(this, i, J);
  }
  f(W, "click_handler");
  function X(J) {
    gt.call(this, i, J);
  }
  f(X, "contextmenu_handler");
  function te(J) {
    st[J ? "unshift" : "push"](() => {
      D = J, t(5, D);
    });
  }
  return f(te, "a_binding"), i.$$set = (J) => {
    "button" in J && t(20, c = J.button), "icon" in J && t(0, u = J.icon), "title" in J && t(13, d = J.title), "titleSelected" in J && t(14, p = J.titleSelected), "store" in J && r(t(1, m = J.store)), "styles" in J && t(2, g = J.styles), "efx" in J && t(3, h = J.efx), "keyCode" in J && t(15, _ = J.keyCode), "onPress" in J && t(16, y = J.onPress), "onClose" in J && t(17, k = J.onClose), "onContextMenu" in J && t(18, v = J.onContextMenu), "onClickPropagate" in J && t(19, O = J.onClickPropagate), "$$scope" in J && t(22, a = J.$$scope);
  }, i.$$.update = () => {
    i.$$.dirty & /*button, icon*/
    1048577 && t(0, u = ke(c) && typeof c.icon == "string" ? c.icon : typeof u == "string" ? u : ""), i.$$.dirty & /*button, title*/
    1056768 && t(13, d = ke(c) && typeof c.title == "string" ? c.title : typeof d == "string" ? d : ""), i.$$.dirty & /*button, titleSelected*/
    1064960 && t(14, p = ke(c) && typeof c.titleSelected == "string" ? c.titleSelected : typeof p == "string" ? p : ""), i.$$.dirty & /*button, store*/
    1048578 && r(t(1, m = ke(c) && pl(c.store) ? c.store : pl(m) ? m : void 0)), i.$$.dirty & /*button, styles*/
    1048580 && t(2, g = ke(c) && ke(c.styles) ? c.styles : ke(g) ? g : void 0), i.$$.dirty & /*button, efx*/
    1048584 && t(3, h = ke(c) && typeof c.efx == "function" ? c.efx : typeof h == "function" ? h : () => {
    }), i.$$.dirty & /*button, keyCode*/
    1081344 && t(15, _ = ke(c) && typeof c.keyCode == "string" ? c.keyCode : typeof _ == "string" ? _ : "Enter"), i.$$.dirty & /*button, onPress*/
    1114112 && t(16, y = ke(c) && typeof c.onPress == "function" ? c.onPress : typeof y == "function" ? y : void 0), i.$$.dirty & /*button, onClose*/
    1179648 && t(17, k = ke(c) && typeof c.onClose == "function" ? c.onClose : typeof k == "function" ? k : void 0), i.$$.dirty & /*button, onContextMenu*/
    1310720 && t(18, v = ke(c) && typeof c.onContextMenu == "function" ? c.onContextMenu : typeof v == "function" ? v : void 0), i.$$.dirty & /*button, onClickPropagate*/
    1572864 && t(19, O = ke(c) && typeof c.onClickPropagate == "boolean" ? c.onClickPropagate : typeof O == "boolean" ? O : !1), i.$$.dirty & /*store, $store*/
    2097154 && m && t(4, I = n), i.$$.dirty & /*selected, titleSelected, title*/
    24592 && t(6, s = I && p !== "" ? p : d);
  }, [
    u,
    m,
    g,
    h,
    I,
    D,
    s,
    B,
    F,
    H,
    G,
    U,
    q,
    d,
    p,
    _,
    y,
    k,
    v,
    O,
    c,
    n,
    a,
    o,
    W,
    X,
    te
  ];
}
f(wZ, "instance$3e");
const y2 = class y2 extends ie {
  constructor(e) {
    super(), le(this, e, wZ, kZ, ne, {
      button: 20,
      icon: 0,
      title: 13,
      titleSelected: 14,
      store: 1,
      styles: 2,
      efx: 3,
      keyCode: 15,
      onPress: 16,
      onClose: 17,
      onContextMenu: 18,
      onClickPropagate: 19
    });
  }
};
f(y2, "TJSToggleIconButton");
let Qd = y2;
function $Z(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("div"), t = E("input"), b(t, "class", "tjs-input svelte-1lqnchb"), b(t, "type", "number"), b(
        t,
        "max",
        /*max*/
        i[1]
      ), b(
        t,
        "min",
        /*min*/
        i[2]
      ), b(
        t,
        "step",
        /*step*/
        i[4]
      ), b(
        t,
        "placeholder",
        /*placeholder*/
        i[3]
      ), t.disabled = /*disabled*/
      i[0], Q(t, "is-value-invalid", !/*$storeIsValid*/
      i[10]), b(e, "class", "tjs-input-container svelte-1lqnchb");
    },
    m(r, o) {
      T(r, e, o), A(e, t), i[16](t), qe(
        t,
        /*$store*/
        i[11]
      ), n || (l = [
        V(
          t,
          "input",
          /*input_1_input_handler*/
          i[17]
        ),
        V(
          t,
          "focusin",
          /*onFocusIn*/
          i[12]
        ),
        V(
          t,
          "keydown",
          /*onKeyDown*/
          i[13]
        ),
        At(
          /*efx*/
          i[8].call(null, e)
        ),
        At(s = Rs.call(
          null,
          e,
          /*styles*/
          i[7]
        ))
      ], n = !0);
    },
    p(r, [o]) {
      o & /*max*/
      2 && b(
        t,
        "max",
        /*max*/
        r[1]
      ), o & /*min*/
      4 && b(
        t,
        "min",
        /*min*/
        r[2]
      ), o & /*step*/
      16 && b(
        t,
        "step",
        /*step*/
        r[4]
      ), o & /*placeholder*/
      8 && b(
        t,
        "placeholder",
        /*placeholder*/
        r[3]
      ), o & /*disabled*/
      1 && (t.disabled = /*disabled*/
      r[0]), o & /*$store*/
      2048 && ii(t.value) !== /*$store*/
      r[11] && qe(
        t,
        /*$store*/
        r[11]
      ), o & /*$storeIsValid*/
      1024 && Q(t, "is-value-invalid", !/*$storeIsValid*/
      r[10]), s && $t(s.update) && o & /*styles*/
      128 && s.update.call(
        null,
        /*styles*/
        r[7]
      );
    },
    i: ee,
    o: ee,
    d(r) {
      r && S(e), i[16](null), n = !1, Ne(l);
    }
  };
}
f($Z, "create_fragment$3m");
function AZ(i, e, t) {
  let s, n = ee, l = /* @__PURE__ */ f(() => (n(), n = Et(y, (G) => t(10, s = G)), y), "$$subscribe_storeIsValid"), r, o = ee, a = /* @__PURE__ */ f(() => (o(), o = Et(_, (G) => t(11, r = G)), _), "$$subscribe_store");
  i.$$.on_destroy.push(() => n()), i.$$.on_destroy.push(() => o());
  let { input: c = void 0 } = e, { disabled: u = void 0 } = e, { options: d = void 0 } = e, { max: p = void 0 } = e, { min: m = void 0 } = e, { placeholder: g = void 0 } = e, { step: h = void 0 } = e, { store: _ = void 0 } = e;
  a();
  let { storeIsValid: y = void 0 } = e;
  l();
  let { styles: k = void 0 } = e, { efx: v = void 0 } = e;
  const O = {
    blurOnEnterKey: !0,
    cancelOnEscKey: !1
  };
  let P, D;
  function I() {
    O.cancelOnEscKey && (D = P.value === "" ? null : globalThis.parseFloat(P.value));
  }
  f(I, "onFocusIn");
  function B(G) {
    if (O.blurOnEnterKey && G.code === "Enter") {
      G.preventDefault(), G.stopPropagation(), P.blur();
      return;
    }
    G.code === "Escape" && O.cancelOnEscKey && (D === null || typeof D == "number") && (G.preventDefault(), G.stopPropagation(), _.set(D), D = void 0, P.blur());
  }
  f(B, "onKeyDown");
  function F(G) {
    st[G ? "unshift" : "push"](() => {
      P = G, t(9, P);
    });
  }
  f(F, "input_1_binding");
  function H() {
    r = ii(this.value), _.set(r);
  }
  return f(H, "input_1_input_handler"), i.$$set = (G) => {
    "input" in G && t(15, c = G.input), "disabled" in G && t(0, u = G.disabled), "options" in G && t(14, d = G.options), "max" in G && t(1, p = G.max), "min" in G && t(2, m = G.min), "placeholder" in G && t(3, g = G.placeholder), "step" in G && t(4, h = G.step), "store" in G && a(t(5, _ = G.store)), "storeIsValid" in G && l(t(6, y = G.storeIsValid)), "styles" in G && t(7, k = G.styles), "efx" in G && t(8, v = G.efx);
  }, i.$$.update = () => {
    i.$$.dirty & /*input, disabled*/
    32769 && t(0, u = ke(c) && typeof c.disabled == "boolean" ? c.disabled : typeof u == "boolean" ? u : !1), i.$$.dirty & /*input, options*/
    49152 && (t(14, d = ke(c) && ke(c.options) ? c.options : ke(d) ? d : {}), typeof (d == null ? void 0 : d.blurOnEnterKey) == "boolean" && (O.blurOnEnterKey = d.blurOnEnterKey), typeof (d == null ? void 0 : d.cancelOnEscKey) == "boolean" && (O.cancelOnEscKey = d.cancelOnEscKey)), i.$$.dirty & /*input, max*/
    32770 && t(1, p = ke(c) && typeof c.max == "number" ? c.max : typeof p == "number" ? p : void 0), i.$$.dirty & /*input, min*/
    32772 && t(2, m = ke(c) && typeof c.min == "number" ? c.min : typeof m == "number" ? m : void 0), i.$$.dirty & /*input, placeholder*/
    32776 && t(3, g = ke(c) && typeof c.placeholder == "string" ? K(c.placeholder) : typeof g == "string" ? K(g) : void 0), i.$$.dirty & /*input, step*/
    32784 && t(4, h = ke(c) && typeof c.step == "number" ? c.step : typeof h == "number" ? h : void 0), i.$$.dirty & /*input, store*/
    32800 && a(t(5, _ = ke(c) && pl(c.store) ? c.store : pl(_) ? _ : It(void 0))), i.$$.dirty & /*input, storeIsValid*/
    32832 && l(t(6, y = ke(c) && Kr(c.storeIsValid) ? c.storeIsValid : Kr(y) ? y : It(!0))), i.$$.dirty & /*input, storeIsValid*/
    32832 && l(t(6, y = ke(c) && Kr(c.storeIsValid) ? c.storeIsValid : Kr(y) ? y : It(!0))), i.$$.dirty & /*input, styles*/
    32896 && t(7, k = ke(c) && ke(c.styles) ? c.styles : ke(k) ? k : void 0), i.$$.dirty & /*input, efx*/
    33024 && t(8, v = ke(c) && typeof c.efx == "function" ? c.efx : typeof v == "function" ? v : () => {
    });
  }, [
    u,
    p,
    m,
    g,
    h,
    _,
    y,
    k,
    v,
    P,
    s,
    r,
    I,
    B,
    d,
    c,
    F,
    H
  ];
}
f(AZ, "instance$3d");
const v2 = class v2 extends ie {
  constructor(e) {
    super(), le(this, e, AZ, $Z, ne, {
      input: 15,
      disabled: 0,
      options: 14,
      max: 1,
      min: 2,
      placeholder: 3,
      step: 4,
      store: 5,
      storeIsValid: 6,
      styles: 7,
      efx: 8
    });
  }
};
f(v2, "TJSInputNumber");
let k0 = v2;
function EZ(i) {
  let e, t, s, n, l, r = [
    { class: "tjs-input" },
    { type: (
      /*type*/
      i[0]
    ) },
    { placeholder: (
      /*placeholder*/
      i[2]
    ) },
    { disabled: (
      /*disabled*/
      i[1]
    ) }
  ], o = {};
  for (let a = 0; a < r.length; a += 1)
    o = fs(o, r[a]);
  return {
    c() {
      e = E("div"), t = E("input"), yd(t, o), Q(t, "is-value-invalid", !/*$storeIsValid*/
      i[8]), Q(t, "svelte-dc9eoa", !0), b(e, "class", "tjs-input-container svelte-dc9eoa");
    },
    m(a, c) {
      T(a, e, c), A(e, t), t.autofocus && t.focus(), i[14](t), qe(
        t,
        /*$store*/
        i[9]
      ), n || (l = [
        V(
          t,
          "input",
          /*input_1_input_handler*/
          i[15]
        ),
        V(
          t,
          "focusin",
          /*onFocusIn*/
          i[10]
        ),
        V(
          t,
          "keydown",
          /*onKeyDown*/
          i[11]
        ),
        At(
          /*efx*/
          i[6].call(null, e)
        ),
        At(s = Rs.call(
          null,
          e,
          /*styles*/
          i[5]
        ))
      ], n = !0);
    },
    p(a, [c]) {
      yd(t, o = hs(r, [
        { class: "tjs-input" },
        c & /*type*/
        1 && { type: (
          /*type*/
          a[0]
        ) },
        c & /*placeholder*/
        4 && { placeholder: (
          /*placeholder*/
          a[2]
        ) },
        c & /*disabled*/
        2 && { disabled: (
          /*disabled*/
          a[1]
        ) }
      ])), c & /*$store*/
      512 && t.value !== /*$store*/
      a[9] && qe(
        t,
        /*$store*/
        a[9]
      ), Q(t, "is-value-invalid", !/*$storeIsValid*/
      a[8]), Q(t, "svelte-dc9eoa", !0), s && $t(s.update) && c & /*styles*/
      32 && s.update.call(
        null,
        /*styles*/
        a[5]
      );
    },
    i: ee,
    o: ee,
    d(a) {
      a && S(e), i[14](null), n = !1, Ne(l);
    }
  };
}
f(EZ, "create_fragment$3l");
function SZ(i, e, t) {
  let s, n = ee, l = /* @__PURE__ */ f(() => (n(), n = Et(h, (F) => t(8, s = F)), h), "$$subscribe_storeIsValid"), r, o = ee, a = /* @__PURE__ */ f(() => (o(), o = Et(g, (F) => t(9, r = F)), g), "$$subscribe_store");
  i.$$.on_destroy.push(() => n()), i.$$.on_destroy.push(() => o());
  let { input: c = void 0 } = e, { type: u = void 0 } = e, { disabled: d = void 0 } = e, { options: p = void 0 } = e, { placeholder: m = void 0 } = e, { store: g = void 0 } = e;
  a();
  let { storeIsValid: h = void 0 } = e;
  l();
  let { styles: _ = void 0 } = e, { efx: y = void 0 } = e;
  const k = {
    blurOnEnterKey: !0,
    cancelOnEscKey: !1,
    clearOnEscKey: !1
  };
  let v, O;
  function P(F) {
    O = k.cancelOnEscKey ? v.value : void 0;
  }
  f(P, "onFocusIn");
  function D(F) {
    if (k.blurOnEnterKey && F.code === "Enter") {
      F.preventDefault(), F.stopPropagation(), v.blur();
      return;
    }
    F.code === "Escape" && (k.cancelOnEscKey && typeof O == "string" ? (F.preventDefault(), F.stopPropagation(), g.set(O), O = void 0, v.blur()) : k.clearOnEscKey && (F.preventDefault(), F.stopPropagation(), g.set(""), v.blur()));
  }
  f(D, "onKeyDown");
  function I(F) {
    st[F ? "unshift" : "push"](() => {
      v = F, t(7, v);
    });
  }
  f(I, "input_1_binding");
  function B() {
    r = this.value, g.set(r);
  }
  return f(B, "input_1_input_handler"), i.$$set = (F) => {
    "input" in F && t(13, c = F.input), "type" in F && t(0, u = F.type), "disabled" in F && t(1, d = F.disabled), "options" in F && t(12, p = F.options), "placeholder" in F && t(2, m = F.placeholder), "store" in F && a(t(3, g = F.store)), "storeIsValid" in F && l(t(4, h = F.storeIsValid)), "styles" in F && t(5, _ = F.styles), "efx" in F && t(6, y = F.efx);
  }, i.$$.update = () => {
    if (i.$$.dirty & /*input, type*/
    8193)
      switch (t(0, u = ke(c) && typeof c.type == "string" ? c.type : typeof u == "string" ? u : "text"), u) {
        case "email":
        case "password":
        case "search":
        case "text":
        case "url":
          break;
        default:
          throw new Error("'TJSInputText only supports text input types: 'email', 'password', 'search', 'text', 'url'.");
      }
    i.$$.dirty & /*input, disabled*/
    8194 && t(1, d = ke(c) && typeof c.disabled == "boolean" ? c.disabled : typeof d == "boolean" ? d : !1), i.$$.dirty & /*input, options*/
    12288 && (t(12, p = ke(c) && ke(c.options) ? c.options : ke(p) ? p : {}), typeof (p == null ? void 0 : p.blurOnEnterKey) == "boolean" && (k.blurOnEnterKey = p.blurOnEnterKey), typeof (p == null ? void 0 : p.cancelOnEscKey) == "boolean" && (k.cancelOnEscKey = p.cancelOnEscKey), typeof (p == null ? void 0 : p.clearOnEscKey) == "boolean" && (k.clearOnEscKey = p.clearOnEscKey)), i.$$.dirty & /*input, placeholder*/
    8196 && t(2, m = ke(c) && typeof c.placeholder == "string" ? K(c.placeholder) : typeof m == "string" ? K(m) : void 0), i.$$.dirty & /*input, store*/
    8200 && a(t(3, g = ke(c) && pl(c.store) ? c.store : pl(g) ? g : It(void 0))), i.$$.dirty & /*input, storeIsValid*/
    8208 && l(t(4, h = ke(c) && Kr(c.storeIsValid) ? c.storeIsValid : Kr(h) ? h : It(!0))), i.$$.dirty & /*input, styles*/
    8224 && t(5, _ = ke(c) && ke(c.styles) ? c.styles : ke(_) ? _ : void 0), i.$$.dirty & /*input, efx*/
    8256 && t(6, y = ke(c) && typeof c.efx == "function" ? c.efx : typeof y == "function" ? y : () => {
    });
  }, [
    u,
    d,
    m,
    g,
    h,
    _,
    y,
    v,
    s,
    r,
    P,
    D,
    p,
    c,
    I,
    B
  ];
}
f(SZ, "instance$3c");
const k2 = class k2 extends ie {
  constructor(e) {
    super(), le(this, e, SZ, EZ, ne, {
      input: 13,
      type: 0,
      disabled: 1,
      options: 12,
      placeholder: 2,
      store: 3,
      storeIsValid: 4,
      styles: 5,
      efx: 6
    });
  }
};
f(k2, "TJSInputText");
let w0 = k2;
function TZ(i) {
  let e, t, s;
  var n = (
    /*component*/
    i[1]
  );
  function l(r, o) {
    return { props: { input: (
      /*input*/
      r[0]
    ) } };
  }
  return f(l, "switch_props"), n && (e = nt(n, l(i))), {
    c() {
      e && L(e.$$.fragment), t = $e();
    },
    m(r, o) {
      e && N(e, r, o), T(r, t, o), s = !0;
    },
    p(r, [o]) {
      if (o & /*component*/
      2 && n !== (n = /*component*/
      r[1])) {
        if (e) {
          ce();
          const a = e;
          C(a.$$.fragment, 1, 0, () => {
            j(a, 1);
          }), ue();
        }
        n ? (e = nt(n, l(r)), L(e.$$.fragment), w(e.$$.fragment, 1), N(e, t.parentNode, t)) : e = null;
      } else if (n) {
        const a = {};
        o & /*input*/
        1 && (a.input = /*input*/
        r[0]), e.$set(a);
      }
    },
    i(r) {
      s || (e && w(e.$$.fragment, r), s = !0);
    },
    o(r) {
      e && C(e.$$.fragment, r), s = !1;
    },
    d(r) {
      r && S(t), e && j(e, r);
    }
  };
}
f(TZ, "create_fragment$3k");
function CZ(i, e, t) {
  let { input: s = void 0 } = e, n;
  return i.$$set = (l) => {
    "input" in l && t(0, s = l.input);
  }, i.$$.update = () => {
    if (i.$$.dirty & /*input*/
    1)
      switch (ke(s) && typeof s.type == "string" ? s.type : "text") {
        case "email":
        case "password":
        case "search":
        case "text":
        case "url":
          t(1, n = w0);
          break;
        case "number":
          t(1, n = k0);
          break;
        default:
          throw new Error("'TJSInput' currently only supports text input types: 'email', 'number', 'password', 'search', 'text', 'url'.");
      }
  }, [s, n];
}
f(CZ, "instance$3b");
const w2 = class w2 extends ie {
  constructor(e) {
    super(), le(this, e, CZ, TZ, ne, { input: 0 });
  }
};
f(w2, "TJSInput");
let xd = w2;
globalThis.ProseMirror && globalThis.ProseMirror.ProseMirrorKeyMaps;
globalThis.ProseMirror && globalThis.ProseMirror.Plugin;
var mg, hg;
const Qr = class Qr {
  static beforeInputHandler(e, t, s, n) {
    if (n === void 0 || e.plugins.wordcount === void 0 || !(t != null && t.isTrusted))
      return;
    const l = t.inputType;
    if (l === "deleteContentBackward" || l === "deleteContentForward" || e.plugins.wordcount.selection.getCharacterCount() > 0 && l === "insertText")
      return;
    if (e.plugins.wordcount.body.getCharacterCount() >= n)
      return t.preventDefault(), t.stopPropagation(), !1;
  }
  static hasEnterKeyHandler(e) {
    return typeof e.preventEnterKey == "boolean" && e.preventEnterKey || typeof e.saveOnEnterKey == "boolean" && e.saveOnEnterKey;
  }
  static get isV5() {
    var e;
    return ((e = globalThis.tinymce) == null ? void 0 : e.majorVersion) === "5";
  }
  static get isV6() {
    var e;
    return ((e = globalThis.tinymce) == null ? void 0 : e.majorVersion) === "6";
  }
  static keydownHandler(e, t, s, n, l) {
    switch (t.code) {
      case "Enter":
        if (Qr.hasEnterKeyHandler(s))
          return t.preventDefault(), t.stopPropagation(), typeof s.saveOnEnterKey == "boolean" && s.saveOnEnterKey && n(), !1;
        break;
      case "Escape":
        e.resetContent(l), setTimeout(() => n(), 0);
        break;
    }
  }
  /**
   * Provides a mechanism to load core Foundry fonts and any additional font family definitions. The returned data
   * includes the parsed font family definitions and the configuration data TinyMCE needs for loading the font formats.
   *
   * @param { {[key: string]: globalThis.FontFamilyDefinition} }  [extraFonts] - Extra user defined fonts to load.
   *
   * @returns { {fonts: {[key: string]: globalThis.FontFamilyDefinition}[], fontFormats: string} } Font formats for
   *          MCE & all fonts to load.
   */
  static getFontData(e = {}) {
    if (!ke(e))
      throw new TypeError("'extraFonts' is not an object.");
    const t = [
      ...Mc.getCoreDefinitions(),
      e
    ], s = /* @__PURE__ */ new Set();
    for (const n of t)
      if (ke(n))
        for (const l of Object.keys(n))
          s.add(`${l}=${l};`);
    return { fonts: t, fontFormats: [...s].sort().join("") };
  }
  /**
   * Handles paste preprocessing. Prevents pasting when `options.preventPaste` is true. Prevents pasting when
   * `options.maxContentLength` is set and only partially pastes text to fit within the max length.
   *
   *
   * For Foundry v10 and above when `options.maxContentLength` is not defined pasted text is examined for the shape
   * of a raw UUID and if detected attempts to retrieve the document and if found will generate a proper document link
   * from it. You can get the raw UUID by context-clicking the icon in the app header bar for various documents.
   *
   * @param {object}   editor -
   *
   * @param {object}   args -
   *
   * @param {object}   options -
   *
   * @param {number}   maxCharacterLength -
   */
  static pastePreprocess(e, t, s, n) {
    if ((typeof t.content != "string" || typeof s.preventPaste == "boolean" && s.preventPaste) && (t.stopImmediatePropagation(), t.stopPropagation(), t.preventDefault()), n >= 0) {
      let l = jz(t.content);
      this.hasEnterKeyHandler(s) && (l = l.replace(/[\n\r]+/g, ""));
      const r = e.plugins.wordcount.body.getCharacterCount(), o = e.plugins.wordcount.selection.getCharacterCount();
      if (o > 0) {
        if (l.length > o) {
          const a = l.length + r - o;
          a > n && (l = l.substring(0, l.length - (a - n)));
        }
      } else if (l.length + r > n) {
        const a = n - r;
        l = l.substring(0, a);
      }
      t.content = l;
    } else {
      let l = t.content;
      if (Zd.isAtLeast(10) && M(this, hg).test(l)) {
        const r = globalThis.fromUuidSync(l);
        r && (l = `@UUID[${l}]{${r.name}}`);
      }
      t.content = l;
    }
  }
  /**
   * Sets the initial selection based on `options.initialSelection`.
   *
   * @param {object}   editor - MCE editor.
   *
   * @param {string}   initialSelection - Initial selection option.
   *
   * @param {string}   defaultValue - Default value if initialSelection is invalid.
   */
  static setInitialSelection(e, t, s) {
    const n = t === "all" || t === "end" || t === "start" ? t : s, l = e.selection, r = e.getBody();
    if (r) {
      switch (n) {
        case "all":
          l.select(r, !0);
          break;
        case "end":
          l.select(r, !0), l.collapse(!1);
          break;
        case "start":
          l.select(r, !0), l.collapse(!0);
          break;
      }
      e.focus();
    }
  }
  /**
   * Copies over the CSS variable data that is inspected on the `.editor-content` div before the editor is active if
   * set or the default values to the body element of the TinyMCE IFrame.
   *
   * @param {HTMLElement} editorContentEl - Editor content element.
   *
   * @returns {string} TinyMCE config `content_style` parameter for .
   */
  static setMCEConfigContentStyle(e) {
    const t = {}, s = globalThis.getComputedStyle(e);
    for (const n of M(this, mg)) {
      const l = s.getPropertyValue(n.variable);
      t[n.property] = l !== "" ? l : n.default;
    }
    return `body { ${Object.entries(t).map(
      (n) => `${n[0]}: ${n[1]};`
    ).join(";")} } p:first-of-type { margin-top: 0; }`;
  }
};
mg = new WeakMap(), hg = new WeakMap(), f(Qr, "MCEImpl"), /**
 * Stores the CSS variable data that is inspected on the `.editor-content` div before the editor is active and
 * copies these values if set or the default values to the body element of the TinyMCE IFrame.
 *
 * @type {object[]}
 */
Y(Qr, mg, [
  { variable: "--tjs-editor-content-color", property: "color", default: "#000" },
  { variable: "--tjs-editor-content-font-family", property: "font-family", default: "Signika" },
  { variable: "--tjs-editor-content-font-size", property: "font-size", default: "10.5pt" },
  { variable: "--tjs-editor-content-line-height", property: "line-height", default: "1.2" },
  { variable: "--tjs-editor-content-padding", property: "padding", default: "3px 0 0 0" }
]), /**
 * Defines a regex to check for the shape of a raw Foundry document UUID.
 *
 * @type {RegExp}
 */
Y(Qr, hg, /(\.).*([a-zA-Z0-9]{16})/);
let Lt = Qr;
var Zo, fd, gg, bg, _g, Ku, Qo, yg, vg, xo;
const Zs = class Zs {
  /**
   * Provides a very basic / limited TinyMCE config that limits the ability to apply many styles from the toolbar
   * or with key commands.
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.basicFormats=true] - When true, only basic style formats are allowed.
   *
   * @param {string[]} [opts.contentCSS] - An array of CSS paths to load. `getRoute` will be applied to them.
   *
   * @param {string}   [opts.contentStyle=''] - The same content style string for TinyMCE options.
   *
   * @param {boolean}  [opts.fontFormat=true] - Includes font select box.
   *
   * @param {boolean}  [opts.fontSize=false] - Includes font size select box.
   *
   * @param {boolean}  [opts.help=false] - When true include help plugin / toolbar button.
   *
   * @param {boolean}  [opts.stripStyleFormat=true] - Strips any additional style formats added by other modules.
   *
   * @param {boolean}  [opts.styleFormat=true] - Includes style format select box.
   *
   * @param {boolean}  [opts.tjsStyles=false] - Includes extensive "TJS" styling options.
   *
   * @param {boolean}  [opts.toolbar=true] - Includes the editor toolbar.
   *
   * @returns {object} TinyMCE options
   */
  static configBasic({
    basicFormats: e = !0,
    contentCSS: t,
    contentStyle: s = "",
    fontFormat: n = !0,
    fontSize: l = !1,
    help: r = !1,
    stripStyleFormat: o = !0,
    styleFormat: a = !0,
    tjsStyles: c = !1,
    toolbar: u = !0
  } = {}) {
    const d = Z(this, Zo, fd).call(this, e, o, c ? M(this, xo) : []), p = `${a ? `${Lt.isV6 ? "styles |" : "styleselect |"}` : ""} ${n ? `${Lt.isV6 ? "fontfamily |" : "fontselect |"}` : ""} ${l ? `${Lt.isV6 ? "fontsize |" : "fontsizeselect |"}` : ""} removeformat | save${r ? " | help" : ""}`, m = {
      content_css: Array.isArray(t) ? globalThis.CONFIG.TinyMCE.content_css.concat(t) : globalThis.CONFIG.TinyMCE.content_css,
      content_style: s,
      [`${Lt.isV6 ? "font_size_formats" : "fontsize_formats"}`]: M(this, Qo),
      plugins: `${Lt.isV6 ? "" : "hr paste"} save ${r ? "help" : ""} wordcount`,
      style_formats: d,
      style_formats_merge: !1,
      // This allows the manual addition of a style tag in the code editor.
      valid_children: "+body[style]",
      // Note we can include all internal tags as we prefilter the URL to make sure it is for YouTube then use the
      // oembed API to get the embed URL. Additionally, DOMPurify is configured to only accept iframes from YouTube.
      extended_valid_elements: "iframe[allow|allowfullscreen|frameborder|scrolling|class|style|src|width|height]"
    };
    return e && (m.formats = M(this, bg)), m.toolbar = u ? p : !1, m;
  }
  /**
   * Provides the standard TinyMCE configuration options. This is similar to standard core configuration and the
   * ProseMirror editor.
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.basicFormats=false] - When true, only basic style formats are allowed.
   *
   * @param {boolean}  [opts.code=true] - When true include source code editing option.
   *
   * @param {string[]} [opts.contentCSS] - An array of CSS paths to load. `getRoute` will be applied to them.
   *
   * @param {string}   [opts.contentStyle=''] - The same content style string for TinyMCE options.
   *
   * @param {boolean}  [opts.fontFormat=true] - Includes font select box.
   *
   * @param {boolean}  [opts.fontSize=false] - Includes font size select box.
   *
   * @param {boolean}  [opts.help=false] - When true include help plugin / toolbar button.
   *
   * @param {boolean}  [opts.stripStyleFormat=true] - Strips any additional style formats added by other modules.
   *
   * @param {boolean}  [opts.styleFormat=true] - Includes style format select box.
   *
   * @param {boolean}  [opts.tjsOembed=false] - Includes custom oEmbed plugin to include video from YouTube / Vimeo.
   *
   * @param {boolean}  [opts.tjsStyles=false] - Includes extensive "TJS" styling options.
   *
   * @param {boolean}  [opts.toolbar=true] - Includes the editor toolbar.
   *
   * @returns {object} TinyMCE options
   */
  static configStandard({
    basicFormats: e = !1,
    code: t = !0,
    contentCSS: s,
    contentStyle: n = "",
    fontFormat: l = !0,
    fontSize: r = !1,
    help: o = !1,
    stripStyleFormat: a = !0,
    styleFormat: c = !0,
    tjsOembed: u = !1,
    tjsStyles: d = !1,
    toolbar: p = !0
  } = {}) {
    const m = Z(this, Zo, fd).call(this, e, a, d ? M(this, xo) : []), g = `${c ? `${Lt.isV6 ? "styles |" : "styleselect |"}` : ""} ${l ? `${Lt.isV6 ? "fontfamily |" : "fontselect |"}` : ""} ${r ? `${Lt.isV6 ? "fontsize |" : "fontsizeselect |"}` : ""} table | bullist | numlist | image ${u ? "| typhonjs-oembed" : ""} | hr | link | removeformat | save${t ? " | code" : ""}${o ? " | help" : ""}`, h = {
      content_css: Array.isArray(s) ? globalThis.CONFIG.TinyMCE.content_css.concat(s) : globalThis.CONFIG.TinyMCE.content_css,
      content_style: n,
      [`${Lt.isV6 ? "font_size_formats" : "fontsize_formats"}`]: M(this, Qo),
      plugins: `${Lt.isV6 ? "" : "hr paste"} emoticons image link lists charmap table ${u ? "typhonjs-oembed" : ""} ${t ? "code" : ""} save ${o ? "help" : ""} wordcount`,
      style_formats: m,
      style_formats_merge: !1,
      // For typhonjs-oembed plugin when loaded.
      oembed_live_embeds: !1,
      oembed_default_width: 424,
      oembed_default_height: 238,
      oembed_disable_file_source: !0,
      // This allows the manual addition of a style tag in the code editor.
      valid_children: "+body[style]",
      // Note we can include all internal tags as we prefilter the URL to make sure it is for YouTube then use the
      // oembed API to get the embed URL. Additionally, DOMPurify is configured to only accept iframes from YouTube.
      extended_valid_elements: "iframe[allow|allowfullscreen|frameborder|scrolling|class|style|src|width|height]"
    };
    return h.toolbar = p ? g : !1, h;
  }
  /**
   * Provides the TJS super cool TinyMCE configuration options. These options are selected for increased media
   * embedding and styling flexibility.
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.basicFormats=false] - When true, only basic style formats are allowed.
   *
   * @param {boolean}  [opts.code=true] - When true include source code editing option.
   *
   * @param {string[]} [opts.contentCSS] - An array of CSS paths to load. `getRoute` will be applied to them.
   *
   * @param {string}   [opts.contentStyle=''] - The same content style string for TinyMCE options.
   *
   * @param {boolean}  [opts.fontFormat=true] - Includes font formats, size, line spacing and color options.
   *
   * @param {boolean}  [opts.fontSize=true] - Includes font size options.
   *
   * @param {boolean}  [opts.help=false] - When true include help plugin / toolbar button.
   *
   * @param {boolean}  [opts.stripStyleFormat=true] - Strips any additional style formats added by other modules.
   *
   * @param {boolean}  [opts.styleFormat=true] - Includes style format select box.
   *
   * @param {boolean}  [opts.tjsOembed=true] - Includes custom oEmbed plugin to include video from YouTube / Vimeo.
   *
   * @param {boolean}  [opts.tjsStyles=true] - Includes extensive "TJS" styling options.
   *
   * @param {boolean}  [opts.toolbar=true] - Includes the editor toolbar.
   *
   * @returns {object} TinyMCE options
   */
  static configTJS({
    basicFormats: e = !1,
    code: t = !0,
    contentCSS: s,
    contentStyle: n = "",
    fontFormat: l = !0,
    fontSize: r = !0,
    help: o = !1,
    stripStyleFormat: a = !0,
    styleFormat: c = !0,
    tjsOembed: u = !0,
    tjsStyles: d = !0,
    toolbar: p = !0
  } = {}) {
    const m = Z(this, Zo, fd).call(this, e, a, d ? M(this, xo) : []), g = `${c ? `${Lt.isV6 ? "styles |" : "styleselect |"}` : ""} table | ${l ? "formatgroup |" : ""} removeformat | insertgroup | bulletgroup | save${t ? " | code" : ""}${o ? " | help" : ""}`, h = {
      plugins: `${Lt.isV6 ? "" : "hr paste"} emoticons image link lists ${u ? "typhonjs-oembed" : ""} charmap table ${t ? "code" : ""} save ${o ? "help" : ""} wordcount`,
      toolbar_groups: {
        bulletgroup: {
          icon: "unordered-list",
          tooltip: "Lists",
          items: "bullist | numlist"
        },
        formatgroup: {
          icon: "format",
          tooltip: "Fonts",
          items: `${Lt.isV6 ? "fontfamily |" : "fontselect |"} ${r ? `${Lt.isV6 ? "fontsize |" : "fontsizeselect |"}` : ""} lineheight | forecolor backcolor`
        },
        insertgroup: {
          icon: "plus",
          tooltip: "Insert",
          items: `link image ${u ? "typhonjs-oembed" : ""} emoticons charmap hr`
        }
      },
      content_css: Array.isArray(s) ? globalThis.CONFIG.TinyMCE.content_css.concat(s) : globalThis.CONFIG.TinyMCE.content_css,
      content_style: n,
      contextmenu: !1,
      // Prefer default browser context menu
      [`${Lt.isV6 ? "font_size_formats" : "fontsize_formats"}`]: M(this, Qo),
      file_picker_types: "image media",
      image_advtab: !0,
      [`${Lt.isV6 ? "line_height_formats" : "lineheight_formats"}`]: M(this, yg),
      // For typhonjs-oembed plugin when loaded.
      oembed_live_embeds: !1,
      oembed_default_width: 424,
      oembed_default_height: 238,
      oembed_disable_file_source: !0,
      style_formats: m,
      style_formats_merge: !1,
      table_class_list: M(this, vg),
      // This allows the manual addition of a style tag in the code editor.
      valid_children: "+body[style]",
      // Note we can include all internal tags as we prefilter the URL to make sure it is for YouTube then use the
      // oembed API to get the embed URL. Additionally, DOMPurify is configured to only accept iframes from YouTube.
      extended_valid_elements: "iframe[allow|allowfullscreen|frameborder|scrolling|class|style|src|width|height]"
    };
    return h.toolbar = p ? g : !1, h;
  }
  /**
   * Provides a combined `mceConfig` and other default options to create a single line editor that prevents pasting,
   * prevents enter key / new lines, saves on editor blur, and doesn't show the toolbar. This is useful as a shortcut
   * to enable TJSTinyMCE to act as a content editable text entry for a single line text field.
   *
   * Note: Since this function returns an object w/ mceConfig and other options you must use it like in TJSTinyMCE
   * options; where `font-size` in contentStyleBody and any other styles match the editor CSS variables:
   *
   * ...TinyMCEHelper.configSingleLine({ contentStyleBody: { 'font-size': '22pt' }})
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {string[]} [opts.contentCSS] - An array of CSS paths to load. `getRoute` will be applied to them.
   *
   * @param {string}   [opts.contentStyle=''] - The same content style string for TinyMCE options.
   *
   * @returns {object} TinyMCE options
   */
  static optionsSingleLine({ contentCSS: e, contentStyle: t = "" } = {}) {
    return {
      mceConfig: {
        ...this.configBasic({ contentCSS: e, contentStyle: t, toolbar: !1 }),
        save_enablewhendirty: !1
      },
      preventEnterKey: !0,
      saveOnEnterKey: !0,
      saveOnBlur: !0
    };
  }
};
Zo = new WeakSet(), fd = /* @__PURE__ */ f(function(e = !1, t = !0, s = []) {
  const n = JSON.parse(JSON.stringify(e ? M(this, _g) : M(this, gg))), l = e ? 0 : 1;
  if (t)
    globalThis.game.user.isGM && n[l].items.push(M(this, Ku));
  else {
    const r = globalThis.CONFIG.TinyMCE.style_formats.filter((o) => o.title !== "Custom");
    n.push(...r), globalThis.game.user.isGM && n[l].items.push(M(this, Ku));
  }
  return n.concat(s);
}, "#getStyleFormats"), gg = new WeakMap(), bg = new WeakMap(), _g = new WeakMap(), Ku = new WeakMap(), Qo = new WeakMap(), yg = new WeakMap(), vg = new WeakMap(), xo = new WeakMap(), // Internal methods -----------------------------------------------------------------------------------------------
/**
 * @param {boolean}  [basicFormats=false] - When true limits core formats to basic style formats.
 *
 * @param {boolean}  [stripStyleFormat=true] - Strips any non-core items added to the style format select group.
 *
 * @param {object[]} [additionalStyleFormats=[]] - Add additional style formats.
 *
 * @returns {{title: string, items: [{classes: string, block: string, wrapper: boolean, title: string}]}[]} MCE
 *          style formats configuration data.
 */
Y(Zs, Zo), f(Zs, "TinyMCEHelper"), // Static data -----------------------------------------------------------------------------------------------------
/**
 * Defines the standard all style formats menu for style formats.
 *
 * @type {object[]}
 */
Y(Zs, gg, [
  {
    title: "Headings",
    items: [
      { title: "Heading 1", format: "h1" },
      { title: "Heading 2", format: "h2" },
      { title: "Heading 3", format: "h3" },
      { title: "Heading 4", format: "h4" },
      { title: "Heading 5", format: "h5" },
      { title: "Heading 6", format: "h6" }
    ]
  },
  {
    title: "Blocks",
    items: [
      { title: "Paragraph", format: "p" },
      { title: "Blockquote", format: "blockquote" },
      { title: "Pre", format: "pre" }
    ]
  },
  {
    title: "Inline",
    items: [
      { title: "Bold", format: "bold" },
      { title: "Italic", format: "italic" },
      { title: "Code", format: "code" },
      { title: "Underline", format: "underline" },
      { title: "Strikethrough", format: "strikethrough" },
      { title: "Superscript", format: "superscript" },
      { title: "Subscript", format: "subscript" }
    ]
  },
  {
    title: "Align",
    items: [
      { title: "Left", format: "alignleft" },
      { title: "Center", format: "aligncenter" },
      { title: "Right", format: "alignright" },
      { title: "Justify", format: "alignjustify" }
    ]
  }
]), /**
 * Removes the TMCE core format options that are not considered basic / essential formats when `basicFormats`
 * is true.
 *
 * @type {object}
 */
Y(Zs, bg, {
  blockquote: {},
  div: {},
  h1: {},
  h2: {},
  h3: {},
  h4: {},
  h5: {},
  h6: {},
  pre: {}
}), /**
 * Defines the limited style formats options when `basicFormats` is true.
 *
 * @type {object[]}
 */
Y(Zs, _g, [
  {
    title: "Blocks",
    items: [
      { title: "Paragraph", format: "p" }
    ]
  },
  {
    title: "Inline",
    items: [
      { title: "Bold", format: "bold" },
      { title: "Italic", format: "italic" },
      { title: "Underline", format: "underline" },
      { title: "Strikethrough", format: "strikethrough" },
      { title: "Superscript", format: "superscript" },
      { title: "Subscript", format: "subscript" },
      { title: "Code", format: "code" }
    ]
  },
  {
    title: "Align",
    items: [
      { title: "Left", format: "alignleft" },
      { title: "Center", format: "aligncenter" },
      { title: "Right", format: "alignright" },
      { title: "Justify", format: "alignjustify" }
    ]
  }
]), /**
 * Defines the secret FVTT core format item.
 *
 * @type {object}
 */
Y(Zs, Ku, {
  title: "Secret",
  block: "section",
  classes: "secret",
  wrapper: !0
}), /**
 * Defines the font sizes available in the toolbar options.
 *
 * @type {string}
 */
Y(Zs, Qo, "10.5pt 12pt 13pt 14pt 15pt 16pt 18pt 22pt 28pt 32pt 36pt 42pt 48pt 64pt"), /**
 * Defines the line-height styles available in the toolbar options.
 *
 * @type {string}
 */
Y(Zs, yg, "0.8 0.9 1 1.1 1.2 1.3 1.4 1.5 1.75 2"), /**
 * Provides a class list for the table dialog.
 *
 * @type {object}
 */
Y(Zs, vg, [
  { title: "None", value: "" },
  { title: "No Colors / Border", value: "tmce-nocolors" }
]), /**
 * Provides extra CSS styles to configure text and various elements in TinyMCE.
 *
 * @type {object[]}
 */
Y(Zs, xo, [{
  title: "Styles",
  items: [
    {
      title: "Blend Mode",
      items: [
        {
          title: "BM Unset",
          selector: "*",
          styles: {
            "mix-blend-mode": "unset"
          }
        },
        {
          title: "BM Normal",
          selector: "*",
          styles: {
            "mix-blend-mode": "normal"
          }
        },
        {
          title: "BM Multiply",
          selector: "*",
          styles: {
            "mix-blend-mode": "multiply"
          }
        },
        {
          title: "BM Screen",
          selector: "*",
          styles: {
            "mix-blend-mode": "screen"
          }
        },
        {
          title: "BM Overlay",
          selector: "*",
          styles: {
            "mix-blend-mode": "overlay"
          }
        },
        {
          title: "BM Darken",
          selector: "*",
          styles: {
            "mix-blend-mode": "darken"
          }
        },
        {
          title: "BM Lighten",
          selector: "*",
          styles: {
            "mix-blend-mode": "lighten"
          }
        },
        {
          title: "BM Color Dodge",
          selector: "*",
          styles: {
            "mix-blend-mode": "color-dodge"
          }
        },
        {
          title: "BM Color Burn",
          selector: "*",
          styles: {
            "mix-blend-mode": "color-burn"
          }
        },
        {
          title: "BM Hard Light",
          selector: "*",
          styles: {
            "mix-blend-mode": "hard-light"
          }
        },
        {
          title: "BM Soft Light",
          selector: "*",
          styles: {
            "mix-blend-mode": "soft-light"
          }
        },
        {
          title: "BM Difference",
          selector: "*",
          styles: {
            "mix-blend-mode": "difference"
          }
        },
        {
          title: "BM Exclusion",
          selector: "*",
          styles: {
            "mix-blend-mode": "exclusion"
          }
        },
        {
          title: "BM Hue",
          selector: "*",
          styles: {
            "mix-blend-mode": "hue"
          }
        },
        {
          title: "BM Saturation",
          selector: "*",
          styles: {
            "mix-blend-mode": "saturation"
          }
        },
        {
          title: "BM Color",
          selector: "*",
          styles: {
            "mix-blend-mode": "color"
          }
        },
        {
          title: "BM Luminosity",
          selector: "*",
          styles: {
            "mix-blend-mode": "luminosity"
          }
        }
      ]
    },
    {
      title: "Border",
      items: [
        {
          title: "No Border",
          selector: "*",
          styles: {
            border: "none"
          }
        },
        {
          title: "Border Radius",
          items: [
            {
              title: "BR None",
              selector: "*",
              styles: {
                "border-radius": "unset"
              }
            },
            {
              title: "BR 4px",
              selector: "*",
              styles: {
                "border-radius": "4px"
              }
            },
            {
              title: "BR 8px",
              selector: "*",
              styles: {
                "border-radius": "8px"
              }
            },
            {
              title: "BR 16px",
              selector: "*",
              styles: {
                "border-radius": "16px"
              }
            }
          ]
        }
      ]
    },
    {
      title: "Filters",
      items: [
        {
          title: "No Filter",
          selector: "*",
          styles: {
            filter: "none"
          }
        },
        {
          title: "Blur",
          items: [
            {
              title: "Blur 1px",
              selector: "*",
              styles: {
                filter: "blur(1px)"
              }
            },
            {
              title: "Blur 2px",
              selector: "*",
              styles: {
                filter: "blur(2px)"
              }
            },
            {
              title: "Blur 3px",
              selector: "*",
              styles: {
                filter: "blur(3px)"
              }
            },
            {
              title: "Blur 4px",
              selector: "*",
              styles: {
                filter: "blur(4px)"
              }
            }
          ]
        },
        {
          title: "Drop Shadow",
          items: [
            {
              title: "DS 2px",
              selector: "*",
              styles: {
                filter: "drop-shadow(2px 2px 2px black)"
              }
            },
            {
              title: "DS 4px",
              selector: "*",
              styles: {
                filter: "drop-shadow(4px 4px 3px black)"
              }
            },
            {
              title: "DS 8px",
              selector: "*",
              styles: {
                filter: "drop-shadow(8px 8px 6px black)"
              }
            }
          ]
        },
        {
          title: "Grayscale",
          items: [
            {
              title: "GS 25%",
              selector: "*",
              styles: {
                filter: "grayscale(25%)"
              }
            },
            {
              title: "GS 50%",
              selector: "*",
              styles: {
                filter: "grayscale(50%)"
              }
            },
            {
              title: "GS 75%",
              selector: "*",
              styles: {
                filter: "grayscale(75%)"
              }
            },
            {
              title: "GS 100%",
              selector: "*",
              styles: {
                filter: "grayscale(100%)"
              }
            }
          ]
        }
      ]
    },
    {
      title: "Float",
      items: [
        {
          title: "Float Left",
          selector: "*",
          styles: {
            float: "left",
            margin: "0 10px 0 0"
          }
        },
        {
          title: "Float Right",
          selector: "*",
          styles: {
            float: "right",
            margin: "0 0 0 10px"
          }
        }
      ]
    },
    {
      title: "Fonts",
      items: [
        {
          title: "Neon",
          items: [
            {
              title: "Neon Blue",
              selector: "*",
              styles: {
                color: "#fff",
                "text-shadow": "0 0 5px #fff, 0 0 10px #fff, 0 0 15px #0073e6, 0 0 20px #0073e6, 0 0 25px #0073e6"
              }
            },
            {
              title: "Neon Green",
              selector: "*",
              styles: {
                color: "#fff",
                "text-shadow": "0 0 5px #fff, 0 0 10px #fff, 0 0 15px #00e704, 0 0 20px #00e704, 0 0 25px #00e704"
              }
            },
            {
              title: "Neon Red",
              selector: "*",
              styles: {
                color: "#fff",
                "text-shadow": "0 0 5px #fff, 0 0 10px #fff, 0 0 15px #e70000, 0 0 20px #e70000, 0 0 25px #e70000"
              }
            },
            {
              title: "Neon Purple",
              selector: "*",
              styles: {
                color: "#fff",
                "text-shadow": "0 0 5px #fff, 0 0 10px #fff, 0 0 15px #7900ea, 0 0 20px #7900ea, 0 0 25px #7900ea"
              }
            }
          ]
        }
      ]
    },
    {
      title: "Margin",
      items: [
        {
          title: "No Margin",
          selector: "*",
          styles: {
            margin: "unset"
          }
        },
        {
          title: "Top",
          items: [
            {
              title: "MT 5px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-top": "5px"
              }
            },
            {
              title: "MT 10px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-top": "10px"
              }
            },
            {
              title: "MT 15px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-top": "15px"
              }
            },
            {
              title: "MT 25px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-top": "25px"
              }
            }
          ]
        },
        {
          title: "Left",
          items: [
            {
              title: "ML 5px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-left": "5px"
              }
            },
            {
              title: "ML 10px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-left": "10px"
              }
            },
            {
              title: "ML 15px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-left": "15px"
              }
            },
            {
              title: "ML 25px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-left": "25px"
              }
            },
            {
              title: "ML 50px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-left": "50px"
              }
            },
            {
              title: "ML 75px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-left": "75px"
              }
            },
            {
              title: "ML 100px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-left": "100px"
              }
            }
          ]
        },
        {
          title: "Bottom",
          items: [
            {
              title: "MB 5px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-bottom": "5px"
              }
            },
            {
              title: "MB 10px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-bottom": "10px"
              }
            },
            {
              title: "MB 15px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-bottom": "15px"
              }
            },
            {
              title: "MB 25px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-bottom": "25px"
              }
            }
          ]
        },
        {
          title: "Right",
          items: [
            {
              title: "MR 5px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-right": "5px"
              }
            },
            {
              title: "MR 10px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-right": "10px"
              }
            },
            {
              title: "MR 15px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-right": "15px"
              }
            },
            {
              title: "MR 25px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-right": "25px"
              }
            },
            {
              title: "MR 50px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-right": "50px"
              }
            },
            {
              title: "MR 75px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-right": "75px"
              }
            },
            {
              title: "MR 100px",
              selector: "*",
              styles: {
                inline: "span",
                "margin-right": "100px"
              }
            }
          ]
        }
      ]
    },
    {
      title: "Opacity",
      items: [
        {
          title: "OP 100%",
          selector: "*",
          styles: {
            opacity: "1"
          }
        },
        {
          title: "OP 90%",
          selector: "*",
          styles: {
            opacity: "0.9"
          }
        },
        {
          title: "OP 80%",
          selector: "*",
          styles: {
            opacity: "0.8"
          }
        },
        {
          title: "OP 70%",
          selector: "*",
          styles: {
            opacity: "0.7"
          }
        },
        {
          title: "OP 60%",
          selector: "*",
          styles: {
            opacity: "0.6"
          }
        },
        {
          title: "OP 50%",
          selector: "*",
          styles: {
            opacity: "0.5"
          }
        },
        {
          title: "OP 40%",
          selector: "*",
          styles: {
            opacity: "0.4"
          }
        },
        {
          title: "OP 30%",
          selector: "*",
          styles: {
            opacity: "0.3"
          }
        },
        {
          title: "OP 20%",
          selector: "*",
          styles: {
            opacity: "0.2"
          }
        },
        {
          title: "OP 10%",
          selector: "*",
          styles: {
            opacity: "0.1"
          }
        }
      ]
    }
  ]
}]);
let ep = Zs;
function g4(i) {
  let e, t, s;
  return {
    c() {
      e = E("a"), e.innerHTML = '<i class="fas fa-edit"></i>', b(e, "class", "editor-edit svelte-1vyshng"), b(e, "role", "button"), b(e, "tabindex", "-1");
    },
    m(n, l) {
      T(n, e, l), t || (s = V(
        e,
        "click",
        /*click_handler*/
        i[17]
      ), t = !0);
    },
    p: ee,
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(g4, "create_if_block_1$1f");
function b4(i) {
  let e, t;
  return {
    c() {
      e = new As(!1), t = $e(), e.a = t;
    },
    m(s, n) {
      e.m(
        /*enrichedContent*/
        i[1],
        s,
        n
      ), T(s, t, n);
    },
    p(s, n) {
      n & /*enrichedContent*/
      2 && e.p(
        /*enrichedContent*/
        s[1]
      );
    },
    d(s) {
      s && (S(t), e.d());
    }
  };
}
f(b4, "create_if_block$1S");
function OZ(i) {
  let e, t, s, n, l, r, o, a = (
    /*editorButton*/
    i[5] && g4(i)
  ), c = !/*editorActive*/
  i[3] && b4(i);
  return {
    c() {
      e = E("div"), a && a.c(), t = R(), s = E("div"), c && c.c(), b(s, "class", "editor-content tjs-editor-content svelte-1vyshng"), b(e, "class", n = "editor tinymce tjs-editor " + (Array.isArray(
        /*options*/
        i[0].classes
      ) ? (
        /*options*/
        i[0].classes.join(" ")
      ) : "") + " svelte-1vyshng"), b(e, "role", "textbox"), b(e, "tabindex", "0"), Q(
        e,
        "click-to-edit",
        /*clickToEdit*/
        i[2]
      ), Q(
        e,
        "editor-active",
        /*editorActive*/
        i[3]
      );
    },
    m(u, d) {
      T(u, e, d), a && a.m(e, null), A(e, t), A(e, s), c && c.m(s, null), i[18](s), i[19](e), r || (o = [
        At(l = Rs.call(
          null,
          e,
          /*options*/
          i[0].styles
        )),
        V(
          e,
          "click",
          /*onClick*/
          i[10]
        ),
        V(
          e,
          "keydown",
          /*onKeydown*/
          i[11]
        ),
        V(
          e,
          "keyup",
          /*onKeyup*/
          i[12]
        )
      ], r = !0);
    },
    p(u, [d]) {
      /*editorButton*/
      u[5] ? a ? a.p(u, d) : (a = g4(u), a.c(), a.m(e, t)) : a && (a.d(1), a = null), /*editorActive*/
      u[3] ? c && (c.d(1), c = null) : c ? c.p(u, d) : (c = b4(u), c.c(), c.m(s, null)), d & /*options*/
      1 && n !== (n = "editor tinymce tjs-editor " + (Array.isArray(
        /*options*/
        u[0].classes
      ) ? (
        /*options*/
        u[0].classes.join(" ")
      ) : "") + " svelte-1vyshng") && b(e, "class", n), l && $t(l.update) && d & /*options*/
      1 && l.update.call(
        null,
        /*options*/
        u[0].styles
      ), d & /*options, clickToEdit*/
      5 && Q(
        e,
        "click-to-edit",
        /*clickToEdit*/
        u[2]
      ), d & /*options, editorActive*/
      9 && Q(
        e,
        "editor-active",
        /*editorActive*/
        u[3]
      );
    },
    i: ee,
    o: ee,
    d(u) {
      u && S(e), a && a.d(), c && c.d(), i[18](null), i[19](null), r = !1, Ne(o);
    }
  };
}
f(OZ, "create_fragment$3j");
function DZ(i, e, t) {
  let s, n, { content: l = "" } = e, { enrichedContent: r = "" } = e, { options: o = {} } = e;
  const a = fe("#external").application.position;
  pe(i, a, (J) => t(16, n = J));
  const c = it(), u = new Bt({ delete: H });
  pe(i, u, (J) => t(15, s = J));
  let d, p = !0, m, g = !1, h, _, y, k, v = !1, O;
  Nt(() => {
    g ? q({
      remove: typeof o.button == "boolean" ? o.button : !0
    }) : P();
  }), Sr(() => {
    p && !h && !d && D();
  });
  function P(J = !0) {
    m && (setTimeout(
      () => {
        m == null || m.destroy(), _ && t(6, _.innerText = "", _), m = void 0, setTimeout(() => t(3, g = !1), 0), v && (v = !1, setTimeout(
          () => {
            y instanceof HTMLElement && (y != null && y.isConnected) && y.focus();
          },
          100
        ));
      },
      0
    ), J && c("editor:cancel"));
  }
  f(P, "destroyEditor");
  async function D() {
    var ve;
    const J = (ve = o == null ? void 0 : o.mceConfig) == null ? void 0 : ve.setup, { fonts: re, fontFormats: ae } = Lt.getFontData(o.fonts), be = {
      ...o.mceConfig ?? ep.configStandard(),
      engine: "tinymce",
      [`${Lt.isV6 ? "font_family_formats" : "font_formats"}`]: ae,
      target: _,
      save_onsavecallback: () => q(),
      height: "100%",
      paste_as_text: O >= 0
      // Pasted content must be text when limiting to a max length;
    };
    Lt.isV5 && (be.paste_filter_drop = !1), be.setup = (me) => {
      me.on("beforeinput", (he) => Lt.beforeInputHandler(me, he, o, O)), me.on("keydown", (he) => Lt.keydownHandler(me, he, o, q, l)), typeof J == "function" && J(me);
    }, be.paste_preprocess = (me, he) => Lt.pastePreprocess(m, he, o, O), be.content_style = `${Lt.setMCEConfigContentStyle(_)} ${be.content_style}`, t(3, g = !0), await A7(), m = await TextEditor.create(be, l), Lt.setInitialSelection(m, o.initialSelection, "start");
    const we = y.querySelector(".tox-edit-area__iframe");
    we && await Mc.loadFonts({
      document: we.contentDocument,
      fonts: re
    }), m.on("blur", (me) => I()), c("editor:start");
  }
  f(D, "initEditor");
  function I(J) {
    g && typeof o.saveOnBlur == "boolean" && o.saveOnBlur && q();
  }
  f(I, "onBlur");
  function B(J) {
    !g && d && D();
  }
  f(B, "onClick");
  async function F(J, re) {
    typeof J == "string" ? re ? t(1, r = await TextEditor.enrichHTML(J, {
      async: !0,
      secrets: globalThis.game.user.isGM
    })) : t(1, r = J) : t(1, r = ""), c("editor:enrichedContent", { enrichedContent: r });
  }
  f(F, "onContentChanged");
  function H(J) {
    t(0, o.document = void 0, o), P(), c("editor:document:deleted", { document: J }), t(13, l = ""), t(1, r = "");
  }
  f(H, "onDocumentDeleted");
  function G(J) {
    g ? (J.code === "Escape" || J.code === "KeyS" && (J.ctrlKey || J.metaKey)) && (J.preventDefault(), J.stopPropagation()) : J.code === k && (J.preventDefault(), J.stopPropagation());
  }
  f(G, "onKeydown");
  function U(J) {
    J.code === k && (g || (v = !0, D()), J.preventDefault(), J.stopPropagation());
  }
  f(U, "onKeyup");
  function q({ remove: J = typeof o.button == "boolean" ? o.button : !0 } = {}) {
    var re;
    if (m) {
      let ae = m.getContent();
      const be = ae !== l;
      be && (o != null && o.DOMPurify && typeof ((re = o == null ? void 0 : o.DOMPurify) == null ? void 0 : re.sanitizeWithVideo) == "function" && (ae = o.DOMPurify.sanitizeWithVideo(ae)), s && o.fieldName ? s.update({ [o.fieldName]: ae }) : t(13, l = ae), c("editor:save", { content: ae })), J && P(!be);
    }
  }
  f(q, "saveEditor");
  const W = /* @__PURE__ */ f(() => D(), "click_handler");
  function X(J) {
    st[J ? "unshift" : "push"](() => {
      _ = J, t(6, _);
    });
  }
  f(X, "div0_binding");
  function te(J) {
    st[J ? "unshift" : "push"](() => {
      y = J, t(4, y);
    });
  }
  return f(te, "div1_binding"), i.$$set = (J) => {
    "content" in J && t(13, l = J.content), "enrichedContent" in J && t(1, r = J.enrichedContent), "options" in J && t(0, o = J.options);
  }, i.$$.update = () => {
    if (i.$$.dirty & /*editorActive, editorEl, $positionStore*/
    65560 && g && y && n) {
      const J = Lt.isV6 ? ".tox-tbtn[aria-controls^='aria-controls_']" : ".tox-tbtn[aria-owns^='aria-owns_']", re = y.querySelector(J);
      re && re.click();
      const ae = document.querySelector(".tox.tox-tinymce-aux");
      if (ae) {
        let be = ae.lastElementChild;
        for (; be; )
          ae.removeChild(be), be = ae.lastElementChild;
      }
    }
    if (i.$$.dirty & /*options, editable*/
    16385 && (t(14, p = typeof o.editable == "boolean" ? o.editable : !0), p || P()), i.$$.dirty & /*editorActive, editable, options*/
    16393 && t(2, d = !g && p && (typeof o.clickToEdit == "boolean" ? o.clickToEdit : !1)), i.$$.dirty & /*editorActive, editable, options, clickToEdit*/
    16397 && t(5, h = !g && p && (typeof o.button == "boolean" ? o.button : !0) && !d), i.$$.dirty & /*options*/
    1 && (k = typeof o.keyCode == "string" ? o.keyCode : "Enter"), i.$$.dirty & /*options*/
    1 && (O = Number.isInteger(o.maxCharacterLength) && o.maxCharacterLength >= 0 ? o.maxCharacterLength : void 0), i.$$.dirty & /*options*/
    1 && o.fonts && Mc.loadFonts({ fonts: o.fonts }), i.$$.dirty & /*options, $doc*/
    32769)
      if (o.document !== void 0) {
        if (!(o.document instanceof globalThis.foundry.abstract.Document))
          throw new TypeError("TJSTinyMCE error: 'options.document' is not a Foundry document.");
        if (typeof o.fieldName != "string")
          throw new TypeError("TJSTinyMCE error: 'options.document' is defined, but 'options.fieldName' is not a string.");
        o.document !== s && (t(1, r = ""), t(13, l = ""), P()), u.set(o.document);
      } else
        s && (t(1, r = ""), t(13, l = ""), P(), u.set(void 0));
    i.$$.dirty & /*$doc, options, content*/
    40961 && (t(13, l = s !== void 0 ? globalThis.foundry.utils.getProperty(s, o.fieldName) : typeof l == "string" ? l : ""), F(l, typeof o.enrichContent == "boolean" ? o.enrichContent : !0));
  }, [
    o,
    r,
    d,
    g,
    y,
    h,
    _,
    a,
    u,
    D,
    B,
    G,
    U,
    l,
    p,
    s,
    n,
    W,
    X,
    te
  ];
}
f(DZ, "instance$3a");
const $2 = class $2 extends ie {
  constructor(e) {
    super(), le(this, e, DZ, OZ, ne, {
      content: 13,
      enrichedContent: 1,
      options: 0
    });
  }
};
f($2, "TJSTinyMCE");
let $0 = $2;
const { document: _4 } = q5, IZ = /* @__PURE__ */ f((i) => ({}), "get_after_slot_changes"), y4 = /* @__PURE__ */ f((i) => ({}), "get_after_slot_context");
function v4(i, e, t) {
  const s = i.slice();
  return s[36] = e[t], s;
}
f(v4, "get_each_context$1l");
const PZ = /* @__PURE__ */ f((i) => ({}), "get_before_slot_changes"), k4 = /* @__PURE__ */ f((i) => ({}), "get_before_slot_context");
function w4(i) {
  var o, a;
  let e, t, s;
  const n = [
    ke(
      /*menu*/
      (a = (o = i[2]) == null ? void 0 : o.slotDefault) == null ? void 0 : a.props
    ) ? (
      /*menu*/
      i[2].slotDefault.props
    ) : {}
  ];
  var l = (
    /*menu*/
    i[2].slotDefault.class
  );
  function r(c, u) {
    var p, m;
    let d = {};
    for (let g = 0; g < n.length; g += 1)
      d = fs(d, n[g]);
    return u !== void 0 && u[0] & /*menu*/
    4 && (d = fs(d, hs(n, [
      Es(ke(
        /*menu*/
        (m = (p = c[2]) == null ? void 0 : p.slotDefault) == null ? void 0 : m.props
      ) ? (
        /*menu*/
        c[2].slotDefault.props
      ) : {})
    ]))), { props: d };
  }
  return f(r, "switch_props"), l && (e = nt(l, r(i))), {
    c() {
      e && L(e.$$.fragment), t = $e();
    },
    m(c, u) {
      e && N(e, c, u), T(c, t, u), s = !0;
    },
    p(c, u) {
      var d, p;
      if (u[0] & /*menu*/
      4 && l !== (l = /*menu*/
      c[2].slotDefault.class)) {
        if (e) {
          ce();
          const m = e;
          C(m.$$.fragment, 1, 0, () => {
            j(m, 1);
          }), ue();
        }
        l ? (e = nt(l, r(c, u)), L(e.$$.fragment), w(e.$$.fragment, 1), N(e, t.parentNode, t)) : e = null;
      } else if (l) {
        const m = u[0] & /*menu*/
        4 ? hs(n, [
          Es(ke(
            /*menu*/
            (p = (d = c[2]) == null ? void 0 : d.slotDefault) == null ? void 0 : p.props
          ) ? (
            /*menu*/
            c[2].slotDefault.props
          ) : {})
        ]) : {};
        e.$set(m);
      }
    },
    i(c) {
      s || (e && w(e.$$.fragment, c), s = !0);
    },
    o(c) {
      e && C(e.$$.fragment, c), s = !1;
    },
    d(c) {
      c && S(t), e && j(e, c);
    }
  };
}
f(w4, "create_if_block_6$f");
function MZ(i) {
  var l, r;
  let e = ti(
    /*menu*/
    (r = (l = i[2]) == null ? void 0 : l.slotDefault) == null ? void 0 : r.class
  ), t, s, n = e && w4(i);
  return {
    c() {
      n && n.c(), t = $e();
    },
    m(o, a) {
      n && n.m(o, a), T(o, t, a), s = !0;
    },
    p(o, a) {
      var c, u;
      a[0] & /*menu*/
      4 && (e = ti(
        /*menu*/
        (u = (c = o[2]) == null ? void 0 : c.slotDefault) == null ? void 0 : u.class
      )), e ? n ? (n.p(o, a), a[0] & /*menu*/
      4 && w(n, 1)) : (n = w4(o), n.c(), w(n, 1), n.m(t.parentNode, t)) : n && (ce(), C(n, 1, 1, () => {
        n = null;
      }), ue());
    },
    i(o) {
      s || (w(n), s = !0);
    },
    o(o) {
      C(n), s = !1;
    },
    d(o) {
      o && S(t), n && n.d(o);
    }
  };
}
f(MZ, "fallback_block$1");
function $4(i) {
  let e, t, s, n, l, r;
  const o = (
    /*#slots*/
    i[19].before
  ), a = Pt(
    o,
    i,
    /*$$scope*/
    i[18],
    k4
  );
  return {
    c() {
      e = E("li"), t = E("span"), s = R(), a && a.c(), b(t, "class", "tjs-menu-focus-indicator svelte-7526ak"), b(e, "class", "tjs-menu-item svelte-7526ak"), b(e, "role", "menuitem"), b(e, "tabindex", "0");
    },
    m(c, u) {
      T(c, e, u), A(e, t), A(e, s), a && a.m(e, null), n = !0, l || (r = [
        V(
          e,
          "click",
          /*click_handler*/
          i[20]
        ),
        V(
          e,
          "keyup",
          /*keyup_handler*/
          i[21]
        )
      ], l = !0);
    },
    p(c, u) {
      a && a.p && (!n || u[0] & /*$$scope*/
      262144) && Rt(
        a,
        o,
        c,
        /*$$scope*/
        c[18],
        n ? Mt(
          o,
          /*$$scope*/
          c[18],
          u,
          PZ
        ) : Ft(
          /*$$scope*/
          c[18]
        ),
        k4
      );
    },
    i(c) {
      n || (w(a, c), n = !0);
    },
    o(c) {
      C(a, c), n = !1;
    },
    d(c) {
      c && S(e), a && a.d(c), l = !1, Ne(r);
    }
  };
}
f($4, "create_if_block_5$h");
function RZ(i) {
  let e;
  return {
    c() {
      e = E("hr"), b(e, "class", "svelte-7526ak");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: ee,
    i: ee,
    o: ee,
    d(t) {
      t && S(e);
    }
  };
}
f(RZ, "create_if_block_4$p");
function FZ(i) {
  let e, t, s, n, l, r, o, a, c = K(
    /*item*/
    i[36].label
  ) + "", u, d, p;
  function m() {
    return (
      /*click_handler_3*/
      i[26](
        /*item*/
        i[36]
      )
    );
  }
  f(m, "click_handler_3");
  function g(...h) {
    return (
      /*keyup_handler_3*/
      i[27](
        /*item*/
        i[36],
        ...h
      )
    );
  }
  return f(g, "keyup_handler_3"), {
    c() {
      e = E("li"), t = E("span"), s = R(), n = E("img"), o = R(), a = E("span"), u = x(c), b(t, "class", "tjs-menu-focus-indicator svelte-7526ak"), ze(n.src, l = /*item*/
      i[36].image) || b(n, "src", l), b(n, "alt", r = /*item*/
      i[36].imageAlt), b(n, "class", "svelte-7526ak"), b(a, "class", "tjs-menu-item-label svelte-7526ak"), b(e, "class", "tjs-menu-item tjs-menu-item-button svelte-7526ak"), b(e, "role", "menuitem"), b(e, "tabindex", "0");
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(e, s), A(e, n), A(e, o), A(e, a), A(a, u), d || (p = [
        V(e, "click", m),
        V(e, "keyup", g)
      ], d = !0);
    },
    p(h, _) {
      i = h, _[0] & /*allItems*/
      8 && !ze(n.src, l = /*item*/
      i[36].image) && b(n, "src", l), _[0] & /*allItems*/
      8 && r !== (r = /*item*/
      i[36].imageAlt) && b(n, "alt", r), _[0] & /*allItems*/
      8 && c !== (c = K(
        /*item*/
        i[36].label
      ) + "") && _e(u, c);
    },
    i: ee,
    o: ee,
    d(h) {
      h && S(e), d = !1, Ne(p);
    }
  };
}
f(FZ, "create_if_block_3$u");
function NZ(i) {
  let e, t, s, n, l, r, o, a = K(
    /*item*/
    i[36].label
  ) + "", c, u, d;
  function p() {
    return (
      /*click_handler_2*/
      i[24](
        /*item*/
        i[36]
      )
    );
  }
  f(p, "click_handler_2");
  function m(...g) {
    return (
      /*keyup_handler_2*/
      i[25](
        /*item*/
        i[36],
        ...g
      )
    );
  }
  return f(m, "keyup_handler_2"), {
    c() {
      e = E("li"), t = E("span"), s = R(), n = E("i"), r = R(), o = E("span"), c = x(a), b(t, "class", "tjs-menu-focus-indicator svelte-7526ak"), b(n, "class", l = ni(
        /*item*/
        i[36].icon
      ) + " svelte-7526ak"), b(o, "class", "tjs-menu-item-label svelte-7526ak"), b(e, "class", "tjs-menu-item tjs-menu-item-button svelte-7526ak"), b(e, "role", "menuitem"), b(e, "tabindex", "0");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(e, s), A(e, n), A(e, r), A(e, o), A(o, c), u || (d = [
        V(e, "click", p),
        V(e, "keyup", m)
      ], u = !0);
    },
    p(g, h) {
      i = g, h[0] & /*allItems*/
      8 && l !== (l = ni(
        /*item*/
        i[36].icon
      ) + " svelte-7526ak") && b(n, "class", l), h[0] & /*allItems*/
      8 && a !== (a = K(
        /*item*/
        i[36].label
      ) + "") && _e(c, a);
    },
    i: ee,
    o: ee,
    d(g) {
      g && S(e), u = !1, Ne(d);
    }
  };
}
f(NZ, "create_if_block_2$M");
function jZ(i) {
  let e, t, s, n, l, r, o;
  const a = [
    ke(
      /*item*/
      i[36].props
    ) ? (
      /*item*/
      i[36].props
    ) : {}
  ];
  var c = (
    /*item*/
    i[36].class
  );
  function u(m, g) {
    let h = {};
    for (let _ = 0; _ < a.length; _ += 1)
      h = fs(h, a[_]);
    return g !== void 0 && g[0] & /*allItems*/
    8 && (h = fs(h, hs(a, [
      Es(ke(
        /*item*/
        m[36].props
      ) ? (
        /*item*/
        m[36].props
      ) : {})
    ]))), { props: h };
  }
  f(u, "switch_props"), c && (n = nt(c, u(i)));
  function d() {
    return (
      /*click_handler_1*/
      i[22](
        /*item*/
        i[36]
      )
    );
  }
  f(d, "click_handler_1");
  function p(...m) {
    return (
      /*keyup_handler_1*/
      i[23](
        /*item*/
        i[36],
        ...m
      )
    );
  }
  return f(p, "keyup_handler_1"), {
    c() {
      e = E("li"), t = E("span"), s = R(), n && L(n.$$.fragment), b(t, "class", "tjs-menu-focus-indicator svelte-7526ak"), b(e, "class", "tjs-menu-item svelte-7526ak"), b(e, "role", "menuitem"), b(e, "tabindex", "0");
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(e, s), n && N(n, e, null), l = !0, r || (o = [
        V(e, "click", d),
        V(e, "keyup", p)
      ], r = !0);
    },
    p(m, g) {
      if (i = m, g[0] & /*allItems*/
      8 && c !== (c = /*item*/
      i[36].class)) {
        if (n) {
          ce();
          const h = n;
          C(h.$$.fragment, 1, 0, () => {
            j(h, 1);
          }), ue();
        }
        c ? (n = nt(c, u(i, g)), L(n.$$.fragment), w(n.$$.fragment, 1), N(n, e, null)) : n = null;
      } else if (c) {
        const h = g[0] & /*allItems*/
        8 ? hs(a, [
          Es(ke(
            /*item*/
            i[36].props
          ) ? (
            /*item*/
            i[36].props
          ) : {})
        ]) : {};
        n.$set(h);
      }
    },
    i(m) {
      l || (n && w(n.$$.fragment, m), l = !0);
    },
    o(m) {
      n && C(n.$$.fragment, m), l = !1;
    },
    d(m) {
      m && S(e), n && j(n), r = !1, Ne(o);
    }
  };
}
f(jZ, "create_if_block_1$1e");
function A4(i) {
  let e, t, s, n;
  const l = [jZ, NZ, FZ, RZ], r = [];
  function o(a, c) {
    return (
      /*item*/
      a[36]["#type"] === "class" ? 0 : (
        /*item*/
        a[36]["#type"] === "icon" ? 1 : (
          /*item*/
          a[36]["#type"] === "image" ? 2 : (
            /*item*/
            a[36]["#type"] === "separator-hr" ? 3 : -1
          )
        )
      )
    );
  }
  return f(o, "select_block_type"), ~(e = o(i)) && (t = r[e] = l[e](i)), {
    c() {
      t && t.c(), s = $e();
    },
    m(a, c) {
      ~e && r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let u = e;
      e = o(a), e === u ? ~e && r[e].p(a, c) : (t && (ce(), C(r[u], 1, 1, () => {
        r[u] = null;
      }), ue()), ~e ? (t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s)) : t = null);
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), ~e && r[e].d(a);
    }
  };
}
f(A4, "create_each_block$1l");
function E4(i) {
  let e, t, s, n, l, r;
  const o = (
    /*#slots*/
    i[19].after
  ), a = Pt(
    o,
    i,
    /*$$scope*/
    i[18],
    y4
  );
  return {
    c() {
      e = E("li"), t = E("span"), s = R(), a && a.c(), b(t, "class", "tjs-menu-focus-indicator svelte-7526ak"), b(e, "class", "tjs-menu-item svelte-7526ak"), b(e, "role", "menuitem"), b(e, "tabindex", "0");
    },
    m(c, u) {
      T(c, e, u), A(e, t), A(e, s), a && a.m(e, null), n = !0, l || (r = [
        V(
          e,
          "click",
          /*click_handler_4*/
          i[28]
        ),
        V(
          e,
          "keyup",
          /*keyup_handler_4*/
          i[29]
        )
      ], l = !0);
    },
    p(c, u) {
      a && a.p && (!n || u[0] & /*$$scope*/
      262144) && Rt(
        a,
        o,
        c,
        /*$$scope*/
        c[18],
        n ? Mt(
          o,
          /*$$scope*/
          c[18],
          u,
          IZ
        ) : Ft(
          /*$$scope*/
          c[18]
        ),
        y4
      );
    },
    i(c) {
      n || (w(a, c), n = !0);
    },
    o(c) {
      C(a, c), n = !1;
    },
    d(c) {
      c && S(e), a && a.d(c), l = !1, Ne(r);
    }
  };
}
f(E4, "create_if_block$1R");
function LZ(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m;
  const g = (
    /*#slots*/
    i[19].default
  ), h = Pt(
    g,
    i,
    /*$$scope*/
    i[18],
    null
  ), _ = h || MZ(i);
  let y = (
    /*$$slots*/
    i[12].before && $4(i)
  ), k = oe(
    /*allItems*/
    i[3]
  ), v = [];
  for (let D = 0; D < k.length; D += 1)
    v[D] = A4(v4(i, k, D));
  const O = /* @__PURE__ */ f((D) => C(v[D], 1, 1, () => {
    v[D] = null;
  }), "out");
  let P = (
    /*$$slots*/
    i[12].after && E4(i)
  );
  return a = new U5({
    props: { elementRoot: (
      /*menuEl*/
      i[4]
    ) }
  }), {
    c() {
      e = R(), t = E("nav"), s = E("ol"), _ && _.c(), n = R(), y && y.c(), l = R();
      for (let D = 0; D < v.length; D += 1)
        v[D].c();
      r = R(), P && P.c(), o = R(), L(a.$$.fragment), b(s, "class", "tjs-menu-items svelte-7526ak"), b(s, "role", "menu"), b(t, "class", "tjs-menu svelte-7526ak"), b(t, "tabindex", "-1");
    },
    m(D, I) {
      T(D, e, I), T(D, t, I), A(t, s), _ && _.m(s, null), A(s, n), y && y.m(s, null), A(s, l);
      for (let B = 0; B < v.length; B += 1)
        v[B] && v[B].m(s, null);
      A(s, r), P && P.m(s, null), A(t, o), N(a, t, null), i[30](t), d = !0, p || (m = [
        V(
          window,
          "blur",
          /*onWindowBlur*/
          i[11]
        ),
        V(
          _4.body,
          "pointerdown",
          /*onClose*/
          i[7]
        ),
        V(
          _4.body,
          "wheel",
          /*onClose*/
          i[7]
        ),
        V(t, "click", We(tt(BZ))),
        V(t, "keydown", We(
          /*onKeydownMenu*/
          i[8]
        )),
        V(t, "keyup", We(tt(
          /*onKeyupMenu*/
          i[9]
        ))),
        V(t, "pointerdown", We(qZ)),
        V(t, "pointerup", We(GZ)),
        At(c = Rs.call(
          null,
          t,
          /*styles*/
          i[0]
        )),
        At(
          /*efx*/
          i[1].call(null, t)
        )
      ], p = !0);
    },
    p(D, I) {
      if (h ? h.p && (!d || I[0] & /*$$scope*/
      262144) && Rt(
        h,
        g,
        D,
        /*$$scope*/
        D[18],
        d ? Mt(
          g,
          /*$$scope*/
          D[18],
          I,
          null
        ) : Ft(
          /*$$scope*/
          D[18]
        ),
        null
      ) : _ && _.p && (!d || I[0] & /*menu*/
      4) && _.p(D, d ? I : [-1, -1]), /*$$slots*/
      D[12].before ? y ? (y.p(D, I), I[0] & /*$$slots*/
      4096 && w(y, 1)) : (y = $4(D), y.c(), w(y, 1), y.m(s, l)) : y && (ce(), C(y, 1, 1, () => {
        y = null;
      }), ue()), I[0] & /*onClick, allItems, onKeyupItem*/
      1096) {
        k = oe(
          /*allItems*/
          D[3]
        );
        let F;
        for (F = 0; F < k.length; F += 1) {
          const H = v4(D, k, F);
          v[F] ? (v[F].p(H, I), w(v[F], 1)) : (v[F] = A4(H), v[F].c(), w(v[F], 1), v[F].m(s, r));
        }
        for (ce(), F = k.length; F < v.length; F += 1)
          O(F);
        ue();
      }
      /*$$slots*/
      D[12].after ? P ? (P.p(D, I), I[0] & /*$$slots*/
      4096 && w(P, 1)) : (P = E4(D), P.c(), w(P, 1), P.m(s, null)) : P && (ce(), C(P, 1, 1, () => {
        P = null;
      }), ue());
      const B = {};
      I[0] & /*menuEl*/
      16 && (B.elementRoot = /*menuEl*/
      D[4]), a.$set(B), c && $t(c.update) && I[0] & /*styles*/
      1 && c.update.call(
        null,
        /*styles*/
        D[0]
      );
    },
    i(D) {
      if (!d) {
        w(_, D), w(y);
        for (let I = 0; I < k.length; I += 1)
          w(v[I]);
        w(P), w(a.$$.fragment, D), is(() => {
          d && (u || (u = dl(
            t,
            /*animate*/
            i[5],
            {},
            !0
          )), u.run(1));
        }), d = !0;
      }
    },
    o(D) {
      C(_, D), C(y), v = v.filter(Boolean);
      for (let I = 0; I < v.length; I += 1)
        C(v[I]);
      C(P), C(a.$$.fragment, D), u || (u = dl(
        t,
        /*animate*/
        i[5],
        {},
        !1
      )), u.run(0), d = !1;
    },
    d(D) {
      D && (S(e), S(t)), _ && _.d(D), y && y.d(), Le(v, D), P && P.d(), j(a), i[30](null), D && u && u.end(), p = !1, Ne(m);
    }
  };
}
f(LZ, "create_fragment$3i");
const BZ = /* @__PURE__ */ f(() => null, "click_handler_5"), qZ = /* @__PURE__ */ f(() => null, "pointerdown_handler"), GZ = /* @__PURE__ */ f(() => null, "pointerup_handler");
function zZ(i, e, t) {
  let { $$slots: s = {}, $$scope: n } = e;
  const l = b7(s);
  let { menu: r = void 0 } = e, { items: o = void 0 } = e, { focusEl: a = void 0 } = e, { offset: c = void 0 } = e, { styles: u = void 0 } = e, { efx: d = void 0 } = e, { keyCode: p = void 0 } = e, { transitionOptions: m = void 0 } = e;
  const g = { x: 0, y: 0 }, h = { ignoreClasses: ["tjs-focus-wrap"] };
  let _, y, k = !1, v, O = !1;
  Sr(() => {
    const me = document.activeElement, he = y.parentElement;
    if (he instanceof HTMLElement && me instanceof HTMLElement && he.contains(me) && me.matches(":focus-visible")) {
      const Ae = dn.getFirstFocusableElement(y);
      Ae instanceof HTMLElement && !Ae.classList.contains("tjs-focus-wrap") ? (Ae.focus(), O = !0) : y.focus(), v = { focusSource: { focusEl: [me] } }, a && v.focusSource.focusEl.push(a);
    } else
      y.focus(), a && (v = { focusSource: { focusEl: [a] } });
  });
  function P(me) {
    const he = xb(me.parentElement);
    if (!((he == null ? void 0 : he.node) instanceof HTMLElement)) {
      console.warn("'TJSMenu.animate warning: Could not locate parent stacking context element.");
      return;
    }
    const Ae = he == null ? void 0 : he.node.getBoundingClientRect(), Fe = Ae.x + Ae.width, Ve = me.getBoundingClientRect(), je = me.parentElement.getBoundingClientRect(), Pe = { ...g, ...c };
    return me.style.top = `${Pe.y + je.height}px`, je.x + Ve.width < Fe ? (me.style.left = `${Pe.x}px`, me.style.removeProperty("right")) : (me.style.right = `${Pe.x}px`, me.style.removeProperty("left")), Xz(me, m);
  }
  f(P, "animate");
  function D(me) {
    const he = me == null ? void 0 : me.onPress;
    typeof he == "function" && he(me, v), k || (k = !0, y.dispatchEvent(new CustomEvent("close:popup", { bubbles: !0, cancelable: !0 })));
  }
  f(D, "onClick");
  async function I(me) {
    me.target === y || y.contains(me.target) || me.target === y.parentElement || y.parentElement.contains(me.target) || k || (k = !0, y.dispatchEvent(new CustomEvent(
      "close:popup",
      {
        bubbles: !0,
        cancelable: !0,
        detail: { target: me.target }
      }
    )));
  }
  f(I, "onClose");
  function B(me) {
    if (me.code === p) {
      me.stopPropagation();
      return;
    }
    switch (me.code) {
      case "Tab":
        if (me.stopPropagation(), me.shiftKey) {
          const he = dn.getFocusableElements(y, h), Ae = he.length > 0 ? he[0] : void 0, Fe = he.length > 0 ? he[he.length - 1] : void 0;
          (y === document.activeElement || Ae === document.activeElement) && (Fe instanceof HTMLElement && Ae !== Fe && Fe.focus(), me.preventDefault());
        }
        break;
      default:
        me.stopPropagation();
        break;
    }
  }
  f(B, "onKeydownMenu");
  function F(me) {
    switch (me.code) {
      case "Escape":
        k || (k = !0, y.dispatchEvent(new CustomEvent(
          "close:popup",
          {
            bubbles: !0,
            cancelable: !0,
            detail: { keyboardFocus: O }
          }
        ))), me.preventDefault(), me.stopPropagation();
        break;
    }
  }
  f(F, "onKeyupMenu");
  function H(me, he) {
    if (me.code === p) {
      const Ae = he == null ? void 0 : he.onPress;
      typeof Ae == "function" && Ae(he, v), k || (k = !0, me.preventDefault(), me.stopPropagation(), y.dispatchEvent(new CustomEvent(
        "close:popup",
        {
          bubbles: !0,
          cancelable: !0,
          detail: { keyboardFocus: O }
        }
      )));
    }
  }
  f(H, "onKeyupItem");
  function G() {
    k || (k = !0, y.dispatchEvent(new CustomEvent("close:popup", { bubbles: !0, cancelable: !0 })));
  }
  f(G, "onWindowBlur");
  const U = /* @__PURE__ */ f(() => D(), "click_handler"), q = /* @__PURE__ */ f((me) => H(me), "keyup_handler"), W = /* @__PURE__ */ f((me) => D(me), "click_handler_1"), X = /* @__PURE__ */ f((me, he) => H(he, me), "keyup_handler_1"), te = /* @__PURE__ */ f((me) => D(me), "click_handler_2"), J = /* @__PURE__ */ f((me, he) => H(he, me), "keyup_handler_2"), re = /* @__PURE__ */ f((me) => D(me), "click_handler_3"), ae = /* @__PURE__ */ f((me, he) => H(he, me), "keyup_handler_3"), be = /* @__PURE__ */ f(() => D(), "click_handler_4"), we = /* @__PURE__ */ f((me) => H(me), "keyup_handler_4");
  function ve(me) {
    st[me ? "unshift" : "push"](() => {
      y = me, t(4, y);
    });
  }
  return f(ve, "nav_binding"), i.$$set = (me) => {
    "menu" in me && t(2, r = me.menu), "items" in me && t(17, o = me.items), "focusEl" in me && t(13, a = me.focusEl), "offset" in me && t(14, c = me.offset), "styles" in me && t(0, u = me.styles), "efx" in me && t(1, d = me.efx), "keyCode" in me && t(15, p = me.keyCode), "transitionOptions" in me && t(16, m = me.transitionOptions), "$$scope" in me && t(18, n = me.$$scope);
  }, i.$$.update = () => {
    if (i.$$.dirty[0] & /*menu, items*/
    131076) {
      const me = ke(r) && vt(r.items) ? r.items : vt(o) ? o : [], he = [];
      let Ae = -1;
      for (const Fe of me) {
        if (Ae++, !ke(Fe))
          throw new TypeError(`TJSMenu error: 'item[${Ae}]' is not an object.`);
        if (typeof Fe.condition == "function" && !Fe.condition() || typeof Fe.condition == "boolean" && !Fe.condition)
          continue;
        let Ve;
        if (ti(Fe.class))
          Ve = "class";
        else if (typeof Fe.icon == "string")
          Ve = "icon";
        else if (typeof Fe.image == "string")
          Ve = "image";
        else if (typeof Fe.separator == "string") {
          if (Fe.separator !== "hr")
            throw new Error(`TJSMenu error: 'item[${Ae}]' has unknown separator type; only 'hr' is currently supported.`);
          Ve = "separator-hr";
        }
        if (Ve === void 0)
          throw new TypeError(`TJSMenu error: Unknown type for 'item[${Ae}]'.`);
        he.push({ ...Fe, "#type": Ve });
      }
      t(3, _ = he);
    }
    i.$$.dirty[0] & /*menu, focusEl*/
    8196 && t(13, a = ke(r) && dn.isFocusSource(r.focusEl) ? r.focusEl : dn.isFocusSource(a) ? a : void 0), i.$$.dirty[0] & /*menu, offset*/
    16388 && t(14, c = ke(r) && ke(r.offset) ? r.offset : ke(c) ? c : g), i.$$.dirty[0] & /*menu, styles*/
    5 && t(0, u = ke(r) && ke(r.styles) ? r.styles : ke(u) ? u : void 0), i.$$.dirty[0] & /*menu, efx*/
    6 && t(1, d = ke(r) && typeof r.efx == "function" ? r.efx : typeof d == "function" ? d : () => {
    }), i.$$.dirty[0] & /*menu, keyCode*/
    32772 && t(15, p = ke(r) && typeof r.keyCode == "string" ? r.keyCode : typeof p == "string" ? p : "Enter"), i.$$.dirty[0] & /*menu, transitionOptions*/
    65540 && t(16, m = ke(r) && ke(r.transitionOptions) ? r.transitionOptions : ke(m) ? m : { duration: 200, easing: Rz });
  }, [
    u,
    d,
    r,
    _,
    y,
    P,
    D,
    I,
    B,
    F,
    H,
    G,
    l,
    a,
    c,
    p,
    m,
    o,
    n,
    s,
    U,
    q,
    W,
    X,
    te,
    J,
    re,
    ae,
    be,
    we,
    ve
  ];
}
f(zZ, "instance$39");
const A2 = class A2 extends ie {
  constructor(e) {
    super(), le(
      this,
      e,
      zZ,
      LZ,
      ne,
      {
        menu: 2,
        items: 17,
        focusEl: 13,
        offset: 14,
        styles: 0,
        efx: 1,
        keyCode: 15,
        transitionOptions: 16
      },
      null,
      [-1, -1]
    );
  }
};
f(A2, "TJSMenu");
let tp = A2;
Ma.setProperties({
  // For components w/ transparent background checkered pattern.
  "--tjs-checkerboard-background-dark": "rgb(205, 205, 205)",
  "--tjs-checkerboard-background-10": `url('data:image/svg+xml;utf8,<svg preserveAspectRatio="none"  viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="5" height="5" fill="transparent" /><rect x="5" y="5" width="5" height="5" fill="transparent" /><rect x="5" y="0" width="5" height="5" fill="white" /><rect x="0" y="5" width="5" height="5" fill="white" /></svg>') 0 0 / 10px 10px, var(--tjs-checkerboard-background-dark, rgb(205, 205, 205))`
}, !1);
Ma.setProperties({
  "--tjs-action-ripple-background": "rgba(0, 0, 0, 0.35)"
}, !1);
Ma.setProperties({
  "--tjs-icon-button-background-hover": "rgba(0, 0, 0, 0.10)",
  "--tjs-icon-button-background-selected": "rgba(0, 0, 0, 0.20)"
}, !1);
{
  const i = y0.getProperties('input[type="text"], input[type="number"]');
  ke(i) && Ma.setProperties({
    "--tjs-input-background": "background" in i ? i.background : "rgba(0, 0, 0, 0.05)",
    "--tjs-input-border": "border" in i ? i.border : "1px solid var(--color-border-light-tertiary)",
    "--tjs-input-border-radius": "border-radius" in i ? i["border-radius"] : "3px",
    "--tjs-input-height": "height" in i ? i.height : "var(--form-field-height)",
    "--tjs-input-min-width": "min-width" in i ? i["min-width"] : "20px",
    "--tjs-input-padding": "padding" in i ? i.padding : "1px 3px",
    "--tjs-input-width": "width" in i ? i.width : "calc(100% - 2px)",
    // Set default values that are only to be referenced and not set.
    "--_tjs-default-input-height": "height" in i ? i.height : "var(--form-field-height)",
    // Set directly / no lookup:
    "--tjs-input-border-color": "var(--color-border-light-tertiary)"
  }, !1);
}
Ma.setProperties({
  // `popup` is for components that are slightly elevated, but connected to an application;
  // see: TJSMenu / TJSContextMenu / TJSColordPicker
  "--tjs-default-popup-background": "var(--color-text-dark-header, #23221d)",
  "--tjs-default-popup-border": "1px solid var(--color-border-dark, #000)",
  "--tjs-default-popup-box-shadow": "0 0 2px var(--color-shadow-dark, #000)",
  "--tjs-default-popup-primary-color": "var(--color-text-light-primary, #b5b3a4)",
  "--tjs-default-popup-highlight-color": "var(--color-text-light-highlight, #f0f0e0)",
  // `popover` is for components that are elevated and independent; see: TJSContextMenu
  "--tjs-default-popover-border": "1px solid var(--color-border-dark, #000)",
  "--tjs-default-popover-box-shadow": "0 0 10px var(--color-shadow-dark, #000)"
}, !1);
Hooks.on("PopOut:loading", (i, e) => {
  i instanceof _s && e.document.addEventListener("DOMContentLoaded", () => Ma.clone(e.document));
});
function HZ(i) {
  let e, t, s;
  return t = new $0({
    props: {
      content: (
        /*content*/
        i[0]
      ),
      enrichedContent: (
        /*enrichedContent*/
        i[2]
      ),
      options: (
        /*options*/
        i[4]
      )
    }
  }), t.$on(
    "editor:save",
    /*updateEditorContent*/
    i[3]
  ), {
    c() {
      e = E("div"), L(t.$$.fragment), b(e, "class", "editor svelte-vna24l");
    },
    m(n, l) {
      T(n, e, l), N(t, e, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*content*/
      1 && (r.content = /*content*/
      n[0]), l & /*enrichedContent*/
      4 && (r.enrichedContent = /*enrichedContent*/
      n[2]), t.$set(r);
    },
    i(n) {
      s || (w(t.$$.fragment, n), s = !0);
    },
    o(n) {
      C(t.$$.fragment, n), s = !1;
    },
    d(n) {
      n && S(e), j(t);
    }
  };
}
f(HZ, "create_fragment$3h");
function UZ(i, e, t) {
  let s, n, l = ee, r = /* @__PURE__ */ f(() => (l(), l = Et(o, (_) => t(8, n = _)), o), "$$subscribe_document");
  i.$$.on_destroy.push(() => l());
  let { document: o } = e;
  r();
  let { content: a } = e, { updatePath: c } = e, { async: u = !1 } = e;
  const d = {
    secretDescription: "A5E.NoSecretDescription",
    unidentifiedDescription: "A5E.NoUnidentifiedDescription",
    description: "A5E.NoDescription"
  };
  function p(_) {
    const { content: y } = _.detail;
    n.update({
      [c]: y === "<p></p>" ? "" : y
    });
  }
  f(p, "updateEditorContent");
  let m;
  Object.entries(d).forEach(([_, y]) => {
    c.includes(_) && t(7, m = K(y));
  });
  const g = ep.configStandard();
  g.toolbar = "styles | fontfamily | table | bullist | numlist | image | superscript | subscript | hr | save | link | removeformat | code ";
  const h = { mceConfig: g };
  return i.$$set = (_) => {
    "document" in _ && r(t(1, o = _.document)), "content" in _ && t(0, a = _.content), "updatePath" in _ && t(5, c = _.updatePath), "async" in _ && t(6, u = _.async);
  }, i.$$.update = () => {
    i.$$.dirty & /*content, newLabel*/
    129 && (t(0, a = a || m) || K("A5E.NoDescription")), i.$$.dirty & /*$document, updatePath, async*/
    352 && t(2, s = TextEditor.enrichHTML(n[c], { async: u }));
  }, [
    a,
    o,
    s,
    p,
    h,
    c,
    u,
    m,
    n
  ];
}
f(UZ, "instance$38");
const E2 = class E2 extends ie {
  constructor(e) {
    super(), le(this, e, UZ, HZ, ne, {
      document: 1,
      content: 0,
      updatePath: 5,
      async: 6
    });
  }
};
f(E2, "Editor");
let hl = E2;
function S4(i, e, t) {
  const s = i.slice();
  return s[5] = e[t].field, s[6] = e[t].label, s;
}
f(S4, "get_each_context$1k");
function T4(i) {
  let e, t = (
    /*summaryData*/
    i[0].objectMechanics + ""
  ), s;
  return {
    c() {
      e = E("p"), s = x(t), b(e, "class", "item-properties svelte-3wy19q");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*summaryData*/
      1 && t !== (t = /*summaryData*/
      n[0].objectMechanics + "") && _e(s, t);
    },
    d(n) {
      n && S(e);
    }
  };
}
f(T4, "create_if_block_5$g");
function C4(i) {
  let e, t = (
    /*summaryData*/
    i[0].objectProperties + ""
  ), s;
  return {
    c() {
      e = E("p"), s = x(t), b(e, "class", "item-properties svelte-3wy19q");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*summaryData*/
      1 && t !== (t = /*summaryData*/
      n[0].objectProperties + "") && _e(s, t);
    },
    d(n) {
      n && S(e);
    }
  };
}
f(C4, "create_if_block_4$o");
function O4(i) {
  let e, t = (
    /*summaryData*/
    i[0].maneuverProperties + ""
  ), s;
  return {
    c() {
      e = E("p"), s = x(t), b(e, "class", "item-properties svelte-3wy19q");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*summaryData*/
      1 && t !== (t = /*summaryData*/
      n[0].maneuverProperties + "") && _e(s, t);
    },
    d(n) {
      n && S(e);
    }
  };
}
f(O4, "create_if_block_3$t");
function D4(i) {
  let e, t = (
    /*summaryData*/
    i[0].spellProperties + ""
  ), s;
  return {
    c() {
      e = E("p"), s = x(t), b(e, "class", "item-properties svelte-3wy19q");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*summaryData*/
      1 && t !== (t = /*summaryData*/
      n[0].spellProperties + "") && _e(s, t);
    },
    d(n) {
      n && S(e);
    }
  };
}
f(D4, "create_if_block_2$L");
function I4(i) {
  let e, t, s = oe(
    /*fields*/
    i[2]
  ), n = [];
  for (let l = 0; l < s.length; l += 1)
    n[l] = M4(S4(i, s, l));
  return {
    c() {
      e = E("ul");
      for (let l = 0; l < n.length; l += 1)
        n[l].c();
      b(e, "class", "summary-list svelte-3wy19q"), is(() => (
        /*ul_elementresize_handler*/
        i[4].call(e)
      )), Q(
        e,
        "hide",
        /*listHeight*/
        i[1] === 0
      );
    },
    m(l, r) {
      T(l, e, r);
      for (let o = 0; o < n.length; o += 1)
        n[o] && n[o].m(e, null);
      t = yz(
        e,
        /*ul_elementresize_handler*/
        i[4].bind(e)
      );
    },
    p(l, r) {
      if (r & /*summaryData, fields*/
      5) {
        s = oe(
          /*fields*/
          l[2]
        );
        let o;
        for (o = 0; o < s.length; o += 1) {
          const a = S4(l, s, o);
          n[o] ? n[o].p(a, r) : (n[o] = M4(a), n[o].c(), n[o].m(e, null));
        }
        for (; o < n.length; o += 1)
          n[o].d(1);
        n.length = s.length;
      }
      r & /*listHeight*/
      2 && Q(
        e,
        "hide",
        /*listHeight*/
        l[1] === 0
      );
    },
    d(l) {
      l && S(e), Le(n, l), t();
    }
  };
}
f(I4, "create_if_block$1Q");
function P4(i) {
  let e, t, s, n = (
    /*summaryData*/
    i[0][
      /*field*/
      i[5]
    ] + ""
  ), l, r;
  return {
    c() {
      e = E("li"), t = E("span"), t.textContent = `${K(
        /*label*/
        i[6]
      )}:`, s = R(), l = x(n), r = R(), b(t, "class", "field-header svelte-3wy19q");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(e, s), A(e, l), A(e, r);
    },
    p(o, a) {
      a & /*summaryData*/
      1 && n !== (n = /*summaryData*/
      o[0][
        /*field*/
        o[5]
      ] + "") && _e(l, n);
    },
    d(o) {
      o && S(e);
    }
  };
}
f(P4, "create_if_block_1$1d");
function M4(i) {
  let e, t = (
    /*summaryData*/
    i[0][
      /*field*/
      i[5]
    ] && P4(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*summaryData*/
      s[0][
        /*field*/
        s[5]
      ] ? t ? t.p(s, n) : (t = P4(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && S(e), t && t.d(s);
    }
  };
}
f(M4, "create_each_block$1k");
function VZ(i) {
  let e, t, s, n, l, r = (
    /*fields*/
    i[2].some(
      /*func*/
      i[3]
    )
  ), o = (
    /*summaryData*/
    i[0].objectMechanics && T4(i)
  ), a = (
    /*summaryData*/
    i[0].objectProperties && C4(i)
  ), c = (
    /*summaryData*/
    i[0].maneuverProperties && O4(i)
  ), u = (
    /*summaryData*/
    i[0].spellProperties && D4(i)
  ), d = r && I4(i);
  return {
    c() {
      e = E("div"), o && o.c(), t = R(), a && a.c(), s = R(), c && c.c(), n = R(), u && u.c(), l = R(), d && d.c(), b(e, "class", "summary-wrapper svelte-3wy19q");
    },
    m(p, m) {
      T(p, e, m), o && o.m(e, null), A(e, t), a && a.m(e, null), A(e, s), c && c.m(e, null), A(e, n), u && u.m(e, null), A(e, l), d && d.m(e, null);
    },
    p(p, [m]) {
      /*summaryData*/
      p[0].objectMechanics ? o ? o.p(p, m) : (o = T4(p), o.c(), o.m(e, t)) : o && (o.d(1), o = null), /*summaryData*/
      p[0].objectProperties ? a ? a.p(p, m) : (a = C4(p), a.c(), a.m(e, s)) : a && (a.d(1), a = null), /*summaryData*/
      p[0].maneuverProperties ? c ? c.p(p, m) : (c = O4(p), c.c(), c.m(e, n)) : c && (c.d(1), c = null), /*summaryData*/
      p[0].spellProperties ? u ? u.p(p, m) : (u = D4(p), u.c(), u.m(e, l)) : u && (u.d(1), u = null), m & /*summaryData*/
      1 && (r = /*fields*/
      p[2].some(
        /*func*/
        p[3]
      )), r ? d ? d.p(p, m) : (d = I4(p), d.c(), d.m(e, null)) : d && (d.d(1), d = null);
    },
    i: ee,
    o: ee,
    d(p) {
      p && S(e), o && o.d(), a && a.d(), c && c.d(), u && u.d(), d && d.d();
    }
  };
}
f(VZ, "create_fragment$3g");
function WZ(i, e, t) {
  const s = [
    {
      field: "craftingComponents",
      label: "A5E.CraftingComponents"
    },
    { field: "spellClasses", label: "Classes" },
    {
      field: "activationCost",
      label: "A5E.ActionActivationCost"
    },
    { field: "ranges", label: "A5E.ItemRange" },
    {
      field: "targets",
      label: "A5E.ItemTargetPlural"
    },
    { field: "area", label: "A5E.TargetArea" },
    {
      field: "spellComponents",
      label: "A5E.SpellComponents"
    },
    {
      field: "duration",
      label: "A5E.ItemDuration"
    }
  ];
  let { summaryData: n = {} } = e, l;
  const r = /* @__PURE__ */ f(({ field: a }) => n[a], "func");
  function o() {
    l = this.clientHeight, t(1, l);
  }
  return f(o, "ul_elementresize_handler"), i.$$set = (a) => {
    "summaryData" in a && t(0, n = a.summaryData);
  }, [n, l, s, r, o];
}
f(WZ, "instance$37");
const S2 = class S2 extends ie {
  constructor(e) {
    super(), le(this, e, WZ, VZ, ne, { summaryData: 0 });
  }
};
f(S2, "ItemSummary");
let va = S2;
function R4(i) {
  let e, t, s, n, l;
  return e = new va({
    props: { summaryData: (
      /*summaryData*/
      i[0]
    ) }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), n = E("hr"), z(t, "display", "contents"), z(t, "--inline-padding", "0.25rem"), b(n, "class", "a5e-rule a5e-rule--card");
    },
    m(r, o) {
      T(r, t, o), N(e, t, null), T(r, s, o), T(r, n, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*summaryData*/
      1 && (a.summaryData = /*summaryData*/
      r[0]), e.$set(a);
    },
    i(r) {
      l || (w(e.$$.fragment, r), l = !0);
    },
    o(r) {
      C(e.$$.fragment, r), l = !1;
    },
    d(r) {
      r && (S(s), S(n)), r && e && S(t), j(e, r);
    }
  };
}
f(R4, "create_if_block$1P");
function KZ(i) {
  let e = Object.values(
    /*summaryData*/
    i[0] ?? {}
  ).some(Boolean), t, s, n, l, r, o, a = e && R4(i);
  return n = new Ze({
    props: {
      heading: "A5E.ActionDescriptionOptions",
      hint: "A5E.ActionDescriptionOptionsHint",
      options: (
        /*descriptionOutputOptions*/
        i[6]
      ),
      selected: (
        /*descriptionOutputs*/
        i[2]
      )
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  ), r = new hl({
    props: {
      document: (
        /*item*/
        i[4]
      ),
      content: (
        /*content*/
        i[3]
      ),
      updatePath: `system.actions.${/*actionId*/
      i[5]}.description`
    }
  }), {
    c() {
      a && a.c(), t = R(), s = E("section"), L(n.$$.fragment), l = R(), L(r.$$.fragment), b(s, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable");
    },
    m(c, u) {
      a && a.m(c, u), T(c, t, u), T(c, s, u), N(n, s, null), A(s, l), N(r, s, null), o = !0;
    },
    p(c, [u]) {
      u & /*summaryData*/
      1 && (e = Object.values(
        /*summaryData*/
        c[0] ?? {}
      ).some(Boolean)), e ? a ? (a.p(c, u), u & /*summaryData*/
      1 && w(a, 1)) : (a = R4(c), a.c(), w(a, 1), a.m(t.parentNode, t)) : a && (ce(), C(a, 1, 1, () => {
        a = null;
      }), ue());
      const d = {};
      u & /*descriptionOutputs*/
      4 && (d.selected = /*descriptionOutputs*/
      c[2]), n.$set(d);
      const p = {};
      u & /*content*/
      8 && (p.content = /*content*/
      c[3]), r.$set(p);
    },
    i(c) {
      o || (w(a), w(n.$$.fragment, c), w(r.$$.fragment, c), o = !0);
    },
    o(c) {
      C(a), C(n.$$.fragment, c), C(r.$$.fragment, c), o = !1;
    },
    d(c) {
      c && (S(t), S(s)), a && a.d(c), j(n), j(r);
    }
  };
}
f(KZ, "create_fragment$3f");
function YZ(i, e, t) {
  let s, n, l, { summaryData: r = {} } = e;
  const o = fe("item");
  pe(i, o, (d) => t(1, l = d));
  const a = fe("actionId"), c = [["action", "A5E.ActionActivationAction"], ["item", "A5E.Item"]], u = /* @__PURE__ */ f(({ detail: d }) => se(l, `system.actions.${a}.descriptionOutputs`, d), "updateSelection_handler");
  return i.$$set = (d) => {
    "summaryData" in d && t(0, r = d.summaryData);
  }, i.$$.update = () => {
    var d, p;
    i.$$.dirty & /*$item*/
    2 && t(3, s = (d = l.system.actions[a]) == null ? void 0 : d.description), i.$$.dirty & /*$item*/
    2 && t(2, n = ((p = l.system.actions[a]) == null ? void 0 : p.descriptionOutputs) ?? ["item"]), i.$$.dirty & /*$item*/
    2 && t(0, r = Of(l, l.actions.get(a)));
  }, [
    r,
    l,
    n,
    s,
    o,
    a,
    c,
    u
  ];
}
f(YZ, "instance$36");
const T2 = class T2 extends ie {
  constructor(e) {
    super(), le(this, e, YZ, KZ, ne, { summaryData: 0 });
  }
};
f(T2, "ActionsDescriptionTab");
let A0 = T2;
const li = It({});
function XZ(i, e) {
  if (i === "feature")
    return K(CONFIG.A5E.featureTypes[e]);
  if (i === "object")
    return K(CONFIG.A5E.objectTypes[e]);
  if (i === "spell") {
    const t = parseInt(e, 10);
    return K(t === 0 ? CONFIG.A5E.spellLevels[0] : "A5E.Spell");
  }
  return K(CONFIG.A5E.itemTypes[i]);
}
f(XZ, "getItemName");
function JZ(i) {
  return {
    featureType: i
  };
}
f(JZ, "createFeature");
function ZZ(i) {
  const e = {
    degree: Number(i)
  }, t = {
    [foundry.utils.randomID()]: {
      name: "Execute",
      consumers: {
        [foundry.utils.randomID()]: {
          resource: "exertion",
          quantity: 1,
          type: "resource"
        }
      }
    }
  };
  return e.actions = t, e;
}
f(ZZ, "createManuever");
function QZ(i) {
  return {
    objectType: i
  };
}
f(QZ, "createObject");
function xZ(i, e = {}) {
  var r, o, a, c;
  const { actor: t } = e, s = ((o = (r = fn(li)) == null ? void 0 : r[t.uuid]) == null ? void 0 : o.currentSpellBook) || ((c = (a = t.spellBooks) == null ? void 0 : a.first()) == null ? void 0 : c._id), n = {
    level: Number(i),
    spellBook: s
  };
  if (n.level === 0)
    return n;
  const l = {
    [foundry.utils.randomID()]: {
      name: "Cast Spell",
      consumers: {
        [foundry.utils.randomID()]: {
          mode: "variable",
          spellLevel: Number(i),
          points: CONFIG.A5E.spellLevelCost[Number(i)],
          type: "spell"
        }
      }
    }
  };
  return n.actions = l, n;
}
f(xZ, "createSpell");
const eQ = {
  feature: JZ,
  maneuver: ZZ,
  object: QZ,
  spell: xZ
};
async function tQ(i, e, t) {
  const s = {
    name: K("A5E.NewItem", { type: K(XZ(e, t)) }),
    type: e,
    system: eQ[e](t, { actor: i })
  };
  (await i.createEmbeddedDocuments("Item", [s])).forEach((l) => {
    var r;
    return (r = l == null ? void 0 : l.sheet) == null ? void 0 : r.render(!0);
  });
}
f(tQ, "createItem");
async function sQ(i, { effectType: e, actionId: t }) {
  var r;
  const s = ((r = i == null ? void 0 : i.actions) == null ? void 0 : r[t]) ?? {}, n = {
    label: K("A5E.effects.new"),
    icon: i.documentName === "Item" ? (s == null ? void 0 : s.img) ?? i.img : "icons/svg/aura.svg",
    origin: i.uuid
  };
  if (foundry.utils.setProperty(n, "flags.a5e.sort", 0), i.documentName === "Item")
    if (n.transfer = !1, e === "onUse") {
      if (!t) {
        ui.notifications.error(K("A5E.notifications.effects.noActionId"));
        return;
      }
      foundry.utils.setProperty(n, "flags.a5e.transferType", "onUse"), foundry.utils.setProperty(n, "flags.a5e.actionId", t);
    } else
      foundry.utils.setProperty(n, "flags.a5e.transferType", "passive");
  e === "inactive" && (n.disabled = !0);
  const l = await i.createEmbeddedDocuments("ActiveEffect", [n]);
  if (l.forEach((o) => {
    var a;
    return (a = o == null ? void 0 : o.sheet) == null ? void 0 : a.render(!0);
  }), e === "onUse") {
    if (!s)
      return;
    ri.addPrompt(
      i,
      [t, s],
      "effect",
      { effectId: l[0].id }
    );
  }
}
f(sQ, "createEffect");
function F4(i, e, t) {
  const s = i.slice();
  return s[13] = e[t][0], s[14] = e[t][1], s;
}
f(F4, "get_each_context$1j");
function nQ(i) {
  let e, t, s;
  return e = new ya({
    props: {
      title: "Add " + /*documentName*/
      i[0],
      icon: "fas fa-plus",
      onPress: (
        /*func*/
        i[10]
      )
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--tjs-icon-button-background-hover", "none"), z(t, "--tjs-icon-button-background-focus", "none"), z(t, "--tjs-icon-button-background-focus-visible", "none"), z(t, "--tjs-icon-button-background-selected", "none"), z(t, "--tjs-icon-button-text-shadow-hover", "none"), z(t, "--tjs-icon-button-text-shadow-focus", "none"), z(t, "--tjs-icon-button-transition", "$standard-transition"), z(t, "--tjs-icon-button-diameter", "1rem"), z(t, "--tjs-icon-button-border-radius", "0");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*documentName*/
      1 && (r.title = "Add " + /*documentName*/
      n[0]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(nQ, "create_else_block$y");
function iQ(i) {
  let e, t, s;
  return e = new Qd({
    props: {
      title: "Add " + /*documentName*/
      i[0],
      icon: "fas fa-plus",
      $$slots: { default: [rQ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--tjs-icon-button-background-hover", "none"), z(t, "--tjs-icon-button-background-focus", "none"), z(t, "--tjs-icon-button-background-focus-visible", "none"), z(t, "--tjs-icon-button-background-selected", "none"), z(t, "--tjs-icon-button-text-shadow-hover", "none"), z(t, "--tjs-icon-button-text-shadow-focus", "none"), z(t, "--tjs-icon-button-transition", "all 0.15s ease-in-out"), z(t, "--tjs-icon-button-diameter", "1.1rem"), z(t, "--tjs-icon-button-border-radius", "0");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*documentName*/
      1 && (r.title = "Add " + /*documentName*/
      n[0]), l & /*$$scope, offset, menuList*/
      131078 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(iQ, "create_if_block$1O");
function N4(i) {
  let e, t = K(
    /*heading*/
    i[14]
  ) + "", s, n, l, r;
  function o() {
    return (
      /*click_handler*/
      i[9](
        /*type*/
        i[13]
      )
    );
  }
  return f(o, "click_handler"), {
    c() {
      e = E("button"), s = x(t), n = R(), b(e, "class", "svelte-1ca75lv");
    },
    m(a, c) {
      T(a, e, c), A(e, s), A(e, n), l || (r = V(e, "click", tt(o)), l = !0);
    },
    p(a, c) {
      i = a, c & /*menuList*/
      2 && t !== (t = K(
        /*heading*/
        i[14]
      ) + "") && _e(s, t);
    },
    d(a) {
      a && S(e), l = !1, r();
    }
  };
}
f(N4, "create_each_block$1j");
function lQ(i) {
  let e, t = oe(
    /*menuList*/
    i[1]
  ), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = N4(F4(i, t, n));
  return {
    c() {
      e = E("article");
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      b(e, "class", "svelte-1ca75lv");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l & /*createDocument, menuList*/
      10) {
        t = oe(
          /*menuList*/
          n[1]
        );
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = F4(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = N4(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && S(e), Le(s, n);
    }
  };
}
f(lQ, "create_default_slot_1$Q");
function rQ(i) {
  let e, t;
  return e = new tp({
    props: {
      offset: (
        /*offset*/
        i[2]
      ),
      $$slots: { default: [lQ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*offset*/
      4 && (l.offset = /*offset*/
      s[2]), n & /*$$scope, menuList*/
      131074 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(rQ, "create_default_slot$1x");
function oQ(i) {
  let e, t, s, n;
  const l = [iQ, nQ], r = [];
  function o(a, c) {
    return (
      /*menuList*/
      a[1].length ? 0 : 1
    );
  }
  return f(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, [c]) {
      let u = e;
      e = o(a), e === u ? r[e].p(a, c) : (ce(), C(r[u], 1, 1, () => {
        r[u] = null;
      }), ue(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), r[e].d(a);
    }
  };
}
f(oQ, "create_fragment$3e");
function aQ(i, e, t) {
  let s, { documentName: n = "Item" } = e, { menuList: l = [] } = e, { offset: r = { x: 0, y: 0 } } = e, { reducerType: o = null } = e, { reducer: a = null } = e, { options: c = {} } = e, { entityTypeOverride: u = null } = e;
  function d(_) {
    if (_ || (_ = u), !["Item", "ActiveEffect"].includes(n))
      return m("press", _);
    if (n === "Item" && s.documentName === "Actor")
      return tQ(s, o.slice(0, -1), _);
    if (n === "ActiveEffect")
      return sQ(s, c);
  }
  f(d, "createDocument");
  const p = fe("actor") ?? fe("item");
  pe(i, p, (_) => t(11, s = _)), a || (a = p[o]);
  const m = it(), g = /* @__PURE__ */ f((_) => d(_), "click_handler"), h = /* @__PURE__ */ f(() => d(), "func");
  return i.$$set = (_) => {
    "documentName" in _ && t(0, n = _.documentName), "menuList" in _ && t(1, l = _.menuList), "offset" in _ && t(2, r = _.offset), "reducerType" in _ && t(6, o = _.reducerType), "reducer" in _ && t(5, a = _.reducer), "options" in _ && t(7, c = _.options), "entityTypeOverride" in _ && t(8, u = _.entityTypeOverride);
  }, [
    n,
    l,
    r,
    d,
    p,
    a,
    o,
    c,
    u,
    g,
    h
  ];
}
f(aQ, "instance$35");
const C2 = class C2 extends ie {
  constructor(e) {
    super(), le(this, e, aQ, oQ, ne, {
      documentName: 0,
      menuList: 1,
      offset: 2,
      reducerType: 6,
      reducer: 5,
      options: 7,
      entityTypeOverride: 8
    });
  }
};
f(C2, "CreateMenu");
let Ys = C2;
function j4(i) {
  let e, t;
  return e = new bt({
    props: {
      hint: "You can reenable this dialog at any time by turning off the 'Hide Deletion Confirmation Dialog' system setting.",
      $$slots: { default: [cQ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, hideDeleteConfirmation*/
      516 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(j4, "create_if_block$1N");
function cQ(i) {
  let e, t;
  return e = new De({
    props: {
      label: "Don't show this dialog again",
      checked: (
        /*hideDeleteConfirmation*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[6]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*hideDeleteConfirmation*/
      4 && (l.checked = /*hideDeleteConfirmation*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(cQ, "create_default_slot$1w");
function uQ(i) {
  let e, t, s, n, l, r, o = `Delete ${/*itemDocument*/
  i[0].type.capitalize()}`, a, c, u, d, p, m, g = !/*hideDeleteSection*/
  i[1] && j4(i);
  return {
    c() {
      e = E("form"), g && g.c(), t = R(), s = E("div"), n = E("button"), l = E("i"), r = R(), a = x(o), c = R(), u = E("button"), u.innerHTML = `<i class="fa-solid fa-ban"></i>
            Cancel Deletion`, b(l, "class", "fa-solid fa-trash"), b(s, "class", "button-container svelte-1ev6ohd"), b(e, "class", "svelte-1ev6ohd");
    },
    m(h, _) {
      T(h, e, _), g && g.m(e, null), A(e, t), A(e, s), A(s, n), A(n, l), A(n, r), A(n, a), A(s, c), A(s, u), d = !0, p || (m = [
        V(n, "click", tt(
          /*click_handler*/
          i[7]
        )),
        V(u, "click", tt(
          /*click_handler_1*/
          i[8]
        ))
      ], p = !0);
    },
    p(h, [_]) {
      /*hideDeleteSection*/
      h[1] ? g && (ce(), C(g, 1, 1, () => {
        g = null;
      }), ue()) : g ? (g.p(h, _), _ & /*hideDeleteSection*/
      2 && w(g, 1)) : (g = j4(h), g.c(), w(g, 1), g.m(e, t)), (!d || _ & /*itemDocument*/
      1) && o !== (o = `Delete ${/*itemDocument*/
      h[0].type.capitalize()}`) && _e(a, o);
    },
    i(h) {
      d || (w(g), d = !0);
    },
    o(h) {
      C(g), d = !1;
    },
    d(h) {
      h && S(e), g && g.d(), p = !1, Ne(m);
    }
  };
}
f(uQ, "create_fragment$3d");
function fQ(i, e, t) {
  let { dialog: s, itemDocument: n, hideDeleteSection: l } = fe("#external").application, { dialog: r = s, itemDocument: o = n, hideDeleteSection: a = l } = e;
  function c() {
    r.submit({
      confirmDeletion: !0,
      hideDeleteConfirmation: d
    });
  }
  f(c, "onSubmit");
  function u() {
    r.submit({ confirmDeletion: !1 });
  }
  f(u, "onCancelDeletion");
  let d = game.settings.get("a5e", "hideDeleteConfirmation");
  const p = /* @__PURE__ */ f(({ detail: h }) => {
    t(2, d = h);
  }, "updateSelection_handler"), m = /* @__PURE__ */ f(() => c(), "click_handler"), g = /* @__PURE__ */ f(() => u(), "click_handler_1");
  return i.$$set = (h) => {
    "dialog" in h && t(5, r = h.dialog), "itemDocument" in h && t(0, o = h.itemDocument), "hideDeleteSection" in h && t(1, a = h.hideDeleteSection);
  }, [
    o,
    a,
    d,
    c,
    u,
    r,
    p,
    m,
    g
  ];
}
f(fQ, "instance$34");
var Yu;
let dQ = (Yu = class extends ie {
  constructor(e) {
    super(), le(this, e, fQ, uQ, ne, {
      dialog: 5,
      itemDocument: 0,
      hideDeleteSection: 1
    });
  }
}, f(Yu, "DeletionConfirmationDialog"), Yu);
var Xu, E0;
const O2 = class O2 extends Fs {
  constructor(t, s = !1) {
    super({
      title: `${t == null ? void 0 : t.name}: Confirm Deletion`,
      content: {
        class: dQ,
        props: { itemDocument: t, hideDeleteSection: s }
      }
    }, {
      classes: ["a5e-sheet"],
      width: 420
    });
    Y(this, Xu);
    this.data.content.props.dialog = this, this.promise = new Promise((n) => {
      this.resolve = n;
    });
  }
  /** @inheritdoc */
  close(t) {
    return Z(this, Xu, E0).call(this, null), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    return Z(this, Xu, E0).call(this, t), super.close();
  }
};
Xu = new WeakSet(), E0 = /* @__PURE__ */ f(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), f(O2, "DeletionConfirmationDialog");
let Rc = O2;
function L4(i) {
  let e;
  return {
    c() {
      e = E("div"), e.innerHTML = '<div class="component svelte-grdis8" data-tooltip="A5E.effects.types.singular.temporary" data-tooltip-direction="UP"><i class="fa-solid fa-hourglass-half"></i></div>', b(e, "class", "component-wrapper svelte-grdis8");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(L4, "create_if_block_4$n");
function B4(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "effect-button fa-regular fa-circle-down svelte-grdis8"), b(e, "data-tooltip", "A5E.effects.applyToActor"), b(e, "data-tooltip-direction", "UP");
    },
    m(n, l) {
      T(n, e, l), t || (s = V(
        e,
        "click",
        /*click_handler_2*/
        i[12]
      ), t = !0);
    },
    p: ee,
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(B4, "create_if_block_3$s");
function q4(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "effect-button effect-button--active-toggle fas svelte-grdis8"), b(e, "data-tooltip", t = /*effect*/
      i[0].isLocked ? "Originating item is not equipped." : "A5E.effects.toggleActiveState"), b(e, "data-tooltip-direction", "UP"), Q(
        e,
        "fa-toggle-off",
        /*effect*/
        i[0].isSuppressed
      ), Q(e, "fa-toggle-on", !/*effect*/
      i[0].isSuppressed), Q(e, "active", !/*effect*/
      i[0].isSuppressed), Q(
        e,
        "locked",
        /*effect*/
        i[0].isLocked
      );
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "click",
        /*click_handler_3*/
        i[13]
      ), s = !0);
    },
    p(l, r) {
      r & /*effect*/
      1 && t !== (t = /*effect*/
      l[0].isLocked ? "Originating item is not equipped." : "A5E.effects.toggleActiveState") && b(e, "data-tooltip", t), r & /*effect*/
      1 && Q(
        e,
        "fa-toggle-off",
        /*effect*/
        l[0].isSuppressed
      ), r & /*effect*/
      1 && Q(e, "fa-toggle-on", !/*effect*/
      l[0].isSuppressed), r & /*effect*/
      1 && Q(e, "active", !/*effect*/
      l[0].isSuppressed), r & /*effect*/
      1 && Q(
        e,
        "locked",
        /*effect*/
        l[0].isLocked
      );
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(q4, "create_if_block_2$K");
function G4(i) {
  let e, t = !/*sheetIsLocked*/
  i[2] && z4(i);
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*sheetIsLocked*/
      s[2] ? t && (t.d(1), t = null) : t ? t.p(s, n) : (t = z4(s), t.c(), t.m(e.parentNode, e));
    },
    d(s) {
      s && S(e), t && t.d(s);
    }
  };
}
f(G4, "create_if_block$1M");
function z4(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g;
  return {
    c() {
      e = E("div"), t = E("i"), s = R(), n = E("ul"), l = E("li"), r = E("button"), o = R(), a = E("li"), c = E("button"), u = R(), d = E("li"), p = E("button"), b(t, "class", "track-icon fa-solid fa-ellipsis-vertical svelte-grdis8"), b(r, "class", "action-button fas fa-cog svelte-grdis8"), b(r, "data-tooltip", "A5E.ButtonToolTipConfigure"), b(r, "data-tooltip-direction", "UP"), b(c, "class", "action-button fa-solid fa-clone svelte-grdis8"), b(c, "data-tooltip", "A5E.ButtonToolTipDuplicate"), b(c, "data-tooltip-direction", "UP"), b(p, "class", "action-button delete-button fas fa-trash svelte-grdis8"), b(p, "data-tooltip", "A5E.ButtonToolTipDelete"), b(p, "data-tooltip-direction", "UP"), b(n, "class", "track-items svelte-grdis8"), b(e, "class", "track svelte-grdis8");
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(e, s), A(e, n), A(n, l), A(l, r), A(n, o), A(n, a), A(a, c), A(n, u), A(n, d), A(d, p), m || (g = [
        V(r, "click", We(
          /*onConfigure*/
          i[4]
        )),
        V(c, "click", We(
          /*onDuplicate*/
          i[5]
        )),
        V(p, "click", We(
          /*onDelete*/
          i[6]
        )),
        V(e, "click", We(
          /*click_handler*/
          i[10]
        ))
      ], m = !0);
    },
    p: ee,
    d(h) {
      h && S(e), m = !1, Ne(g);
    }
  };
}
f(z4, "create_if_block_1$1c");
function pQ(i) {
  let e, t, s, n, l, r, o, a, c = (
    /*effect*/
    i[0].name + ""
  ), u, d, p, m, g, h, _, y, k, v = (
    /*effect*/
    i[0].isTemporary && L4()
  ), O = (
    /*allowTransfer*/
    i[3] && B4(i)
  ), P = (
    /*$doc*/
    i[1].documentName === "Actor" && q4(i)
  ), D = (
    /*$doc*/
    i[1].isOwner && G4(i)
  );
  return {
    c() {
      var I, B;
      e = E("li"), t = E("button"), s = E("img"), r = R(), o = E("div"), a = E("div"), u = x(c), d = R(), p = E("div"), v && v.c(), m = R(), g = E("div"), O && O.c(), h = R(), P && P.c(), _ = R(), D && D.c(), b(s, "class", "effect-image svelte-grdis8"), ze(s.src, n = /*effect*/
      ((I = i[0]) == null ? void 0 : I.icon) ?? /*doc*/
      i[8].img ?? "icons/svg/aura.svg") || b(s, "src", n), b(s, "alt", l = /*effect*/
      ((B = i[0]) == null ? void 0 : B.name) ?? K("A5E.effects.new")), b(t, "class", "effect-activate-button svelte-grdis8"), t.disabled = !0, Q(t, "disable-pointer-events", !/*$doc*/
      i[1].isOwner), b(a, "class", "name svelte-grdis8"), b(o, "class", "name-wrapper svelte-grdis8"), b(g, "class", "button-wrapper svelte-grdis8"), b(p, "class", "indicator-wrapper svelte-grdis8"), b(e, "class", "a5e-item a5e-item--effect"), b(e, "draggable", "true");
    },
    m(I, B) {
      T(I, e, B), A(e, t), A(t, s), A(e, r), A(e, o), A(o, a), A(a, u), A(e, d), A(e, p), v && v.m(p, null), A(p, m), A(p, g), O && O.m(g, null), A(g, h), P && P.m(g, null), A(e, _), D && D.m(e, null), y || (k = [
        V(t, "click", We(
          /*click_handler_1*/
          i[11]
        )),
        V(
          e,
          "dragstart",
          /*onDragStart*/
          i[7]
        ),
        V(e, "auxclick", tt(
          /*auxclick_handler*/
          i[14]
        ))
      ], y = !0);
    },
    p(I, [B]) {
      var F, H;
      B & /*effect*/
      1 && !ze(s.src, n = /*effect*/
      ((F = I[0]) == null ? void 0 : F.icon) ?? /*doc*/
      I[8].img ?? "icons/svg/aura.svg") && b(s, "src", n), B & /*effect*/
      1 && l !== (l = /*effect*/
      ((H = I[0]) == null ? void 0 : H.name) ?? K("A5E.effects.new")) && b(s, "alt", l), B & /*$doc*/
      2 && Q(t, "disable-pointer-events", !/*$doc*/
      I[1].isOwner), B & /*effect*/
      1 && c !== (c = /*effect*/
      I[0].name + "") && _e(u, c), /*effect*/
      I[0].isTemporary ? v || (v = L4(), v.c(), v.m(p, m)) : v && (v.d(1), v = null), /*allowTransfer*/
      I[3] ? O ? O.p(I, B) : (O = B4(I), O.c(), O.m(g, h)) : O && (O.d(1), O = null), /*$doc*/
      I[1].documentName === "Actor" ? P ? P.p(I, B) : (P = q4(I), P.c(), P.m(g, null)) : P && (P.d(1), P = null), /*$doc*/
      I[1].isOwner ? D ? D.p(I, B) : (D = G4(I), D.c(), D.m(e, null)) : D && (D.d(1), D = null);
    },
    i: ee,
    o: ee,
    d(I) {
      I && S(e), v && v.d(), O && O.d(), P && P.d(), D && D.d(), y = !1, Ne(k);
    }
  };
}
f(pQ, "create_fragment$3c");
function mQ(i, e, t) {
  let s, n, l, { effect: r } = e;
  function o() {
    var v;
    (v = r.sheet) == null || v.render(!0);
  }
  f(o, "onConfigure");
  function a() {
    r.duplicateEffect();
  }
  f(a, "onDuplicate");
  async function c() {
    let v;
    if (!game.settings.get("a5e", "hideDeleteConfirmation")) {
      const I = { name: r.name, type: "Active Effect" }, B = new Rc(I);
      if (await B.render(!0), v = await B.promise, !v || !v.confirmDeletion)
        return;
    }
    await game.settings.set("a5e", "hideDeleteConfirmation", (v == null ? void 0 : v.hideDeleteConfirmation) ?? game.settings.get("a5e", "hideDeleteConfirmation"));
    const O = r.id;
    if (r.delete(), !p || l.documentName !== "Item")
      return;
    const P = l.system.actions[p], D = Object.entries((P == null ? void 0 : P.prompts) ?? {}).find(([, I]) => I.type === "effect" && I.effectId === O);
    D != null && D[0] && l.update({
      [`system.actions.${p}.prompts.-=${D[0]}`]: null
    });
  }
  f(c, "onDelete");
  function u(v) {
    var P;
    const O = r.toDragData();
    if (O)
      return O.parentId = (P = r == null ? void 0 : r.parent) == null ? void 0 : P.id, v.dataTransfer.setData("text/plain", JSON.stringify(O));
  }
  f(u, "onDragStart");
  const d = fe("actor") ?? fe("item");
  pe(i, d, (v) => t(1, l = v));
  const p = fe("actionId");
  let m = game.settings.get("a5e", "itemRightClickConfigure") ?? !1;
  function g(v) {
    gt.call(this, i, v);
  }
  f(g, "click_handler");
  const h = /* @__PURE__ */ f(({ target: v }) => {
    v.blur();
  }, "click_handler_1"), _ = /* @__PURE__ */ f(() => r.transferEffect(l.parent), "click_handler_2"), y = /* @__PURE__ */ f(() => r.toggleActiveState(), "click_handler_3"), k = /* @__PURE__ */ f(() => {
    m && o();
  }, "auxclick_handler");
  return i.$$set = (v) => {
    "effect" in v && t(0, r = v.effect);
  }, i.$$.update = () => {
    var v, O, P;
    i.$$.dirty & /*effect, $doc*/
    3 && t(3, s = r.getFlag("a5e", "transferType") === "passive" && l.documentName === "Item" && ["Actor", "ActorDelta"].includes((v = l.parent) == null ? void 0 : v.documentName)), i.$$.dirty & /*$doc*/
    2 && t(2, n = l.isOwner ? l.documentName === "Item" ? !1 : ((P = (O = l.flags) == null ? void 0 : O.a5e) == null ? void 0 : P.sheetIsLocked) ?? !0 : !0);
  }, [
    r,
    l,
    n,
    s,
    o,
    a,
    c,
    u,
    d,
    m,
    g,
    h,
    _,
    y,
    k
  ];
}
f(mQ, "instance$33");
const D2 = class D2 extends ie {
  constructor(e) {
    super(), le(this, e, mQ, pQ, ne, { effect: 0 });
  }
};
f(D2, "Effect");
let S0 = D2;
function H4(i, e, t) {
  const s = i.slice();
  return s[7] = e[t], s;
}
f(H4, "get_each_context$1i");
function U4(i, e) {
  let t, s, n, l, r, o;
  return s = new S0({ props: { effect: (
    /*effect*/
    e[7]
  ) } }), {
    key: i,
    first: null,
    c() {
      t = $e(), n = E("div"), L(s.$$.fragment), z(n, "display", "contents"), z(n, "--effectTemplateAreas", l = /*effectTemplateConfiguration*/
      e[2].areas), z(n, "--effectTemplateColumns", r = /*effectTemplateConfiguration*/
      e[2].columns), this.first = t;
    },
    m(a, c) {
      T(a, t, c), T(a, n, c), N(s, n, null), o = !0;
    },
    p(a, c) {
      e = a, c & /*effectTemplateConfiguration*/
      4 && l !== (l = /*effectTemplateConfiguration*/
      e[2].areas) && z(n, "--effectTemplateAreas", l), c & /*effectTemplateConfiguration*/
      4 && r !== (r = /*effectTemplateConfiguration*/
      e[2].columns) && z(n, "--effectTemplateColumns", r);
      const u = {};
      c & /*effects*/
      2 && (u.effect = /*effect*/
      e[7]), s.$set(u);
    },
    i(a) {
      o || (w(s.$$.fragment, a), o = !0);
    },
    o(a) {
      C(s.$$.fragment, a), o = !1;
    },
    d(a) {
      a && S(t), a && s && S(n), j(s, a);
    }
  };
}
f(U4, "create_each_block$1i");
function hQ(i) {
  let e, t, s, n = K(
    /*label*/
    i[0]
  ) + "", l, r, o, a = [], c = /* @__PURE__ */ new Map(), u, d = oe([.../*effects*/
  i[1]]);
  const p = /* @__PURE__ */ f((m) => (
    /*effect*/
    m[7].id
  ), "get_key");
  for (let m = 0; m < d.length; m += 1) {
    let g = H4(i, d, m), h = p(g);
    c.set(h, a[m] = U4(h, g));
  }
  return {
    c() {
      e = E("section"), t = E("header"), s = E("h3"), l = x(n), r = R(), o = E("ul");
      for (let m = 0; m < a.length; m += 1)
        a[m].c();
      b(s, "class", "a5e-section-header__heading"), b(t, "class", "a5e-section-header a5e-section-header--item-list"), Q(t, "a5e-section-header--flat-bottom", [.../*effects*/
      i[1]].length), b(o, "class", "a5e-item-list");
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(t, s), A(s, l), A(e, r), A(e, o);
      for (let h = 0; h < a.length; h += 1)
        a[h] && a[h].m(o, null);
      u = !0;
    },
    p(m, [g]) {
      (!u || g & /*label*/
      1) && n !== (n = K(
        /*label*/
        m[0]
      ) + "") && _e(l, n), (!u || g & /*effects*/
      2) && Q(t, "a5e-section-header--flat-bottom", [.../*effects*/
      m[1]].length), g & /*effects, effectTemplateConfiguration*/
      6 && (d = oe([.../*effects*/
      m[1]]), ce(), a = kt(a, g, p, 1, m, d, c, o, ks, U4, null, H4), ue());
    },
    i(m) {
      if (!u) {
        for (let g = 0; g < d.length; g += 1)
          w(a[g]);
        u = !0;
      }
    },
    o(m) {
      for (let g = 0; g < a.length; g += 1)
        C(a[g]);
      u = !1;
    },
    d(m) {
      m && S(e);
      for (let g = 0; g < a.length; g += 1)
        a[g].d();
    }
  };
}
f(hQ, "create_fragment$3b");
function gQ(i, e, t) {
  let s, n, l, { label: r } = e, { effects: o } = e;
  function a(u) {
    let d = "icon name indicators", p = "min-content 1fr min-content";
    return (l.documentName === "Item" || !u) && (d += " menu", p += " 2rem"), { areas: `"${d}"`, columns: p };
  }
  f(a, "getEffectTemplateConfiguration");
  const c = fe("actor") ?? fe("item");
  return pe(i, c, (u) => t(5, l = u)), i.$$set = (u) => {
    "label" in u && t(0, r = u.label), "effects" in u && t(1, o = u.effects);
  }, i.$$.update = () => {
    var u, d;
    i.$$.dirty & /*$doc*/
    32 && t(4, s = l.isOwner ? l.documentName === "Item" ? !1 : ((d = (u = l.flags) == null ? void 0 : u.a5e) == null ? void 0 : d.sheetIsLocked) ?? !0 : !0), i.$$.dirty & /*sheetIsLocked*/
    16 && t(2, n = a(s));
  }, [r, o, n, c, s, l];
}
f(gQ, "instance$32");
const I2 = class I2 extends ie {
  constructor(e) {
    super(), le(this, e, gQ, hQ, ne, { label: 0, effects: 1 });
  }
};
f(I2, "EffectCategory");
let Fc = I2;
function bB(i) {
  const e = Kb.filters.regexObjectQuery(["name", "containerItemNames"]), t = {
    store: e,
    placeholder: "Search",
    type: "search"
  };
  return i.filters.add({ id: "searchFilter", filter: e }), t;
}
f(bB, "addSearchFilter");
function _B(i) {
  i.filters.removeById("searchFilter");
}
f(_B, "removeSearchFilter");
function bQ(i) {
  let e, t, s, n;
  return t = new xd({ props: { input: (
    /*input*/
    i[0]
  ) } }), {
    c() {
      e = E("div"), s = E("div"), L(t.$$.fragment), z(s, "display", "contents"), z(s, "--tjs-input-placeholder-color", "#555"), z(s, "--tjs-input-text-margin", "0"), z(s, "--tjs-input-text-width", "100%"), b(e, "class", "search-container svelte-1s7i15h");
    },
    m(l, r) {
      T(l, e, r), A(e, s), N(t, s, null), n = !0;
    },
    p: ee,
    i(l) {
      n || (w(t.$$.fragment, l), n = !0);
    },
    o(l) {
      C(t.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(e), j(t);
    }
  };
}
f(bQ, "create_fragment$3a");
function _Q(i, e, t) {
  let { reducerType: s } = e, { reducer: n = null } = e;
  const l = fe("actor") ?? fe("item");
  n || (n = l[s]);
  const r = bB(n);
  return Nt(() => _B(n)), i.$$set = (o) => {
    "reducerType" in o && t(2, s = o.reducerType), "reducer" in o && t(1, n = o.reducer);
  }, [r, n, s];
}
f(_Q, "instance$31");
const P2 = class P2 extends ie {
  constructor(e) {
    super(), le(this, e, _Q, bQ, ne, { reducerType: 2, reducer: 1 });
  }
};
f(P2, "Search");
let Fi = P2;
async function V4(i, e, t) {
  const s = [...e];
  s.sort((l, r) => l.name.toLowerCase().localeCompare(r.name.toLowerCase()));
  const n = s.map((l, r) => t === "ActiveEffect" ? { _id: l.id, flags: { a5e: { sort: r } } } : { _id: l.id, sort: r });
  await i.updateEmbeddedDocuments(t, n);
}
f(V4, "sortAscending");
async function yQ(i, e, t) {
  const s = [...e];
  s.sort((l, r) => l.name.toLowerCase().localeCompare(r.name.toLowerCase())).reverse();
  const n = s.map((l, r) => t === "ActiveEffect" ? { _id: l.id, flags: { a5e: { sort: r } } } : { _id: l.id, sort: r });
  await i.updateEmbeddedDocuments(t, n);
}
f(yQ, "sortDescending");
function vQ(i) {
  let e, t, s;
  return e = new ya({
    props: {
      title: "Sort",
      icon: `fas ${/*sortIcons*/
      i[3][
        /*sortMode*/
        i[1]
      ]}`,
      onPress: (
        /*onSortReducer*/
        i[4]
      )
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--tjs-icon-button-background-hover", "none"), z(t, "--tjs-icon-button-background-focus", "none"), z(t, "--tjs-icon-button-background-focus-visible", "none"), z(t, "--tjs-icon-button-background-selected", "none"), z(t, "--tjs-icon-button-text-shadow-hover", "none"), z(t, "--tjs-icon-button-text-shadow-focus", "none"), z(t, "--tjs-icon-button-transition", "all 0.15s ease-in-out"), z(t, "--tjs-icon-button-diameter", "1.1rem"), z(t, "--tjs-icon-button-border-radius", "0");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*sortMode*/
      2 && (r.icon = `fas ${/*sortIcons*/
      n[3][
        /*sortMode*/
        n[1]
      ]}`), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(vQ, "create_fragment$39");
function kQ(i, e, t) {
  let s, n, l, r = ee, o = /* @__PURE__ */ f(() => (r(), r = Et(u, (y) => t(9, l = y)), u), "$$subscribe_reducer");
  i.$$.on_destroy.push(() => r());
  let { reducerType: a } = e, { reducerId: c = null } = e, { reducer: u = null } = e;
  o();
  let { documentName: d = "Item" } = e;
  const p = fe("actor") ?? fe("item");
  pe(i, p, (y) => t(8, n = y)), u || o(u = p[a]);
  const m = {
    0: "fa-sort",
    1: "fa-arrow-down-a-z",
    2: "fa-arrow-down-z-a"
  }, g = {
    0: V4,
    1: yQ,
    2: V4
  };
  async function h() {
    await g[s](n, l, d);
    let y = (s + 1) % 3;
    y = y === 0 ? 1 : y, await n.setFlag("a5e", _, y);
  }
  f(h, "onSortReducer");
  let _ = c ? `sortMode.${a}.${c}` : `sortMode.${a}`;
  return i.$$set = (y) => {
    "reducerType" in y && t(5, a = y.reducerType), "reducerId" in y && t(6, c = y.reducerId), "reducer" in y && o(t(0, u = y.reducer)), "documentName" in y && t(7, d = y.documentName);
  }, i.$$.update = () => {
    i.$$.dirty & /*$document*/
    256 && t(1, s = n.getFlag("a5e", _) || 0);
  }, [
    u,
    s,
    p,
    m,
    h,
    a,
    c,
    d,
    n
  ];
}
f(kQ, "instance$30");
const M2 = class M2 extends ie {
  constructor(e) {
    super(), le(this, e, kQ, vQ, ne, {
      reducerType: 5,
      reducerId: 6,
      reducer: 0,
      documentName: 7
    });
  }
};
f(M2, "Sort");
let Ni = M2;
function wQ(i) {
  let e, t;
  const s = (
    /*#slots*/
    i[1].default
  ), n = Pt(
    s,
    i,
    /*$$scope*/
    i[0],
    null
  );
  return {
    c() {
      e = E("section"), n && n.c(), b(e, "class", "utility-bar svelte-47b32");
    },
    m(l, r) {
      T(l, e, r), n && n.m(e, null), t = !0;
    },
    p(l, [r]) {
      n && n.p && (!t || r & /*$$scope*/
      1) && Rt(
        n,
        s,
        l,
        /*$$scope*/
        l[0],
        t ? Mt(
          s,
          /*$$scope*/
          l[0],
          r,
          null
        ) : Ft(
          /*$$scope*/
          l[0]
        ),
        null
      );
    },
    i(l) {
      t || (w(n, l), t = !0);
    },
    o(l) {
      C(n, l), t = !1;
    },
    d(l) {
      l && S(e), n && n.d(l);
    }
  };
}
f(wQ, "create_fragment$38");
function $Q(i, e, t) {
  let { $$slots: s = {}, $$scope: n } = e;
  return i.$$set = (l) => {
    "$$scope" in l && t(0, n = l.$$scope);
  }, [n, s];
}
f($Q, "instance$2$");
const R2 = class R2 extends ie {
  constructor(e) {
    super(), le(this, e, $Q, wQ, ne, {});
  }
};
f(R2, "UtilityBar");
let ji = R2;
function W4(i, e, t) {
  const s = i.slice();
  return s[7] = e[t][0], s[8] = e[t][1], s;
}
f(W4, "get_each_context$1h");
function K4(i) {
  let e, t;
  return e = new ji({
    props: {
      $$slots: { default: [AQ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope*/
      2048 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(K4, "create_if_block_1$1b");
function AQ(i) {
  let e, t, s, n, l, r;
  return e = new Fi({ props: { reducerType: Ob } }), s = new Ni({
    props: {
      reducerType: Ob,
      documentName: "ActiveEffect"
    }
  }), l = new Ys({
    props: {
      reducerType: Ob,
      documentName: "ActiveEffect",
      options: {
        actionId: (
          /*actionId*/
          i[3]
        ),
        effectType: "onUse"
      }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment);
    },
    m(o, a) {
      N(e, o, a), T(o, t, a), N(s, o, a), T(o, n, a), N(l, o, a), r = !0;
    },
    p: ee,
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(s.$$.fragment, o), C(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (S(t), S(n)), j(e, o), j(s, o), j(l, o);
    }
  };
}
f(AQ, "create_default_slot$1v");
function Y4(i) {
  let e, t;
  return e = new Fc({
    props: {
      label: (
        /*subTypes*/
        i[5][
          /*label*/
          i[7]
        ]
      ),
      effects: (
        /*effects*/
        i[8]
      )
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$activeEffects*/
      2 && (l.label = /*subTypes*/
      s[5][
        /*label*/
        s[7]
      ]), n & /*$activeEffects*/
      2 && (l.effects = /*effects*/
      s[8]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Y4, "create_if_block$1L");
function X4(i) {
  let e, t, s = (
    /*effects*/
    i[8].length && /*label*/
    i[7] === "onUse" && Y4(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*effects*/
      n[8].length && /*label*/
      n[7] === "onUse" ? s ? (s.p(n, l), l & /*$activeEffects*/
      2 && w(s, 1)) : (s = Y4(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ce(), C(s, 1, 1, () => {
        s = null;
      }), ue());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f(X4, "create_each_block$1h");
function EQ(i) {
  let e, t, s, n = (
    /*$item*/
    i[0].isOwner && K4(i)
  ), l = oe(Object.entries(
    /*$activeEffects*/
    i[1]._types
  )), r = [];
  for (let a = 0; a < l.length; a += 1)
    r[a] = X4(W4(i, l, a));
  const o = /* @__PURE__ */ f((a) => C(r[a], 1, 1, () => {
    r[a] = null;
  }), "out");
  return {
    c() {
      n && n.c(), e = R(), t = E("section");
      for (let a = 0; a < r.length; a += 1)
        r[a].c();
      b(t, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable");
    },
    m(a, c) {
      n && n.m(a, c), T(a, e, c), T(a, t, c);
      for (let u = 0; u < r.length; u += 1)
        r[u] && r[u].m(t, null);
      s = !0;
    },
    p(a, [c]) {
      if (/*$item*/
      a[0].isOwner ? n ? (n.p(a, c), c & /*$item*/
      1 && w(n, 1)) : (n = K4(a), n.c(), w(n, 1), n.m(e.parentNode, e)) : n && (ce(), C(n, 1, 1, () => {
        n = null;
      }), ue()), c & /*subTypes, Object, $activeEffects*/
      34) {
        l = oe(Object.entries(
          /*$activeEffects*/
          a[1]._types
        ));
        let u;
        for (u = 0; u < l.length; u += 1) {
          const d = W4(a, l, u);
          r[u] ? (r[u].p(d, c), w(r[u], 1)) : (r[u] = X4(d), r[u].c(), w(r[u], 1), r[u].m(t, null));
        }
        for (ce(), u = l.length; u < r.length; u += 1)
          o(u);
        ue();
      }
    },
    i(a) {
      if (!s) {
        w(n);
        for (let c = 0; c < l.length; c += 1)
          w(r[c]);
        s = !0;
      }
    },
    o(a) {
      C(n), r = r.filter(Boolean);
      for (let c = 0; c < r.length; c += 1)
        C(r[c]);
      s = !1;
    },
    d(a) {
      a && (S(e), S(t)), n && n.d(a), Le(r, a);
    }
  };
}
f(EQ, "create_fragment$37");
const Ob = "activeEffects";
function SQ(i, e, t) {
  let s, n;
  const l = fe("item");
  pe(i, l, (u) => t(0, s = u));
  const r = fe("actionId"), { activeEffects: o } = l;
  pe(i, o, (u) => t(1, n = u));
  const a = CONFIG.A5E.actionActiveEffectTypesPlural;
  let c = new Set(s.actions.keys());
  return o == null || o.filters.add({
    id: "onUse-filter",
    filter: (u) => {
      var d, p, m, g, h, _;
      return console.log("flagId", (p = (d = u.flags) == null ? void 0 : d.a5e) == null ? void 0 : p.actionId), console.log("actionId", r), ((g = (m = u.flags) == null ? void 0 : m.a5e) == null ? void 0 : g.actionId) === r || !c.has((_ = (h = u.flags) == null ? void 0 : h.a5e) == null ? void 0 : _.actionId);
    }
  }), Nt(() => {
    o == null || o.filters.clear();
  }), [s, n, l, r, o, a];
}
f(SQ, "instance$2_");
const F2 = class F2 extends ie {
  constructor(e) {
    super(), le(this, e, SQ, EQ, ne, {});
  }
};
f(F2, "ActionsEffectsTab");
let T0 = F2;
function TQ(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*prompt*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[8]
      ), s = !0);
    },
    p(l, r) {
      r & /*prompt*/
      4 && t !== (t = /*prompt*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(TQ, "create_default_slot$1u");
function CQ(i) {
  let e, t, s, n, l, r, o;
  return e = new de({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[9]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[10]
          )
        }
      ],
      $$slots: { default: [TQ] },
      $$scope: { ctx: i }
    }
  }), n = new Ye({
    props: {
      allowDeselect: !1,
      heading: "A5E.ItemAbilityCheckType",
      optionStyles: "min-width: 2rem; text-align: center;",
      options: ci(),
      selected: (
        /*selectedAbility*/
        i[4]
      )
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[11]
  ), r = new De({
    props: {
      label: "A5E.PromptDefaultSelection",
      checked: (
        /*prompt*/
        i[2].default ?? !0
      )
    }
  }), r.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[12]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), l = R(), L(r.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-header-button-color", "#bebdb5"), z(t, "--a5e-header-button-color-hover", "#555"), z(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem");
    },
    m(a, c) {
      T(a, t, c), N(e, t, null), T(a, s, c), N(n, a, c), T(a, l, c), N(r, a, c), o = !0;
    },
    p(a, [c]) {
      const u = {};
      c & /*duplicatePrompt, prompt, deletePrompt, promptId*/
      15 && (u.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            a[9]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            a[10]
          )
        }
      ]), c & /*$$scope, prompt, $item, promptId*/
      16428 && (u.$$scope = { dirty: c, ctx: a }), e.$set(u);
      const d = {};
      c & /*selectedAbility*/
      16 && (d.selected = /*selectedAbility*/
      a[4]), n.$set(d);
      const p = {};
      c & /*prompt*/
      4 && (p.checked = /*prompt*/
      a[2].default ?? !0), r.$set(p);
    },
    i(a) {
      o || (w(e.$$.fragment, a), w(n.$$.fragment, a), w(r.$$.fragment, a), o = !0);
    },
    o(a) {
      C(e.$$.fragment, a), C(n.$$.fragment, a), C(r.$$.fragment, a), o = !1;
    },
    d(a) {
      a && (S(s), S(l)), a && e && S(t), j(e, a), j(n, a), j(r, a);
    }
  };
}
f(CQ, "create_fragment$36");
function OQ(i, e, t) {
  let s, n, { deletePrompt: l } = e, { duplicatePrompt: r } = e, { prompt: o } = e, { promptId: a } = e;
  const c = fe("item");
  pe(i, c, (y) => t(5, n = y));
  const u = fe("actionId");
  function d() {
    se(n, `system.actions.${u}.prompts.${a}.ability`, s);
  }
  f(d, "updateAbility");
  const p = /* @__PURE__ */ f(({ target: y }) => se(n, `system.actions.${u}.prompts.${a}.label`, y.value), "change_handler"), m = /* @__PURE__ */ f(() => r(u, o), "func"), g = /* @__PURE__ */ f(() => l(u, a), "func_1"), h = /* @__PURE__ */ f(({ detail: y }) => t(4, s = y), "updateSelection_handler"), _ = /* @__PURE__ */ f(({ detail: y }) => {
    se(n, `system.actions.${u}.prompts.${a}.default`, y);
  }, "updateSelection_handler_1");
  return i.$$set = (y) => {
    "deletePrompt" in y && t(0, l = y.deletePrompt), "duplicatePrompt" in y && t(1, r = y.duplicatePrompt), "prompt" in y && t(2, o = y.prompt), "promptId" in y && t(3, a = y.promptId);
  }, i.$$.update = () => {
    i.$$.dirty & /*prompt*/
    4 && t(4, s = o.ability ?? "none"), i.$$.dirty & /*selectedAbility*/
    16 && d();
  }, [
    l,
    r,
    o,
    a,
    s,
    n,
    c,
    u,
    p,
    m,
    g,
    h,
    _
  ];
}
f(OQ, "instance$2Z");
const N2 = class N2 extends ie {
  constructor(e) {
    super(), le(this, e, OQ, CQ, ne, {
      deletePrompt: 0,
      duplicatePrompt: 1,
      prompt: 2,
      promptId: 3
    });
  }
};
f(N2, "AbilityCheckPromptConfig");
let C0 = N2;
function J4(i, e, t) {
  const s = i.slice();
  return s[12] = e[t][0], s[13] = e[t][1], s;
}
f(J4, "get_each_context$1g");
function DQ(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*prompt*/
      i[0].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[8]
      ), s = !0);
    },
    p(l, r) {
      r & /*prompt, effects*/
      33 && t !== (t = /*prompt*/
      l[0].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(DQ, "create_default_slot_1$P");
function Z4(i) {
  let e, t = (
    /*effectName*/
    i[13] + ""
  ), s, n, l, r;
  return {
    c() {
      var o;
      e = E("option"), s = x(t), n = R(), e.__value = l = /*effectId*/
      i[12], qe(e, e.__value), e.selected = r = /*prompt*/
      ((o = i[0]) == null ? void 0 : o.effectId) === /*effectId*/
      i[12];
    },
    m(o, a) {
      T(o, e, a), A(e, s), A(e, n);
    },
    p(o, a) {
      var c;
      a & /*effects*/
      32 && t !== (t = /*effectName*/
      o[13] + "") && _e(s, t), a & /*effects*/
      32 && l !== (l = /*effectId*/
      o[12]) && (e.__value = l, qe(e, e.__value)), a & /*prompt, effects*/
      33 && r !== (r = /*prompt*/
      ((c = o[0]) == null ? void 0 : c.effectId) === /*effectId*/
      o[12]) && (e.selected = r);
    },
    d(o) {
      o && S(e);
    }
  };
}
f(Z4, "create_each_block$1g");
function IQ(i) {
  let e, t, s, n, l = oe(
    /*effects*/
    i[5]
  ), r = [];
  for (let o = 0; o < l.length; o += 1)
    r[o] = Z4(J4(i, l, o));
  return {
    c() {
      e = E("select");
      for (let o = 0; o < r.length; o += 1)
        r[o].c();
      b(e, "class", "u-w-fit"), z(e, "min-width", "9rem");
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < r.length; c += 1)
        r[c] && r[c].m(e, null);
      ds(
        e,
        /*prompt*/
        i[0].effectId ?? ""
      ), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[11]
      ), s = !0);
    },
    p(o, a) {
      if (a & /*effects, prompt*/
      33) {
        l = oe(
          /*effects*/
          o[5]
        );
        let c;
        for (c = 0; c < l.length; c += 1) {
          const u = J4(o, l, c);
          r[c] ? r[c].p(u, a) : (r[c] = Z4(u), r[c].c(), r[c].m(e, null));
        }
        for (; c < r.length; c += 1)
          r[c].d(1);
        r.length = l.length;
      }
      a & /*prompt, effects*/
      33 && t !== (t = /*prompt*/
      o[0].effectId ?? "") && ds(
        e,
        /*prompt*/
        o[0].effectId ?? ""
      );
    },
    d(o) {
      o && S(e), Le(r, o), s = !1, n();
    }
  };
}
f(IQ, "create_default_slot$1t");
function PQ(i) {
  let e, t, s, n, l;
  return e = new de({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[9]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[10]
          )
        }
      ],
      $$slots: { default: [DQ] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      heading: "A5E.Effect",
      $$slots: { default: [IQ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-header-button-color", "#bebdb5"), z(t, "--a5e-header-button-color-hover", "#555"), z(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem");
    },
    m(r, o) {
      T(r, t, o), N(e, t, null), T(r, s, o), N(n, r, o), l = !0;
    },
    p(r, [o]) {
      const a = {};
      o & /*duplicatePrompt, prompt, deletePrompt, promptId*/
      15 && (a.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            r[9]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            r[10]
          )
        }
      ]), o & /*$$scope, prompt, $item, promptId*/
      65561 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, prompt, $item, promptId, effects*/
      65593 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && S(s), r && e && S(t), j(e, r), j(n, r);
    }
  };
}
f(PQ, "create_fragment$35");
function MQ(i, e, t) {
  let s, n, { deletePrompt: l } = e, { duplicatePrompt: r } = e, { prompt: o } = e, { promptId: a } = e;
  const c = fe("item");
  pe(i, c, (h) => t(4, n = h));
  const u = fe("actionId"), d = /* @__PURE__ */ f(({ target: h }) => se(n, `system.actions.${u}.prompts.${a}.label`, h.value), "change_handler"), p = /* @__PURE__ */ f(() => r(u, o), "func"), m = /* @__PURE__ */ f(() => l(u, a), "func_1"), g = /* @__PURE__ */ f(({ target: h }) => se(n, `system.actions.${u}.prompts.${a}.effectId`, h.value), "change_handler_1");
  return i.$$set = (h) => {
    "deletePrompt" in h && t(1, l = h.deletePrompt), "duplicatePrompt" in h && t(2, r = h.duplicatePrompt), "prompt" in h && t(0, o = h.prompt), "promptId" in h && t(3, a = h.promptId);
  }, i.$$.update = () => {
    i.$$.dirty & /*prompt*/
    1 && t(0, o), i.$$.dirty & /*$item*/
    16 && t(5, s = n.effects.filter((h) => {
      var _, y;
      return ((y = (_ = h.flags) == null ? void 0 : _.a5e) == null ? void 0 : y.transferType) === "onUse";
    }).map((h) => [h._id, h.name]));
  }, [
    o,
    l,
    r,
    a,
    n,
    s,
    c,
    u,
    d,
    p,
    m,
    g
  ];
}
f(MQ, "instance$2Y");
const j2 = class j2 extends ie {
  constructor(e) {
    super(), le(this, e, MQ, PQ, ne, {
      deletePrompt: 1,
      duplicatePrompt: 2,
      prompt: 0,
      promptId: 3
    });
  }
};
f(j2, "ActiveEffectPromptConfig");
let O0 = j2;
function RQ(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*prompt*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[7]
      ), s = !0);
    },
    p(l, r) {
      r & /*prompt*/
      4 && t !== (t = /*prompt*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(RQ, "create_default_slot_1$O");
function FQ(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("input"), b(e, "id", t = /*actionId*/
      i[6] + "-" + /*promptId*/
      i[3] + "-roll-formula"), b(e, "type", "text"), e.value = s = /*prompt*/
      i[2].formula ?? "";
    },
    m(r, o) {
      T(r, e, o), n || (l = V(
        e,
        "change",
        /*change_handler_1*/
        i[10]
      ), n = !0);
    },
    p(r, o) {
      o & /*promptId*/
      8 && t !== (t = /*actionId*/
      r[6] + "-" + /*promptId*/
      r[3] + "-roll-formula") && b(e, "id", t), o & /*prompt*/
      4 && s !== (s = /*prompt*/
      r[2].formula ?? "") && e.value !== s && (e.value = s);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(FQ, "create_default_slot$1s");
function NQ(i) {
  let e, t, s, n, l, r, o;
  return e = new de({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[8]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[9]
          )
        }
      ],
      $$slots: { default: [RQ] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      heading: "A5E.RollFormula",
      $$slots: { default: [FQ] },
      $$scope: { ctx: i }
    }
  }), r = new De({
    props: {
      label: "A5E.PromptDefaultSelection",
      checked: (
        /*prompt*/
        i[2].default ?? !0
      )
    }
  }), r.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[11]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), l = R(), L(r.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-header-button-color", "#bebdb5"), z(t, "--a5e-header-button-color-hover", "#555"), z(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem");
    },
    m(a, c) {
      T(a, t, c), N(e, t, null), T(a, s, c), N(n, a, c), T(a, l, c), N(r, a, c), o = !0;
    },
    p(a, [c]) {
      const u = {};
      c & /*duplicatePrompt, prompt, deletePrompt, promptId*/
      15 && (u.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            a[8]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            a[9]
          )
        }
      ]), c & /*$$scope, prompt, $item, promptId*/
      4124 && (u.$$scope = { dirty: c, ctx: a }), e.$set(u);
      const d = {};
      c & /*$$scope, promptId, prompt, $item*/
      4124 && (d.$$scope = { dirty: c, ctx: a }), n.$set(d);
      const p = {};
      c & /*prompt*/
      4 && (p.checked = /*prompt*/
      a[2].default ?? !0), r.$set(p);
    },
    i(a) {
      o || (w(e.$$.fragment, a), w(n.$$.fragment, a), w(r.$$.fragment, a), o = !0);
    },
    o(a) {
      C(e.$$.fragment, a), C(n.$$.fragment, a), C(r.$$.fragment, a), o = !1;
    },
    d(a) {
      a && (S(s), S(l)), a && e && S(t), j(e, a), j(n, a), j(r, a);
    }
  };
}
f(NQ, "create_fragment$34");
function jQ(i, e, t) {
  let s;
  const n = fe("item");
  pe(i, n, (h) => t(4, s = h));
  const l = fe("actionId");
  let { deletePrompt: r } = e, { duplicatePrompt: o } = e, { prompt: a } = e, { promptId: c } = e;
  const u = /* @__PURE__ */ f(({ target: h }) => se(s, `system.actions.${l}.prompts.${c}.label`, h.value), "change_handler"), d = /* @__PURE__ */ f(() => o(l, a), "func"), p = /* @__PURE__ */ f(() => r(l, c), "func_1"), m = /* @__PURE__ */ f(({ target: h }) => se(s, `system.actions.${l}.prompts.${c}.formula`, h.value), "change_handler_1"), g = /* @__PURE__ */ f(({ detail: h }) => {
    se(s, `system.actions.${l}.prompts.${c}.default`, h);
  }, "updateSelection_handler");
  return i.$$set = (h) => {
    "deletePrompt" in h && t(0, r = h.deletePrompt), "duplicatePrompt" in h && t(1, o = h.duplicatePrompt), "prompt" in h && t(2, a = h.prompt), "promptId" in h && t(3, c = h.promptId);
  }, [
    r,
    o,
    a,
    c,
    s,
    n,
    l,
    u,
    d,
    p,
    m,
    g
  ];
}
f(jQ, "instance$2X");
const L2 = class L2 extends ie {
  constructor(e) {
    super(), le(this, e, jQ, NQ, ne, {
      deletePrompt: 0,
      duplicatePrompt: 1,
      prompt: 2,
      promptId: 3
    });
  }
};
f(L2, "GenericPromptConfig");
let D0 = L2;
function Q4(i, e, t) {
  const s = i.slice();
  return s[25] = e[t][0], s[26] = e[t][1], s;
}
f(Q4, "get_each_context$1f");
function LQ(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*prompt*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      r & /*prompt*/
      4 && t !== (t = /*prompt*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(LQ, "create_default_slot_4$i");
function x4(i) {
  let e, t = K(
    /*label*/
    i[26]
  ) + "", s, n, l;
  return {
    c() {
      var r, o;
      e = E("option"), s = x(t), n = R(), e.__value = /*type*/
      i[25], qe(e, e.__value), e.selected = l = /*type*/
      i[25] === /*prompt*/
      ((o = (r = i[2]) == null ? void 0 : r.saveDC) == null ? void 0 : o.type);
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      var a, c;
      o & /*prompt*/
      4 && l !== (l = /*type*/
      r[25] === /*prompt*/
      ((c = (a = r[2]) == null ? void 0 : a.saveDC) == null ? void 0 : c.type)) && (e.selected = l);
    },
    d(r) {
      r && S(e);
    }
  };
}
f(x4, "create_each_block$1f");
function BQ(i) {
  let e, t, s, n = oe(Object.entries(
    /*saveDCOptions*/
    i[13]
  )), l = [];
  for (let r = 0; r < n.length; r += 1)
    l[r] = x4(Q4(i, n, r));
  return {
    c() {
      e = E("select");
      for (let r = 0; r < l.length; r += 1)
        l[r].c();
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < l.length; a += 1)
        l[a] && l[a].m(e, null);
      t || (s = V(
        e,
        "change",
        /*selectSaveDCCalculationType*/
        i[9]
      ), t = !0);
    },
    p(r, o) {
      if (o & /*Object, saveDCOptions, prompt*/
      8196) {
        n = oe(Object.entries(
          /*saveDCOptions*/
          r[13]
        ));
        let a;
        for (a = 0; a < n.length; a += 1) {
          const c = Q4(r, n, a);
          l[a] ? l[a].p(c, o) : (l[a] = x4(c), l[a].c(), l[a].m(e, null));
        }
        for (; a < l.length; a += 1)
          l[a].d(1);
        l.length = n.length;
      }
    },
    d(r) {
      r && S(e), Le(l, r), t = !1, s();
    }
  };
}
f(BQ, "create_default_slot_3$s");
function eP(i) {
  let e;
  function t(l, r) {
    return (
      /*saveDCIsValid*/
      l[6] ? GQ : qQ
    );
  }
  f(t, "select_block_type");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("span"), n.c(), b(e, "class", "save-dc-preview svelte-3zhgbi"), b(e, "type", "number"), Q(e, "save-dc-preview--invalid", !/*saveDCIsValid*/
      i[6]);
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null))), r & /*saveDCIsValid*/
      64 && Q(e, "save-dc-preview--invalid", !/*saveDCIsValid*/
      l[6]);
    },
    d(l) {
      l && S(e), n.d();
    }
  };
}
f(eP, "create_if_block$1K");
function qQ(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "fa-solid fa-circle-exclamation");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: ee,
    d(t) {
      t && S(e);
    }
  };
}
f(qQ, "create_else_block$x");
function GQ(i) {
  let e;
  return {
    c() {
      e = x(
        /*saveDC*/
        i[7]
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*saveDC*/
      128 && _e(
        e,
        /*saveDC*/
        t[7]
      );
    },
    d(t) {
      t && S(e);
    }
  };
}
f(GQ, "create_if_block_1$1a");
function zQ(i) {
  let e, t, s, n, l, r = (
    /*saveDC*/
    (i[7] || !/*saveDCIsValid*/
    i[6]) && eP(i)
  );
  return {
    c() {
      e = E("div"), t = E("input"), s = R(), r && r.c(), b(t, "type", "text"), b(t, "autocomplete", "off"), b(e, "class", "u-flex u-gap-sm");
    },
    m(o, a) {
      T(o, e, a), A(e, t), qe(
        t,
        /*saveDCBonus*/
        i[4]
      ), A(e, s), r && r.m(e, null), n || (l = [
        V(
          t,
          "input",
          /*input_input_handler*/
          i[19]
        ),
        V(
          t,
          "change",
          /*change_handler_1*/
          i[20]
        )
      ], n = !0);
    },
    p(o, a) {
      a & /*saveDCBonus*/
      16 && t.value !== /*saveDCBonus*/
      o[4] && qe(
        t,
        /*saveDCBonus*/
        o[4]
      ), /*saveDC*/
      o[7] || !/*saveDCIsValid*/
      o[6] ? r ? r.p(o, a) : (r = eP(o), r.c(), r.m(e, null)) : r && (r.d(1), r = null);
    },
    d(o) {
      o && S(e), r && r.d(), n = !1, Ne(l);
    }
  };
}
f(zQ, "create_default_slot_2$A");
function HQ(i) {
  var o, a;
  let e, t, s, n, l, r;
  return e = new de({
    props: {
      heading: "A5E.ItemSavingThrowDC",
      $$slots: { default: [BQ] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      heading: (
        /*prompt*/
        ((a = (o = i[2]) == null ? void 0 : o.saveDC) == null ? void 0 : a.type) === "custom" ? "A5E.ItemSavingThrowDCCustom" : "A5E.ItemSavingThrowDCBonus"
      ),
      $$slots: { default: [zQ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), l = E("div"), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-label-width", "9rem"), z(l, "display", "contents"), z(l, "--a5e-field-wrapper-grow", "1");
    },
    m(c, u) {
      T(c, t, u), N(e, t, null), T(c, s, u), T(c, l, u), N(n, l, null), r = !0;
    },
    p(c, u) {
      var m, g;
      const d = {};
      u & /*$$scope, prompt*/
      536870916 && (d.$$scope = { dirty: u, ctx: c }), e.$set(d);
      const p = {};
      u & /*prompt*/
      4 && (p.heading = /*prompt*/
      ((g = (m = c[2]) == null ? void 0 : m.saveDC) == null ? void 0 : g.type) === "custom" ? "A5E.ItemSavingThrowDCCustom" : "A5E.ItemSavingThrowDCBonus"), u & /*$$scope, saveDCIsValid, saveDC, saveDCBonus, $item, promptId*/
      536871384 && (p.$$scope = { dirty: u, ctx: c }), n.$set(p);
    },
    i(c) {
      r || (w(e.$$.fragment, c), w(n.$$.fragment, c), r = !0);
    },
    o(c) {
      C(e.$$.fragment, c), C(n.$$.fragment, c), r = !1;
    },
    d(c) {
      c && S(s), c && e && S(t), j(e, c), c && n && S(l), j(n, c);
    }
  };
}
f(HQ, "create_default_slot_1$N");
function UQ(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*prompt*/
      i[2].onSave ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_2*/
        i[21]
      ), s = !0);
    },
    p(l, r) {
      r & /*prompt*/
      4 && t !== (t = /*prompt*/
      l[2].onSave ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(UQ, "create_default_slot$1r");
function VQ(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p;
  return e = new de({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[16]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[17]
          )
        }
      ],
      $$slots: { default: [LQ] },
      $$scope: { ctx: i }
    }
  }), n = new Ye({
    props: {
      heading: "A5E.ItemSavingThrowType",
      optionStyles: "min-width: 2rem; text-align: center;",
      options: ci(),
      selected: (
        /*selectedAbility*/
        i[5]
      ),
      allowDeselect: !1
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[18]
  ), r = new Me({
    props: {
      $$slots: { default: [HQ] },
      $$scope: { ctx: i }
    }
  }), c = new de({
    props: {
      heading: "A5E.ItemEffectOnSave",
      $$slots: { default: [UQ] },
      $$scope: { ctx: i }
    }
  }), d = new De({
    props: {
      label: "A5E.PromptDefaultSelection",
      checked: (
        /*prompt*/
        i[2].default ?? !0
      )
    }
  }), d.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[22]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), l = R(), o = E("div"), L(r.$$.fragment), a = R(), L(c.$$.fragment), u = R(), L(d.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-header-button-color", "#bebdb5"), z(t, "--a5e-header-button-color-hover", "#555"), z(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem"), z(o, "display", "contents"), z(o, "--a5e-section-body-direction", "row"), z(o, "--a5e-section-body-wrap", "nowrap"), z(o, "--a5e-section-body-padding", "0");
    },
    m(m, g) {
      T(m, t, g), N(e, t, null), T(m, s, g), N(n, m, g), T(m, l, g), T(m, o, g), N(r, o, null), T(m, a, g), N(c, m, g), T(m, u, g), N(d, m, g), p = !0;
    },
    p(m, [g]) {
      const h = {};
      g & /*duplicatePrompt, prompt, deletePrompt, promptId*/
      15 && (h.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            m[16]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            m[17]
          )
        }
      ]), g & /*$$scope, prompt, $item, promptId*/
      536871180 && (h.$$scope = { dirty: g, ctx: m }), e.$set(h);
      const _ = {};
      g & /*selectedAbility*/
      32 && (_.selected = /*selectedAbility*/
      m[5]), n.$set(_);
      const y = {};
      g & /*$$scope, prompt, saveDCIsValid, saveDC, saveDCBonus, $item, promptId*/
      536871388 && (y.$$scope = { dirty: g, ctx: m }), r.$set(y);
      const k = {};
      g & /*$$scope, prompt, $item, promptId*/
      536871180 && (k.$$scope = { dirty: g, ctx: m }), c.$set(k);
      const v = {};
      g & /*prompt*/
      4 && (v.checked = /*prompt*/
      m[2].default ?? !0), d.$set(v);
    },
    i(m) {
      p || (w(e.$$.fragment, m), w(n.$$.fragment, m), w(r.$$.fragment, m), w(c.$$.fragment, m), w(d.$$.fragment, m), p = !0);
    },
    o(m) {
      C(e.$$.fragment, m), C(n.$$.fragment, m), C(r.$$.fragment, m), C(c.$$.fragment, m), C(d.$$.fragment, m), p = !1;
    },
    d(m) {
      m && (S(s), S(l), S(a), S(u)), m && e && S(t), j(e, m), j(n, m), m && r && S(o), j(r, m), j(c, m), j(d, m);
    }
  };
}
f(VQ, "create_fragment$33");
function WQ(i, e, t) {
  var U;
  let s, n, l, r;
  function o() {
    se(r, `system.actions.${_}.prompts.${m}.ability`, n);
  }
  f(o, "updateAbility");
  function a(q) {
    var X, te;
    const W = (te = (X = q.target) == null ? void 0 : X.selectedOptions[0]) == null ? void 0 : te.value;
    r.update({
      [`system.actions.${_}.prompts.${m}.saveDC.type`]: W
    });
  }
  f(a, "selectSaveDCCalculationType");
  function c(q) {
    var W;
    try {
      const X = W5(q, r, {
        type: (W = p == null ? void 0 : p.saveDC) == null ? void 0 : W.type,
        bonus: v
      });
      return t(6, k = !0), X;
    } catch {
      t(6, k = !1);
    }
  }
  f(c, "onSaveDCUpdate");
  let { deletePrompt: u } = e, { duplicatePrompt: d } = e, { prompt: p } = e, { promptId: m } = e;
  const g = fe("item");
  pe(i, g, (q) => t(8, r = q));
  const h = r.actor && new Bt(r.actor);
  pe(i, h, (q) => t(14, l = q));
  const _ = fe("actionId"), { saveDCOptions: y } = CONFIG.A5E;
  let k = !0, v = (U = p == null ? void 0 : p.saveDC) == null ? void 0 : U.bonus;
  const O = /* @__PURE__ */ f(({ target: q }) => se(r, `system.actions.${_}.prompts.${m}.label`, q.value), "change_handler"), P = /* @__PURE__ */ f(() => d(_, p), "func"), D = /* @__PURE__ */ f(() => u(_, m), "func_1"), I = /* @__PURE__ */ f(({ detail: q }) => t(5, n = q), "updateSelection_handler");
  function B() {
    v = this.value, t(4, v);
  }
  f(B, "input_input_handler");
  const F = /* @__PURE__ */ f(({ target: q }) => se(r, `system.actions.${_}.prompts.${m}.saveDC.bonus`, q.value), "change_handler_1"), H = /* @__PURE__ */ f(({ target: q }) => se(r, `system.actions.${_}.prompts.${m}.onSave`, q.value), "change_handler_2"), G = /* @__PURE__ */ f(({ detail: q }) => {
    se(r, `system.actions.${_}.prompts.${m}.default`, q);
  }, "updateSelection_handler_1");
  return i.$$set = (q) => {
    "deletePrompt" in q && t(0, u = q.deletePrompt), "duplicatePrompt" in q && t(1, d = q.duplicatePrompt), "prompt" in q && t(2, p = q.prompt), "promptId" in q && t(3, m = q.promptId);
  }, i.$$.update = () => {
    var q;
    i.$$.dirty & /*$actor, prompt, saveDCBonus*/
    16404 && t(7, s = c(l, (q = p == null ? void 0 : p.saveDC) == null ? void 0 : q.type)), i.$$.dirty & /*prompt*/
    4 && t(5, n = p.ability ?? "none"), i.$$.dirty & /*selectedAbility*/
    32 && o();
  }, [
    u,
    d,
    p,
    m,
    v,
    n,
    k,
    s,
    r,
    a,
    g,
    h,
    _,
    y,
    l,
    O,
    P,
    D,
    I,
    B,
    F,
    H,
    G
  ];
}
f(WQ, "instance$2W");
const B2 = class B2 extends ie {
  constructor(e) {
    super(), le(this, e, WQ, VQ, ne, {
      deletePrompt: 0,
      duplicatePrompt: 1,
      prompt: 2,
      promptId: 3
    });
  }
};
f(B2, "SavePromptConfig");
let I0 = B2;
function tP(i, e, t) {
  const s = i.slice();
  return s[16] = e[t][0], s[17] = e[t][1], s;
}
f(tP, "get_each_context$1e");
function KQ(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*prompt*/
      i[0].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[9]
      ), s = !0);
    },
    p(l, r) {
      r & /*prompt*/
      1 && t !== (t = /*prompt*/
      l[0].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(KQ, "create_default_slot_1$M");
function sP(i) {
  let e, t = K(
    /*label*/
    i[17]
  ) + "", s, n, l;
  return {
    c() {
      var r;
      e = E("option"), s = x(t), n = R(), e.__value = /*skill*/
      i[16], qe(e, e.__value), e.selected = l = /*prompt*/
      ((r = i[0]) == null ? void 0 : r.skill) === /*skill*/
      i[16];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      var a;
      o & /*prompt*/
      1 && l !== (l = /*prompt*/
      ((a = r[0]) == null ? void 0 : a.skill) === /*skill*/
      r[16]) && (e.selected = l);
    },
    d(r) {
      r && S(e);
    }
  };
}
f(sP, "create_each_block$1e");
function YQ(i) {
  let e, t, s, n = oe(Object.entries(
    /*skills*/
    i[8]
  )), l = [];
  for (let r = 0; r < n.length; r += 1)
    l[r] = sP(tP(i, n, r));
  return {
    c() {
      e = E("select");
      for (let r = 0; r < l.length; r += 1)
        l[r].c();
      b(e, "class", "u-w-fit");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < l.length; a += 1)
        l[a] && l[a].m(e, null);
      t || (s = V(
        e,
        "change",
        /*change_handler_1*/
        i[12]
      ), t = !0);
    },
    p(r, o) {
      if (o & /*Object, skills, prompt*/
      257) {
        n = oe(Object.entries(
          /*skills*/
          r[8]
        ));
        let a;
        for (a = 0; a < n.length; a += 1) {
          const c = tP(r, n, a);
          l[a] ? l[a].p(c, o) : (l[a] = sP(c), l[a].c(), l[a].m(e, null));
        }
        for (; a < l.length; a += 1)
          l[a].d(1);
        l.length = n.length;
      }
    },
    d(r) {
      r && S(e), Le(l, r), t = !1, s();
    }
  };
}
f(YQ, "create_default_slot$1q");
function XQ(i) {
  let e, t, s, n, l, r, o, a, c;
  return e = new de({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[11]
          )
        }
      ],
      $$slots: { default: [KQ] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      heading: "A5E.Skill",
      $$slots: { default: [YQ] },
      $$scope: { ctx: i }
    }
  }), r = new Ye({
    props: {
      heading: "A5E.ItemAbilityCheckType",
      optionStyles: "min-width: 2rem; text-align: center;",
      options: ci(!1, !0),
      selected: (
        /*selectedAbility*/
        i[4]
      ),
      allowDeselect: !1
    }
  }), r.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[13]
  ), a = new De({
    props: {
      label: "A5E.PromptDefaultSelection",
      checked: (
        /*prompt*/
        i[0].default ?? !0
      )
    }
  }), a.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[14]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), l = R(), L(r.$$.fragment), o = R(), L(a.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-header-button-color", "#bebdb5"), z(t, "--a5e-header-button-color-hover", "#555"), z(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem");
    },
    m(u, d) {
      T(u, t, d), N(e, t, null), T(u, s, d), N(n, u, d), T(u, l, d), N(r, u, d), T(u, o, d), N(a, u, d), c = !0;
    },
    p(u, [d]) {
      const p = {};
      d & /*duplicatePrompt, prompt, deletePrompt, promptId*/
      15 && (p.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            u[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            u[11]
          )
        }
      ]), d & /*$$scope, prompt, $item, promptId*/
      1048617 && (p.$$scope = { dirty: d, ctx: u }), e.$set(p);
      const m = {};
      d & /*$$scope, $item, promptId, prompt*/
      1048617 && (m.$$scope = { dirty: d, ctx: u }), n.$set(m);
      const g = {};
      d & /*selectedAbility*/
      16 && (g.selected = /*selectedAbility*/
      u[4]), r.$set(g);
      const h = {};
      d & /*prompt*/
      1 && (h.checked = /*prompt*/
      u[0].default ?? !0), a.$set(h);
    },
    i(u) {
      c || (w(e.$$.fragment, u), w(n.$$.fragment, u), w(r.$$.fragment, u), w(a.$$.fragment, u), c = !0);
    },
    o(u) {
      C(e.$$.fragment, u), C(n.$$.fragment, u), C(r.$$.fragment, u), C(a.$$.fragment, u), c = !1;
    },
    d(u) {
      u && (S(s), S(l), S(o)), u && e && S(t), j(e, u), j(n, u), j(r, u), j(a, u);
    }
  };
}
f(XQ, "create_fragment$32");
function JQ(i, e, t) {
  let s, n, { deletePrompt: l } = e, { duplicatePrompt: r } = e, { prompt: o } = e, { promptId: a } = e;
  const c = fe("item");
  pe(i, c, (v) => t(5, n = v));
  const u = fe("actionId"), d = { ...CONFIG.A5E.skills };
  game.settings.get("a5e", "hideA5eSkills") && (delete d.cul, delete d.eng);
  function p() {
    se(n, `system.actions.${u}.prompts.${a}.ability`, s);
  }
  f(p, "updateAbility");
  const m = /* @__PURE__ */ f(({ target: v }) => se(n, `system.actions.${u}.prompts.${a}.label`, v.value), "change_handler"), g = /* @__PURE__ */ f(() => r(u, o), "func"), h = /* @__PURE__ */ f(() => l(u, a), "func_1"), _ = /* @__PURE__ */ f(({ target: v }) => se(n, `system.actions.${u}.prompts.${a}.skill`, v.value), "change_handler_1"), y = /* @__PURE__ */ f(({ detail: v }) => t(4, s = v), "updateSelection_handler"), k = /* @__PURE__ */ f(({ detail: v }) => {
    se(n, `system.actions.${u}.prompts.${a}.default`, v);
  }, "updateSelection_handler_1");
  return i.$$set = (v) => {
    "deletePrompt" in v && t(1, l = v.deletePrompt), "duplicatePrompt" in v && t(2, r = v.duplicatePrompt), "prompt" in v && t(0, o = v.prompt), "promptId" in v && t(3, a = v.promptId);
  }, i.$$.update = () => {
    i.$$.dirty & /*prompt*/
    1 && t(0, o), i.$$.dirty & /*prompt*/
    1 && t(4, s = o.ability ?? "none"), i.$$.dirty & /*selectedAbility*/
    16 && p();
  }, [
    o,
    l,
    r,
    a,
    s,
    n,
    c,
    u,
    d,
    m,
    g,
    h,
    _,
    y,
    k
  ];
}
f(JQ, "instance$2V");
const q2 = class q2 extends ie {
  constructor(e) {
    super(), le(this, e, JQ, XQ, ne, {
      deletePrompt: 1,
      duplicatePrompt: 2,
      prompt: 0,
      promptId: 3
    });
  }
};
f(q2, "SkillCheckPromptConfig");
let P0 = q2;
function nP(i, e, t) {
  const s = i.slice();
  return s[13] = e[t][0], s[14] = e[t][1].heading, s[15] = e[t][1].singleLabel, s[16] = e[t][1].component, s;
}
f(nP, "get_each_context$1d");
function iP(i, e, t) {
  const s = i.slice();
  return s[19] = e[t][0], s[20] = e[t][1], s;
}
f(iP, "get_each_context_1$i");
function lP(i) {
  let e, t, s, n, l;
  function r() {
    return (
      /*func_2*/
      i[11](
        /*promptType*/
        i[13]
      )
    );
  }
  return f(r, "func_2"), t = new Me({
    props: {
      heading: (
        /*heading*/
        i[14]
      ),
      headerButtons: [
        {
          classes: "add-button",
          handler: r,
          label: K("A5E.ButtonAddPrompt", { type: K(
            /*singleLabel*/
            i[15]
          ) })
        }
      ],
      $$slots: { default: [ZQ] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("li"), s = E("div"), L(t.$$.fragment), n = R(), z(s, "display", "contents"), z(s, "--a5e-section-gap", "0"), b(e, "class", "prompts-config-list__item svelte-1nvyy2l");
    },
    m(o, a) {
      T(o, e, a), A(e, s), N(t, s, null), A(e, n), l = !0;
    },
    p(o, a) {
      i = o;
      const c = {};
      a & /*$item, action*/
      3 && (c.headerButtons = [
        {
          classes: "add-button",
          handler: r,
          label: K("A5E.ButtonAddPrompt", { type: K(
            /*singleLabel*/
            i[15]
          ) })
        }
      ]), a & /*$$scope, prompts*/
      8388616 && (c.$$scope = { dirty: a, ctx: i }), t.$set(c);
    },
    i(o) {
      l || (w(t.$$.fragment, o), l = !0);
    },
    o(o) {
      C(t.$$.fragment, o), l = !1;
    },
    d(o) {
      o && S(e), j(t);
    }
  };
}
f(lP, "create_if_block$1J");
function rP(i, e) {
  let t, s, n, l;
  var r = (
    /*component*/
    e[16]
  );
  function o(a, c) {
    return {
      props: {
        prompt: (
          /*prompt*/
          a[20]
        ),
        promptId: (
          /*promptId*/
          a[19]
        ),
        deletePrompt: (
          /*deletePrompt*/
          a[4]
        ),
        duplicatePrompt: (
          /*duplicatePrompt*/
          a[5]
        )
      }
    };
  }
  return f(o, "switch_props"), r && (s = nt(r, o(e))), {
    key: i,
    first: null,
    c() {
      t = E("li"), s && L(s.$$.fragment), n = R(), b(t, "class", "a5e-item a5e-item--action-config"), this.first = t;
    },
    m(a, c) {
      T(a, t, c), s && N(s, t, null), A(t, n), l = !0;
    },
    p(a, c) {
      if (e = a, r !== (r = /*component*/
      e[16])) {
        if (s) {
          ce();
          const u = s;
          C(u.$$.fragment, 1, 0, () => {
            j(u, 1);
          }), ue();
        }
        r ? (s = nt(r, o(e)), L(s.$$.fragment), w(s.$$.fragment, 1), N(s, t, n)) : s = null;
      } else if (r) {
        const u = {};
        c & /*prompts*/
        8 && (u.prompt = /*prompt*/
        e[20]), c & /*prompts*/
        8 && (u.promptId = /*promptId*/
        e[19]), s.$set(u);
      }
    },
    i(a) {
      l || (s && w(s.$$.fragment, a), l = !0);
    },
    o(a) {
      s && C(s.$$.fragment, a), l = !1;
    },
    d(a) {
      a && S(t), s && j(s);
    }
  };
}
f(rP, "create_each_block_1$i");
function ZQ(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n;
  function l(...a) {
    return (
      /*func_1*/
      i[10](
        /*promptType*/
        i[13],
        ...a
      )
    );
  }
  f(l, "func_1");
  let r = oe(Object.entries(
    /*prompts*/
    i[3]
  ).filter(l));
  const o = /* @__PURE__ */ f((a) => (
    /*promptId*/
    a[19]
  ), "get_key");
  for (let a = 0; a < r.length; a += 1) {
    let c = iP(i, r, a), u = o(c);
    s.set(u, t[a] = rP(u, c));
  }
  return {
    c() {
      e = E("ul");
      for (let a = 0; a < t.length; a += 1)
        t[a].c();
      b(e, "class", "a5e-item-list");
    },
    m(a, c) {
      T(a, e, c);
      for (let u = 0; u < t.length; u += 1)
        t[u] && t[u].m(e, null);
      n = !0;
    },
    p(a, c) {
      i = a, c & /*Object, promptTypes, prompts, deletePrompt, duplicatePrompt*/
      312 && (r = oe(Object.entries(
        /*prompts*/
        i[3]
      ).filter(l)), ce(), t = kt(t, c, o, 1, i, r, s, e, ks, rP, null, iP), ue());
    },
    i(a) {
      if (!n) {
        for (let c = 0; c < r.length; c += 1)
          w(t[c]);
        n = !0;
      }
    },
    o(a) {
      for (let c = 0; c < t.length; c += 1)
        C(t[c]);
      n = !1;
    },
    d(a) {
      a && S(e);
      for (let c = 0; c < t.length; c += 1)
        t[c].d();
    }
  };
}
f(ZQ, "create_default_slot$1p");
function oP(i, e) {
  let t, s = Object.values(
    /*prompts*/
    e[3]
  ).filter(r).length, n, l;
  function r(...a) {
    return (
      /*func*/
      e[9](
        /*promptType*/
        e[13],
        ...a
      )
    );
  }
  f(r, "func");
  let o = s && lP(e);
  return {
    key: i,
    first: null,
    c() {
      t = $e(), o && o.c(), n = $e(), this.first = t;
    },
    m(a, c) {
      T(a, t, c), o && o.m(a, c), T(a, n, c), l = !0;
    },
    p(a, c) {
      e = a, c & /*prompts*/
      8 && (s = Object.values(
        /*prompts*/
        e[3]
      ).filter(r).length), s ? o ? (o.p(e, c), c & /*prompts*/
      8 && w(o, 1)) : (o = lP(e), o.c(), w(o, 1), o.m(n.parentNode, n)) : o && (ce(), C(o, 1, 1, () => {
        o = null;
      }), ue());
    },
    i(a) {
      l || (w(o), l = !0);
    },
    o(a) {
      C(o), l = !1;
    },
    d(a) {
      a && (S(t), S(n)), o && o.d(a);
    }
  };
}
f(oP, "create_each_block$1d");
function QQ(i) {
  let e, t, s = [], n = /* @__PURE__ */ new Map(), l, r, o, a, c = oe(Object.entries(
    /*promptTypes*/
    i[8]
  ));
  const u = /* @__PURE__ */ f((d) => (
    /*promptType*/
    d[13]
  ), "get_key");
  for (let d = 0; d < c.length; d += 1) {
    let p = nP(i, c, d), m = u(p);
    n.set(m, s[d] = oP(m, p));
  }
  return o = new Ys({
    props: {
      menuList: (
        /*menuList*/
        i[2]
      ),
      offset: { x: -110, y: -105 },
      documentName: "Prompt"
    }
  }), o.$on(
    "press",
    /*press_handler*/
    i[12]
  ), {
    c() {
      e = E("div"), t = E("ul");
      for (let d = 0; d < s.length; d += 1)
        s[d].c();
      l = R(), r = E("div"), L(o.$$.fragment), b(t, "class", "prompts-config-list svelte-1nvyy2l"), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable"), b(r, "class", "sticky-add-button svelte-1nvyy2l");
    },
    m(d, p) {
      T(d, e, p), A(e, t);
      for (let m = 0; m < s.length; m += 1)
        s[m] && s[m].m(t, null);
      T(d, l, p), T(d, r, p), N(o, r, null), a = !0;
    },
    p(d, [p]) {
      p & /*Object, promptTypes, $item, actionId, action, prompts, deletePrompt, duplicatePrompt*/
      443 && (c = oe(Object.entries(
        /*promptTypes*/
        d[8]
      )), ce(), s = kt(s, p, u, 1, d, c, n, t, ks, oP, null, nP), ue());
      const m = {};
      p & /*menuList*/
      4 && (m.menuList = /*menuList*/
      d[2]), o.$set(m);
    },
    i(d) {
      if (!a) {
        for (let p = 0; p < c.length; p += 1)
          w(s[p]);
        w(o.$$.fragment, d), a = !0;
      }
    },
    o(d) {
      for (let p = 0; p < s.length; p += 1)
        C(s[p]);
      C(o.$$.fragment, d), a = !1;
    },
    d(d) {
      d && (S(e), S(l), S(r));
      for (let p = 0; p < s.length; p += 1)
        s[p].d();
      j(o);
    }
  };
}
f(QQ, "create_fragment$31");
function xQ(i, e, t) {
  let s, n, l, r;
  function o(_, y) {
    r.update({
      [`system.actions.${_}.prompts`]: { [`-=${y}`]: null }
    });
  }
  f(o, "deletePrompt");
  function a(_, y) {
    const k = foundry.utils.duplicate(y);
    r.update({
      [`system.actions.${_}.prompts`]: { [foundry.utils.randomID()]: k }
    });
  }
  f(a, "duplicatePrompt");
  const c = fe("item");
  pe(i, c, (_) => t(1, r = _));
  const u = fe("actionId"), d = {
    savingThrow: {
      heading: "A5E.SavingThrowPlural",
      singleLabel: "A5E.SavingThrow",
      component: I0
    },
    abilityCheck: {
      heading: "A5E.AbilityCheckPlural",
      singleLabel: "A5E.AbilityCheck",
      component: C0
    },
    skillCheck: {
      heading: "A5E.SkillCheckPlural",
      singleLabel: "A5E.SkillCheckSingular",
      component: P0
    },
    generic: {
      heading: "A5E.OtherPlural",
      singleLabel: "A5E.Other",
      component: D0
    },
    effect: {
      heading: "A5E.EffectPlural",
      singleLabel: "A5E.Effect",
      component: O0
    }
  }, p = /* @__PURE__ */ f((_, y) => y.type === _, "func"), m = /* @__PURE__ */ f((_, [y, k]) => k.type === _, "func_1"), g = /* @__PURE__ */ f((_) => ri.addPrompt(r, [u, s], _), "func_2"), h = /* @__PURE__ */ f(({ detail: _ }) => ri.addPrompt(r, [u, s], _), "press_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    2 && t(0, s = r.actions[u]), i.$$.dirty & /*action*/
    1 && t(3, n = s.prompts ?? {});
  }, t(2, l = Object.entries(d).map(([_, { heading: y }]) => [_, y])), [
    s,
    r,
    l,
    n,
    o,
    a,
    c,
    u,
    d,
    p,
    m,
    g,
    h
  ];
}
f(xQ, "instance$2U");
const G2 = class G2 extends ie {
  constructor(e) {
    super(), le(this, e, xQ, QQ, ne, {});
  }
};
f(G2, "ActionsPromptsTab");
let M0 = G2;
function ex(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[9]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(ex, "create_default_slot_1$L");
function tx(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].bonus ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[13]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].bonus ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(tx, "create_default_slot$1o");
function sx(i) {
  let e, t, s, n, l, r, o, a, c;
  return e = new de({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[11]
          )
        }
      ],
      $$slots: { default: [ex] },
      $$scope: { ctx: i }
    }
  }), n = new Ye({
    props: {
      heading: "A5E.ItemAbilityCheckType",
      optionStyles: "min-width: 2rem; text-align: center;",
      options: Object.entries(
        /*abilities*/
        i[8]
      ),
      selected: (
        /*selectedAbility*/
        i[4]
      ),
      allowDeselect: !1
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[12]
  ), r = new de({
    props: {
      heading: "A5E.CheckBonus",
      $$slots: { default: [tx] },
      $$scope: { ctx: i }
    }
  }), a = new De({
    props: {
      label: "A5E.AbilityCheckDefaultSelection",
      checked: (
        /*roll*/
        i[2].default ?? !0
      )
    }
  }), a.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[14]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), l = R(), L(r.$$.fragment), o = R(), L(a.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-header-button-color", "#bebdb5"), z(t, "--a5e-header-button-color-hover", "#555"), z(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem");
    },
    m(u, d) {
      T(u, t, d), N(e, t, null), T(u, s, d), N(n, u, d), T(u, l, d), N(r, u, d), T(u, o, d), N(a, u, d), c = !0;
    },
    p(u, [d]) {
      const p = {};
      d & /*duplicateRoll, roll, deleteRoll, rollId*/
      15 && (p.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            u[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            u[11]
          )
        }
      ]), d & /*$$scope, roll, $item, rollId*/
      65580 && (p.$$scope = { dirty: d, ctx: u }), e.$set(p);
      const m = {};
      d & /*selectedAbility*/
      16 && (m.selected = /*selectedAbility*/
      u[4]), n.$set(m);
      const g = {};
      d & /*$$scope, roll, $item, rollId*/
      65580 && (g.$$scope = { dirty: d, ctx: u }), r.$set(g);
      const h = {};
      d & /*roll*/
      4 && (h.checked = /*roll*/
      u[2].default ?? !0), a.$set(h);
    },
    i(u) {
      c || (w(e.$$.fragment, u), w(n.$$.fragment, u), w(r.$$.fragment, u), w(a.$$.fragment, u), c = !0);
    },
    o(u) {
      C(e.$$.fragment, u), C(n.$$.fragment, u), C(r.$$.fragment, u), C(a.$$.fragment, u), c = !1;
    },
    d(u) {
      u && (S(s), S(l), S(o)), u && e && S(t), j(e, u), j(n, u), j(r, u), j(a, u);
    }
  };
}
f(sx, "create_fragment$30");
function nx(i, e, t) {
  let s, n, { deleteRoll: l } = e, { duplicateRoll: r } = e, { roll: o } = e, { rollId: a } = e;
  const c = fe("item");
  pe(i, c, (v) => t(5, n = v));
  const u = fe("actionId"), { abilities: d } = CONFIG.A5E;
  function p() {
    se(n, `system.actions.${u}.rolls.${a}.ability`, s);
  }
  f(p, "updateAbility");
  const m = /* @__PURE__ */ f(({ target: v }) => se(n, `system.actions.${u}.rolls.${a}.label`, v.value), "change_handler"), g = /* @__PURE__ */ f(() => r(u, o), "func"), h = /* @__PURE__ */ f(() => l(u, a), "func_1"), _ = /* @__PURE__ */ f(({ detail: v }) => t(4, s = v), "updateSelection_handler"), y = /* @__PURE__ */ f(({ target: v }) => se(n, `system.actions.${u}.rolls.${a}.bonus`, v.value), "change_handler_1"), k = /* @__PURE__ */ f(({ detail: v }) => {
    se(n, `system.actions.${u}.rolls.${a}.default`, v);
  }, "updateSelection_handler_1");
  return i.$$set = (v) => {
    "deleteRoll" in v && t(0, l = v.deleteRoll), "duplicateRoll" in v && t(1, r = v.duplicateRoll), "roll" in v && t(2, o = v.roll), "rollId" in v && t(3, a = v.rollId);
  }, i.$$.update = () => {
    i.$$.dirty & /*roll*/
    4 && t(4, s = o.ability ?? "none"), i.$$.dirty & /*selectedAbility*/
    16 && p();
  }, [
    l,
    r,
    o,
    a,
    s,
    n,
    c,
    u,
    d,
    m,
    g,
    h,
    _,
    y,
    k
  ];
}
f(nx, "instance$2T");
const z2 = class z2 extends ie {
  constructor(e) {
    super(), le(this, e, nx, sx, ne, {
      deleteRoll: 0,
      duplicateRoll: 1,
      roll: 2,
      rollId: 3
    });
  }
};
f(z2, "AbilityCheckRollConfig");
let R0 = z2;
function aP(i, e, t) {
  const s = i.slice();
  return s[19] = e[t][0], s[20] = e[t][1], s;
}
f(aP, "get_each_context$1c");
function ix(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(ix, "create_default_slot_4$h");
function cP(i, e) {
  let t, s = K(
    /*name*/
    e[20]
  ) + "", n, l, r;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = x(s), l = R(), t.__value = /*key*/
      e[19], qe(t, t.__value), t.selected = r = /*roll*/
      e[2].attackType === /*key*/
      e[19], this.first = t;
    },
    m(o, a) {
      T(o, t, a), A(t, n), A(t, l);
    },
    p(o, a) {
      e = o, a & /*roll*/
      4 && r !== (r = /*roll*/
      e[2].attackType === /*key*/
      e[19]) && (t.selected = r);
    },
    d(o) {
      o && S(t);
    }
  };
}
f(cP, "create_each_block$1c");
function lx(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n, l, r = oe(Object.entries(
    /*A5E*/
    i[8].attackTypes
  ));
  const o = /* @__PURE__ */ f((a) => (
    /*key*/
    a[19]
  ), "get_key");
  for (let a = 0; a < r.length; a += 1) {
    let c = aP(i, r, a), u = o(c);
    s.set(u, t[a] = cP(u, c));
  }
  return {
    c() {
      e = E("select");
      for (let a = 0; a < t.length; a += 1)
        t[a].c();
      b(e, "class", "u-w-full");
    },
    m(a, c) {
      T(a, e, c);
      for (let u = 0; u < t.length; u += 1)
        t[u] && t[u].m(e, null);
      n || (l = V(
        e,
        "change",
        /*change_handler_1*/
        i[14]
      ), n = !0);
    },
    p(a, c) {
      c & /*Object, A5E, roll*/
      260 && (r = oe(Object.entries(
        /*A5E*/
        a[8].attackTypes
      )), t = kt(t, c, o, 1, a, r, s, e, vs, cP, null, aP));
    },
    d(a) {
      a && S(e);
      for (let c = 0; c < t.length; c += 1)
        t[c].d();
      n = !1, l();
    }
  };
}
f(lx, "create_default_slot_3$r");
function rx(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].bonus ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_2*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].bonus ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(rx, "create_default_slot_2$z");
function ox(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), e.value = t = /*roll*/
      i[2].critThreshold ?? 20;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_3*/
        i[16]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].critThreshold ?? 20) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(ox, "create_default_slot_1$K");
function ax(i) {
  let e, t, s, n, l, r, o;
  return e = new de({
    props: {
      heading: "A5E.AttackType",
      $$slots: { default: [lx] },
      $$scope: { ctx: i }
    }
  }), s = new de({
    props: {
      heading: "A5E.AttackBonus",
      $$slots: { default: [rx] },
      $$scope: { ctx: i }
    }
  }), r = new de({
    props: {
      heading: "A5E.CriticalHitThreshold",
      $$slots: { default: [ox] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), n = E("div"), L(s.$$.fragment), l = R(), L(r.$$.fragment), z(n, "display", "contents"), z(n, "--a5e-field-wrapper-grow", "1");
    },
    m(a, c) {
      N(e, a, c), T(a, t, c), T(a, n, c), N(s, n, null), T(a, l, c), N(r, a, c), o = !0;
    },
    p(a, c) {
      const u = {};
      c & /*$$scope, $item, rollId, roll*/
      8388652 && (u.$$scope = { dirty: c, ctx: a }), e.$set(u);
      const d = {};
      c & /*$$scope, roll, $item, rollId*/
      8388652 && (d.$$scope = { dirty: c, ctx: a }), s.$set(d);
      const p = {};
      c & /*$$scope, roll, $item, rollId*/
      8388652 && (p.$$scope = { dirty: c, ctx: a }), r.$set(p);
    },
    i(a) {
      o || (w(e.$$.fragment, a), w(s.$$.fragment, a), w(r.$$.fragment, a), o = !0);
    },
    o(a) {
      C(e.$$.fragment, a), C(s.$$.fragment, a), C(r.$$.fragment, a), o = !1;
    },
    d(a) {
      a && (S(t), S(l)), j(e, a), a && s && S(n), j(s, a), j(r, a);
    }
  };
}
f(ax, "create_default_slot$1n");
function cx(i) {
  let e, t, s, n, l, r, o, a, c, u;
  return e = new de({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[11]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[12]
          )
        }
      ],
      $$slots: { default: [ix] },
      $$scope: { ctx: i }
    }
  }), n = new Ye({
    props: {
      heading: "A5E.AbilityScore",
      hint: "The ability score modifier to add to the attack roll.",
      optionStyles: "min-width: 2rem; text-align: center;",
      options: (
        /*abilityOptions*/
        i[9]
      ),
      selected: (
        /*selectedAbility*/
        i[4]
      )
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[13]
  ), r = new Me({
    props: {
      $$slots: { default: [ax] },
      $$scope: { ctx: i }
    }
  }), c = new De({
    props: {
      label: "A5E.AddProficiency",
      checked: (
        /*roll*/
        i[2].proficient ?? !0
      )
    }
  }), c.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[17]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), l = R(), o = E("div"), L(r.$$.fragment), a = R(), L(c.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-header-button-color", "#bebdb5"), z(t, "--a5e-header-button-color-hover", "#555"), z(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem"), z(o, "display", "contents"), z(o, "--a5e-section-body-direction", "row"), z(o, "--a5e-section-body-padding", "0"), z(o, "--a5e-section-body-wrap", "nowrap");
    },
    m(d, p) {
      T(d, t, p), N(e, t, null), T(d, s, p), N(n, d, p), T(d, l, p), T(d, o, p), N(r, o, null), T(d, a, p), N(c, d, p), u = !0;
    },
    p(d, [p]) {
      const m = {};
      p & /*duplicateRoll, roll, deleteRoll, rollId*/
      15 && (m.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            d[11]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            d[12]
          )
        }
      ]), p & /*$$scope, roll, $item, rollId*/
      8388652 && (m.$$scope = { dirty: p, ctx: d }), e.$set(m);
      const g = {};
      p & /*selectedAbility*/
      16 && (g.selected = /*selectedAbility*/
      d[4]), n.$set(g);
      const h = {};
      p & /*$$scope, roll, $item, rollId*/
      8388652 && (h.$$scope = { dirty: p, ctx: d }), r.$set(h);
      const _ = {};
      p & /*roll*/
      4 && (_.checked = /*roll*/
      d[2].proficient ?? !0), c.$set(_);
    },
    i(d) {
      u || (w(e.$$.fragment, d), w(n.$$.fragment, d), w(r.$$.fragment, d), w(c.$$.fragment, d), u = !0);
    },
    o(d) {
      C(e.$$.fragment, d), C(n.$$.fragment, d), C(r.$$.fragment, d), C(c.$$.fragment, d), u = !1;
    },
    d(d) {
      d && (S(s), S(l), S(a)), d && e && S(t), j(e, d), j(n, d), d && r && S(o), j(r, d), j(c, d);
    }
  };
}
f(cx, "create_fragment$2$");
function ux(i, e, t) {
  let s, n, { deleteRoll: l } = e, { duplicateRoll: r } = e, { roll: o } = e, { rollId: a } = e;
  const c = fe("item");
  pe(i, c, (D) => t(5, n = D));
  const u = fe("actionId");
  function d() {
    se(n, `system.actions.${u}.rolls.${a}.ability`, s);
  }
  f(d, "updateAbility");
  const p = CONFIG.A5E, m = [
    ["none", "A5E.None"],
    ["default", "A5E.abilities.default"],
    ["spellcasting", "A5E.abilities.spellcasting"],
    ...ci()
  ], g = /* @__PURE__ */ f(({ target: D }) => se(n, `system.actions.${u}.rolls.${a}.label`, D.value), "change_handler"), h = /* @__PURE__ */ f(() => r(u, o), "func"), _ = /* @__PURE__ */ f(() => l(u, a), "func_1"), y = /* @__PURE__ */ f(({ detail: D }) => t(4, s = D), "updateSelection_handler"), k = /* @__PURE__ */ f(({ target: D }) => se(n, `system.actions.${u}.rolls.${a}.attackType`, D.value), "change_handler_1"), v = /* @__PURE__ */ f(({ target: D }) => se(n, `system.actions.${u}.rolls.${a}.bonus`, D.value), "change_handler_2"), O = /* @__PURE__ */ f(({ target: D }) => se(n, `system.actions.${u}.rolls.${a}.critThreshold`, Number(D.value)), "change_handler_3"), P = /* @__PURE__ */ f(({ detail: D }) => {
    se(n, `system.actions.${u}.rolls.${a}.proficient`, D);
  }, "updateSelection_handler_1");
  return i.$$set = (D) => {
    "deleteRoll" in D && t(0, l = D.deleteRoll), "duplicateRoll" in D && t(1, r = D.duplicateRoll), "roll" in D && t(2, o = D.roll), "rollId" in D && t(3, a = D.rollId);
  }, i.$$.update = () => {
    i.$$.dirty & /*roll*/
    4 && t(4, s = o.ability ?? "none"), i.$$.dirty & /*selectedAbility*/
    16 && d();
  }, [
    l,
    r,
    o,
    a,
    s,
    n,
    c,
    u,
    p,
    m,
    g,
    h,
    _,
    y,
    k,
    v,
    O,
    P
  ];
}
f(ux, "instance$2S");
const H2 = class H2 extends ie {
  constructor(e) {
    super(), le(this, e, ux, cx, ne, {
      deleteRoll: 0,
      duplicateRoll: 1,
      roll: 2,
      rollId: 3
    });
  }
};
f(H2, "AttackRollConfig");
let F0 = H2;
function fx(i) {
  let e, t;
  return e = new bt({
    props: {
      $$slots: { default: [mx] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, scalingMode, actionId, rollId, roll, $item*/
      8223 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(fx, "create_if_block_2$J");
function dx(i) {
  let e, t;
  return e = new bt({
    props: {
      $$slots: { default: [hx] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, actionId, rollId, roll, $item*/
      8207 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(dx, "create_if_block_1$19");
function px(i) {
  let e, t;
  return e = new bt({
    props: {
      heading: "Roll Increment",
      hint: "This increment will be applied automatically to your roll based on your caster level.",
      $$slots: { default: [gx] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, actionId, rollId, roll, $item*/
      8207 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(px, "create_if_block$1I");
function mx(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k, v, O, P, D, I, B, F = (
    /*scalingMode*/
    i[4] === "spellPoints" ? "Points" : "Uses"
  ), H, G, U;
  return {
    c() {
      var q, W;
      e = E("section"), t = E("div"), s = E("label"), n = x("Roll Increment"), r = R(), o = E("input"), d = R(), p = E("div"), m = E("label"), g = x("Per"), _ = R(), y = E("input"), P = R(), D = E("div"), I = E("span"), B = x("Additional "), H = x(F), b(s, "for", l = /*actionId*/
      i[0] + "-" + /*rollId*/
      i[1] + "-roll-scaling-formula"), b(s, "class", "svelte-1iq6rn"), b(o, "id", a = /*actionId*/
      i[0] + "-" + /*rollId*/
      i[1] + "-roll-scaling-formula"), b(o, "type", "text"), b(o, "name", c = "system.actions." + /*actionId*/
      i[0] + ".rolls." + /*rollId*/
      i[1] + ".scaling.formula"), o.value = u = /*roll*/
      ((q = i[2].scaling) == null ? void 0 : q.formula) ?? 0, b(o, "class", "svelte-1iq6rn"), b(t, "class", "a5e-field-group a5e-field-group--formula"), b(m, "for", h = /*actionId*/
      i[0] + "-" + /*rollId*/
      i[1] + "-roll-scaling-step"), b(m, "class", "svelte-1iq6rn"), b(y, "id", k = /*actionId*/
      i[0] + "-" + /*rollId*/
      i[1] + "-roll-scaling-step"), z(y, "text-align", "center"), b(y, "type", "number"), b(y, "name", v = "system.actions." + /*actionId*/
      i[0] + ".rolls." + /*rollId*/
      i[1] + ".scaling.step"), y.value = O = /*roll*/
      ((W = i[2].scaling) == null ? void 0 : W.step) ?? 1, b(y, "class", "svelte-1iq6rn"), b(p, "class", "a5e-field-group u-w-12"), b(I, "class", "levels svelte-1iq6rn"), b(D, "class", "a5e-field-group levels-wrapper svelte-1iq6rn"), b(e, "class", "row u-flex-wrap svelte-1iq6rn");
    },
    m(q, W) {
      T(q, e, W), A(e, t), A(t, s), A(s, n), A(t, r), A(t, o), A(e, d), A(e, p), A(p, m), A(m, g), A(p, _), A(p, y), A(e, P), A(e, D), A(D, I), A(I, B), A(I, H), G || (U = [
        V(
          o,
          "change",
          /*change_handler_3*/
          i[11]
        ),
        V(
          y,
          "change",
          /*change_handler_4*/
          i[12]
        )
      ], G = !0);
    },
    p(q, W) {
      var X, te;
      W & /*actionId, rollId*/
      3 && l !== (l = /*actionId*/
      q[0] + "-" + /*rollId*/
      q[1] + "-roll-scaling-formula") && b(s, "for", l), W & /*actionId, rollId*/
      3 && a !== (a = /*actionId*/
      q[0] + "-" + /*rollId*/
      q[1] + "-roll-scaling-formula") && b(o, "id", a), W & /*actionId, rollId*/
      3 && c !== (c = "system.actions." + /*actionId*/
      q[0] + ".rolls." + /*rollId*/
      q[1] + ".scaling.formula") && b(o, "name", c), W & /*roll*/
      4 && u !== (u = /*roll*/
      ((X = q[2].scaling) == null ? void 0 : X.formula) ?? 0) && o.value !== u && (o.value = u), W & /*actionId, rollId*/
      3 && h !== (h = /*actionId*/
      q[0] + "-" + /*rollId*/
      q[1] + "-roll-scaling-step") && b(m, "for", h), W & /*actionId, rollId*/
      3 && k !== (k = /*actionId*/
      q[0] + "-" + /*rollId*/
      q[1] + "-roll-scaling-step") && b(y, "id", k), W & /*actionId, rollId*/
      3 && v !== (v = "system.actions." + /*actionId*/
      q[0] + ".rolls." + /*rollId*/
      q[1] + ".scaling.step") && b(y, "name", v), W & /*roll*/
      4 && O !== (O = /*roll*/
      ((te = q[2].scaling) == null ? void 0 : te.step) ?? 1) && y.value !== O && (y.value = O), W & /*scalingMode*/
      16 && F !== (F = /*scalingMode*/
      q[4] === "spellPoints" ? "Points" : "Uses") && _e(H, F);
    },
    d(q) {
      q && S(e), G = !1, Ne(U);
    }
  };
}
f(mx, "create_default_slot_2$y");
function hx(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k, v, O, P, D, I, B, F, H;
  return {
    c() {
      var G, U;
      e = E("section"), t = E("div"), s = E("label"), n = x("Roll Increment"), r = R(), o = E("input"), d = R(), p = E("div"), m = E("label"), g = x("Per"), _ = R(), y = E("input"), P = R(), D = E("div"), D.innerHTML = '<span class="levels svelte-1iq6rn">Levels</span>', I = R(), B = E("small"), B.textContent = `This increment will be applied automatically to your roll
                    based the spell slot used during activation.`, b(s, "for", l = /*actionId*/
      i[0] + "-" + /*rollId*/
      i[1] + "-roll-scaling-formula"), b(s, "class", "svelte-1iq6rn"), b(o, "id", a = /*actionId*/
      i[0] + "-" + /*rollId*/
      i[1] + "-roll-scaling-formula"), b(o, "type", "text"), b(o, "name", c = "system.actions." + /*actionId*/
      i[0] + ".rolls." + /*rollId*/
      i[1] + ".scaling.formula"), o.value = u = /*roll*/
      ((G = i[2].scaling) == null ? void 0 : G.formula) ?? 0, b(o, "class", "svelte-1iq6rn"), b(t, "class", "a5e-field-group a5e-field-group--formula a5e-field-group--spell-level svelte-1iq6rn"), b(m, "for", h = /*actionId*/
      i[0] + "-" + /*rollId*/
      i[1] + "-roll-scaling-step"), b(m, "class", "svelte-1iq6rn"), b(y, "id", k = /*actionId*/
      i[0] + "-" + /*rollId*/
      i[1] + "-roll-scaling-step"), b(y, "type", "number"), b(y, "name", v = "system.actions." + /*actionId*/
      i[0] + ".rolls." + /*rollId*/
      i[1] + ".scaling.step"), y.value = O = /*roll*/
      ((U = i[2].scaling) == null ? void 0 : U.step) ?? 1, b(y, "class", "svelte-1iq6rn"), b(p, "class", "a5e-field-group u-w-12 a5e-field-group--spell-level svelte-1iq6rn"), b(D, "class", "a5e-field-group levels-wrapper svelte-1iq6rn"), b(B, "class", "svelte-1iq6rn"), b(e, "class", "row u-flex-wrap svelte-1iq6rn");
    },
    m(G, U) {
      T(G, e, U), A(e, t), A(t, s), A(s, n), A(t, r), A(t, o), A(e, d), A(e, p), A(p, m), A(m, g), A(p, _), A(p, y), A(e, P), A(e, D), A(e, I), A(e, B), F || (H = [
        V(
          o,
          "change",
          /*change_handler_1*/
          i[9]
        ),
        V(
          y,
          "change",
          /*change_handler_2*/
          i[10]
        )
      ], F = !0);
    },
    p(G, U) {
      var q, W;
      U & /*actionId, rollId*/
      3 && l !== (l = /*actionId*/
      G[0] + "-" + /*rollId*/
      G[1] + "-roll-scaling-formula") && b(s, "for", l), U & /*actionId, rollId*/
      3 && a !== (a = /*actionId*/
      G[0] + "-" + /*rollId*/
      G[1] + "-roll-scaling-formula") && b(o, "id", a), U & /*actionId, rollId*/
      3 && c !== (c = "system.actions." + /*actionId*/
      G[0] + ".rolls." + /*rollId*/
      G[1] + ".scaling.formula") && b(o, "name", c), U & /*roll*/
      4 && u !== (u = /*roll*/
      ((q = G[2].scaling) == null ? void 0 : q.formula) ?? 0) && o.value !== u && (o.value = u), U & /*actionId, rollId*/
      3 && h !== (h = /*actionId*/
      G[0] + "-" + /*rollId*/
      G[1] + "-roll-scaling-step") && b(m, "for", h), U & /*actionId, rollId*/
      3 && k !== (k = /*actionId*/
      G[0] + "-" + /*rollId*/
      G[1] + "-roll-scaling-step") && b(y, "id", k), U & /*actionId, rollId*/
      3 && v !== (v = "system.actions." + /*actionId*/
      G[0] + ".rolls." + /*rollId*/
      G[1] + ".scaling.step") && b(y, "name", v), U & /*roll*/
      4 && O !== (O = /*roll*/
      ((W = G[2].scaling) == null ? void 0 : W.step) ?? 1) && y.value !== O && (y.value = O);
    },
    d(G) {
      G && S(e), F = !1, Ne(H);
    }
  };
}
f(hx, "create_default_slot_1$J");
function gx(i) {
  let e, t, s, n, l;
  return {
    c() {
      var r;
      e = E("input"), b(e, "class", "a5e-input svelte-1iq6rn"), b(e, "type", "text"), b(e, "name", t = "system.actions." + /*actionId*/
      i[0] + ".rolls." + /*rollId*/
      i[1] + ".scaling.formula"), e.value = s = /*roll*/
      ((r = i[2].scaling) == null ? void 0 : r.formula) ?? 0;
    },
    m(r, o) {
      T(r, e, o), n || (l = V(
        e,
        "change",
        /*change_handler*/
        i[8]
      ), n = !0);
    },
    p(r, o) {
      var a;
      o & /*actionId, rollId*/
      3 && t !== (t = "system.actions." + /*actionId*/
      r[0] + ".rolls." + /*rollId*/
      r[1] + ".scaling.formula") && b(e, "name", t), o & /*roll*/
      4 && s !== (s = /*roll*/
      ((a = r[2].scaling) == null ? void 0 : a.formula) ?? 0) && e.value !== s && (e.value = s);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(gx, "create_default_slot$1m");
function bx(i) {
  let e, t, s, n, l, r, o;
  t = new Ye({
    props: {
      heading: "Scaling Mode",
      options: _x(),
      selected: (
        /*scalingMode*/
        i[4]
      ),
      allowDeselect: !1
    }
  }), t.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  );
  const a = [px, dx, fx], c = [];
  function u(d, p) {
    return p & /*scalingMode*/
    16 && (n = null), /*scalingMode*/
    d[4] === "cantrip" ? 0 : (
      /*scalingMode*/
      d[4] === "spellLevel" ? 1 : (n == null && (n = !!["spellPoints", "actionUses", "itemUses"].includes(
        /*scalingMode*/
        d[4]
      )), n ? 2 : -1)
    );
  }
  return f(u, "select_block_type"), ~(l = u(i, -1)) && (r = c[l] = a[l](i)), {
    c() {
      e = E("form"), L(t.$$.fragment), s = R(), r && r.c(), b(e, "class", "svelte-1iq6rn");
    },
    m(d, p) {
      T(d, e, p), N(t, e, null), A(e, s), ~l && c[l].m(e, null), o = !0;
    },
    p(d, [p]) {
      const m = {};
      p & /*scalingMode*/
      16 && (m.selected = /*scalingMode*/
      d[4]), t.$set(m);
      let g = l;
      l = u(d, p), l === g ? ~l && c[l].p(d, p) : (r && (ce(), C(c[g], 1, 1, () => {
        c[g] = null;
      }), ue()), ~l ? (r = c[l], r ? r.p(d, p) : (r = c[l] = a[l](d), r.c()), w(r, 1), r.m(e, null)) : r = null);
    },
    i(d) {
      o || (w(t.$$.fragment, d), w(r), o = !0);
    },
    o(d) {
      C(t.$$.fragment, d), C(r), o = !1;
    },
    d(d) {
      d && S(e), j(t), ~l && c[l].d();
    }
  };
}
f(bx, "create_fragment$2_");
function _x() {
  return [[null, "A5E.None"], ...Object.entries(CONFIG.A5E.baseScalingModes)];
}
f(_x, "getScalingOptions$1");
function yx(i, e, t) {
  let s, n, l, { document: r, actionId: o, rollId: a } = fe("#external").application, { document: c = r, actionId: u = o, rollId: d = a } = e;
  const p = c;
  pe(i, p, (v) => t(3, l = v));
  const m = /* @__PURE__ */ f((v) => {
    se(l, `system.actions.${u}.rolls.${d}.scaling.mode`, v.detail);
  }, "updateSelection_handler"), g = /* @__PURE__ */ f(({ target: v }) => se(l, v.name, v.value), "change_handler"), h = /* @__PURE__ */ f(({ target: v }) => se(l, v.name, v.value), "change_handler_1"), _ = /* @__PURE__ */ f(({ target: v }) => se(l, v.name, parseInt(v.value, 10)), "change_handler_2"), y = /* @__PURE__ */ f(({ target: v }) => se(l, v.name, v.value), "change_handler_3"), k = /* @__PURE__ */ f(({ target: v }) => se(l, v.name, parseInt(v.value, 10)), "change_handler_4");
  return i.$$set = (v) => {
    "document" in v && t(6, c = v.document), "actionId" in v && t(0, u = v.actionId), "rollId" in v && t(1, d = v.rollId);
  }, i.$$.update = () => {
    var v;
    i.$$.dirty & /*$item, actionId, rollId*/
    11 && t(2, s = l.actions[u].rolls[d]), i.$$.dirty & /*roll*/
    4 && t(4, n = ((v = s.scaling) == null ? void 0 : v.mode) ?? null);
  }, [
    u,
    d,
    s,
    l,
    n,
    p,
    c,
    m,
    g,
    h,
    _,
    y,
    k
  ];
}
f(yx, "instance$2R");
const U2 = class U2 extends ie {
  constructor(e) {
    super(), le(this, e, yx, bx, ne, { document: 6, actionId: 0, rollId: 1 });
  }
};
f(U2, "RollScalingDialog");
let Nc = U2;
function Li(i) {
  const e = parseInt((i == null ? void 0 : i.toString()) ?? 0, 10) % 10, t = parseInt((i == null ? void 0 : i.toString()) ?? 0, 10) % 100;
  return e === 1 && t !== 11 ? `${i}st` : e === 2 && t !== 12 ? `${i}nd` : e === 3 && t !== 13 ? `${i}rd` : `${i}th`;
}
f(Li, "getOrdinalNumber");
function uP(i, e, t) {
  const s = i.slice();
  return s[19] = e[t][0], s[20] = e[t][1], s;
}
f(uP, "get_each_context$1b");
function vx(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[9]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(vx, "create_default_slot_4$g");
function kx(i) {
  let e, t, s, n, l, r, o, a;
  return {
    c() {
      e = E("div"), t = E("input"), l = R(), r = E("button"), r.innerHTML = '<i class="fa-solid fa-arrow-up-right-dots svelte-w86fws" data-tooltip="A5E.ConfigureDamageScaling" data-tooltip-direction="UP"></i>', b(t, "id", s = /*actionId*/
      i[7] + "-" + /*rollId*/
      i[3] + "-damage-formula"), b(t, "type", "text"), t.value = n = /*roll*/
      i[2].formula ?? "", b(r, "class", "scaling-button svelte-w86fws"), b(e, "class", "u-flex u-gap-sm u-w-full");
    },
    m(c, u) {
      T(c, e, u), A(e, t), A(e, l), A(e, r), o || (a = [
        V(
          t,
          "change",
          /*change_handler_1*/
          i[12]
        ),
        V(r, "click", tt(
          /*onClickScalingButton*/
          i[5]
        ))
      ], o = !0);
    },
    p(c, u) {
      u & /*rollId*/
      8 && s !== (s = /*actionId*/
      c[7] + "-" + /*rollId*/
      c[3] + "-damage-formula") && b(t, "id", s), u & /*roll*/
      4 && n !== (n = /*roll*/
      c[2].formula ?? "") && t.value !== n && (t.value = n);
    },
    d(c) {
      c && S(e), o = !1, Ne(a);
    }
  };
}
f(kx, "create_default_slot_3$q");
function fP(i, e) {
  let t, s = K(
    /*name*/
    e[20]
  ) + "", n, l, r;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = x(s), l = R(), t.__value = /*key*/
      e[19], qe(t, t.__value), t.selected = r = /*roll*/
      e[2].damageType === /*key*/
      e[19], this.first = t;
    },
    m(o, a) {
      T(o, t, a), A(t, n), A(t, l);
    },
    p(o, a) {
      e = o, a & /*roll*/
      4 && r !== (r = /*roll*/
      e[2].damageType === /*key*/
      e[19]) && (t.selected = r);
    },
    d(o) {
      o && S(t);
    }
  };
}
f(fP, "create_each_block$1b");
function wx(i) {
  let e, t, s = K("A5E.None") + "", n, l, r, o = [], a = /* @__PURE__ */ new Map(), c, u, d, p = oe(Object.entries(
    /*damageTypes*/
    i[8]
  ));
  const m = /* @__PURE__ */ f((g) => (
    /*key*/
    g[19]
  ), "get_key");
  for (let g = 0; g < p.length; g += 1) {
    let h = uP(i, p, g), _ = m(h);
    a.set(_, o[g] = fP(_, h));
  }
  return {
    c() {
      e = E("select"), t = E("option"), n = x(s), l = R();
      for (let g = 0; g < o.length; g += 1)
        o[g].c();
      t.__value = null, qe(t, t.__value), t.selected = r = /*roll*/
      i[2].damageType === "null", b(e, "id", c = /*actionId*/
      i[7] + "-" + /*rollId*/
      i[3] + "-damage-type"), b(e, "class", "u-w-fit damage-type-select svelte-w86fws");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(t, n), A(t, l);
      for (let _ = 0; _ < o.length; _ += 1)
        o[_] && o[_].m(e, null);
      u || (d = V(
        e,
        "change",
        /*change_handler_2*/
        i[13]
      ), u = !0);
    },
    p(g, h) {
      h & /*roll*/
      4 && r !== (r = /*roll*/
      g[2].damageType === "null") && (t.selected = r), h & /*Object, damageTypes, roll*/
      260 && (p = oe(Object.entries(
        /*damageTypes*/
        g[8]
      )), o = kt(o, h, m, 1, g, p, a, e, vs, fP, null, uP)), h & /*rollId*/
      8 && c !== (c = /*actionId*/
      g[7] + "-" + /*rollId*/
      g[3] + "-damage-type") && b(e, "id", c);
    },
    d(g) {
      g && S(e);
      for (let h = 0; h < o.length; h += 1)
        o[h].d();
      u = !1, d();
    }
  };
}
f(wx, "create_default_slot_2$x");
function $x(i) {
  let e, t, s, n, l;
  return e = new de({
    props: {
      heading: "A5E.DamageFormula",
      $$slots: { default: [kx] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      heading: "A5E.DamageType",
      $$slots: { default: [wx] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-grow", "1");
    },
    m(r, o) {
      T(r, t, o), N(e, t, null), T(r, s, o), N(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*$$scope, rollId, roll, $item*/
      8388636 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, rollId, $item, roll*/
      8388636 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && S(s), r && e && S(t), j(e, r), j(n, r);
    }
  };
}
f($x, "create_default_slot_1$I");
function dP(i) {
  let e, t;
  return e = new de({
    props: {
      heading: "A5E.DamageBonusOnCrit",
      hint: `When you score a critical hit, this damage is added after doubling
    the attack's damage.`,
      $$slots: { default: [Ax] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, rollId, roll, $item*/
      8388636 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(dP, "create_if_block$1H");
function Ax(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("input"), b(e, "id", t = /*actionId*/
      i[7] + "-" + /*rollId*/
      i[3] + "-crit-bonus"), b(e, "type", "text"), e.value = s = /*roll*/
      i[2].critBonus ?? "";
    },
    m(r, o) {
      T(r, e, o), n || (l = V(
        e,
        "change",
        /*change_handler_3*/
        i[15]
      ), n = !0);
    },
    p(r, o) {
      o & /*rollId*/
      8 && t !== (t = /*actionId*/
      r[7] + "-" + /*rollId*/
      r[3] + "-crit-bonus") && b(e, "id", t), o & /*roll*/
      4 && s !== (s = /*roll*/
      r[2].critBonus ?? "") && e.value !== s && (e.value = s);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(Ax, "create_default_slot$1l");
function Ex(i) {
  let e, t, s, n, l, r, o, a, c, u, d;
  e = new de({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[11]
          )
        }
      ],
      $$slots: { default: [vx] },
      $$scope: { ctx: i }
    }
  }), n = new Me({
    props: {
      $$slots: { default: [$x] },
      $$scope: { ctx: i }
    }
  }), o = new De({
    props: {
      label: "A5E.DamageDoubleOnCrit",
      checked: (
        /*roll*/
        i[2].canCrit ?? !0
      )
    }
  }), o.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[14]
  );
  let p = (
    /*roll*/
    (i[2].canCrit ?? !0) && dP(i)
  );
  return u = new De({
    props: {
      label: "A5E.DamageDefaultSelection",
      checked: (
        /*roll*/
        i[2].default ?? !0
      )
    }
  }), u.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[16]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), l = E("div"), L(n.$$.fragment), r = R(), L(o.$$.fragment), a = R(), p && p.c(), c = R(), L(u.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-header-button-color", "#bebdb5"), z(t, "--a5e-header-button-color-hover", "#555"), z(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem"), z(l, "display", "contents"), z(l, "--a5e-section-body-direction", "row"), z(l, "--a5e-section-body-wrap", "nowrap"), z(l, "--a5e-section-body-padding", "0");
    },
    m(m, g) {
      T(m, t, g), N(e, t, null), T(m, s, g), T(m, l, g), N(n, l, null), T(m, r, g), N(o, m, g), T(m, a, g), p && p.m(m, g), T(m, c, g), N(u, m, g), d = !0;
    },
    p(m, [g]) {
      const h = {};
      g & /*duplicateRoll, roll, deleteRoll, rollId*/
      15 && (h.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            m[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            m[11]
          )
        }
      ]), g & /*$$scope, roll, $item, rollId*/
      8388636 && (h.$$scope = { dirty: g, ctx: m }), e.$set(h);
      const _ = {};
      g & /*$$scope, rollId, $item, roll*/
      8388636 && (_.$$scope = { dirty: g, ctx: m }), n.$set(_);
      const y = {};
      g & /*roll*/
      4 && (y.checked = /*roll*/
      m[2].canCrit ?? !0), o.$set(y), /*roll*/
      m[2].canCrit ?? !0 ? p ? (p.p(m, g), g & /*roll*/
      4 && w(p, 1)) : (p = dP(m), p.c(), w(p, 1), p.m(c.parentNode, c)) : p && (ce(), C(p, 1, 1, () => {
        p = null;
      }), ue());
      const k = {};
      g & /*roll*/
      4 && (k.checked = /*roll*/
      m[2].default ?? !0), u.$set(k);
    },
    i(m) {
      d || (w(e.$$.fragment, m), w(n.$$.fragment, m), w(o.$$.fragment, m), w(p), w(u.$$.fragment, m), d = !0);
    },
    o(m) {
      C(e.$$.fragment, m), C(n.$$.fragment, m), C(o.$$.fragment, m), C(p), C(u.$$.fragment, m), d = !1;
    },
    d(m) {
      m && (S(s), S(r), S(a), S(c)), m && e && S(t), j(e, m), m && n && S(l), j(n, m), j(o, m), p && p.d(m), j(u, m);
    }
  };
}
f(Ex, "create_fragment$2Z");
function Sx(i, e, t) {
  let s;
  function n(P) {
    var G, U, q, W, X, te, J;
    const D = (G = P.scaling) == null ? void 0 : G.mode, I = ((U = P.scaling) == null ? void 0 : U.formula) ?? 0, B = a[P.damageType], F = Li(s.system.level ?? 1), H = (q = P.scaling) == null ? void 0 : q.step;
    return D === "cantrip" ? K("A5E.scaling.summaries.cantrip.damage", { formula: I, damageType: B }) : D === "spellLevel" ? !H || H === 1 ? K("A5E.scaling.summaries.spellLevel.damage", { formula: I, level: F, damageType: B }) : K("A5E.scaling.summaries.steppedSpellLevel.damage", { formula: I, step: H, level: F, damageType: B }) : D === "spellPoints" ? !((W = P.scaling) != null && W.step) || ((X = P.scaling) == null ? void 0 : X.step) === 1 ? K("A5E.scaling.summaries.spellPoint.damage", { formula: I }) : K("A5E.scaling.summaries.steppedSpellPoint.damage", { formula: I, step: H }) : ["actionUses", "itemUses"].includes(D) ? !((te = P.scaling) != null && te.step) || ((J = P.scaling) == null ? void 0 : J.step) === 1 ? K("A5E.scaling.summaries.uses.damage", { formula: I }) : K("A5E.scaling.summaries.steppedUses.damage", { formula: I, step: H }) : null;
  }
  f(n, "getScalingSummary");
  function l() {
    let P = s.dialogs.rollScaling[p];
    P || (fl(r, s.dialogs.rollScaling[p] = new gn(s, `${s.name} Damage Scaling Configuration`, Nc, { actionId: o, rollId: p }, { width: 432 }), s), P = s.dialogs.rollScaling[p]), P.render(!0);
  }
  f(l, "onClickScalingButton");
  const r = fe("item");
  pe(i, r, (P) => t(4, s = P));
  const o = fe("actionId"), { damageTypes: a } = CONFIG.A5E;
  let { deleteRoll: c } = e, { duplicateRoll: u } = e, { roll: d } = e, { rollId: p } = e;
  const m = /* @__PURE__ */ f(({ target: P }) => se(s, `system.actions.${o}.rolls.${p}.label`, P.value), "change_handler"), g = /* @__PURE__ */ f(() => u(o, d), "func"), h = /* @__PURE__ */ f(() => c(o, p), "func_1"), _ = /* @__PURE__ */ f(({ target: P }) => se(s, `system.actions.${o}.rolls.${p}.formula`, P.value), "change_handler_1"), y = /* @__PURE__ */ f(({ target: P }) => se(s, `system.actions.${o}.rolls.${p}.damageType`, P.value), "change_handler_2"), k = /* @__PURE__ */ f(({ detail: P }) => {
    se(s, `system.actions.${o}.rolls.${p}.canCrit`, P);
  }, "updateSelection_handler"), v = /* @__PURE__ */ f(({ target: P }) => se(s, `system.actions.${o}.rolls.${p}.critBonus`, P.value), "change_handler_3"), O = /* @__PURE__ */ f(({ detail: P }) => {
    se(s, `system.actions.${o}.rolls.${p}.default`, P);
  }, "updateSelection_handler_1");
  return i.$$set = (P) => {
    "deleteRoll" in P && t(0, c = P.deleteRoll), "duplicateRoll" in P && t(1, u = P.duplicateRoll), "roll" in P && t(2, d = P.roll), "rollId" in P && t(3, p = P.rollId);
  }, i.$$.update = () => {
    i.$$.dirty & /*roll*/
    4 && n(d);
  }, [
    c,
    u,
    d,
    p,
    s,
    l,
    r,
    o,
    a,
    m,
    g,
    h,
    _,
    y,
    k,
    v,
    O
  ];
}
f(Sx, "instance$2Q");
const V2 = class V2 extends ie {
  constructor(e) {
    super(), le(this, e, Sx, Ex, ne, {
      deleteRoll: 0,
      duplicateRoll: 1,
      roll: 2,
      rollId: 3
    });
  }
};
f(V2, "DamageRollConfig");
let N0 = V2;
function Tx(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[8]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Tx, "create_default_slot_1$H");
function Cx(i) {
  let e, t, s, n, l, r, o;
  return {
    c() {
      e = E("div"), t = E("input"), n = R(), l = E("button"), l.innerHTML = '<i class="fa-solid fa-arrow-up-right-dots svelte-107w4nj" data-tooltip="A5E.ConfigureDamageScaling" data-tooltip-direction="UP"></i>', b(t, "type", "text"), t.value = s = /*roll*/
      i[2].formula ?? "", b(l, "class", "scaling-button svelte-107w4nj"), b(e, "class", "u-flex u-gap-sm u-w-full");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(e, n), A(e, l), r || (o = [
        V(
          t,
          "change",
          /*change_handler_1*/
          i[11]
        ),
        V(l, "click", tt(
          /*onClickScalingButton*/
          i[5]
        ))
      ], r = !0);
    },
    p(a, c) {
      c & /*roll*/
      4 && s !== (s = /*roll*/
      a[2].formula ?? "") && t.value !== s && (t.value = s);
    },
    d(a) {
      a && S(e), r = !1, Ne(o);
    }
  };
}
f(Cx, "create_default_slot$1k");
function Ox(i) {
  let e, t, s, n, l, r, o, a;
  return e = new de({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[9]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[10]
          )
        }
      ],
      $$slots: { default: [Tx] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      heading: "A5E.RollFormula",
      $$slots: { default: [Cx] },
      $$scope: { ctx: i }
    }
  }), o = new De({
    props: {
      label: "A5E.GenericDefaultSelection",
      checked: (
        /*roll*/
        i[2].default ?? !0
      )
    }
  }), o.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[12]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), l = E("div"), L(n.$$.fragment), r = R(), L(o.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-header-button-color", "#bebdb5"), z(t, "--a5e-header-button-color-hover", "#555"), z(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem"), z(l, "display", "contents"), z(l, "--a5e-field-wrapper-grow", "1");
    },
    m(c, u) {
      T(c, t, u), N(e, t, null), T(c, s, u), T(c, l, u), N(n, l, null), T(c, r, u), N(o, c, u), a = !0;
    },
    p(c, [u]) {
      const d = {};
      u & /*duplicateRoll, roll, deleteRoll, rollId*/
      15 && (d.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            c[9]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            c[10]
          )
        }
      ]), u & /*$$scope, roll, $item, rollId*/
      8220 && (d.$$scope = { dirty: u, ctx: c }), e.$set(d);
      const p = {};
      u & /*$$scope, roll, $item, rollId*/
      8220 && (p.$$scope = { dirty: u, ctx: c }), n.$set(p);
      const m = {};
      u & /*roll*/
      4 && (m.checked = /*roll*/
      c[2].default ?? !0), o.$set(m);
    },
    i(c) {
      a || (w(e.$$.fragment, c), w(n.$$.fragment, c), w(o.$$.fragment, c), a = !0);
    },
    o(c) {
      C(e.$$.fragment, c), C(n.$$.fragment, c), C(o.$$.fragment, c), a = !1;
    },
    d(c) {
      c && (S(s), S(r)), c && e && S(t), j(e, c), c && n && S(l), j(n, c), j(o, c);
    }
  };
}
f(Ox, "create_fragment$2Y");
function Dx(i, e, t) {
  let s;
  function n() {
    let _ = s.dialogs.rollScaling[u];
    _ || (fl(l, s.dialogs.rollScaling[u] = new gn(s, `${s.name} Roll Scaling Configuration`, Nc, { actionId: r, rollId: u }, { width: 432 }), s), _ = s.dialogs.rollScaling[u]), _.render(!0);
  }
  f(n, "onClickScalingButton");
  const l = fe("item");
  pe(i, l, (_) => t(4, s = _));
  const r = fe("actionId");
  let { deleteRoll: o } = e, { duplicateRoll: a } = e, { roll: c } = e, { rollId: u } = e;
  const d = /* @__PURE__ */ f(({ target: _ }) => se(s, `system.actions.${r}.rolls.${u}.label`, _.value), "change_handler"), p = /* @__PURE__ */ f(() => a(r, c), "func"), m = /* @__PURE__ */ f(() => o(r, u), "func_1"), g = /* @__PURE__ */ f(({ target: _ }) => se(s, `system.actions.${r}.rolls.${u}.formula`, _.value), "change_handler_1"), h = /* @__PURE__ */ f(({ detail: _ }) => {
    se(s, `system.actions.${r}.rolls.${u}.default`, _);
  }, "updateSelection_handler");
  return i.$$set = (_) => {
    "deleteRoll" in _ && t(0, o = _.deleteRoll), "duplicateRoll" in _ && t(1, a = _.duplicateRoll), "roll" in _ && t(2, c = _.roll), "rollId" in _ && t(3, u = _.rollId);
  }, [
    o,
    a,
    c,
    u,
    s,
    n,
    l,
    r,
    d,
    p,
    m,
    g,
    h
  ];
}
f(Dx, "instance$2P");
const W2 = class W2 extends ie {
  constructor(e) {
    super(), le(this, e, Dx, Ox, ne, {
      deleteRoll: 0,
      duplicateRoll: 1,
      roll: 2,
      rollId: 3
    });
  }
};
f(W2, "GenericRollConfig");
let j0 = W2;
function pP(i, e, t) {
  const s = i.slice();
  return s[18] = e[t][0], s[19] = e[t][1], s;
}
f(pP, "get_each_context$1a");
function Ix(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[9]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Ix, "create_default_slot_3$p");
function Px(i) {
  let e, t, s, n, l, r, o;
  return {
    c() {
      e = E("div"), t = E("input"), n = R(), l = E("button"), l.innerHTML = '<i class="fa-solid fa-arrow-up-right-dots svelte-107w4nj" data-tooltip="A5E.ConfigureDamageScaling" data-tooltip-direction="UP"></i>', b(t, "type", "text"), t.value = s = /*roll*/
      i[2].formula ?? "", b(l, "class", "scaling-button svelte-107w4nj"), b(e, "class", "u-flex u-gap-sm u-w-full");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(e, n), A(e, l), r || (o = [
        V(
          t,
          "change",
          /*change_handler_1*/
          i[12]
        ),
        V(l, "click", tt(
          /*onClickScalingButton*/
          i[5]
        ))
      ], r = !0);
    },
    p(a, c) {
      c & /*roll*/
      4 && s !== (s = /*roll*/
      a[2].formula ?? "") && t.value !== s && (t.value = s);
    },
    d(a) {
      a && S(e), r = !1, Ne(o);
    }
  };
}
f(Px, "create_default_slot_2$w");
function mP(i, e) {
  let t, s = K(
    /*name*/
    e[19]
  ) + "", n, l, r;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = x(s), l = R(), t.__value = /*key*/
      e[18], qe(t, t.__value), t.selected = r = /*roll*/
      e[2].healingType === /*key*/
      e[18], this.first = t;
    },
    m(o, a) {
      T(o, t, a), A(t, n), A(t, l);
    },
    p(o, a) {
      e = o, a & /*roll*/
      4 && r !== (r = /*roll*/
      e[2].healingType === /*key*/
      e[18]) && (t.selected = r);
    },
    d(o) {
      o && S(t);
    }
  };
}
f(mP, "create_each_block$1a");
function Mx(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n, l, r, o = oe(Object.entries(
    /*healingTypes*/
    i[8]
  ));
  const a = /* @__PURE__ */ f((c) => (
    /*key*/
    c[18]
  ), "get_key");
  for (let c = 0; c < o.length; c += 1) {
    let u = pP(i, o, c), d = a(u);
    s.set(d, t[c] = mP(d, u));
  }
  return {
    c() {
      e = E("select");
      for (let c = 0; c < t.length; c += 1)
        t[c].c();
      b(e, "id", n = /*actionId*/
      i[7] + "-" + /*rollId*/
      i[3] + "-healing-type"), b(e, "class", "u-w-fit");
    },
    m(c, u) {
      T(c, e, u);
      for (let d = 0; d < t.length; d += 1)
        t[d] && t[d].m(e, null);
      l || (r = V(
        e,
        "change",
        /*change_handler_2*/
        i[13]
      ), l = !0);
    },
    p(c, u) {
      u & /*Object, healingTypes, roll*/
      260 && (o = oe(Object.entries(
        /*healingTypes*/
        c[8]
      )), t = kt(t, u, a, 1, c, o, s, e, vs, mP, null, pP)), u & /*rollId*/
      8 && n !== (n = /*actionId*/
      c[7] + "-" + /*rollId*/
      c[3] + "-healing-type") && b(e, "id", n);
    },
    d(c) {
      c && S(e);
      for (let u = 0; u < t.length; u += 1)
        t[u].d();
      l = !1, r();
    }
  };
}
f(Mx, "create_default_slot_1$G");
function Rx(i) {
  let e, t, s, n, l;
  return e = new de({
    props: {
      heading: "A5E.HealingFormula",
      $$slots: { default: [Px] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      heading: "A5E.HealingType",
      $$slots: { default: [Mx] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-grow", "1");
    },
    m(r, o) {
      T(r, t, o), N(e, t, null), T(r, s, o), N(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*$$scope, roll, $item, rollId*/
      4194332 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, rollId, $item, roll*/
      4194332 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && S(s), r && e && S(t), j(e, r), j(n, r);
    }
  };
}
f(Rx, "create_default_slot$1j");
function Fx(i) {
  let e, t, s, n, l, r, o, a;
  return e = new de({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[11]
          )
        }
      ],
      $$slots: { default: [Ix] },
      $$scope: { ctx: i }
    }
  }), n = new Me({
    props: {
      $$slots: { default: [Rx] },
      $$scope: { ctx: i }
    }
  }), o = new De({
    props: {
      label: "A5E.HealingDefaultSelection",
      checked: (
        /*roll*/
        i[2].default ?? !0
      )
    }
  }), o.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[14]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), l = E("div"), L(n.$$.fragment), r = R(), L(o.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-header-button-color", "#bebdb5"), z(t, "--a5e-header-button-color-hover", "#555"), z(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem"), z(l, "display", "contents"), z(l, "--a5e-section-body-direction", "row"), z(l, "--a5e-section-body-wrap", "nowrap"), z(l, "--a5e-section-body-padding", "0");
    },
    m(c, u) {
      T(c, t, u), N(e, t, null), T(c, s, u), T(c, l, u), N(n, l, null), T(c, r, u), N(o, c, u), a = !0;
    },
    p(c, [u]) {
      const d = {};
      u & /*duplicateRoll, roll, deleteRoll, rollId*/
      15 && (d.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            c[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            c[11]
          )
        }
      ]), u & /*$$scope, roll, $item, rollId*/
      4194332 && (d.$$scope = { dirty: u, ctx: c }), e.$set(d);
      const p = {};
      u & /*$$scope, rollId, $item, roll*/
      4194332 && (p.$$scope = { dirty: u, ctx: c }), n.$set(p);
      const m = {};
      u & /*roll*/
      4 && (m.checked = /*roll*/
      c[2].default ?? !0), o.$set(m);
    },
    i(c) {
      a || (w(e.$$.fragment, c), w(n.$$.fragment, c), w(o.$$.fragment, c), a = !0);
    },
    o(c) {
      C(e.$$.fragment, c), C(n.$$.fragment, c), C(o.$$.fragment, c), a = !1;
    },
    d(c) {
      c && (S(s), S(r)), c && e && S(t), j(e, c), c && n && S(l), j(n, c), j(o, c);
    }
  };
}
f(Fx, "create_fragment$2X");
function Nx(i, e, t) {
  let s;
  function n(O) {
    var H, G, U, q, W, X, te;
    const P = (H = O.scaling) == null ? void 0 : H.mode, D = ((G = O.scaling) == null ? void 0 : G.formula) ?? 0, I = (c[O.healingType] ?? c.healing).toLocaleLowerCase(), B = Li(s.system.level ?? 1), F = (U = O.scaling) == null ? void 0 : U.step;
    return P === "cantrip" ? K("A5E.scaling.summaries.cantrip.healing", { formula: D, healingType: I }) : P === "spellLevel" ? !F || F === 1 ? K("A5E.scaling.summaries.spellLevel.healing", { formula: D, level: B, healingType: I }) : K("A5E.scaling.summaries.steppedSpellLevel.healing", { formula: D, step: F, level: B, healingType: I }) : P === "spellPoints" ? !((q = O.scaling) != null && q.step) || ((W = O.scaling) == null ? void 0 : W.step) === 1 ? K("A5E.scaling.summaries.spellPoint.healing", { formula: D, healingType: I }) : K("A5E.scaling.summaries.steppedSpellPoint.healing", { formula: D, step: F, healingType: I }) : ["actionUses", "itemUses"].includes(P) ? !((X = O.scaling) != null && X.step) || ((te = O.scaling) == null ? void 0 : te.step) === 1 ? K("A5E.scaling.summaries.uses.healing", { formula: D, healingType: I }) : K("A5E.scaling.summaries.steppedUses.healing", { formula: D, step: F, healingType: I }) : null;
  }
  f(n, "getScalingSummary");
  function l() {
    let O = s.dialogs.rollScaling[m];
    O || (fl(r, s.dialogs.rollScaling[m] = new gn(s, `${s.name} Healing Scaling Configuration`, Nc, { actionId: o, rollId: m }, { width: 432 }), s), O = s.dialogs.rollScaling[m]), O.render(!0);
  }
  f(l, "onClickScalingButton");
  const r = fe("item");
  pe(i, r, (O) => t(4, s = O));
  const o = fe("actionId"), { A5E: a } = CONFIG, { healingTypes: c } = a;
  let { deleteRoll: u } = e, { duplicateRoll: d } = e, { roll: p } = e, { rollId: m } = e;
  const g = /* @__PURE__ */ f(({ target: O }) => se(s, `system.actions.${o}.rolls.${m}.label`, O.value), "change_handler"), h = /* @__PURE__ */ f(() => d(o, p), "func"), _ = /* @__PURE__ */ f(() => u(o, m), "func_1"), y = /* @__PURE__ */ f(({ target: O }) => se(s, `system.actions.${o}.rolls.${m}.formula`, O.value), "change_handler_1"), k = /* @__PURE__ */ f(({ target: O }) => se(s, `system.actions.${o}.rolls.${m}.healingType`, O.value), "change_handler_2"), v = /* @__PURE__ */ f(({ detail: O }) => {
    se(s, `system.actions.${o}.rolls.${m}.default`, O);
  }, "updateSelection_handler");
  return i.$$set = (O) => {
    "deleteRoll" in O && t(0, u = O.deleteRoll), "duplicateRoll" in O && t(1, d = O.duplicateRoll), "roll" in O && t(2, p = O.roll), "rollId" in O && t(3, m = O.rollId);
  }, i.$$.update = () => {
    i.$$.dirty & /*roll*/
    4 && n(p);
  }, [
    u,
    d,
    p,
    m,
    s,
    l,
    r,
    o,
    c,
    g,
    h,
    _,
    y,
    k,
    v
  ];
}
f(Nx, "instance$2O");
const K2 = class K2 extends ie {
  constructor(e) {
    super(), le(this, e, Nx, Fx, ne, {
      deleteRoll: 0,
      duplicateRoll: 1,
      roll: 2,
      rollId: 3
    });
  }
};
f(K2, "HealingRollConfig");
let L0 = K2;
function jx(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[8]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(jx, "create_default_slot_1$F");
function Lx(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("input"), b(e, "id", t = /*actionId*/
      i[7] + "-" + /*rollId*/
      i[3] + "-bonus"), b(e, "type", "text"), e.value = s = /*roll*/
      i[2].bonus ?? "";
    },
    m(r, o) {
      T(r, e, o), n || (l = V(
        e,
        "change",
        /*change_handler_1*/
        i[12]
      ), n = !0);
    },
    p(r, o) {
      o & /*rollId*/
      8 && t !== (t = /*actionId*/
      r[7] + "-" + /*rollId*/
      r[3] + "-bonus") && b(e, "id", t), o & /*roll*/
      4 && s !== (s = /*roll*/
      r[2].bonus ?? "") && e.value !== s && (e.value = s);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(Lx, "create_default_slot$1i");
function Bx(i) {
  let e, t, s, n, l, r, o, a, c;
  return e = new de({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[9]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[10]
          )
        }
      ],
      $$slots: { default: [jx] },
      $$scope: { ctx: i }
    }
  }), n = new Ye({
    props: {
      heading: "A5E.ItemSavingThrowType",
      optionStyles: "min-width: 2rem; text-align: center;",
      options: ci(),
      selected: (
        /*selectedAbility*/
        i[4]
      ),
      allowDeselect: !1
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[11]
  ), r = new de({
    props: {
      heading: "A5E.SaveBonus",
      $$slots: { default: [Lx] },
      $$scope: { ctx: i }
    }
  }), a = new De({
    props: {
      label: "A5E.SavingThrowDefaultSelection",
      checked: (
        /*roll*/
        i[2].default ?? !0
      )
    }
  }), a.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[13]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), l = R(), L(r.$$.fragment), o = R(), L(a.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-header-button-color", "#bebdb5"), z(t, "--a5e-header-button-color-hover", "#555"), z(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem");
    },
    m(u, d) {
      T(u, t, d), N(e, t, null), T(u, s, d), N(n, u, d), T(u, l, d), N(r, u, d), T(u, o, d), N(a, u, d), c = !0;
    },
    p(u, [d]) {
      const p = {};
      d & /*duplicateRoll, roll, deleteRoll, rollId*/
      15 && (p.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            u[9]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            u[10]
          )
        }
      ]), d & /*$$scope, roll, $item, rollId*/
      32812 && (p.$$scope = { dirty: d, ctx: u }), e.$set(p);
      const m = {};
      d & /*selectedAbility*/
      16 && (m.selected = /*selectedAbility*/
      u[4]), n.$set(m);
      const g = {};
      d & /*$$scope, rollId, roll, $item*/
      32812 && (g.$$scope = { dirty: d, ctx: u }), r.$set(g);
      const h = {};
      d & /*roll*/
      4 && (h.checked = /*roll*/
      u[2].default ?? !0), a.$set(h);
    },
    i(u) {
      c || (w(e.$$.fragment, u), w(n.$$.fragment, u), w(r.$$.fragment, u), w(a.$$.fragment, u), c = !0);
    },
    o(u) {
      C(e.$$.fragment, u), C(n.$$.fragment, u), C(r.$$.fragment, u), C(a.$$.fragment, u), c = !1;
    },
    d(u) {
      u && (S(s), S(l), S(o)), u && e && S(t), j(e, u), j(n, u), j(r, u), j(a, u);
    }
  };
}
f(Bx, "create_fragment$2W");
function qx(i, e, t) {
  let s, n, { deleteRoll: l } = e, { duplicateRoll: r } = e, { roll: o } = e, { rollId: a } = e;
  const c = fe("item");
  pe(i, c, (k) => t(5, n = k));
  const u = fe("actionId");
  function d() {
    se(n, `system.actions.${u}.rolls.${a}.ability`, s);
  }
  f(d, "updateAbility");
  const p = /* @__PURE__ */ f(({ target: k }) => se(n, `system.actions.${u}.rolls.${a}.label`, k.value), "change_handler"), m = /* @__PURE__ */ f(() => r(u, o), "func"), g = /* @__PURE__ */ f(() => l(u, a), "func_1"), h = /* @__PURE__ */ f(({ detail: k }) => t(4, s = k), "updateSelection_handler"), _ = /* @__PURE__ */ f(({ target: k }) => se(n, `system.actions.${u}.rolls.${a}.bonus`, k.value), "change_handler_1"), y = /* @__PURE__ */ f(({ detail: k }) => {
    se(n, `system.actions.${u}.rolls.${a}.default`, k);
  }, "updateSelection_handler_1");
  return i.$$set = (k) => {
    "deleteRoll" in k && t(0, l = k.deleteRoll), "duplicateRoll" in k && t(1, r = k.duplicateRoll), "roll" in k && t(2, o = k.roll), "rollId" in k && t(3, a = k.rollId);
  }, i.$$.update = () => {
    i.$$.dirty & /*roll*/
    4 && t(4, s = o.ability ?? "none"), i.$$.dirty & /*selectedAbility*/
    16 && d();
  }, [
    l,
    r,
    o,
    a,
    s,
    n,
    c,
    u,
    p,
    m,
    g,
    h,
    _,
    y
  ];
}
f(qx, "instance$2N");
const Y2 = class Y2 extends ie {
  constructor(e) {
    super(), le(this, e, qx, Bx, ne, {
      deleteRoll: 0,
      duplicateRoll: 1,
      roll: 2,
      rollId: 3
    });
  }
};
f(Y2, "SavingThrowRollConfig");
let B0 = Y2;
function hP(i, e, t) {
  const s = i.slice();
  return s[17] = e[t][0], s[18] = e[t][1], s;
}
f(hP, "get_each_context$19");
function Gx(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      ((l = i[2]) == null ? void 0 : l.label) ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[9]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r & /*roll*/
      4 && t !== (t = /*roll*/
      ((o = l[2]) == null ? void 0 : o.label) ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Gx, "create_default_slot_2$v");
function gP(i) {
  let e, t = K(
    /*label*/
    i[18]
  ) + "", s, n, l;
  return {
    c() {
      var r;
      e = E("option"), s = x(t), n = R(), e.__value = /*skill*/
      i[17], qe(e, e.__value), e.selected = l = /*roll*/
      ((r = i[2]) == null ? void 0 : r.skill) === /*skill*/
      i[17];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      var a;
      o & /*roll*/
      4 && l !== (l = /*roll*/
      ((a = r[2]) == null ? void 0 : a.skill) === /*skill*/
      r[17]) && (e.selected = l);
    },
    d(r) {
      r && S(e);
    }
  };
}
f(gP, "create_each_block$19");
function zx(i) {
  let e, t, s, n = oe(Object.entries(
    /*skills*/
    i[8]
  )), l = [];
  for (let r = 0; r < n.length; r += 1)
    l[r] = gP(hP(i, n, r));
  return {
    c() {
      e = E("select");
      for (let r = 0; r < l.length; r += 1)
        l[r].c();
      b(e, "class", "u-w-fit");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < l.length; a += 1)
        l[a] && l[a].m(e, null);
      t || (s = V(
        e,
        "change",
        /*change_handler_1*/
        i[12]
      ), t = !0);
    },
    p(r, o) {
      if (o & /*Object, skills, roll*/
      260) {
        n = oe(Object.entries(
          /*skills*/
          r[8]
        ));
        let a;
        for (a = 0; a < n.length; a += 1) {
          const c = hP(r, n, a);
          l[a] ? l[a].p(c, o) : (l[a] = gP(c), l[a].c(), l[a].m(e, null));
        }
        for (; a < l.length; a += 1)
          l[a].d(1);
        l.length = n.length;
      }
    },
    d(r) {
      r && S(e), Le(l, r), t = !1, s();
    }
  };
}
f(zx, "create_default_slot_1$E");
function Hx(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].bonus ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_2*/
        i[14]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].bonus ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Hx, "create_default_slot$1h");
function Ux(i) {
  let e, t, s, n, l, r, o, a, c, u, d;
  return e = new de({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[11]
          )
        }
      ],
      $$slots: { default: [Gx] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      heading: "A5E.Skill",
      $$slots: { default: [zx] },
      $$scope: { ctx: i }
    }
  }), r = new Ye({
    props: {
      allowDeselect: !1,
      heading: "A5E.DefaultAbilityScore",
      optionStyles: "min-width: 2rem; text-align: center;",
      options: ci(!1, !0),
      selected: (
        /*selectedAbility*/
        i[4]
      )
    }
  }), r.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[13]
  ), a = new de({
    props: {
      heading: "A5E.CheckBonus",
      $$slots: { default: [Hx] },
      $$scope: { ctx: i }
    }
  }), u = new De({
    props: {
      label: "A5E.SkillCheckDefaultSelection",
      checked: (
        /*roll*/
        i[2].default ?? !0
      )
    }
  }), u.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[15]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), l = R(), L(r.$$.fragment), o = R(), L(a.$$.fragment), c = R(), L(u.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-header-button-color", "#bebdb5"), z(t, "--a5e-header-button-color-hover", "#555"), z(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem");
    },
    m(p, m) {
      T(p, t, m), N(e, t, null), T(p, s, m), N(n, p, m), T(p, l, m), N(r, p, m), T(p, o, m), N(a, p, m), T(p, c, m), N(u, p, m), d = !0;
    },
    p(p, [m]) {
      const g = {};
      m & /*duplicateRoll, roll, deleteRoll, rollId*/
      15 && (g.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            p[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            p[11]
          )
        }
      ]), m & /*$$scope, roll, $item, rollId*/
      2097196 && (g.$$scope = { dirty: m, ctx: p }), e.$set(g);
      const h = {};
      m & /*$$scope, $item, rollId, roll*/
      2097196 && (h.$$scope = { dirty: m, ctx: p }), n.$set(h);
      const _ = {};
      m & /*selectedAbility*/
      16 && (_.selected = /*selectedAbility*/
      p[4]), r.$set(_);
      const y = {};
      m & /*$$scope, roll, $item, rollId*/
      2097196 && (y.$$scope = { dirty: m, ctx: p }), a.$set(y);
      const k = {};
      m & /*roll*/
      4 && (k.checked = /*roll*/
      p[2].default ?? !0), u.$set(k);
    },
    i(p) {
      d || (w(e.$$.fragment, p), w(n.$$.fragment, p), w(r.$$.fragment, p), w(a.$$.fragment, p), w(u.$$.fragment, p), d = !0);
    },
    o(p) {
      C(e.$$.fragment, p), C(n.$$.fragment, p), C(r.$$.fragment, p), C(a.$$.fragment, p), C(u.$$.fragment, p), d = !1;
    },
    d(p) {
      p && (S(s), S(l), S(o), S(c)), p && e && S(t), j(e, p), j(n, p), j(r, p), j(a, p), j(u, p);
    }
  };
}
f(Ux, "create_fragment$2V");
function Vx(i, e, t) {
  let s, n, { deleteRoll: l } = e, { duplicateRoll: r } = e, { roll: o } = e, { rollId: a } = e;
  const c = fe("item");
  pe(i, c, (O) => t(5, n = O));
  const u = fe("actionId"), d = { ...CONFIG.A5E.skills };
  game.settings.get("a5e", "hideA5eSkills") && (delete d.cul, delete d.eng);
  function p() {
    se(n, `system.actions.${u}.rolls.${a}.ability`, s);
  }
  f(p, "updateAbility");
  const m = /* @__PURE__ */ f(({ target: O }) => se(n, `system.actions.${u}.rolls.${a}.label`, O.value), "change_handler"), g = /* @__PURE__ */ f(() => r(u, o), "func"), h = /* @__PURE__ */ f(() => l(u, a), "func_1"), _ = /* @__PURE__ */ f(({ target: O }) => se(n, `system.actions.${u}.rolls.${a}.skill`, O.value), "change_handler_1"), y = /* @__PURE__ */ f(({ detail: O }) => t(4, s = O), "updateSelection_handler"), k = /* @__PURE__ */ f(({ target: O }) => se(n, `system.actions.${u}.rolls.${a}.bonus`, O.value), "change_handler_2"), v = /* @__PURE__ */ f(({ detail: O }) => {
    se(n, `system.actions.${u}.rolls.${a}.default`, O);
  }, "updateSelection_handler_1");
  return i.$$set = (O) => {
    "deleteRoll" in O && t(0, l = O.deleteRoll), "duplicateRoll" in O && t(1, r = O.duplicateRoll), "roll" in O && t(2, o = O.roll), "rollId" in O && t(3, a = O.rollId);
  }, i.$$.update = () => {
    i.$$.dirty & /*roll*/
    4 && t(4, s = (o == null ? void 0 : o.ability) ?? "none"), i.$$.dirty & /*selectedAbility*/
    16 && p();
  }, [
    l,
    r,
    o,
    a,
    s,
    n,
    c,
    u,
    d,
    m,
    g,
    h,
    _,
    y,
    k,
    v
  ];
}
f(Vx, "instance$2M");
const X2 = class X2 extends ie {
  constructor(e) {
    super(), le(this, e, Vx, Ux, ne, {
      deleteRoll: 0,
      duplicateRoll: 1,
      roll: 2,
      rollId: 3
    });
  }
};
f(X2, "SkillCheckRollConfig");
let q0 = X2;
function bP(i, e, t) {
  const s = i.slice();
  return s[17] = e[t][0], s[18] = e[t][1], s;
}
f(bP, "get_each_context$18");
function Wx(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[9]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Wx, "create_default_slot_2$u");
function _P(i) {
  let e, t = K(
    /*label*/
    i[18]
  ) + "", s, n, l;
  return {
    c() {
      var r;
      e = E("option"), s = x(t), n = R(), e.__value = /*tool*/
      i[17], qe(e, e.__value), e.selected = l = /*roll*/
      ((r = i[2]) == null ? void 0 : r.tool) === /*tool*/
      i[17];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      var a;
      o & /*roll*/
      4 && l !== (l = /*roll*/
      ((a = r[2]) == null ? void 0 : a.tool) === /*tool*/
      r[17]) && (e.selected = l);
    },
    d(r) {
      r && S(e);
    }
  };
}
f(_P, "create_each_block$18");
function Kx(i) {
  let e, t, s, n = oe(
    /*tools*/
    i[8]
  ), l = [];
  for (let r = 0; r < n.length; r += 1)
    l[r] = _P(bP(i, n, r));
  return {
    c() {
      e = E("select");
      for (let r = 0; r < l.length; r += 1)
        l[r].c();
      b(e, "class", "u-w-fit");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < l.length; a += 1)
        l[a] && l[a].m(e, null);
      t || (s = V(
        e,
        "change",
        /*change_handler_1*/
        i[12]
      ), t = !0);
    },
    p(r, o) {
      if (o & /*tools, roll*/
      260) {
        n = oe(
          /*tools*/
          r[8]
        );
        let a;
        for (a = 0; a < n.length; a += 1) {
          const c = bP(r, n, a);
          l[a] ? l[a].p(c, o) : (l[a] = _P(c), l[a].c(), l[a].m(e, null));
        }
        for (; a < l.length; a += 1)
          l[a].d(1);
        l.length = n.length;
      }
    },
    d(r) {
      r && S(e), Le(l, r), t = !1, s();
    }
  };
}
f(Kx, "create_default_slot_1$D");
function Yx(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*roll*/
      i[2].bonus ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_2*/
        i[14]
      ), s = !0);
    },
    p(l, r) {
      r & /*roll*/
      4 && t !== (t = /*roll*/
      l[2].bonus ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Yx, "create_default_slot$1g");
function Xx(i) {
  let e, t, s, n, l, r, o, a, c, u, d;
  return e = new de({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            i[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            i[11]
          )
        }
      ],
      $$slots: { default: [Wx] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      heading: "A5E.Tool",
      $$slots: { default: [Kx] },
      $$scope: { ctx: i }
    }
  }), r = new Ye({
    props: {
      heading: "A5E.DefaultAbilityScore",
      optionStyles: "min-width: 2rem; text-align: center;",
      options: ci(!1, !0),
      selected: (
        /*selectedAbility*/
        i[4]
      ),
      allowDeselect: !1
    }
  }), r.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[13]
  ), a = new de({
    props: {
      heading: "A5E.CheckBonus",
      $$slots: { default: [Yx] },
      $$scope: { ctx: i }
    }
  }), u = new De({
    props: {
      label: "A5E.ToolCheckDefaultSelection",
      checked: (
        /*roll*/
        i[2].default ?? !0
      )
    }
  }), u.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[15]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), l = R(), L(r.$$.fragment), o = R(), L(a.$$.fragment), c = R(), L(u.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-header-button-color", "#bebdb5"), z(t, "--a5e-header-button-color-hover", "#555"), z(t, "--a5e-field-wrapper-button-wrapper-gap", "0.75rem");
    },
    m(p, m) {
      T(p, t, m), N(e, t, null), T(p, s, m), N(n, p, m), T(p, l, m), N(r, p, m), T(p, o, m), N(a, p, m), T(p, c, m), N(u, p, m), d = !0;
    },
    p(p, [m]) {
      const g = {};
      m & /*duplicateRoll, roll, deleteRoll, rollId*/
      15 && (g.buttons = [
        {
          classes: "fa-solid fa-clone a5e-field-wrapper__header-button--scale",
          handler: (
            /*func*/
            p[10]
          )
        },
        {
          classes: "fas fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*func_1*/
            p[11]
          )
        }
      ]), m & /*$$scope, roll, $item, rollId*/
      2097196 && (g.$$scope = { dirty: m, ctx: p }), e.$set(g);
      const h = {};
      m & /*$$scope, $item, rollId, roll*/
      2097196 && (h.$$scope = { dirty: m, ctx: p }), n.$set(h);
      const _ = {};
      m & /*selectedAbility*/
      16 && (_.selected = /*selectedAbility*/
      p[4]), r.$set(_);
      const y = {};
      m & /*$$scope, roll, $item, rollId*/
      2097196 && (y.$$scope = { dirty: m, ctx: p }), a.$set(y);
      const k = {};
      m & /*roll*/
      4 && (k.checked = /*roll*/
      p[2].default ?? !0), u.$set(k);
    },
    i(p) {
      d || (w(e.$$.fragment, p), w(n.$$.fragment, p), w(r.$$.fragment, p), w(a.$$.fragment, p), w(u.$$.fragment, p), d = !0);
    },
    o(p) {
      C(e.$$.fragment, p), C(n.$$.fragment, p), C(r.$$.fragment, p), C(a.$$.fragment, p), C(u.$$.fragment, p), d = !1;
    },
    d(p) {
      p && (S(s), S(l), S(o), S(c)), p && e && S(t), j(e, p), j(n, p), j(r, p), j(a, p), j(u, p);
    }
  };
}
f(Xx, "create_fragment$2U");
function Jx(i, e, t) {
  let s, n;
  function l() {
    se(n, `system.actions.${d}.rolls.${c}.ability`, s);
  }
  f(l, "updateAbility");
  let { deleteRoll: r } = e, { duplicateRoll: o } = e, { roll: a } = e, { rollId: c } = e;
  const u = fe("item");
  pe(i, u, (O) => t(5, n = O));
  const d = fe("actionId"), p = Object.entries(CONFIG.A5E.tools).map(([O, P]) => Object.entries(P)).flat().sort((O, P) => O[0].toLowerCase().localeCompare(P[0].toLowerCase())), m = /* @__PURE__ */ f(({ target: O }) => se(n, `system.actions.${d}.rolls.${c}.label`, O.value), "change_handler"), g = /* @__PURE__ */ f(() => o(d, a), "func"), h = /* @__PURE__ */ f(() => r(d, c), "func_1"), _ = /* @__PURE__ */ f(({ target: O }) => se(n, `system.actions.${d}.rolls.${c}.tool`, O.value), "change_handler_1"), y = /* @__PURE__ */ f(({ detail: O }) => t(4, s = O), "updateSelection_handler"), k = /* @__PURE__ */ f(({ target: O }) => se(n, `system.actions.${d}.rolls.${c}.bonus`, O.value), "change_handler_2"), v = /* @__PURE__ */ f(({ detail: O }) => {
    se(n, `system.actions.${d}.rolls.${c}.default`, O);
  }, "updateSelection_handler_1");
  return i.$$set = (O) => {
    "deleteRoll" in O && t(0, r = O.deleteRoll), "duplicateRoll" in O && t(1, o = O.duplicateRoll), "roll" in O && t(2, a = O.roll), "rollId" in O && t(3, c = O.rollId);
  }, i.$$.update = () => {
    i.$$.dirty & /*roll*/
    4 && t(4, s = a.ability ?? "none"), i.$$.dirty & /*selectedAbility*/
    16 && l();
  }, [
    r,
    o,
    a,
    c,
    s,
    n,
    u,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    k,
    v
  ];
}
f(Jx, "instance$2L");
const J2 = class J2 extends ie {
  constructor(e) {
    super(), le(this, e, Jx, Xx, ne, {
      deleteRoll: 0,
      duplicateRoll: 1,
      roll: 2,
      rollId: 3
    });
  }
};
f(J2, "ToolCheckRollConfig");
let G0 = J2;
function yP(i, e, t) {
  const s = i.slice();
  return s[14] = e[t][0], s[15] = e[t][1].heading, s[16] = e[t][1].singleLabel, s[17] = e[t][1].buttonLabel, s[18] = e[t][1].component, s;
}
f(yP, "get_each_context$17");
function vP(i, e, t) {
  const s = i.slice();
  return s[21] = e[t][0], s[22] = e[t][1], s;
}
f(vP, "get_each_context_1$h");
function kP(i) {
  let e, t, s, n, l;
  function r() {
    return (
      /*func_2*/
      i[12](
        /*rollType*/
        i[14]
      )
    );
  }
  return f(r, "func_2"), t = new Me({
    props: {
      heading: (
        /*heading*/
        i[15]
      ),
      headerButtons: [
        {
          classes: "add-button",
          handler: r,
          label: K("A5E.ButtonAddRoll", {
            type: K(
              /*rollType*/
              i[14] === "damage" ? (
                /*buttonLabel*/
                i[17]
              ) : (
                /*singleLabel*/
                i[16]
              )
            )
          })
        }
      ],
      $$slots: { default: [Zx] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("li"), s = E("div"), L(t.$$.fragment), n = R(), z(s, "display", "contents"), z(s, "--a5e-section-gap", "0"), b(e, "class", "roll-config-list__item svelte-1eyedz");
    },
    m(o, a) {
      T(o, e, a), A(e, s), N(t, s, null), A(e, n), l = !0;
    },
    p(o, a) {
      i = o;
      const c = {};
      a & /*$item, action*/
      3 && (c.headerButtons = [
        {
          classes: "add-button",
          handler: r,
          label: K("A5E.ButtonAddRoll", {
            type: K(
              /*rollType*/
              i[14] === "damage" ? (
                /*buttonLabel*/
                i[17]
              ) : (
                /*singleLabel*/
                i[16]
              )
            )
          })
        }
      ]), a & /*$$scope, rolls*/
      33554440 && (c.$$scope = { dirty: a, ctx: i }), t.$set(c);
    },
    i(o) {
      l || (w(t.$$.fragment, o), l = !0);
    },
    o(o) {
      C(t.$$.fragment, o), l = !1;
    },
    d(o) {
      o && S(e), j(t);
    }
  };
}
f(kP, "create_if_block$1G");
function wP(i, e) {
  let t, s, n, l;
  var r = (
    /*component*/
    e[18]
  );
  function o(a, c) {
    return {
      props: {
        deleteRoll: (
          /*deleteRoll*/
          a[4]
        ),
        duplicateRoll: (
          /*duplicateRoll*/
          a[5]
        ),
        roll: (
          /*roll*/
          a[22]
        ),
        rollId: (
          /*rollId*/
          a[21]
        )
      }
    };
  }
  return f(o, "switch_props"), r && (s = nt(r, o(e))), {
    key: i,
    first: null,
    c() {
      t = E("li"), s && L(s.$$.fragment), n = R(), b(t, "class", "a5e-item a5e-item--action-config"), this.first = t;
    },
    m(a, c) {
      T(a, t, c), s && N(s, t, null), A(t, n), l = !0;
    },
    p(a, c) {
      if (e = a, r !== (r = /*component*/
      e[18])) {
        if (s) {
          ce();
          const u = s;
          C(u.$$.fragment, 1, 0, () => {
            j(u, 1);
          }), ue();
        }
        r ? (s = nt(r, o(e)), L(s.$$.fragment), w(s.$$.fragment, 1), N(s, t, n)) : s = null;
      } else if (r) {
        const u = {};
        c & /*rolls*/
        8 && (u.roll = /*roll*/
        e[22]), c & /*rolls*/
        8 && (u.rollId = /*rollId*/
        e[21]), s.$set(u);
      }
    },
    i(a) {
      l || (s && w(s.$$.fragment, a), l = !0);
    },
    o(a) {
      s && C(s.$$.fragment, a), l = !1;
    },
    d(a) {
      a && S(t), s && j(s);
    }
  };
}
f(wP, "create_each_block_1$h");
function Zx(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n;
  function l(...a) {
    return (
      /*func_1*/
      i[11](
        /*rollType*/
        i[14],
        ...a
      )
    );
  }
  f(l, "func_1");
  let r = oe(Object.entries(
    /*rolls*/
    i[3]
  ).filter(l));
  const o = /* @__PURE__ */ f((a) => (
    /*rollId*/
    a[21]
  ), "get_key");
  for (let a = 0; a < r.length; a += 1) {
    let c = vP(i, r, a), u = o(c);
    s.set(u, t[a] = wP(u, c));
  }
  return {
    c() {
      e = E("ul");
      for (let a = 0; a < t.length; a += 1)
        t[a].c();
      b(e, "class", "a5e-item-list");
    },
    m(a, c) {
      T(a, e, c);
      for (let u = 0; u < t.length; u += 1)
        t[u] && t[u].m(e, null);
      n = !0;
    },
    p(a, c) {
      i = a, c & /*Object, rollTypes, deleteRoll, duplicateRoll, rolls*/
      312 && (r = oe(Object.entries(
        /*rolls*/
        i[3]
      ).filter(l)), ce(), t = kt(t, c, o, 1, i, r, s, e, ks, wP, null, vP), ue());
    },
    i(a) {
      if (!n) {
        for (let c = 0; c < r.length; c += 1)
          w(t[c]);
        n = !0;
      }
    },
    o(a) {
      for (let c = 0; c < t.length; c += 1)
        C(t[c]);
      n = !1;
    },
    d(a) {
      a && S(e);
      for (let c = 0; c < t.length; c += 1)
        t[c].d();
    }
  };
}
f(Zx, "create_default_slot$1f");
function $P(i, e) {
  let t, s = Object.values(
    /*rolls*/
    e[3]
  ).filter(r).length, n, l;
  function r(...a) {
    return (
      /*func*/
      e[10](
        /*rollType*/
        e[14],
        ...a
      )
    );
  }
  f(r, "func");
  let o = s && kP(e);
  return {
    key: i,
    first: null,
    c() {
      t = $e(), o && o.c(), n = $e(), this.first = t;
    },
    m(a, c) {
      T(a, t, c), o && o.m(a, c), T(a, n, c), l = !0;
    },
    p(a, c) {
      e = a, c & /*rolls*/
      8 && (s = Object.values(
        /*rolls*/
        e[3]
      ).filter(r).length), s ? o ? (o.p(e, c), c & /*rolls*/
      8 && w(o, 1)) : (o = kP(e), o.c(), w(o, 1), o.m(n.parentNode, n)) : o && (ce(), C(o, 1, 1, () => {
        o = null;
      }), ue());
    },
    i(a) {
      l || (w(o), l = !0);
    },
    o(a) {
      C(o), l = !1;
    },
    d(a) {
      a && (S(t), S(n)), o && o.d(a);
    }
  };
}
f($P, "create_each_block$17");
function Qx(i) {
  let e, t, s = [], n = /* @__PURE__ */ new Map(), l, r, o, a, c = oe(Object.entries(
    /*rollTypes*/
    i[8]
  ));
  const u = /* @__PURE__ */ f((d) => (
    /*rollType*/
    d[14]
  ), "get_key");
  for (let d = 0; d < c.length; d += 1) {
    let p = yP(i, c, d), m = u(p);
    n.set(m, s[d] = $P(m, p));
  }
  return o = new Ys({
    props: {
      menuList: (
        /*menuList*/
        i[2]
      ),
      offset: { x: -110, y: -140 },
      documentName: "Roll"
    }
  }), o.$on(
    "press",
    /*press_handler*/
    i[13]
  ), {
    c() {
      e = E("div"), t = E("ul");
      for (let d = 0; d < s.length; d += 1)
        s[d].c();
      l = R(), r = E("div"), L(o.$$.fragment), b(t, "class", "roll-config-list svelte-1eyedz"), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable"), b(r, "class", "sticky-add-button svelte-1eyedz");
    },
    m(d, p) {
      T(d, e, p), A(e, t);
      for (let m = 0; m < s.length; m += 1)
        s[m] && s[m].m(t, null);
      T(d, l, p), T(d, r, p), N(o, r, null), a = !0;
    },
    p(d, [p]) {
      p & /*Object, rollTypes, $item, actionId, action, rolls, deleteRoll, duplicateRoll*/
      443 && (c = oe(Object.entries(
        /*rollTypes*/
        d[8]
      )), ce(), s = kt(s, p, u, 1, d, c, n, t, ks, $P, null, yP), ue());
      const m = {};
      p & /*menuList*/
      4 && (m.menuList = /*menuList*/
      d[2]), o.$set(m);
    },
    i(d) {
      if (!a) {
        for (let p = 0; p < c.length; p += 1)
          w(s[p]);
        w(o.$$.fragment, d), a = !0;
      }
    },
    o(d) {
      for (let p = 0; p < s.length; p += 1)
        C(s[p]);
      C(o.$$.fragment, d), a = !1;
    },
    d(d) {
      d && (S(e), S(l), S(r));
      for (let p = 0; p < s.length; p += 1)
        s[p].d();
      j(o);
    }
  };
}
f(Qx, "create_fragment$2T");
function xx(i, e, t) {
  let s, n, l, r, o;
  async function a(y, k) {
    const v = o.dialogs.rollScaling[k];
    await (v == null ? void 0 : v.close()), delete o.dialogs.rollScaling[k], o.update({
      [`system.actions.${y}.rolls`]: { [`-=${k}`]: null }
    });
  }
  f(a, "deleteRoll");
  function c(y, k) {
    const v = foundry.utils.duplicate(k);
    o.update({
      [`system.actions.${y}.rolls`]: { [foundry.utils.randomID()]: v }
    });
  }
  f(c, "duplicateRoll");
  const u = fe("item");
  pe(i, u, (y) => t(1, o = y));
  const d = fe("actionId"), p = {
    attack: {
      heading: "A5E.ItemAttackRoll",
      singleLabel: "A5E.ItemAttackRoll",
      component: F0
    },
    damage: {
      heading: "A5E.ItemDamageRollPlural",
      buttonLabel: "A5E.Damage",
      singleLabel: "A5E.ItemDamageRoll",
      component: N0
    },
    healing: {
      heading: "A5E.ItemHealingRollPlural",
      singleLabel: "A5E.Healing",
      component: L0
    },
    abilityCheck: {
      heading: "A5E.AbilityCheckPlural",
      singleLabel: "A5E.AbilityCheck",
      component: R0
    },
    skillCheck: {
      heading: "A5E.SkillCheckPlural",
      singleLabel: "A5E.SkillCheckSingular",
      component: q0
    },
    toolCheck: {
      heading: "A5E.ToolCheckPlural",
      singleLabel: "A5E.ToolCheck",
      component: G0
    },
    savingThrow: {
      heading: "A5E.SavingThrowPlural",
      singleLabel: "A5E.SavingThrow",
      component: B0
    },
    generic: {
      heading: "A5E.OtherPlural",
      singleLabel: "A5E.Other",
      component: j0
    }
  }, m = /* @__PURE__ */ f((y, k) => k.type === y, "func"), g = /* @__PURE__ */ f((y, [k, v]) => v.type === y, "func_1"), h = /* @__PURE__ */ f((y) => ri.addRoll(o, [d, s], y), "func_2"), _ = /* @__PURE__ */ f(({ detail: y }) => ri.addRoll(o, [d, s], y), "press_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    2 && t(0, s = o.actions[d]), i.$$.dirty & /*action*/
    1 && t(3, n = s.rolls ?? {}), i.$$.dirty & /*action*/
    1 && t(9, l = Object.entries(s.rolls ?? {}).filter(([y, k]) => k.type === "attack")), i.$$.dirty & /*attackRolls*/
    512 && t(2, r = Object.entries(p).reduce(
      (y, [k, { singleLabel: v }]) => (k === "attack" && l.length > 0 || y.push([k, v]), y),
      []
    ));
  }, [
    s,
    o,
    r,
    n,
    a,
    c,
    u,
    d,
    p,
    l,
    m,
    g,
    h,
    _
  ];
}
f(xx, "instance$2K");
const Z2 = class Z2 extends ie {
  constructor(e) {
    super(), le(this, e, xx, Qx, ne, {});
  }
};
f(Z2, "ActionsRollsTab");
let z0 = Z2;
function AP(i, e, t) {
  const s = i.slice();
  return s[13] = e[t].name, s[14] = e[t].id, s;
}
f(AP, "get_each_context$16");
function eee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*consumer*/
      i[0].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[8]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(eee, "create_default_slot_3$o");
function EP(i) {
  let e, t, s = [], n = /* @__PURE__ */ new Map(), l, r, o, a = oe(
    /*ammunitionItems*/
    i[5]
  );
  const c = /* @__PURE__ */ f((u) => (
    /*id*/
    u[14]
  ), "get_key");
  for (let u = 0; u < a.length; u += 1) {
    let d = AP(i, a, u), p = c(d);
    n.set(p, s[u] = SP(p, d));
  }
  return {
    c() {
      e = E("select"), t = E("option");
      for (let u = 0; u < s.length; u += 1)
        s[u].c();
      t.__value = "", qe(t, t.__value), b(e, "id", l = /*actionId*/
      i[7] + "-" + /*consumerId*/
      i[1] + "-item-id"), b(e, "class", "u-w-fit"), /*selectedItem*/
      i[3] === void 0 && is(() => (
        /*select_change_handler*/
        i[10].call(e)
      ));
    },
    m(u, d) {
      T(u, e, d), A(e, t);
      for (let p = 0; p < s.length; p += 1)
        s[p] && s[p].m(e, null);
      ds(
        e,
        /*selectedItem*/
        i[3],
        !0
      ), r || (o = V(
        e,
        "change",
        /*select_change_handler*/
        i[10]
      ), r = !0);
    },
    p(u, d) {
      d & /*ammunitionItems, consumer*/
      33 && (a = oe(
        /*ammunitionItems*/
        u[5]
      ), s = kt(s, d, c, 1, u, a, n, e, vs, SP, null, AP)), d & /*consumerId*/
      2 && l !== (l = /*actionId*/
      u[7] + "-" + /*consumerId*/
      u[1] + "-item-id") && b(e, "id", l), d & /*selectedItem, ammunitionItems*/
      40 && ds(
        e,
        /*selectedItem*/
        u[3]
      );
    },
    d(u) {
      u && S(e);
      for (let d = 0; d < s.length; d += 1)
        s[d].d();
      r = !1, o();
    }
  };
}
f(EP, "create_if_block_1$18");
function SP(i, e) {
  let t, s = (
    /*name*/
    e[13] + ""
  ), n, l, r, o;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = x(s), l = R(), t.__value = r = /*id*/
      e[14], qe(t, t.__value), t.selected = o = /*consumer*/
      e[0].itemId === /*id*/
      e[14], this.first = t;
    },
    m(a, c) {
      T(a, t, c), A(t, n), A(t, l);
    },
    p(a, c) {
      e = a, c & /*ammunitionItems*/
      32 && s !== (s = /*name*/
      e[13] + "") && _e(n, s), c & /*ammunitionItems*/
      32 && r !== (r = /*id*/
      e[14]) && (t.__value = r, qe(t, t.__value)), c & /*consumer, ammunitionItems*/
      33 && o !== (o = /*consumer*/
      e[0].itemId === /*id*/
      e[14]) && (t.selected = o);
    },
    d(a) {
      a && S(t);
    }
  };
}
f(SP, "create_each_block$16");
function tee(i) {
  let e, t = (
    /*$item*/
    i[4].actor && EP(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*$item*/
      s[4].actor ? t ? t.p(s, n) : (t = EP(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && S(e), t && t.d(s);
    }
  };
}
f(tee, "create_default_slot_2$t");
function TP(i) {
  let e, t, s;
  return e = new de({
    props: {
      heading: "A5E.ItemQuantity",
      $$slots: { default: [see] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-width", "7.5rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, consumer, $item, consumerId*/
      131091 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(TP, "create_if_block$1F");
function see(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), b(e, "d-type", "Number"), e.value = t = /*consumer*/
      i[0].quantity ?? 1;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[11]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].quantity ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(see, "create_default_slot_1$C");
function nee(i) {
  let e, t, s, n;
  e = new de({
    props: {
      heading: "A5E.Item",
      warning: "Item selection will be available when item is on an actor.",
      showWarning: !/*$item*/
      i[4].actor,
      $$slots: { default: [tee] },
      $$scope: { ctx: i }
    }
  });
  let l = (
    /*$item*/
    i[4].actor && TP(i)
  );
  return {
    c() {
      L(e.$$.fragment), t = R(), l && l.c(), s = $e();
    },
    m(r, o) {
      N(e, r, o), T(r, t, o), l && l.m(r, o), T(r, s, o), n = !0;
    },
    p(r, o) {
      const a = {};
      o & /*$item*/
      16 && (a.showWarning = !/*$item*/
      r[4].actor), o & /*$$scope, consumerId, selectedItem, ammunitionItems, consumer, $item*/
      131131 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a), /*$item*/
      r[4].actor ? l ? (l.p(r, o), o & /*$item*/
      16 && w(l, 1)) : (l = TP(r), l.c(), w(l, 1), l.m(s.parentNode, s)) : l && (ce(), C(l, 1, 1, () => {
        l = null;
      }), ue());
    },
    i(r) {
      n || (w(e.$$.fragment, r), w(l), n = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(l), n = !1;
    },
    d(r) {
      r && (S(t), S(s)), j(e, r), l && l.d(r);
    }
  };
}
f(nee, "create_default_slot$1e");
function iee(i) {
  let e, t, s, n, l, r;
  return e = new de({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            i[9]
          )
        }
      ],
      $$slots: { default: [eee] },
      $$scope: { ctx: i }
    }
  }), n = new Me({
    props: {
      $$slots: { default: [nee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), l = E("div"), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-header-button-color", "rgba(0, 0, 0, 0.2)"), z(t, "--a5e-header-button-color-hover", "#555"), z(l, "display", "contents"), z(l, "--a5e-section-body-direction", "row"), z(l, "--a5e-section-body-padding", "0"), z(l, "--a5e-section-body-gap", "0.5rem");
    },
    m(o, a) {
      T(o, t, a), N(e, t, null), T(o, s, a), T(o, l, a), N(n, l, null), r = !0;
    },
    p(o, [a]) {
      const c = {};
      a & /*deleteConsumer, consumerId*/
      6 && (c.buttons = [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            o[9]
          )
        }
      ]), a & /*$$scope, consumer, $item, consumerId*/
      131091 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const u = {};
      a & /*$$scope, consumer, $item, consumerId, selectedItem, ammunitionItems*/
      131131 && (u.$$scope = { dirty: a, ctx: o }), n.$set(u);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(n.$$.fragment, o), r = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(n.$$.fragment, o), r = !1;
    },
    d(o) {
      o && S(s), o && e && S(t), j(e, o), o && n && S(l), j(n, o);
    }
  };
}
f(iee, "create_fragment$2S");
function lee(i, e, t) {
  let s, n, { consumer: l } = e, { consumerId: r } = e, { deleteConsumer: o } = e;
  const a = fe("item");
  pe(i, a, (_) => t(4, n = _));
  const c = fe("actionId");
  function u() {
    se(n, `system.actions.${c}.consumers.${r}.itemId`, d);
  }
  f(u, "updateItemSelection");
  let d = l.itemId;
  const p = /* @__PURE__ */ f(() => se(n, `system.actions.${c}.consumers.${r}.label`), "change_handler"), m = /* @__PURE__ */ f(() => o(c, r), "func");
  function g() {
    d = ca(this), t(3, d), t(5, s), t(4, n);
  }
  f(g, "select_change_handler");
  const h = /* @__PURE__ */ f(({ target: _ }) => se(n, `system.actions.${c}.consumers.${r}.quantity`, Number(_.value)), "change_handler_1");
  return i.$$set = (_) => {
    "consumer" in _ && t(0, l = _.consumer), "consumerId" in _ && t(1, r = _.consumerId), "deleteConsumer" in _ && t(2, o = _.deleteConsumer);
  }, i.$$.update = () => {
    i.$$.dirty & /*selectedItem*/
    8 && u(), i.$$.dirty & /*$item*/
    16 && t(5, s = n.actor ? n.actor.items.filter((_) => _.type === "object" && _.system.objectType === "ammunition").map((_) => ({ name: _.name, id: _.id })).sort((_, y) => _.name.toLowerCase().localeCompare(y.name.toLowerCase())) : []);
  }, [
    l,
    r,
    o,
    d,
    n,
    s,
    a,
    c,
    p,
    m,
    g,
    h
  ];
}
f(lee, "instance$2J");
const Q2 = class Q2 extends ie {
  constructor(e) {
    super(), le(this, e, lee, iee, ne, {
      consumer: 0,
      consumerId: 1,
      deleteConsumer: 2
    });
  }
};
f(Q2, "AmmoConsumer");
let H0 = Q2;
function ree(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*consumer*/
      i[0].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[7]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(ree, "create_default_slot$1d");
function oee(i) {
  let e, t, s;
  return e = new de({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            i[8]
          )
        }
      ],
      $$slots: { default: [ree] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-header-button-color", "rgba(0, 0, 0, 0.2)"), z(t, "--a5e-header-button-color-hover", "#555");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*deleteConsumer, consumerId*/
      6 && (r.buttons = [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            n[8]
          )
        }
      ]), l & /*$$scope, consumer, $item, consumerId*/
      8203 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(oee, "create_fragment$2R");
function aee(i, e, t) {
  let s, n, { consumer: l } = e, { consumerId: r } = e, { deleteConsumer: o } = e;
  const a = fe("item");
  pe(i, a, (_) => t(3, n = _));
  const c = fe("actionId");
  function u() {
    se(n, `system.actions.${c}.consumers.${r}.defaultDie`, s);
  }
  f(u, "updateSelection");
  const p = (n.actor ? ob(n.actor) : []).reduce(
    (_, { die: y, total: k }) => (k > 0 && _.push([y, y]), _),
    []
  ), m = p.length ? p[0][0] : "";
  s || u();
  const g = /* @__PURE__ */ f(({ target: _ }) => se(n, `system.actions.${c}.consumers.${r}.label`, _.value), "change_handler"), h = /* @__PURE__ */ f(() => o(c, r), "func");
  return i.$$set = (_) => {
    "consumer" in _ && t(0, l = _.consumer), "consumerId" in _ && t(1, r = _.consumerId), "deleteConsumer" in _ && t(2, o = _.deleteConsumer);
  }, i.$$.update = () => {
    i.$$.dirty & /*consumer*/
    1 && t(6, s = l.defaultDie ?? m), i.$$.dirty & /*selected*/
    64 && u();
  }, [
    l,
    r,
    o,
    n,
    a,
    c,
    s,
    g,
    h
  ];
}
f(aee, "instance$2I");
const x2 = class x2 extends ie {
  constructor(e) {
    super(), le(this, e, aee, oee, ne, {
      consumer: 0,
      consumerId: 1,
      deleteConsumer: 2
    });
  }
};
f(x2, "HitDiceConsumer");
let U0 = x2;
function CP(i, e, t) {
  const s = i.slice();
  return s[14] = e[t][0], s[15] = e[t][1], s;
}
f(CP, "get_each_context$15");
function OP(i, e, t) {
  const s = i.slice();
  return s[18] = e[t].name, s[19] = e[t].id, s;
}
f(OP, "get_each_context_1$g");
function cee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*consumer*/
      i[0].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[9]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(cee, "create_default_slot_3$n");
function DP(i) {
  let e, t, s, n, l, r = oe(Object.entries(
    /*optGroup*/
    i[5]
  )), o = [];
  for (let a = 0; a < r.length; a += 1)
    o[a] = PP(CP(i, r, a));
  return {
    c() {
      e = E("select"), t = E("option");
      for (let a = 0; a < o.length; a += 1)
        o[a].c();
      t.__value = "", qe(t, t.__value), b(e, "id", s = /*actionId*/
      i[7] + "-" + /*consumerId*/
      i[1] + "-item-id"), b(e, "class", "u-w-fit"), /*selectedItem*/
      i[3] === void 0 && is(() => (
        /*select_change_handler*/
        i[11].call(e)
      ));
    },
    m(a, c) {
      T(a, e, c), A(e, t);
      for (let u = 0; u < o.length; u += 1)
        o[u] && o[u].m(e, null);
      ds(
        e,
        /*selectedItem*/
        i[3],
        !0
      ), n || (l = V(
        e,
        "change",
        /*select_change_handler*/
        i[11]
      ), n = !0);
    },
    p(a, c) {
      if (c & /*A5E, Object, optGroup, consumer*/
      289) {
        r = oe(Object.entries(
          /*optGroup*/
          a[5]
        ));
        let u;
        for (u = 0; u < r.length; u += 1) {
          const d = CP(a, r, u);
          o[u] ? o[u].p(d, c) : (o[u] = PP(d), o[u].c(), o[u].m(e, null));
        }
        for (; u < o.length; u += 1)
          o[u].d(1);
        o.length = r.length;
      }
      c & /*consumerId*/
      2 && s !== (s = /*actionId*/
      a[7] + "-" + /*consumerId*/
      a[1] + "-item-id") && b(e, "id", s), c & /*selectedItem, Object, optGroup*/
      40 && ds(
        e,
        /*selectedItem*/
        a[3]
      );
    },
    d(a) {
      a && S(e), Le(o, a), n = !1, l();
    }
  };
}
f(DP, "create_if_block$1E");
function IP(i, e) {
  let t, s = (
    /*name*/
    e[18] + ""
  ), n, l, r, o;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = x(s), l = R(), t.__value = r = /*id*/
      e[19], qe(t, t.__value), t.selected = o = /*consumer*/
      e[0].itemId, this.first = t;
    },
    m(a, c) {
      T(a, t, c), A(t, n), A(t, l);
    },
    p(a, c) {
      e = a, c & /*optGroup*/
      32 && s !== (s = /*name*/
      e[18] + "") && _e(n, s), c & /*optGroup*/
      32 && r !== (r = /*id*/
      e[19]) && (t.__value = r, qe(t, t.__value)), c & /*consumer*/
      1 && o !== (o = /*consumer*/
      e[0].itemId) && (t.selected = o);
    },
    d(a) {
      a && S(t);
    }
  };
}
f(IP, "create_each_block_1$g");
function PP(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n, l = oe(
    /*objects*/
    i[15].sort(MP)
  );
  const r = /* @__PURE__ */ f((o) => (
    /*id*/
    o[19]
  ), "get_key");
  for (let o = 0; o < l.length; o += 1) {
    let a = OP(i, l, o), c = r(a);
    s.set(c, t[o] = IP(c, a));
  }
  return {
    c() {
      e = E("optgroup");
      for (let o = 0; o < t.length; o += 1)
        t[o].c();
      b(e, "label", n = K(
        /*A5E*/
        i[8].objectTypesPlural[
          /*type*/
          i[14]
        ]
      ));
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < t.length; c += 1)
        t[c] && t[c].m(e, null);
    },
    p(o, a) {
      a & /*Object, optGroup, consumer*/
      33 && (l = oe(
        /*objects*/
        o[15].sort(MP)
      ), t = kt(t, a, r, 1, o, l, s, e, vs, IP, null, OP)), a & /*optGroup*/
      32 && n !== (n = K(
        /*A5E*/
        o[8].objectTypesPlural[
          /*type*/
          o[14]
        ]
      )) && b(e, "label", n);
    },
    d(o) {
      o && S(e);
      for (let a = 0; a < t.length; a += 1)
        t[a].d();
    }
  };
}
f(PP, "create_each_block$15");
function uee(i) {
  let e, t = (
    /*$item*/
    i[4].actor && DP(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*$item*/
      s[4].actor ? t ? t.p(s, n) : (t = DP(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && S(e), t && t.d(s);
    }
  };
}
f(uee, "create_default_slot_2$s");
function fee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), b(e, "d-type", "Number"), e.value = t = /*consumer*/
      i[0].quantity ?? 1;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[12]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].quantity ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(fee, "create_default_slot_1$B");
function dee(i) {
  let e, t, s, n, l;
  return e = new de({
    props: {
      heading: "A5E.Item",
      warning: "Item selection will be available when item is on an actor.",
      showWarning: !/*$item*/
      i[4].actor,
      $$slots: { default: [uee] },
      $$scope: { ctx: i }
    }
  }), s = new de({
    props: {
      heading: "A5E.ItemQuantity",
      $$slots: { default: [fee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), n = E("div"), L(s.$$.fragment), z(n, "display", "contents"), z(n, "--a5e-field-wrapper-width", "7.5rem");
    },
    m(r, o) {
      N(e, r, o), T(r, t, o), T(r, n, o), N(s, n, null), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*$item*/
      16 && (a.showWarning = !/*$item*/
      r[4].actor), o & /*$$scope, consumerId, selectedItem, optGroup, consumer, $item*/
      4194363 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, consumer, $item, consumerId*/
      4194323 && (c.$$scope = { dirty: o, ctx: r }), s.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(s.$$.fragment, r), l = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(s.$$.fragment, r), l = !1;
    },
    d(r) {
      r && S(t), j(e, r), r && s && S(n), j(s, r);
    }
  };
}
f(dee, "create_default_slot$1c");
function pee(i) {
  let e, t, s, n, l, r;
  return e = new de({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            i[10]
          )
        }
      ],
      $$slots: { default: [cee] },
      $$scope: { ctx: i }
    }
  }), n = new Me({
    props: {
      $$slots: { default: [dee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), l = E("div"), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-header-button-color", "rgba(0, 0, 0, 0.2)"), z(t, "--a5e-header-button-color-hover", "#555"), z(l, "display", "contents"), z(l, "--a5e-section-body-direction", "row"), z(l, "--a5e-section-body-padding", "0"), z(l, "--a5e-section-body-gap", "0.5rem");
    },
    m(o, a) {
      T(o, t, a), N(e, t, null), T(o, s, a), T(o, l, a), N(n, l, null), r = !0;
    },
    p(o, [a]) {
      const c = {};
      a & /*deleteConsumer, consumerId*/
      6 && (c.buttons = [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            o[10]
          )
        }
      ]), a & /*$$scope, consumer, $item, consumerId*/
      4194323 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const u = {};
      a & /*$$scope, consumer, $item, consumerId, selectedItem, optGroup*/
      4194363 && (u.$$scope = { dirty: a, ctx: o }), n.$set(u);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(n.$$.fragment, o), r = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(n.$$.fragment, o), r = !1;
    },
    d(o) {
      o && S(s), o && e && S(t), j(e, o), o && n && S(l), j(n, o);
    }
  };
}
f(pee, "create_fragment$2Q");
const MP = /* @__PURE__ */ f((i, e) => i.name.toLowerCase().localeCompare(e.name.toLowerCase()), "func_1$2");
function mee(i, e, t) {
  let s, n, { consumer: l } = e, { consumerId: r } = e, { deleteConsumer: o } = e;
  const a = fe("item");
  pe(i, a, (y) => t(4, n = y));
  const c = fe("actionId"), u = CONFIG.A5E;
  function d() {
    se(n, `system.actions.${c}.consumers.${r}.itemId`, p);
  }
  f(d, "updateItemSelection");
  let p = l.itemId ?? "";
  const m = /* @__PURE__ */ f(() => se(n, `system.actions.${c}.consumers.${r}.label`), "change_handler"), g = /* @__PURE__ */ f(() => o(c, r), "func");
  function h() {
    p = ca(this), t(3, p), t(5, s), t(4, n);
  }
  f(h, "select_change_handler");
  const _ = /* @__PURE__ */ f(({ target: y }) => se(n, `system.actions.${c}.consumers.${r}.quantity`, Number(y.value)), "change_handler_1");
  return i.$$set = (y) => {
    "consumer" in y && t(0, l = y.consumer), "consumerId" in y && t(1, r = y.consumerId), "deleteConsumer" in y && t(2, o = y.deleteConsumer);
  }, i.$$.update = () => {
    i.$$.dirty & /*selectedItem*/
    8 && d(), i.$$.dirty & /*$item*/
    16 && t(5, s = n.actor ? n.actor.items.reduce(
      (y, k) => {
        if (k.type !== "object" || k.system.objectType === "ammunition")
          return y;
        const v = k.system.objectType, O = { name: k.name, id: k.id };
        return y != null && y[v] ? y[v].push(O) : y[v] = [O], y;
      },
      {}
    ) : []);
  }, [
    l,
    r,
    o,
    p,
    n,
    s,
    a,
    c,
    u,
    m,
    g,
    h,
    _
  ];
}
f(mee, "instance$2H");
const eS = class eS extends ie {
  constructor(e) {
    super(), le(this, e, mee, pee, ne, {
      consumer: 0,
      consumerId: 1,
      deleteConsumer: 2
    });
  }
};
f(eS, "QuantityConsumer");
let V0 = eS;
function RP(i, e, t) {
  const s = i.slice();
  return s[14] = e[t][0], s[15] = e[t][1].label, s;
}
f(RP, "get_each_context$14");
function hee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*consumer*/
      i[0].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[8]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(hee, "create_default_slot_2$r");
function FP(i, e) {
  let t, s = K(
    /*label*/
    e[15]
  ) + "", n, l;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = x(s), l = R(), t.__value = /*value*/
      e[14], qe(t, t.__value), this.first = t;
    },
    m(r, o) {
      T(r, t, o), A(t, n), A(t, l);
    },
    p(r, o) {
      e = r;
    },
    d(r) {
      r && S(t);
    }
  };
}
f(FP, "create_each_block$14");
function gee(i) {
  let e, t, s = [], n = /* @__PURE__ */ new Map(), l, r, o, a = oe(Object.entries(
    /*A5E*/
    i[7].resourceConsumerConfig
  ));
  const c = /* @__PURE__ */ f((u) => (
    /*value*/
    u[14]
  ), "get_key");
  for (let u = 0; u < a.length; u += 1) {
    let d = RP(i, a, u), p = c(d);
    n.set(p, s[u] = FP(p, d));
  }
  return {
    c() {
      e = E("select"), t = E("option");
      for (let u = 0; u < s.length; u += 1)
        s[u].c();
      t.__value = "", qe(t, t.__value), b(e, "name", l = /*actionId*/
      i[6] + "-" + /*consumerId*/
      i[1] + "-item-id"), b(e, "class", "u-w-fit"), /*selectedResource*/
      i[3] === void 0 && is(() => (
        /*select_change_handler*/
        i[10].call(e)
      ));
    },
    m(u, d) {
      T(u, e, d), A(e, t);
      for (let p = 0; p < s.length; p += 1)
        s[p] && s[p].m(e, null);
      ds(
        e,
        /*selectedResource*/
        i[3],
        !0
      ), r || (o = V(
        e,
        "change",
        /*select_change_handler*/
        i[10]
      ), r = !0);
    },
    p(u, d) {
      d & /*Object, A5E*/
      128 && (a = oe(Object.entries(
        /*A5E*/
        u[7].resourceConsumerConfig
      )), s = kt(s, d, c, 1, u, a, n, e, vs, FP, null, RP)), d & /*consumerId*/
      2 && l !== (l = /*actionId*/
      u[6] + "-" + /*consumerId*/
      u[1] + "-item-id") && b(e, "name", l), d & /*selectedResource, Object, A5E*/
      136 && ds(
        e,
        /*selectedResource*/
        u[3]
      );
    },
    d(u) {
      u && S(e);
      for (let d = 0; d < s.length; d += 1)
        s[d].d();
      r = !1, o();
    }
  };
}
f(gee, "create_default_slot_1$A");
function NP(i) {
  let e, t, s;
  return e = new de({
    props: {
      heading: "A5E.ConsumeValue",
      $$slots: { default: [bee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-width", "7.5rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, consumer, $item, consumerId*/
      262163 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(NP, "create_if_block_1$17");
function bee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), b(e, "d-type", "Number"), e.value = t = /*consumer*/
      i[0].quantity ?? 1;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[11]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].quantity ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(bee, "create_default_slot$1b");
function jP(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.ConsumerRestoreResourceOnUse",
      checked: (
        /*consumer*/
        i[0].restore ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[12]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*consumer*/
      1 && (l.checked = /*consumer*/
      s[0].restore ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(jP, "create_if_block$1D");
function _ee(i) {
  var p, m, g, h;
  let e, t, s, n, l, r, o, a, c;
  e = new de({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            i[9]
          )
        }
      ],
      $$slots: { default: [hee] },
      $$scope: { ctx: i }
    }
  }), l = new de({
    props: {
      heading: "A5E.Resource",
      $$slots: { default: [gee] },
      $$scope: { ctx: i }
    }
  });
  let u = (
    /*A5E*/
    ((m = (p = i[7].resourceConsumerConfig) == null ? void 0 : p[
      /*selectedResource*/
      i[3]
    ]) == null ? void 0 : m.type) === "value" && NP(i)
  ), d = (
    /*A5E*/
    ((h = (g = i[7].resourceConsumerConfig) == null ? void 0 : g[
      /*selectedResource*/
      i[3]
    ]) == null ? void 0 : h.type) === "boolean" && jP(i)
  );
  return {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), n = E("div"), L(l.$$.fragment), r = R(), u && u.c(), o = R(), d && d.c(), a = $e(), z(t, "display", "contents"), z(t, "--a5e-header-button-color", "rgba(0, 0, 0, 0.2)"), z(t, "--a5e-header-button-color-hover", "#555"), b(n, "class", "a5e-field-group u-flex-row u-gap-md");
    },
    m(_, y) {
      T(_, t, y), N(e, t, null), T(_, s, y), T(_, n, y), N(l, n, null), A(n, r), u && u.m(n, null), T(_, o, y), d && d.m(_, y), T(_, a, y), c = !0;
    },
    p(_, [y]) {
      var O, P, D, I;
      const k = {};
      y & /*deleteConsumer, consumerId*/
      6 && (k.buttons = [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            _[9]
          )
        }
      ]), y & /*$$scope, consumer, $item, consumerId*/
      262163 && (k.$$scope = { dirty: y, ctx: _ }), e.$set(k);
      const v = {};
      y & /*$$scope, consumerId, selectedResource*/
      262154 && (v.$$scope = { dirty: y, ctx: _ }), l.$set(v), /*A5E*/
      ((P = (O = _[7].resourceConsumerConfig) == null ? void 0 : O[
        /*selectedResource*/
        _[3]
      ]) == null ? void 0 : P.type) === "value" ? u ? (u.p(_, y), y & /*selectedResource*/
      8 && w(u, 1)) : (u = NP(_), u.c(), w(u, 1), u.m(n, null)) : u && (ce(), C(u, 1, 1, () => {
        u = null;
      }), ue()), /*A5E*/
      ((I = (D = _[7].resourceConsumerConfig) == null ? void 0 : D[
        /*selectedResource*/
        _[3]
      ]) == null ? void 0 : I.type) === "boolean" ? d ? (d.p(_, y), y & /*selectedResource*/
      8 && w(d, 1)) : (d = jP(_), d.c(), w(d, 1), d.m(a.parentNode, a)) : d && (ce(), C(d, 1, 1, () => {
        d = null;
      }), ue());
    },
    i(_) {
      c || (w(e.$$.fragment, _), w(l.$$.fragment, _), w(u), w(d), c = !0);
    },
    o(_) {
      C(e.$$.fragment, _), C(l.$$.fragment, _), C(u), C(d), c = !1;
    },
    d(_) {
      _ && (S(s), S(n), S(o), S(a)), _ && e && S(t), j(e, _), j(l), u && u.d(), d && d.d(_);
    }
  };
}
f(_ee, "create_fragment$2P");
function yee(i, e, t) {
  let s, { consumer: n } = e, { consumerId: l } = e, { deleteConsumer: r } = e;
  const o = fe("item");
  pe(i, o, (y) => t(4, s = y));
  const a = fe("actionId"), c = CONFIG.A5E;
  function u() {
    se(s, `system.actions.${a}.consumers.${l}.resource`, d);
  }
  f(u, "updateResourceSelection");
  let d = n.resource ?? "";
  const p = /* @__PURE__ */ f(() => se(s, `system.actions.${a}.consumers.${l}.label`), "change_handler"), m = /* @__PURE__ */ f(() => r(a, l), "func");
  function g() {
    d = ca(this), t(3, d), t(7, c);
  }
  f(g, "select_change_handler");
  const h = /* @__PURE__ */ f(({ target: y }) => se(s, `system.actions.${a}.consumers.${l}.quantity`, Number(y.value)), "change_handler_1"), _ = /* @__PURE__ */ f(({ detail: y }) => se(s, `system.actions.${a}.consumers.${l}.restore`, y), "updateSelection_handler");
  return i.$$set = (y) => {
    "consumer" in y && t(0, n = y.consumer), "consumerId" in y && t(1, l = y.consumerId), "deleteConsumer" in y && t(2, r = y.deleteConsumer);
  }, i.$$.update = () => {
    i.$$.dirty & /*selectedResource*/
    8 && u();
  }, [
    n,
    l,
    r,
    d,
    s,
    o,
    a,
    c,
    p,
    m,
    g,
    h,
    _
  ];
}
f(yee, "instance$2G");
const tS = class tS extends ie {
  constructor(e) {
    super(), le(this, e, yee, _ee, ne, {
      consumer: 0,
      consumerId: 1,
      deleteConsumer: 2
    });
  }
};
f(tS, "ResourceConsumer");
let W0 = tS;
function LP(i, e, t) {
  const s = i.slice();
  return s[18] = e[t][0], s[19] = e[t][1], s;
}
f(LP, "get_each_context$13");
function BP(i, e, t) {
  const s = i.slice();
  return s[18] = e[t][0], s[19] = e[t][1], s;
}
f(BP, "get_each_context_1$f");
function vee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*consumer*/
      i[0].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(vee, "create_default_slot_4$f");
function qP(i) {
  let e, t = K(
    /*label*/
    i[19]
  ) + "", s, n, l;
  return {
    c() {
      e = E("option"), s = x(t), n = R(), e.__value = /*value*/
      i[18], qe(e, e.__value), e.selected = l = /*mode*/
      i[3] === /*value*/
      i[18];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      o & /*mode, Object, A5E*/
      520 && l !== (l = /*mode*/
      r[3] === /*value*/
      r[18]) && (e.selected = l);
    },
    d(r) {
      r && S(e);
    }
  };
}
f(qP, "create_each_block_1$f");
function kee(i) {
  let e, t, s, n, l = oe(Object.entries(
    /*A5E*/
    i[9].spellConsumerModes
  )), r = [];
  for (let o = 0; o < l.length; o += 1)
    r[o] = qP(BP(i, l, o));
  return {
    c() {
      e = E("select");
      for (let o = 0; o < r.length; o += 1)
        r[o].c();
      b(e, "name", t = /*actionId*/
      i[8] + "-" + /*consumerId*/
      i[1] + "-item-id"), b(e, "class", "u-w-fit"), /*mode*/
      i[3] === void 0 && is(() => (
        /*select_change_handler*/
        i[12].call(e)
      ));
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < r.length; c += 1)
        r[c] && r[c].m(e, null);
      ds(
        e,
        /*mode*/
        i[3],
        !0
      ), s || (n = V(
        e,
        "change",
        /*select_change_handler*/
        i[12]
      ), s = !0);
    },
    p(o, a) {
      if (a & /*Object, A5E, mode*/
      520) {
        l = oe(Object.entries(
          /*A5E*/
          o[9].spellConsumerModes
        ));
        let c;
        for (c = 0; c < l.length; c += 1) {
          const u = BP(o, l, c);
          r[c] ? r[c].p(u, a) : (r[c] = qP(u), r[c].c(), r[c].m(e, null));
        }
        for (; c < r.length; c += 1)
          r[c].d(1);
        r.length = l.length;
      }
      a & /*consumerId*/
      2 && t !== (t = /*actionId*/
      o[8] + "-" + /*consumerId*/
      o[1] + "-item-id") && b(e, "name", t), a & /*mode, Object, A5E*/
      520 && ds(
        e,
        /*mode*/
        o[3]
      );
    },
    d(o) {
      o && S(e), Le(r, o), s = !1, n();
    }
  };
}
f(kee, "create_default_slot_3$m");
function GP(i) {
  let e, t;
  return e = new de({
    props: {
      heading: "A5E.SpellLevel",
      $$slots: { default: [wee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, consumerId, spellLevel*/
      16777234 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(GP, "create_if_block_2$I");
function zP(i) {
  let e, t = K(
    /*label*/
    i[19]
  ) + "", s, n;
  return {
    c() {
      e = E("option"), s = x(t), n = R(), e.__value = Number(
        /*value*/
        i[18]
      ), qe(e, e.__value);
    },
    m(l, r) {
      T(l, e, r), A(e, s), A(e, n);
    },
    p: ee,
    d(l) {
      l && S(e);
    }
  };
}
f(zP, "create_each_block$13");
function wee(i) {
  let e, t, s, n, l = oe(Object.entries(
    /*A5E*/
    i[9].spellLevels
  ).slice(1)), r = [];
  for (let o = 0; o < l.length; o += 1)
    r[o] = zP(LP(i, l, o));
  return {
    c() {
      e = E("select");
      for (let o = 0; o < r.length; o += 1)
        r[o].c();
      b(e, "name", t = /*actionId*/
      i[8] + "-" + /*consumerId*/
      i[1] + "-item-id"), b(e, "class", "u-w-fit"), /*spellLevel*/
      i[4] === void 0 && is(() => (
        /*select_change_handler_1*/
        i[13].call(e)
      ));
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < r.length; c += 1)
        r[c] && r[c].m(e, null);
      ds(
        e,
        /*spellLevel*/
        i[4],
        !0
      ), s || (n = V(
        e,
        "change",
        /*select_change_handler_1*/
        i[13]
      ), s = !0);
    },
    p(o, a) {
      if (a & /*Number, Object, A5E*/
      512) {
        l = oe(Object.entries(
          /*A5E*/
          o[9].spellLevels
        ).slice(1));
        let c;
        for (c = 0; c < l.length; c += 1) {
          const u = LP(o, l, c);
          r[c] ? r[c].p(u, a) : (r[c] = zP(u), r[c].c(), r[c].m(e, null));
        }
        for (; c < r.length; c += 1)
          r[c].d(1);
        r.length = l.length;
      }
      a & /*consumerId*/
      2 && t !== (t = /*actionId*/
      o[8] + "-" + /*consumerId*/
      o[1] + "-item-id") && b(e, "name", t), a & /*spellLevel, Number, Object, A5E*/
      528 && ds(
        e,
        /*spellLevel*/
        o[4]
      );
    },
    d(o) {
      o && S(e), Le(r, o), s = !1, n();
    }
  };
}
f(wee, "create_default_slot_2$q");
function HP(i) {
  let e, t, s;
  return e = new de({
    props: {
      heading: "A5E.SpellPoints",
      $$slots: { default: [$ee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-width", "7.5rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, consumer, $item, consumerId*/
      16777283 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(HP, "create_if_block_1$16");
function $ee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), b(e, "d-type", "Number"), e.value = t = /*consumer*/
      i[0].points ?? 1;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[14]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].points ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f($ee, "create_default_slot_1$z");
function UP(i) {
  let e;
  return {
    c() {
      e = E("div"), e.innerHTML = `<dt class="u-text-bold">Variable</dt> <dd class="u-m-0 u-p-0">Variable mode allows you to select from spell slots or spell
                points at casting time.</dd> <dt class="u-text-bold">Spell Points Only</dt> <dd class="u-m-0 u-p-0">Always consumes spells points, ignoring available spell slots.</dd> <dt class="u-text-bold">Spell Slots Only</dt> <dd class="u-m-0 u-p-0">Always consumes spell slots, ignoring available spell points.</dd>`, b(e, "class", "a5e-box hint svelte-10afkkd");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(UP, "create_if_block$1C");
function Aee(i) {
  let e, t = (
    /*hintToggle*/
    i[5] && UP()
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*hintToggle*/
      s[5] ? t || (t = UP(), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && S(e), t && t.d(s);
    }
  };
}
f(Aee, "create_default_slot$1a");
function Eee(i) {
  let e, t, s, n, l, r, o = ["variable", "slotsOnly"].includes(
    /*mode*/
    i[3]
  ), a, c, u, d, p;
  e = new de({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            i[11]
          )
        }
      ],
      $$slots: { default: [vee] },
      $$scope: { ctx: i }
    }
  }), l = new de({
    props: {
      heading: "A5E.ConsumerSpellMode",
      $$slots: { default: [kee] },
      $$scope: { ctx: i }
    }
  });
  let m = o && GP(i), g = (
    /*mode*/
    i[3] === "pointsOnly" && HP(i)
  );
  return u = new de({
    props: {
      heading: "A5E.ConsumerSpellModeHintTitle",
      buttons: [
        {
          classes: `fa-solid ${/*hintToggle*/
          i[5] ? "fa-minus" : "fa-plus"}`,
          handler: (
            /*func_1*/
            i[15]
          )
        }
      ],
      $$slots: { default: [Aee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), n = E("div"), L(l.$$.fragment), r = R(), m && m.c(), a = R(), g && g.c(), c = R(), d = E("div"), L(u.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-header-button-color", "rgba(0, 0, 0, 0.2)"), z(t, "--a5e-header-button-color-hover", "#555"), b(n, "class", "a5e-field-group u-flex-row u-gap-md"), z(d, "display", "contents"), z(d, "--a5e-field-wrapper-header-item-justification", "flex-start"), z(d, "--a5e-field-wrapper-header-gap", "0.5rem");
    },
    m(h, _) {
      T(h, t, _), N(e, t, null), T(h, s, _), T(h, n, _), N(l, n, null), A(n, r), m && m.m(n, null), A(n, a), g && g.m(n, null), T(h, c, _), T(h, d, _), N(u, d, null), p = !0;
    },
    p(h, [_]) {
      const y = {};
      _ & /*deleteConsumer, consumerId*/
      6 && (y.buttons = [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            h[11]
          )
        }
      ]), _ & /*$$scope, consumer, $item, consumerId*/
      16777283 && (y.$$scope = { dirty: _, ctx: h }), e.$set(y);
      const k = {};
      _ & /*$$scope, consumerId, mode*/
      16777226 && (k.$$scope = { dirty: _, ctx: h }), l.$set(k), _ & /*mode*/
      8 && (o = ["variable", "slotsOnly"].includes(
        /*mode*/
        h[3]
      )), o ? m ? (m.p(h, _), _ & /*mode*/
      8 && w(m, 1)) : (m = GP(h), m.c(), w(m, 1), m.m(n, a)) : m && (ce(), C(m, 1, 1, () => {
        m = null;
      }), ue()), /*mode*/
      h[3] === "pointsOnly" ? g ? (g.p(h, _), _ & /*mode*/
      8 && w(g, 1)) : (g = HP(h), g.c(), w(g, 1), g.m(n, null)) : g && (ce(), C(g, 1, 1, () => {
        g = null;
      }), ue());
      const v = {};
      _ & /*hintToggle*/
      32 && (v.buttons = [
        {
          classes: `fa-solid ${/*hintToggle*/
          h[5] ? "fa-minus" : "fa-plus"}`,
          handler: (
            /*func_1*/
            h[15]
          )
        }
      ]), _ & /*$$scope, hintToggle*/
      16777248 && (v.$$scope = { dirty: _, ctx: h }), u.$set(v);
    },
    i(h) {
      p || (w(e.$$.fragment, h), w(l.$$.fragment, h), w(m), w(g), w(u.$$.fragment, h), p = !0);
    },
    o(h) {
      C(e.$$.fragment, h), C(l.$$.fragment, h), C(m), C(g), C(u.$$.fragment, h), p = !1;
    },
    d(h) {
      h && (S(s), S(n), S(c)), h && e && S(t), j(e, h), j(l), m && m.d(), g && g.d(), h && u && S(d), j(u, h);
    }
  };
}
f(Eee, "create_fragment$2O");
function See(i, e, t) {
  let s, { consumer: n } = e, { consumerId: l } = e, { deleteConsumer: r } = e;
  const o = fe("item");
  pe(i, o, (P) => t(6, s = P));
  const a = fe("actionId"), c = CONFIG.A5E;
  function u() {
    se(s, `system.actions.${a}.consumers.${l}.mode`, p);
  }
  f(u, "updateMode");
  function d() {
    se(s, `system.actions.${a}.consumers.${l}.spellLevel`, Number(m));
  }
  f(d, "updateSpellLevel");
  let p = n.mode ?? "variable", m = n.spellLevel ?? 1, g = !1;
  const h = /* @__PURE__ */ f(() => se(s, `system.actions.${a}.consumers.${l}.label`), "change_handler"), _ = /* @__PURE__ */ f(() => r(a, l), "func");
  function y() {
    p = ca(this), t(3, p), t(9, c);
  }
  f(y, "select_change_handler");
  function k() {
    m = ca(this), t(4, m), t(9, c);
  }
  f(k, "select_change_handler_1");
  const v = /* @__PURE__ */ f(({ target: P }) => se(s, `system.actions.${a}.consumers.${l}.points`, Number(P.value)), "change_handler_1"), O = /* @__PURE__ */ f(() => t(5, g = !g), "func_1");
  return i.$$set = (P) => {
    "consumer" in P && t(0, n = P.consumer), "consumerId" in P && t(1, l = P.consumerId), "deleteConsumer" in P && t(2, r = P.deleteConsumer);
  }, i.$$.update = () => {
    i.$$.dirty & /*mode*/
    8 && u(), i.$$.dirty & /*spellLevel*/
    16 && d();
  }, [
    n,
    l,
    r,
    p,
    m,
    g,
    s,
    o,
    a,
    c,
    h,
    _,
    y,
    k,
    v,
    O
  ];
}
f(See, "instance$2F");
const sS = class sS extends ie {
  constructor(e) {
    super(), le(this, e, See, Eee, ne, {
      consumer: 0,
      consumerId: 1,
      deleteConsumer: 2
    });
  }
};
f(sS, "SpellConsumer");
let K0 = sS;
function Tee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*consumer*/
      i[0].label ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[6]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].label ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Tee, "create_default_slot_1$y");
function Cee(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), b(e, "d-type", "Number"), e.value = t = /*consumer*/
      i[0].quantity ?? 1;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[8]
      ), s = !0);
    },
    p(l, r) {
      r & /*consumer*/
      1 && t !== (t = /*consumer*/
      l[0].quantity ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Cee, "create_default_slot$19");
function Oee(i) {
  let e, t, s, n, l, r;
  return e = new de({
    props: {
      heading: "A5E.Label",
      buttons: [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            i[7]
          )
        }
      ],
      $$slots: { default: [Tee] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      heading: "Default Consumption Amount",
      $$slots: { default: [Cee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), l = E("div"), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-header-button-color", "rgba(0, 0, 0, 0.2)"), z(t, "--a5e-header-button-color-hover", "#555"), z(l, "display", "contents"), z(l, "--a5e-field-wrapper-width", "14rem");
    },
    m(o, a) {
      T(o, t, a), N(e, t, null), T(o, s, a), T(o, l, a), N(n, l, null), r = !0;
    },
    p(o, [a]) {
      const c = {};
      a & /*deleteConsumer, consumerId*/
      6 && (c.buttons = [
        {
          classes: "fa-solid fa-trash",
          handler: (
            /*func*/
            o[7]
          )
        }
      ]), a & /*$$scope, consumer, $item, consumerId*/
      523 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const u = {};
      a & /*$$scope, consumer, $item, consumerId*/
      523 && (u.$$scope = { dirty: a, ctx: o }), n.$set(u);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(n.$$.fragment, o), r = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(n.$$.fragment, o), r = !1;
    },
    d(o) {
      o && S(s), o && e && S(t), j(e, o), o && n && S(l), j(n, o);
    }
  };
}
f(Oee, "create_fragment$2N");
function Dee(i, e, t) {
  let s, { consumer: n } = e, { consumerId: l } = e, { deleteConsumer: r } = e;
  const o = fe("item");
  pe(i, o, (p) => t(3, s = p));
  const a = fe("actionId"), c = /* @__PURE__ */ f(({ target: p }) => se(s, `system.actions.${a}.consumers.${l}.label`, p.value), "change_handler"), u = /* @__PURE__ */ f(() => r(a, l), "func"), d = /* @__PURE__ */ f(({ target: p }) => se(s, `system.actions.${a}.consumers.${l}.quantity`, Number(p.value)), "change_handler_1");
  return i.$$set = (p) => {
    "consumer" in p && t(0, n = p.consumer), "consumerId" in p && t(1, l = p.consumerId), "deleteConsumer" in p && t(2, r = p.deleteConsumer);
  }, [
    n,
    l,
    r,
    s,
    o,
    a,
    c,
    u,
    d
  ];
}
f(Dee, "instance$2E");
const nS = class nS extends ie {
  constructor(e) {
    super(), le(this, e, Dee, Oee, ne, {
      consumer: 0,
      consumerId: 1,
      deleteConsumer: 2
    });
  }
};
f(nS, "UsesConsumer");
let sp = nS;
function ka(i, e = {}) {
  try {
    at(i, e);
  } catch {
    throw ui.notifications.error("Invalid roll formula."), new Error("Invalid Roll Formula.");
  }
}
f(ka, "handleDeterministicInput");
function VP(i, e, t) {
  const s = i.slice();
  return s[18] = e[t][0], s[19] = e[t][1].heading, s[20] = e[t][1].component, s;
}
f(VP, "get_each_context$12");
function WP(i, e, t) {
  const s = i.slice();
  return s[23] = e[t][0], s[24] = e[t][1], s;
}
f(WP, "get_each_context_1$e");
function KP(i, e, t) {
  const s = i.slice();
  return s[27] = e[t][0], s[28] = e[t][1], s;
}
f(KP, "get_each_context_2$3");
function Iee(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "type", "number"), b(e, "d-type", "Number"), b(e, "name", "system.actions." + /*actionId*/
      i[6] + ".uses.value"), e.value = t = /*action*/
      ((l = i[1].uses) == null ? void 0 : l.value) ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[11]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r[0] & /*action*/
      2 && t !== (t = /*action*/
      ((o = l[1].uses) == null ? void 0 : o.value) ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Iee, "create_default_slot_7$8");
function Pee(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "type", "text"), b(e, "name", "system.actions." + /*actionId*/
      i[6] + ".uses.max"), e.value = t = /*action*/
      ((l = i[1].uses) == null ? void 0 : l.max) ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[12]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r[0] & /*action*/
      2 && t !== (t = /*action*/
      ((o = l[1].uses) == null ? void 0 : o.max) ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Pee, "create_default_slot_6$a");
function YP(i) {
  let e, t = K(
    /*name*/
    i[28]
  ) + "", s, n, l;
  return {
    c() {
      var r;
      e = E("option"), s = x(t), n = R(), b(
        e,
        "key",
        /*key*/
        i[27]
      ), e.__value = /*key*/
      i[27], qe(e, e.__value), e.selected = l = /*action*/
      ((r = i[1].uses) == null ? void 0 : r.per) === /*key*/
      i[27];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      var a;
      o[0] & /*action*/
      2 && l !== (l = /*action*/
      ((a = r[1].uses) == null ? void 0 : a.per) === /*key*/
      r[27]) && (e.selected = l);
    },
    d(r) {
      r && S(e);
    }
  };
}
f(YP, "create_each_block_2$3");
function Mee(i) {
  let e, t, s, n, l = oe(Object.entries(
    /*A5E*/
    i[7].resourceRecoveryOptions
  )), r = [];
  for (let o = 0; o < l.length; o += 1)
    r[o] = YP(KP(i, l, o));
  return {
    c() {
      e = E("select"), t = E("option");
      for (let o = 0; o < r.length; o += 1)
        r[o].c();
      t.__value = "", qe(t, t.__value), b(e, "class", "u-w-40"), b(e, "name", "system.actions." + /*actionId*/
      i[6] + ".uses.per");
    },
    m(o, a) {
      T(o, e, a), A(e, t);
      for (let c = 0; c < r.length; c += 1)
        r[c] && r[c].m(e, null);
      s || (n = V(
        e,
        "change",
        /*change_handler_2*/
        i[13]
      ), s = !0);
    },
    p(o, a) {
      if (a[0] & /*A5E, action*/
      130) {
        l = oe(Object.entries(
          /*A5E*/
          o[7].resourceRecoveryOptions
        ));
        let c;
        for (c = 0; c < l.length; c += 1) {
          const u = KP(o, l, c);
          r[c] ? r[c].p(u, a) : (r[c] = YP(u), r[c].c(), r[c].m(e, null));
        }
        for (; c < r.length; c += 1)
          r[c].d(1);
        r.length = l.length;
      }
    },
    d(o) {
      o && S(e), Le(r, o), s = !1, n();
    }
  };
}
f(Mee, "create_default_slot_5$d");
function Ree(i) {
  let e, t, s, n, l, r, o, a;
  return e = new de({
    props: {
      heading: "A5E.UsesCurrent",
      $$slots: { default: [Iee] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      heading: "A5E.UsesMax",
      $$slots: { default: [Pee] },
      $$scope: { ctx: i }
    }
  }), o = new de({
    props: {
      heading: "A5E.UsesPer",
      $$slots: { default: [Mee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), l = E("div"), L(n.$$.fragment), r = R(), L(o.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-width", "7.5rem"), z(l, "display", "contents"), z(l, "--a5e-field-wrapper-width", "7.5rem");
    },
    m(c, u) {
      T(c, t, u), N(e, t, null), T(c, s, u), T(c, l, u), N(n, l, null), T(c, r, u), N(o, c, u), a = !0;
    },
    p(c, u) {
      const d = {};
      u[0] & /*action, $item*/
      6 | u[1] & /*$$scope*/
      1 && (d.$$scope = { dirty: u, ctx: c }), e.$set(d);
      const p = {};
      u[0] & /*action, $item*/
      6 | u[1] & /*$$scope*/
      1 && (p.$$scope = { dirty: u, ctx: c }), n.$set(p);
      const m = {};
      u[0] & /*$item, action*/
      6 | u[1] & /*$$scope*/
      1 && (m.$$scope = { dirty: u, ctx: c }), o.$set(m);
    },
    i(c) {
      a || (w(e.$$.fragment, c), w(n.$$.fragment, c), w(o.$$.fragment, c), a = !0);
    },
    o(c) {
      C(e.$$.fragment, c), C(n.$$.fragment, c), C(o.$$.fragment, c), a = !1;
    },
    d(c) {
      c && (S(s), S(r)), c && e && S(t), j(e, c), c && n && S(l), j(n, c), j(o, c);
    }
  };
}
f(Ree, "create_default_slot_4$e");
function XP(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "A5E.ItemRechargeConfiguration",
      $$slots: { default: [jee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-direction", "row"), z(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l[0] & /*action, $item*/
      6 | l[1] & /*$$scope*/
      1 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(XP, "create_if_block_1$15");
function Fee(i) {
  let e, t, s, n;
  return {
    c() {
      var l, r;
      e = E("input"), b(
        e,
        "id",
        /*actionId*/
        i[6] + "-recharge-formula"
      ), b(e, "type", "text"), e.value = t = /*action*/
      ((r = (l = i[1].uses) == null ? void 0 : l.recharge) == null ? void 0 : r.formula) ?? "1d6", b(e, "placeholder", "1d6");
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_3*/
        i[14]
      ), s = !0);
    },
    p(l, r) {
      var o, a;
      r[0] & /*action*/
      2 && t !== (t = /*action*/
      ((a = (o = l[1].uses) == null ? void 0 : o.recharge) == null ? void 0 : a.formula) ?? "1d6") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Fee, "create_default_slot_3$l");
function Nee(i) {
  let e, t, s, n;
  return {
    c() {
      var l, r;
      e = E("input"), b(
        e,
        "id",
        /*actionId*/
        i[6] + "-recharge-threshold"
      ), b(e, "class", "u-text-center"), b(e, "type", "number"), e.value = t = /*action*/
      ((r = (l = i[1].uses) == null ? void 0 : l.recharge) == null ? void 0 : r.threshold) ?? 6;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_4*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      var o, a;
      r[0] & /*action*/
      2 && t !== (t = /*action*/
      ((a = (o = l[1].uses) == null ? void 0 : o.recharge) == null ? void 0 : a.threshold) ?? 6) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Nee, "create_default_slot_2$p");
function jee(i) {
  let e, t, s, n, l;
  return e = new de({
    props: {
      heading: "A5E.ItemRechargeFormula",
      $$slots: { default: [Fee] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      heading: "A5E.ItemRechargeThreshold",
      $$slots: { default: [Nee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-grow", "1");
    },
    m(r, o) {
      T(r, t, o), N(e, t, null), T(r, s, o), N(n, r, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o[0] & /*action, $item*/
      6 | o[1] & /*$$scope*/
      1 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o[0] & /*action, $item*/
      6 | o[1] & /*$$scope*/
      1 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && S(s), r && e && S(t), j(e, r), j(n, r);
    }
  };
}
f(jee, "create_default_slot_1$x");
function JP(i) {
  let e, t, s, n, l;
  return t = new Me({
    props: {
      heading: (
        /*heading*/
        i[19]
      ),
      $$slots: { default: [Lee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("li"), s = E("div"), L(t.$$.fragment), n = R(), z(s, "display", "contents"), z(s, "--a5e-section-gap", "0"), b(e, "class", "consumers-config-list__item svelte-8c35mw");
    },
    m(r, o) {
      T(r, e, o), A(e, s), N(t, s, null), A(e, n), l = !0;
    },
    p(r, o) {
      const a = {};
      o[0] & /*consumers*/
      1 | o[1] & /*$$scope*/
      1 && (a.$$scope = { dirty: o, ctx: r }), t.$set(a);
    },
    i(r) {
      l || (w(t.$$.fragment, r), l = !0);
    },
    o(r) {
      C(t.$$.fragment, r), l = !1;
    },
    d(r) {
      r && S(e), j(t);
    }
  };
}
f(JP, "create_if_block$1B");
function ZP(i, e) {
  let t, s, n, l;
  var r = (
    /*component*/
    e[20]
  );
  function o(a, c) {
    return {
      props: {
        consumer: (
          /*consumer*/
          a[24]
        ),
        consumerId: (
          /*consumerId*/
          a[23]
        ),
        deleteConsumer: (
          /*deleteConsumer*/
          a[4]
        )
      }
    };
  }
  return f(o, "switch_props"), r && (s = nt(r, o(e))), {
    key: i,
    first: null,
    c() {
      t = E("li"), s && L(s.$$.fragment), n = R(), b(t, "class", "a5e-item a5e-item--action-config"), this.first = t;
    },
    m(a, c) {
      T(a, t, c), s && N(s, t, null), A(t, n), l = !0;
    },
    p(a, c) {
      if (e = a, r !== (r = /*component*/
      e[20])) {
        if (s) {
          ce();
          const u = s;
          C(u.$$.fragment, 1, 0, () => {
            j(u, 1);
          }), ue();
        }
        r ? (s = nt(r, o(e)), L(s.$$.fragment), w(s.$$.fragment, 1), N(s, t, n)) : s = null;
      } else if (r) {
        const u = {};
        c[0] & /*consumers*/
        1 && (u.consumer = /*consumer*/
        e[24]), c[0] & /*consumers*/
        1 && (u.consumerId = /*consumerId*/
        e[23]), s.$set(u);
      }
    },
    i(a) {
      l || (s && w(s.$$.fragment, a), l = !0);
    },
    o(a) {
      s && C(s.$$.fragment, a), l = !1;
    },
    d(a) {
      a && S(t), s && j(s);
    }
  };
}
f(ZP, "create_each_block_1$e");
function Lee(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n;
  function l(...a) {
    return (
      /*func_1*/
      i[16](
        /*consumerType*/
        i[18],
        ...a
      )
    );
  }
  f(l, "func_1");
  let r = oe(Object.entries(
    /*consumers*/
    i[0]
  ).filter(l));
  const o = /* @__PURE__ */ f((a) => (
    /*consumerId*/
    a[23]
  ), "get_key");
  for (let a = 0; a < r.length; a += 1) {
    let c = WP(i, r, a), u = o(c);
    s.set(u, t[a] = ZP(u, c));
  }
  return {
    c() {
      e = E("ul");
      for (let a = 0; a < t.length; a += 1)
        t[a].c();
      b(e, "class", "a5e-item-list");
    },
    m(a, c) {
      T(a, e, c);
      for (let u = 0; u < t.length; u += 1)
        t[u] && t[u].m(e, null);
      n = !0;
    },
    p(a, c) {
      i = a, c[0] & /*consumerTypes, consumers, deleteConsumer*/
      273 && (r = oe(Object.entries(
        /*consumers*/
        i[0]
      ).filter(l)), ce(), t = kt(t, c, o, 1, i, r, s, e, ks, ZP, null, WP), ue());
    },
    i(a) {
      if (!n) {
        for (let c = 0; c < r.length; c += 1)
          w(t[c]);
        n = !0;
      }
    },
    o(a) {
      for (let c = 0; c < t.length; c += 1)
        C(t[c]);
      n = !1;
    },
    d(a) {
      a && S(e);
      for (let c = 0; c < t.length; c += 1)
        t[c].d();
    }
  };
}
f(Lee, "create_default_slot$18");
function QP(i, e) {
  let t, s = Object.values(
    /*consumers*/
    e[0]
  ).filter(r).length, n, l;
  function r(...a) {
    return (
      /*func*/
      e[10](
        /*consumerType*/
        e[18],
        ...a
      )
    );
  }
  f(r, "func");
  let o = s && JP(e);
  return {
    key: i,
    first: null,
    c() {
      t = $e(), o && o.c(), n = $e(), this.first = t;
    },
    m(a, c) {
      T(a, t, c), o && o.m(a, c), T(a, n, c), l = !0;
    },
    p(a, c) {
      e = a, c[0] & /*consumers*/
      1 && (s = Object.values(
        /*consumers*/
        e[0]
      ).filter(r).length), s ? o ? (o.p(e, c), c[0] & /*consumers*/
      1 && w(o, 1)) : (o = JP(e), o.c(), w(o, 1), o.m(n.parentNode, n)) : o && (ce(), C(o, 1, 1, () => {
        o = null;
      }), ue());
    },
    i(a) {
      l || (w(o), l = !0);
    },
    o(a) {
      C(o), l = !1;
    },
    d(a) {
      a && (S(t), S(n)), o && o.d(a);
    }
  };
}
f(QP, "create_each_block$12");
function Bee(i) {
  var _;
  let e, t, s, n, l, r, o = [], a = /* @__PURE__ */ new Map(), c, u, d, p;
  t = new Me({
    props: {
      heading: "A5E.Uses",
      $$slots: { default: [Ree] },
      $$scope: { ctx: i }
    }
  });
  let m = (
    /*action*/
    ((_ = i[1].uses) == null ? void 0 : _.per) === "recharge" && XP(i)
  ), g = oe(Object.entries(
    /*consumerTypes*/
    i[8]
  ));
  const h = /* @__PURE__ */ f((y) => (
    /*consumerType*/
    y[18]
  ), "get_key");
  for (let y = 0; y < g.length; y += 1) {
    let k = VP(i, g, y), v = h(k);
    a.set(v, o[y] = QP(v, k));
  }
  return d = new Ys({
    props: {
      menuList: (
        /*menuList*/
        i[3]
      ),
      offset: { x: -110, y: -100 },
      documentName: "Consumer"
    }
  }), d.$on(
    "press",
    /*press_handler*/
    i[17]
  ), {
    c() {
      e = E("div"), s = E("div"), L(t.$$.fragment), n = R(), m && m.c(), l = R(), r = E("ul");
      for (let y = 0; y < o.length; y += 1)
        o[y].c();
      c = R(), u = E("div"), L(d.$$.fragment), z(s, "display", "contents"), z(s, "--a5e-section-body-direction", "row"), z(s, "--a5e-section-body-gap", "0.5rem"), b(r, "class", "consumers-config-list svelte-8c35mw"), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable"), b(u, "class", "sticky-add-button svelte-8c35mw");
    },
    m(y, k) {
      T(y, e, k), A(e, s), N(t, s, null), A(e, n), m && m.m(e, null), A(e, l), A(e, r);
      for (let v = 0; v < o.length; v += 1)
        o[v] && o[v].m(r, null);
      T(y, c, k), T(y, u, k), N(d, u, null), p = !0;
    },
    p(y, k) {
      var P;
      const v = {};
      k[0] & /*$item, action*/
      6 | k[1] & /*$$scope*/
      1 && (v.$$scope = { dirty: k, ctx: y }), t.$set(v), /*action*/
      ((P = y[1].uses) == null ? void 0 : P.per) === "recharge" ? m ? (m.p(y, k), k[0] & /*action*/
      2 && w(m, 1)) : (m = XP(y), m.c(), w(m, 1), m.m(e, l)) : m && (ce(), C(m, 1, 1, () => {
        m = null;
      }), ue()), k[0] & /*consumerTypes, consumers, deleteConsumer*/
      273 && (g = oe(Object.entries(
        /*consumerTypes*/
        y[8]
      )), ce(), o = kt(o, k, h, 1, y, g, a, r, ks, QP, null, VP), ue());
      const O = {};
      k[0] & /*menuList*/
      8 && (O.menuList = /*menuList*/
      y[3]), d.$set(O);
    },
    i(y) {
      if (!p) {
        w(t.$$.fragment, y), w(m);
        for (let k = 0; k < g.length; k += 1)
          w(o[k]);
        w(d.$$.fragment, y), p = !0;
      }
    },
    o(y) {
      C(t.$$.fragment, y), C(m);
      for (let k = 0; k < o.length; k += 1)
        C(o[k]);
      C(d.$$.fragment, y), p = !1;
    },
    d(y) {
      y && (S(e), S(c), S(u)), j(t), m && m.d();
      for (let k = 0; k < o.length; k += 1)
        o[k].d();
      j(d);
    }
  };
}
f(Bee, "create_fragment$2M");
function qee(i, e, t) {
  let s, n, l, r, o;
  function a(P, D) {
    o.update({
      [`system.actions.${P}.consumers`]: { [`-=${D}`]: null }
    });
  }
  f(a, "deleteConsumer");
  const c = fe("item");
  pe(i, c, (P) => t(2, o = P));
  const u = fe("actionId"), { A5E: d } = CONFIG, p = {
    ammunition: {
      heading: "A5E.ConsumerAmmunition",
      singleLabel: "A5E.ObjectTypeAmmunition",
      component: H0
    },
    hitDice: {
      heading: "A5E.ConsumerHitDice",
      singleLabel: "A5E.HitDiceLabel",
      component: U0
    },
    quantity: {
      heading: "A5E.ConsumerQuantity",
      singleLabel: "A5E.ItemQuantity",
      component: V0
    },
    resource: {
      heading: "A5E.ConsumerResource",
      singleLabel: "A5E.Resource",
      component: W0
    },
    spell: {
      heading: "A5E.ConsumerSpell",
      singleLabel: "A5E.Spell",
      component: K0
    },
    actionUses: {
      heading: "A5E.ConsumerUsesAction",
      singleLabel: "A5E.ConsumerActionUses",
      component: sp
    },
    itemUses: {
      heading: "A5E.ConsumerUsesItem",
      singleLabel: "A5E.ConsumerItemUses",
      component: sp
    }
  }, m = /* @__PURE__ */ f((P, D) => D.type === P, "func"), g = /* @__PURE__ */ f(({ target: P }) => se(o, P.name, Number(P.value)), "change_handler"), h = /* @__PURE__ */ f(({ target: P }) => {
    ka(P.value), se(o, P.name, P.value);
  }, "change_handler_1"), _ = /* @__PURE__ */ f(({ target: P }) => se(o, P.name, P.value), "change_handler_2"), y = /* @__PURE__ */ f(({ target: P }) => {
    ka(P.value), se(o, `system.actions.${u}.uses.recharge.formula`, P.value);
  }, "change_handler_3"), k = /* @__PURE__ */ f(({ target: P }) => se(o, `system.actions.${u}.uses.recharge.threshold`, Number(P.value)), "change_handler_4"), v = /* @__PURE__ */ f((P, [D, I]) => I.type === P, "func_1"), O = /* @__PURE__ */ f(({ detail: P }) => ri.addConsumer(o, [u, s], P), "press_handler");
  return i.$$.update = () => {
    i.$$.dirty[0] & /*$item*/
    4 && t(1, s = o.actions[u]), i.$$.dirty[0] & /*action*/
    2 && t(0, n = s.consumers ?? {}), i.$$.dirty[0] & /*consumers*/
    1 && t(9, l = new Set(Object.values(n).map((P) => P.type))), i.$$.dirty[0] & /*existingConsumers*/
    512 && t(3, r = Object.entries(p).reduce(
      (P, [D, { singleLabel: I }]) => ((D === "resource" || !l.has(D)) && P.push([D, I]), P),
      []
    ));
  }, [
    n,
    s,
    o,
    r,
    a,
    c,
    u,
    d,
    p,
    l,
    m,
    g,
    h,
    _,
    y,
    k,
    v,
    O
  ];
}
f(qee, "instance$2D");
const iS = class iS extends ie {
  constructor(e) {
    super(), le(this, e, qee, Bee, ne, {}, null, [-1, -1]);
  }
};
f(iS, "ActionsResourceManagementTab");
let Y0 = iS;
var Ju, Zu, cn;
const lS = class lS extends MeasuredTemplate {
  constructor() {
    super(...arguments);
    Y(this, Ju, 0);
    Y(this, Zu, void 0);
    Y(this, cn, void 0);
  }
  async drawPreview() {
    const t = canvas.activeLayer;
    this.draw();
    try {
      this.layer.activate();
    } catch (s) {
      if (s.name !== "TypeError")
        throw new Error(s);
    }
    return this.layer.preview.addChild(this), this.activatePreviewListeners(t);
  }
  activatePreviewListeners(t) {
    return new Promise((s, n) => {
      ye(this, Zu, t), ye(this, cn, {
        cancel: this._onCancel.bind(this),
        confirm: this._onConfirm.bind(this),
        move: this._onMove.bind(this),
        rotate: this._onRotate.bind(this),
        resolve: s,
        reject: n
      }), canvas.stage.on("mousemove", M(this, cn).move), canvas.stage.on("mousedown", M(this, cn).confirm), canvas.app.view.oncontextmenu = M(this, cn).cancel, canvas.app.view.onwheel = M(this, cn).rotate;
    });
  }
  async _finishPlacement(t) {
    this.layer._onDragLeftCancel(t ?? {}), canvas.stage.off("mousemove", M(this, cn).move), canvas.stage.off("mousedown", M(this, cn).confirm), canvas.app.view.oncontextmenu = null, canvas.app.view.onwheel = null, M(this, Zu).activate();
  }
  _onMove(t) {
    t.stopPropagation();
    const s = Date.now();
    if (s - M(this, Ju) <= 10)
      return;
    const n = t.data.getLocalPosition(this.layer), l = canvas.grid.type === CONST.GRID_TYPES.GRIDLESS ? 0 : 2, r = canvas.grid.getSnappedPosition(n.x, n.y, l);
    this.document.updateSource({ x: r.x, y: r.y }), this.refresh(), ye(this, Ju, s);
  }
  _onRotate(t) {
    t.ctrlKey && t.preventDefault(), t.stopPropagation();
    const s = canvas.grid.type > CONST.GRID_TYPES.SQUARE ? 30 : 15, n = t.shiftKey ? s : 5, l = {
      direction: this.document.direction + n * Math.sign(t.deltaY)
    };
    this.document.updateSource(l), this.refresh();
  }
  async _onConfirm(t) {
    await this._finishPlacement(t);
    const s = canvas.grid.type === CONST.GRID_TYPES.GRIDLESS ? 0 : 2, n = canvas.grid.getSnappedPosition(this.document.x, this.document.y, s);
    this.document.updateSource(n), M(this, cn).resolve(
      canvas.scene.createEmbeddedDocuments("MeasuredTemplate", [this.document.toObject()])
    );
  }
  async _onCancel(t) {
    await this._finishPlacement(t ?? {}), M(this, cn).reject();
  }
};
Ju = new WeakMap(), Zu = new WeakMap(), cn = new WeakMap(), f(lS, "ItemMeasuredTemplate");
let X0 = lS;
var ea, un, al, Di, kg, yB, wg, vB, $g, kB, Ag, wB, Eg, $B, Sg, AB, Tg, EB, ta, dd, Cg, SB, Qu, J0, Og, TB, xu, Z0, Dg, CB, Ig, OB, Pg, DB, Mg, IB, Rg, PB, Fg, MB, _r, xa;
const hc = class hc {
  constructor(e, t, s, n = {}) {
    // --------------------------------------------
    // Internal Functions - Validators
    // --------------------------------------------
    Y(this, kg);
    Y(this, wg);
    Y(this, $g);
    Y(this, Ag);
    Y(this, Eg);
    Y(this, Sg);
    // --------------------------------------------
    // Internal Functions - Template Creations
    // --------------------------------------------
    Y(this, Tg);
    Y(this, ta);
    Y(this, Cg);
    Y(this, Qu);
    Y(this, Og);
    Y(this, xu);
    // --------------------------------------------
    // Internal Functions - Scaling
    // --------------------------------------------
    Y(this, Dg);
    Y(this, Ig);
    Y(this, Pg);
    Y(this, Mg);
    Y(this, Rg);
    Y(this, Fg);
    Y(this, _r);
    Y(this, ea, void 0);
    Y(this, un, void 0);
    Y(this, al, void 0);
    Y(this, Di, void 0);
    ye(this, un, e), ye(this, ea, s), ye(this, al, n), ye(this, Di, t);
  }
  get TEMPLATE_FUNCTION_MAP() {
    return {
      circle: Z(this, ta, dd),
      cone: Z(this, Cg, SB),
      cube: Z(this, Qu, J0),
      cylinder: Z(this, ta, dd),
      emanation: Z(this, Og, TB),
      line: Z(this, xu, Z0),
      sphere: Z(this, ta, dd),
      square: Z(this, Qu, J0),
      wall: Z(this, xu, Z0)
    };
  }
  // --------------------------------------------
  // Public Functions
  // --------------------------------------------
  async placeActionTemplates() {
    var n, l, r, o, a;
    const { area: e } = M(this, ea);
    let t = foundry.utils.deepClone(e);
    t = Z(this, Dg, CB).call(this, t);
    const s = t.quantity ?? 1;
    await ((l = (n = M(this, un)) == null ? void 0 : n.sheet) == null ? void 0 : l.minimize());
    try {
      for (let c = 0; c < s; c += 1) {
        const u = Z(this, Tg, EB).call(this, t), d = new X0(u);
        if (!d)
          return;
        d.item = M(this, Di), d.actorSheet = ((r = M(this, un)) == null ? void 0 : r.sheet) || null;
        let p = !1;
        setTimeout(() => {
          if (!p)
            throw d == null || d._onCancel(), new Error("Time limit for placing template exceeded");
        }, 3e4);
        const m = await (d == null ? void 0 : d.drawPreview());
        p = !0, m && Hooks.callAll("a5e.measuredTemplatePlaced", M(this, Di), m, game.user.id);
      }
    } catch {
    } finally {
      await ((a = (o = M(this, un)) == null ? void 0 : o.sheet) == null ? void 0 : a.maximize());
    }
  }
  /**
   *
   * @param {ItemA5e} item
   * @param {Action} action
   * @returns {Boolean} validTemplate
   */
  validateBaseTemplateData(e = M(this, ea)) {
    const { area: t } = e ?? {};
    return foundry.utils.isEmpty(t) || (t.quantity ?? (t.quantity = 1), !t.shape) || t.quantity <= 0 ? !1 : t.shape === "cone" ? Z(this, kg, yB).call(this, t) : ["cube", "square"].includes(t.shape) ? Z(this, wg, vB).call(this, t) : ["circle", "emanation", "sphere"].includes(t.shape) ? Z(this, $g, kB).call(this, t) : t.shape === "cylinder" ? Z(this, Ag, wB).call(this, t) : t.shape === "line" ? Z(this, Eg, $B).call(this, t) : t.shape === "wall" ? Z(this, Sg, AB).call(this, t) : !1;
  }
  // --------------------------------------------
  // Static Functions
  // --------------------------------------------
  static getShapeProperties(e) {
    switch (e) {
      case "circle":
      case "emanation":
      case "sphere":
        return ["radius"];
      case "cone":
        return ["length"];
      case "cube":
      case "square":
        return ["width"];
      case "cylinder":
        return ["radius", "height"];
      case "line":
        return ["length", "width"];
      case "wall":
        return ["length", "height", "width"];
      default:
        return [];
    }
  }
};
ea = new WeakMap(), un = new WeakMap(), al = new WeakMap(), Di = new WeakMap(), kg = new WeakSet(), yB = /* @__PURE__ */ f(function(e) {
  const t = parseInt(e == null ? void 0 : e.length, 10);
  return !(!t || t <= 0);
}, "#validateCone"), wg = new WeakSet(), vB = /* @__PURE__ */ f(function(e) {
  const t = parseInt(e == null ? void 0 : e.width, 10);
  return !(!t || t <= 0);
}, "#validateQuadrilateral"), $g = new WeakSet(), kB = /* @__PURE__ */ f(function(e) {
  const t = parseInt(e == null ? void 0 : e.radius, 10);
  return !(!t || t <= 0);
}, "#validateRadialObject"), Ag = new WeakSet(), wB = /* @__PURE__ */ f(function(e) {
  const t = parseInt(e == null ? void 0 : e.radius, 10), s = parseInt(e == null ? void 0 : e.radius, 10);
  return !(!t || !s || t <= 0 || s <= 0);
}, "#validateCylinder"), Eg = new WeakSet(), $B = /* @__PURE__ */ f(function(e) {
  const t = parseInt(e == null ? void 0 : e.length, 10), s = parseInt(e == null ? void 0 : e.width, 10);
  return !(!s || !t || s <= 0 || t <= 0);
}, "#validateLine"), Sg = new WeakSet(), AB = /* @__PURE__ */ f(function(e) {
  const t = parseInt(e == null ? void 0 : e.length, 10), s = parseInt(e == null ? void 0 : e.width, 10), n = parseInt(e == null ? void 0 : e.height, 10);
  return !(!s || !t || !n || s <= 0 || t <= 0 || n <= 0);
}, "#validateWall"), Tg = new WeakSet(), EB = /* @__PURE__ */ f(function(e) {
  const { shape: t } = e, n = this.TEMPLATE_FUNCTION_MAP[t].apply(this, [e]);
  if (!n)
    return null;
  const l = CONFIG.MeasuredTemplate.documentClass;
  return new l(n, { parent: canvas.scene });
}, "#createTemplateDocument"), ta = new WeakSet(), dd = /* @__PURE__ */ f(function(e) {
  return {
    direction: 0,
    distance: parseInt(e.radius, 10),
    fillColor: game.user.color,
    t: "circle",
    user: game.user.id,
    x: 0,
    y: 0
  };
}, "#getCircleTemplateData"), Cg = new WeakSet(), SB = /* @__PURE__ */ f(function(e) {
  const t = parseInt(e.length, 10);
  return {
    angle: CONFIG.MeasuredTemplate.defaults.angle,
    direction: 0,
    distance: t,
    fillColor: game.user.color,
    t: "cone",
    user: game.user.id,
    x: 0,
    y: 0
  };
}, "#getConeTemplateData"), Qu = new WeakSet(), J0 = /* @__PURE__ */ f(function(e) {
  const t = parseInt(e.width, 10);
  return {
    direction: 45,
    distance: Math.hypot(t, t),
    fillColor: game.user.color,
    t: "rect",
    user: game.user.id,
    width: t,
    x: 0,
    y: 0
  };
}, "#getCubeTemplateData"), Og = new WeakSet(), TB = /* @__PURE__ */ f(function(e) {
  var r;
  let t = parseInt(e.radius, 10);
  const s = M(this, un).system.traits.size ?? "med", n = (r = M(this, un).getActiveTokens()) == null ? void 0 : r[0];
  let l;
  if (n) {
    const o = n.document.width, a = n.document.height;
    l = Math.max(o, a) / 2, t += l * 5;
  } else
    s !== "tiny" && (l = CONFIG.A5E.tokenDimensions[s] / 2, t += l * 5);
  return {
    direction: 0,
    distance: t,
    fillColor: game.user.color,
    t: "circle",
    user: game.user.id,
    x: 0,
    y: 0
  };
}, "#getEmanationTemplateData"), xu = new WeakSet(), Z0 = /* @__PURE__ */ f(function(e) {
  const t = parseInt(e.length, 10), s = parseInt(e.width, 10);
  return {
    direction: 0,
    distance: t,
    fillColor: game.user.color,
    t: "ray",
    user: game.user.id,
    width: s,
    x: 0,
    y: 0
  };
}, "#getLineTemplateData"), Dg = new WeakSet(), CB = /* @__PURE__ */ f(function(e) {
  var s;
  const t = (s = e.scaling) == null ? void 0 : s.mode;
  return t ? t === "cantrip" ? Z(this, Ig, OB).call(this, e) : t === "spellLevel" ? Z(this, Pg, DB).call(this, e) : t === "spellPoints" ? Z(this, Mg, IB).call(this, e) : t === "actionUses" ? Z(this, Rg, PB).call(this, e) : t === "itemUses" ? Z(this, Fg, MB).call(this, e) : e : e;
}, "#applyTemplateScaling"), Ig = new WeakSet(), OB = /* @__PURE__ */ f(function(e) {
  const t = M(this, un).system, s = t.details.level ?? t.attributes.casterLevel;
  if (s < 5)
    return e;
  const n = [
    "quantity",
    ...hc.getShapeProperties(e.shape)
  ];
  let l = 0;
  return s >= 17 ? l = 3 : s >= 11 ? l = 2 : s >= 5 && (l = 1), n.forEach((r) => {
    var a, c;
    const o = at(
      ((c = (a = e.scaling) == null ? void 0 : a.formula) == null ? void 0 : c[r]) ?? 0,
      M(this, un).getRollData(M(this, Di))
    ) ?? 1;
    e[r] = parseInt(e[r], 10) + o * l;
  }), e;
}, "#applyCantripScaling"), Pg = new WeakSet(), DB = /* @__PURE__ */ f(function(e) {
  var l;
  const t = M(this, Di).system.level, n = (((l = M(this, al).spell) == null ? void 0 : l.level) ?? t) - t;
  return Z(this, _r, xa).call(this, e, n);
}, "#applySpellLevelScaling"), Mg = new WeakSet(), IB = /* @__PURE__ */ f(function(e) {
  const t = M(this, al).spell;
  if (foundry.utils.isEmpty(t))
    return e;
  const { basePoints: s } = t;
  if (s >= t.points)
    return e;
  const n = Math.max(0, t.points - s);
  return Z(this, _r, xa).call(this, e, n);
}, "#applySpellPointScaling"), Rg = new WeakSet(), PB = /* @__PURE__ */ f(function(e) {
  const t = M(this, al).actionUses;
  if (foundry.utils.isEmpty(t))
    return e;
  const s = t.baseUses;
  if (s >= t.quantity)
    return e;
  const n = t.quantity - s;
  return Z(this, _r, xa).call(this, e, n);
}, "#applyActionUsesScaling"), Fg = new WeakSet(), MB = /* @__PURE__ */ f(function(e) {
  const t = M(this, al).itemUses;
  if (foundry.utils.isEmpty(t))
    return e;
  const s = t.baseUses;
  if (s >= t.quantity)
    return e;
  const n = t.quantity - s;
  return Z(this, _r, xa).call(this, e, n);
}, "#applyItemUsesScaling"), _r = new WeakSet(), xa = /* @__PURE__ */ f(function(e, t) {
  var a;
  const { shape: s, scaling: n } = e;
  if (!t || foundry.utils.isEmpty(n))
    return e;
  const l = [
    "quantity",
    ...hc.getShapeProperties(s)
  ], r = ((a = e.scaling) == null ? void 0 : a.step) || 1, o = Math.floor(t / r);
  return o === 0 || l.forEach((c) => {
    var d, p;
    const u = at(
      ((p = (d = e.scaling) == null ? void 0 : d.formula) == null ? void 0 : p[c]) ?? 0,
      M(this, un).getRollData(M(this, Di))
    ) ?? 1;
    e[c] = parseInt(e[c], 10) + u * o;
  }), e;
}, "#applyResourceBasedScaling"), f(hc, "TemplatePreparationManager");
let wa = hc;
function Gee(i) {
  let e, t, s, n, l, r, o, a = (
    /*A5E*/
    i[6].areaIcons[
      /*key*/
      i[3]
    ] + ""
  ), c, u = K(
    /*name*/
    i[4]
  ) + "", d, p, m, g;
  return {
    c() {
      var h, _;
      e = E("input"), l = R(), r = E("label"), o = E("span"), c = R(), d = x(u), b(e, "class", "area-shape__input svelte-1fg39wt"), b(e, "id", t = "area-" + /*actionId*/
      i[1] + "-" + /*key*/
      i[3]), b(e, "name", s = /*actionId*/
      i[1] + "-area-shape"), e.value = /*key*/
      i[3], b(e, "type", "radio"), e.checked = n = /*action*/
      ((_ = (h = i[0]) == null ? void 0 : h.area) == null ? void 0 : _.shape) === /*key*/
      i[3], b(o, "class", "u-text-sm"), b(r, "class", "area-shape__label svelte-1fg39wt"), b(r, "for", p = "area-" + /*actionId*/
      i[1] + "-" + /*key*/
      i[3]);
    },
    m(h, _) {
      T(h, e, _), T(h, l, _), T(h, r, _), A(r, o), o.innerHTML = a, A(r, c), A(r, d), m || (g = V(
        e,
        "click",
        /*click_handler*/
        i[8]
      ), m = !0);
    },
    p(h, [_]) {
      var y, k;
      _ & /*actionId, key*/
      10 && t !== (t = "area-" + /*actionId*/
      h[1] + "-" + /*key*/
      h[3]) && b(e, "id", t), _ & /*actionId*/
      2 && s !== (s = /*actionId*/
      h[1] + "-area-shape") && b(e, "name", s), _ & /*key*/
      8 && (e.value = /*key*/
      h[3]), _ & /*action, key*/
      9 && n !== (n = /*action*/
      ((k = (y = h[0]) == null ? void 0 : y.area) == null ? void 0 : k.shape) === /*key*/
      h[3]) && (e.checked = n), _ & /*key*/
      8 && a !== (a = /*A5E*/
      h[6].areaIcons[
        /*key*/
        h[3]
      ] + "") && (o.innerHTML = a), _ & /*name*/
      16 && u !== (u = K(
        /*name*/
        h[4]
      ) + "") && _e(d, u), _ & /*actionId, key*/
      10 && p !== (p = "area-" + /*actionId*/
      h[1] + "-" + /*key*/
      h[3]) && b(r, "for", p);
    },
    i: ee,
    o: ee,
    d(h) {
      h && (S(e), S(l), S(r)), m = !1, g();
    }
  };
}
f(Gee, "create_fragment$2L");
function zee(i, e, t) {
  let s, n = ee, l = /* @__PURE__ */ f(() => (n(), n = Et(a, (g) => t(5, s = g)), a), "$$subscribe_item");
  i.$$.on_destroy.push(() => n());
  let { action: r } = e, { actionId: o } = e, { item: a } = e;
  l();
  let { key: c } = e, { name: u } = e;
  const d = CONFIG.A5E;
  function p() {
    s.update({
      [`system.actions.${o}.area`]: {
        "-=width": null,
        "-=radius": null,
        "-=height": null,
        "-=length": null
      }
    });
  }
  f(p, "removeArea");
  const m = /* @__PURE__ */ f(({ target: g }) => {
    p(), Jd(s, `system.actions.${o}.area.shape`, g.value, `system.actions.${o}.area.quantity`);
  }, "click_handler");
  return i.$$set = (g) => {
    "action" in g && t(0, r = g.action), "actionId" in g && t(1, o = g.actionId), "item" in g && l(t(2, a = g.item)), "key" in g && t(3, c = g.key), "name" in g && t(4, u = g.name);
  }, [r, o, a, c, u, s, d, p, m];
}
f(zee, "instance$2C");
const rS = class rS extends ie {
  constructor(e) {
    super(), le(this, e, zee, Gee, ne, {
      action: 0,
      actionId: 1,
      item: 2,
      key: 3,
      name: 4
    });
  }
};
f(rS, "AreaShape");
let Q0 = rS;
function xP(i, e, t) {
  const s = i.slice();
  return s[14] = e[t], s;
}
f(xP, "get_each_context_2$2");
function eM(i, e, t) {
  const s = i.slice();
  return s[14] = e[t], s;
}
f(eM, "get_each_context_1$d");
function tM(i, e, t) {
  const s = i.slice();
  return s[14] = e[t], s;
}
f(tM, "get_each_context$11");
function Hee(i) {
  let e, t;
  return e = new bt({
    props: {
      $$slots: { default: [Wee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, scalingMode, actionId, area, $item, properties*/
      2097211 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Hee, "create_if_block_2$H");
function Uee(i) {
  let e, t;
  return e = new bt({
    props: {
      $$slots: { default: [Kee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, actionId, area, $item, properties*/
      2097179 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Uee, "create_if_block_1$14");
function Vee(i) {
  let e, t;
  return e = new bt({
    props: {
      hint: "This increment will be applied automatically based on your caster level.",
      $$slots: { default: [Yee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, properties, actionId, action, $item*/
      2097181 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Vee, "create_if_block$1A");
function sM(i) {
  let e, t, s = (
    /*property*/
    i[14].capitalize() + ""
  ), n, l, r, o, a, c, u, d, p, m;
  return {
    c() {
      var g, h, _;
      e = E("div"), t = E("label"), n = x(s), l = x(" Increment"), o = R(), a = E("input"), b(t, "for", r = /*actionId*/
      i[0] + "-area-scaling-formula"), b(t, "class", "svelte-c5p657"), b(a, "id", c = /*actionId*/
      i[0] + "-" + /*property*/
      i[14] + "-scaling-formula"), b(a, "type", "text"), b(a, "name", u = "system.actions." + /*actionId*/
      i[0] + ".area.scaling.formula." + /*property*/
      i[14]), a.value = d = /*area*/
      ((_ = (h = (g = i[1]) == null ? void 0 : g.scaling) == null ? void 0 : h.formula) == null ? void 0 : _[
        /*property*/
        i[14]
      ]) ?? 0, b(a, "class", "svelte-c5p657"), b(e, "class", "a5e-field-group a5e-field-group--formula a5e-field-group--spell-level svelte-c5p657");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(t, n), A(t, l), A(e, o), A(e, a), p || (m = V(
        a,
        "change",
        /*change_handler_3*/
        i[12]
      ), p = !0);
    },
    p(g, h) {
      var _, y, k;
      h & /*properties*/
      16 && s !== (s = /*property*/
      g[14].capitalize() + "") && _e(n, s), h & /*actionId*/
      1 && r !== (r = /*actionId*/
      g[0] + "-area-scaling-formula") && b(t, "for", r), h & /*actionId, properties*/
      17 && c !== (c = /*actionId*/
      g[0] + "-" + /*property*/
      g[14] + "-scaling-formula") && b(a, "id", c), h & /*actionId, properties*/
      17 && u !== (u = "system.actions." + /*actionId*/
      g[0] + ".area.scaling.formula." + /*property*/
      g[14]) && b(a, "name", u), h & /*area, properties*/
      18 && d !== (d = /*area*/
      ((k = (y = (_ = g[1]) == null ? void 0 : _.scaling) == null ? void 0 : y.formula) == null ? void 0 : k[
        /*property*/
        g[14]
      ]) ?? 0) && a.value !== d && (a.value = d);
    },
    d(g) {
      g && S(e), p = !1, m();
    }
  };
}
f(sM, "create_each_block_2$2");
function Wee(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _ = (
    /*scalingMode*/
    i[5] === "spellPoints" ? "Points" : "Uses"
  ), y, k, v, O = oe(
    /*properties*/
    i[4]
  ), P = [];
  for (let D = 0; D < O.length; D += 1)
    P[D] = sM(xP(i, O, D));
  return {
    c() {
      var D, I;
      e = E("section");
      for (let B = 0; B < P.length; B += 1)
        P[B].c();
      t = R(), s = E("div"), n = E("label"), l = x("Per"), o = R(), a = E("input"), p = R(), m = E("div"), g = E("span"), h = x("Additional "), y = x(_), b(n, "for", r = /*actionId*/
      i[0] + "-area-scaling-step"), b(n, "class", "svelte-c5p657"), b(a, "id", c = /*actionId*/
      i[0] + "-area-scaling-step"), z(a, "text-align", "center"), b(a, "type", "number"), b(a, "name", u = "system.actions." + /*actionId*/
      i[0] + ".area.scaling.step"), a.value = d = /*area*/
      ((I = (D = i[1]) == null ? void 0 : D.scaling) == null ? void 0 : I.step) ?? 1, b(a, "class", "svelte-c5p657"), b(s, "class", "a5e-field-group u-w-12"), b(g, "class", "levels svelte-c5p657"), b(m, "class", "a5e-field-group levels-wrapper svelte-c5p657"), b(e, "class", "row u-flex-wrap svelte-c5p657");
    },
    m(D, I) {
      T(D, e, I);
      for (let B = 0; B < P.length; B += 1)
        P[B] && P[B].m(e, null);
      A(e, t), A(e, s), A(s, n), A(n, l), A(s, o), A(s, a), A(e, p), A(e, m), A(m, g), A(g, h), A(g, y), k || (v = V(
        a,
        "change",
        /*change_handler_4*/
        i[13]
      ), k = !0);
    },
    p(D, I) {
      var B, F;
      if (I & /*actionId, properties, area, $item*/
      27) {
        O = oe(
          /*properties*/
          D[4]
        );
        let H;
        for (H = 0; H < O.length; H += 1) {
          const G = xP(D, O, H);
          P[H] ? P[H].p(G, I) : (P[H] = sM(G), P[H].c(), P[H].m(e, t));
        }
        for (; H < P.length; H += 1)
          P[H].d(1);
        P.length = O.length;
      }
      I & /*actionId*/
      1 && r !== (r = /*actionId*/
      D[0] + "-area-scaling-step") && b(n, "for", r), I & /*actionId*/
      1 && c !== (c = /*actionId*/
      D[0] + "-area-scaling-step") && b(a, "id", c), I & /*actionId*/
      1 && u !== (u = "system.actions." + /*actionId*/
      D[0] + ".area.scaling.step") && b(a, "name", u), I & /*area*/
      2 && d !== (d = /*area*/
      ((F = (B = D[1]) == null ? void 0 : B.scaling) == null ? void 0 : F.step) ?? 1) && a.value !== d && (a.value = d), I & /*scalingMode*/
      32 && _ !== (_ = /*scalingMode*/
      D[5] === "spellPoints" ? "Points" : "Uses") && _e(y, _);
    },
    d(D) {
      D && S(e), Le(P, D), k = !1, v();
    }
  };
}
f(Wee, "create_default_slot_2$o");
function nM(i) {
  let e, t, s = (
    /*property*/
    i[14].capitalize() + ""
  ), n, l, r, o, a, c, u, d, p, m;
  return {
    c() {
      var g, h, _;
      e = E("div"), t = E("label"), n = x(s), l = x(" Increment"), o = R(), a = E("input"), b(t, "for", r = /*actionId*/
      i[0] + "-" + /*property*/
      i[14] + "-scaling-formula"), b(t, "class", "svelte-c5p657"), b(a, "id", c = /*actionId*/
      i[0] + "-area-scaling-formula"), b(a, "type", "text"), b(a, "name", u = "system.actions." + /*actionId*/
      i[0] + ".area.scaling.formula." + /*property*/
      i[14]), a.value = d = /*area*/
      ((_ = (h = (g = i[1]) == null ? void 0 : g.scaling) == null ? void 0 : h.formula) == null ? void 0 : _[
        /*property*/
        i[14]
      ]) ?? 0, b(a, "class", "svelte-c5p657"), b(e, "class", "a5e-field-group a5e-field-group--formula a5e-field-group--spell-level svelte-c5p657");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(t, n), A(t, l), A(e, o), A(e, a), p || (m = V(
        a,
        "change",
        /*change_handler_1*/
        i[10]
      ), p = !0);
    },
    p(g, h) {
      var _, y, k;
      h & /*properties*/
      16 && s !== (s = /*property*/
      g[14].capitalize() + "") && _e(n, s), h & /*actionId, properties*/
      17 && r !== (r = /*actionId*/
      g[0] + "-" + /*property*/
      g[14] + "-scaling-formula") && b(t, "for", r), h & /*actionId*/
      1 && c !== (c = /*actionId*/
      g[0] + "-area-scaling-formula") && b(a, "id", c), h & /*actionId, properties*/
      17 && u !== (u = "system.actions." + /*actionId*/
      g[0] + ".area.scaling.formula." + /*property*/
      g[14]) && b(a, "name", u), h & /*area, properties*/
      18 && d !== (d = /*area*/
      ((k = (y = (_ = g[1]) == null ? void 0 : _.scaling) == null ? void 0 : y.formula) == null ? void 0 : k[
        /*property*/
        g[14]
      ]) ?? 0) && a.value !== d && (a.value = d);
    },
    d(g) {
      g && S(e), p = !1, m();
    }
  };
}
f(nM, "create_each_block_1$d");
function Kee(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _ = oe(
    /*properties*/
    i[4]
  ), y = [];
  for (let k = 0; k < _.length; k += 1)
    y[k] = nM(eM(i, _, k));
  return {
    c() {
      var k, v;
      e = E("section");
      for (let O = 0; O < y.length; O += 1)
        y[O].c();
      t = R(), s = E("div"), n = E("label"), l = x("Per"), o = R(), a = E("input"), p = R(), m = E("div"), m.innerHTML = '<span class="levels svelte-c5p657">Levels</span>', b(n, "for", r = /*actionId*/
      i[0] + "-area-scaling-step"), b(n, "class", "svelte-c5p657"), b(a, "id", c = /*actionId*/
      i[0] + "-area-scaling-step"), z(a, "text-align", "center"), b(a, "type", "number"), b(a, "name", u = "system.actions." + /*actionId*/
      i[0] + ".area.scaling.step"), a.value = d = /*area*/
      ((v = (k = i[1]) == null ? void 0 : k.scaling) == null ? void 0 : v.step) ?? 1, b(a, "class", "svelte-c5p657"), b(s, "class", "a5e-field-group u-w-12"), b(m, "class", "a5e-field-group levels-wrapper svelte-c5p657"), b(e, "class", "row u-flex-wrap svelte-c5p657");
    },
    m(k, v) {
      T(k, e, v);
      for (let O = 0; O < y.length; O += 1)
        y[O] && y[O].m(e, null);
      A(e, t), A(e, s), A(s, n), A(n, l), A(s, o), A(s, a), A(e, p), A(e, m), g || (h = V(
        a,
        "change",
        /*change_handler_2*/
        i[11]
      ), g = !0);
    },
    p(k, v) {
      var O, P;
      if (v & /*actionId, properties, area, $item*/
      27) {
        _ = oe(
          /*properties*/
          k[4]
        );
        let D;
        for (D = 0; D < _.length; D += 1) {
          const I = eM(k, _, D);
          y[D] ? y[D].p(I, v) : (y[D] = nM(I), y[D].c(), y[D].m(e, t));
        }
        for (; D < y.length; D += 1)
          y[D].d(1);
        y.length = _.length;
      }
      v & /*actionId*/
      1 && r !== (r = /*actionId*/
      k[0] + "-area-scaling-step") && b(n, "for", r), v & /*actionId*/
      1 && c !== (c = /*actionId*/
      k[0] + "-area-scaling-step") && b(a, "id", c), v & /*actionId*/
      1 && u !== (u = "system.actions." + /*actionId*/
      k[0] + ".area.scaling.step") && b(a, "name", u), v & /*area*/
      2 && d !== (d = /*area*/
      ((P = (O = k[1]) == null ? void 0 : O.scaling) == null ? void 0 : P.step) ?? 1) && a.value !== d && (a.value = d);
    },
    d(k) {
      k && S(e), Le(y, k), g = !1, h();
    }
  };
}
f(Kee, "create_default_slot_1$w");
function iM(i) {
  let e, t, s = (
    /*property*/
    i[14].capitalize() + ""
  ), n, l, r, o, a, c, u, d, p, m;
  return {
    c() {
      var g, h;
      e = E("div"), t = E("label"), n = x(s), l = x(" Increment"), o = R(), a = E("input"), d = R(), b(t, "for", r = /*actionId*/
      i[0] + "-" + /*property*/
      i[14] + "-scaling-formula"), b(t, "class", "svelte-c5p657"), b(a, "class", "a5e-input svelte-c5p657"), b(a, "type", "text"), b(a, "name", c = "system.actions." + /*actionId*/
      i[0] + ".area.scaling.formula." + /*property*/
      i[14]), a.value = u = /*action*/
      ((h = (g = i[2].area.scaling) == null ? void 0 : g.formula) == null ? void 0 : h[
        /*property*/
        i[14]
      ]) ?? 0, b(e, "class", "a5e-field-group a5e-field-group--formula a5e-field-group--spell-level svelte-c5p657");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(t, n), A(t, l), A(e, o), A(e, a), A(e, d), p || (m = V(
        a,
        "change",
        /*change_handler*/
        i[9]
      ), p = !0);
    },
    p(g, h) {
      var _, y;
      h & /*properties*/
      16 && s !== (s = /*property*/
      g[14].capitalize() + "") && _e(n, s), h & /*actionId, properties*/
      17 && r !== (r = /*actionId*/
      g[0] + "-" + /*property*/
      g[14] + "-scaling-formula") && b(t, "for", r), h & /*actionId, properties*/
      17 && c !== (c = "system.actions." + /*actionId*/
      g[0] + ".area.scaling.formula." + /*property*/
      g[14]) && b(a, "name", c), h & /*action, properties*/
      20 && u !== (u = /*action*/
      ((y = (_ = g[2].area.scaling) == null ? void 0 : _.formula) == null ? void 0 : y[
        /*property*/
        g[14]
      ]) ?? 0) && a.value !== u && (a.value = u);
    },
    d(g) {
      g && S(e), p = !1, m();
    }
  };
}
f(iM, "create_each_block$11");
function Yee(i) {
  let e, t = oe(
    /*properties*/
    i[4]
  ), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = iM(tM(i, t, n));
  return {
    c() {
      e = E("section");
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      b(e, "class", "row u-flex-wrap svelte-c5p657");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l & /*actionId, properties, action, $item*/
      29) {
        t = oe(
          /*properties*/
          n[4]
        );
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = tM(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = iM(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && S(e), Le(s, n);
    }
  };
}
f(Yee, "create_default_slot$17");
function Xee(i) {
  let e, t, s, n, l, r, o;
  t = new Ye({
    props: {
      heading: "Scaling Mode",
      options: Jee(),
      selected: (
        /*scalingMode*/
        i[5]
      ),
      allowDeselect: !1
    }
  }), t.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[8]
  );
  const a = [Vee, Uee, Hee], c = [];
  function u(d, p) {
    return p & /*scalingMode*/
    32 && (n = null), /*scalingMode*/
    d[5] === "cantrip" ? 0 : (
      /*scalingMode*/
      d[5] === "spellLevel" ? 1 : (n == null && (n = !!["spellPoints", "actionUses", "itemUses"].includes(
        /*scalingMode*/
        d[5]
      )), n ? 2 : -1)
    );
  }
  return f(u, "select_block_type"), ~(l = u(i, -1)) && (r = c[l] = a[l](i)), {
    c() {
      e = E("form"), L(t.$$.fragment), s = R(), r && r.c(), b(e, "class", "svelte-c5p657");
    },
    m(d, p) {
      T(d, e, p), N(t, e, null), A(e, s), ~l && c[l].m(e, null), o = !0;
    },
    p(d, [p]) {
      const m = {};
      p & /*scalingMode*/
      32 && (m.selected = /*scalingMode*/
      d[5]), t.$set(m);
      let g = l;
      l = u(d, p), l === g ? ~l && c[l].p(d, p) : (r && (ce(), C(c[g], 1, 1, () => {
        c[g] = null;
      }), ue()), ~l ? (r = c[l], r ? r.p(d, p) : (r = c[l] = a[l](d), r.c()), w(r, 1), r.m(e, null)) : r = null);
    },
    i(d) {
      o || (w(t.$$.fragment, d), w(r), o = !0);
    },
    o(d) {
      C(t.$$.fragment, d), C(r), o = !1;
    },
    d(d) {
      d && S(e), j(t), ~l && c[l].d();
    }
  };
}
f(Xee, "create_fragment$2K");
function Jee() {
  return [[null, "A5E.None"], ...Object.entries(CONFIG.A5E.targetScalingModes)];
}
f(Jee, "getScalingOptions");
function Zee(i, e, t) {
  let s, n, l, r, o, { document: a, actionId: c } = fe("#external").application, { document: u = a, actionId: d = c } = e;
  const p = u;
  pe(i, p, (v) => t(3, o = v));
  const m = /* @__PURE__ */ f((v) => {
    se(o, `system.actions.${d}.area.scaling.mode`, v.detail);
  }, "updateSelection_handler"), g = /* @__PURE__ */ f(({ target: v }) => se(o, v.name, v.value), "change_handler"), h = /* @__PURE__ */ f(({ target: v }) => se(o, v.name, v.value), "change_handler_1"), _ = /* @__PURE__ */ f(({ target: v }) => se(o, v.name, parseInt(v.value, 10)), "change_handler_2"), y = /* @__PURE__ */ f(({ target: v }) => se(o, v.name, v.value), "change_handler_3"), k = /* @__PURE__ */ f(({ target: v }) => se(o, v.name, parseInt(v.value, 10)), "change_handler_4");
  return i.$$set = (v) => {
    "document" in v && t(7, u = v.document), "actionId" in v && t(0, d = v.actionId);
  }, i.$$.update = () => {
    var v;
    i.$$.dirty & /*$item, actionId*/
    9 && t(2, s = o.actions[d]), i.$$.dirty & /*action*/
    4 && t(1, n = s.area ?? {}), i.$$.dirty & /*area*/
    2 && t(5, l = ((v = n == null ? void 0 : n.scaling) == null ? void 0 : v.mode) ?? null), i.$$.dirty & /*area*/
    2 && t(4, r = ["quantity", ...wa.getShapeProperties(n == null ? void 0 : n.shape)]);
  }, [
    d,
    n,
    s,
    o,
    r,
    l,
    p,
    u,
    m,
    g,
    h,
    _,
    y,
    k
  ];
}
f(Zee, "instance$2B");
const oS = class oS extends ie {
  constructor(e) {
    super(), le(this, e, Zee, Xee, ne, { document: 7, actionId: 0 });
  }
};
f(oS, "TemplateScalingDialog");
let x0 = oS;
function lM(i, e, t) {
  const s = i.slice();
  return s[17] = e[t][0], s[18] = e[t][1], s;
}
f(lM, "get_each_context$10");
function rM(i, e) {
  let t, s, n;
  return s = new Q0({
    props: {
      action: (
        /*action*/
        e[0]
      ),
      actionId: (
        /*actionId*/
        e[1]
      ),
      item: (
        /*item*/
        e[2]
      ),
      key: (
        /*key*/
        e[17]
      ),
      name: (
        /*name*/
        e[18]
      )
    }
  }), {
    key: i,
    first: null,
    c() {
      t = $e(), L(s.$$.fragment), this.first = t;
    },
    m(l, r) {
      T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      e = l;
      const o = {};
      r & /*action*/
      1 && (o.action = /*action*/
      e[0]), r & /*actionId*/
      2 && (o.actionId = /*actionId*/
      e[1]), r & /*item*/
      4 && (o.item = /*item*/
      e[2]), s.$set(o);
    },
    i(l) {
      n || (w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(s, l);
    }
  };
}
f(rM, "create_each_block$10");
function oM(i) {
  let e, t, s, n, l = (
    /*getShapeProperties*/
    i[8](
      /*action*/
      i[0].area.shape
    ).includes("radius")
  ), r, o = (
    /*getShapeProperties*/
    i[8](
      /*action*/
      i[0].area.shape
    ).includes("length")
  ), a, c = (
    /*getShapeProperties*/
    i[8](
      /*action*/
      i[0].area.shape
    ).includes("width")
  ), u, d = (
    /*getShapeProperties*/
    i[8](
      /*action*/
      i[0].area.shape
    ).includes("height")
  ), p, m, g, h, _;
  t = new de({
    props: {
      heading: "A5E.ItemQuantity",
      $$slots: { default: [Qee] },
      $$scope: { ctx: i }
    }
  });
  let y = l && aM(i), k = o && cM(i), v = c && uM(i), O = d && fM(i), P = (
    /*action*/
    i[0].area.shape && dM(i)
  );
  function D(F, H) {
    var G, U, q, W, X, te, J, re;
    if (H & /*action*/
    1 && (g = null), /*action*/
    ((U = (G = F[0].area) == null ? void 0 : G.scaling) == null ? void 0 : U.mode) === "cantrip")
      return nte;
    if (
      /*action*/
      ((W = (q = F[0].area) == null ? void 0 : q.scaling) == null ? void 0 : W.mode) === "spellLevel"
    )
      return ste;
    if (
      /*action*/
      ((te = (X = F[0].area) == null ? void 0 : X.scaling) == null ? void 0 : te.mode) === "spellPoints"
    )
      return tte;
    if (g == null && (g = !!["actionUses", "itemUses"].includes(
      /*action*/
      (re = (J = F[0].area) == null ? void 0 : J.scaling) == null ? void 0 : re.mode
    )), g)
      return ete;
  }
  f(D, "select_block_type");
  let I = D(i, -1), B = I && I(i);
  return {
    c() {
      e = E("div"), s = E("div"), L(t.$$.fragment), n = R(), y && y.c(), r = R(), k && k.c(), a = R(), v && v.c(), u = R(), O && O.c(), p = R(), P && P.c(), m = R(), B && B.c(), h = $e(), z(s, "display", "contents"), z(s, "--a5e-field-wrapper-width", "7.5rem"), b(e, "class", "u-flex u-gap-md u-w-full");
    },
    m(F, H) {
      T(F, e, H), A(e, s), N(t, s, null), A(e, n), y && y.m(e, null), A(e, r), k && k.m(e, null), A(e, a), v && v.m(e, null), A(e, u), O && O.m(e, null), A(e, p), P && P.m(e, null), T(F, m, H), B && B.m(F, H), T(F, h, H), _ = !0;
    },
    p(F, H) {
      const G = {};
      H & /*$$scope, actionId, action, $item*/
      2097163 && (G.$$scope = { dirty: H, ctx: F }), t.$set(G), H & /*action*/
      1 && (l = /*getShapeProperties*/
      F[8](
        /*action*/
        F[0].area.shape
      ).includes("radius")), l ? y ? (y.p(F, H), H & /*action*/
      1 && w(y, 1)) : (y = aM(F), y.c(), w(y, 1), y.m(e, r)) : y && (ce(), C(y, 1, 1, () => {
        y = null;
      }), ue()), H & /*action*/
      1 && (o = /*getShapeProperties*/
      F[8](
        /*action*/
        F[0].area.shape
      ).includes("length")), o ? k ? k.p(F, H) : (k = cM(F), k.c(), k.m(e, a)) : k && (k.d(1), k = null), H & /*action*/
      1 && (c = /*getShapeProperties*/
      F[8](
        /*action*/
        F[0].area.shape
      ).includes("width")), c ? v ? v.p(F, H) : (v = uM(F), v.c(), v.m(e, u)) : v && (v.d(1), v = null), H & /*action*/
      1 && (d = /*getShapeProperties*/
      F[8](
        /*action*/
        F[0].area.shape
      ).includes("height")), d ? O ? O.p(F, H) : (O = fM(F), O.c(), O.m(e, p)) : O && (O.d(1), O = null), /*action*/
      F[0].area.shape ? P ? P.p(F, H) : (P = dM(F), P.c(), P.m(e, null)) : P && (P.d(1), P = null), I === (I = D(F, H)) && B ? B.p(F, H) : (B && B.d(1), B = I && I(F), B && (B.c(), B.m(h.parentNode, h)));
    },
    i(F) {
      _ || (w(t.$$.fragment, F), w(y), _ = !0);
    },
    o(F) {
      C(t.$$.fragment, F), C(y), _ = !1;
    },
    d(F) {
      F && (S(e), S(m), S(h)), j(t), y && y.d(), k && k.d(), v && v.d(), O && O.d(), P && P.d(), B && B.d(F);
    }
  };
}
f(oM, "create_if_block_1$13");
function Qee(i) {
  let e, t, s, n, l;
  return {
    c() {
      var r;
      e = E("input"), b(e, "id", t = /*actionId*/
      i[1] + "-area-quantity"), b(e, "type", "number"), e.value = s = /*action*/
      ((r = i[0].area) == null ? void 0 : r.quantity) ?? 1;
    },
    m(r, o) {
      T(r, e, o), n || (l = V(
        e,
        "change",
        /*change_handler*/
        i[10]
      ), n = !0);
    },
    p(r, o) {
      var a;
      o & /*actionId*/
      2 && t !== (t = /*actionId*/
      r[1] + "-area-quantity") && b(e, "id", t), o & /*action*/
      1 && s !== (s = /*action*/
      ((a = r[0].area) == null ? void 0 : a.quantity) ?? 1) && e.value !== s && (e.value = s);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(Qee, "create_default_slot_3$k");
function aM(i) {
  let e, t, s;
  return e = new de({
    props: {
      heading: "Radius",
      $$slots: { default: [xee] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-width", "7.5rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, actionId, action, $item*/
      2097163 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(aM, "create_if_block_13$2");
function xee(i) {
  let e, t, s, n, l;
  return {
    c() {
      var r;
      e = E("input"), b(e, "id", t = /*actionId*/
      i[1] + "-area-radius"), b(e, "type", "number"), e.value = s = /*action*/
      ((r = i[0].area) == null ? void 0 : r.radius) ?? 0;
    },
    m(r, o) {
      T(r, e, o), n || (l = V(
        e,
        "change",
        /*change_handler_1*/
        i[11]
      ), n = !0);
    },
    p(r, o) {
      var a;
      o & /*actionId*/
      2 && t !== (t = /*actionId*/
      r[1] + "-area-radius") && b(e, "id", t), o & /*action*/
      1 && s !== (s = /*action*/
      ((a = r[0].area) == null ? void 0 : a.radius) ?? 0) && e.value !== s && (e.value = s);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(xee, "create_default_slot_2$n");
function cM(i) {
  let e, t, s, n, l, r, o, a, c, u;
  return {
    c() {
      var d;
      e = E("div"), t = E("label"), s = x("Length"), l = R(), r = E("input"), b(t, "for", n = /*actionId*/
      i[1] + "-area-length"), b(r, "id", o = /*actionId*/
      i[1] + "-area-length"), b(r, "type", "number"), r.value = a = /*action*/
      ((d = i[0].area) == null ? void 0 : d.length) ?? 0, b(e, "class", "u-flex u-flex-col u-gap-xs u-w-30");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(t, s), A(e, l), A(e, r), c || (u = V(
        r,
        "change",
        /*change_handler_2*/
        i[12]
      ), c = !0);
    },
    p(d, p) {
      var m;
      p & /*actionId*/
      2 && n !== (n = /*actionId*/
      d[1] + "-area-length") && b(t, "for", n), p & /*actionId*/
      2 && o !== (o = /*actionId*/
      d[1] + "-area-length") && b(r, "id", o), p & /*action*/
      1 && a !== (a = /*action*/
      ((m = d[0].area) == null ? void 0 : m.length) ?? 0) && r.value !== a && (r.value = a);
    },
    d(d) {
      d && S(e), c = !1, u();
    }
  };
}
f(cM, "create_if_block_12$3");
function uM(i) {
  let e, t, s, n, l, r, o, a, c, u;
  return {
    c() {
      var d;
      e = E("div"), t = E("label"), s = x("Width"), l = R(), r = E("input"), b(t, "for", n = /*actionId*/
      i[1] + "-area-width"), b(r, "id", o = /*actionId*/
      i[1] + "-area-width"), b(r, "type", "number"), r.value = a = /*action*/
      ((d = i[0].area) == null ? void 0 : d.width) ?? 0, b(e, "class", "u-flex u-flex-col u-gap-xs u-w-30");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(t, s), A(e, l), A(e, r), c || (u = V(
        r,
        "change",
        /*change_handler_3*/
        i[13]
      ), c = !0);
    },
    p(d, p) {
      var m;
      p & /*actionId*/
      2 && n !== (n = /*actionId*/
      d[1] + "-area-width") && b(t, "for", n), p & /*actionId*/
      2 && o !== (o = /*actionId*/
      d[1] + "-area-width") && b(r, "id", o), p & /*action*/
      1 && a !== (a = /*action*/
      ((m = d[0].area) == null ? void 0 : m.width) ?? 0) && r.value !== a && (r.value = a);
    },
    d(d) {
      d && S(e), c = !1, u();
    }
  };
}
f(uM, "create_if_block_11$3");
function fM(i) {
  let e, t, s, n, l, r, o, a, c, u;
  return {
    c() {
      var d;
      e = E("div"), t = E("label"), s = x("Height"), l = R(), r = E("input"), b(t, "for", n = /*actionId*/
      i[1] + "-area-height"), b(r, "id", o = /*actionId*/
      i[1] + "-area-height"), b(r, "type", "number"), r.value = a = /*action*/
      ((d = i[0].area) == null ? void 0 : d.height) ?? 0, b(e, "class", "u-flex u-flex-col u-gap-xs u-w-30");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(t, s), A(e, l), A(e, r), c || (u = V(
        r,
        "change",
        /*change_handler_4*/
        i[14]
      ), c = !0);
    },
    p(d, p) {
      var m;
      p & /*actionId*/
      2 && n !== (n = /*actionId*/
      d[1] + "-area-height") && b(t, "for", n), p & /*actionId*/
      2 && o !== (o = /*actionId*/
      d[1] + "-area-height") && b(r, "id", o), p & /*action*/
      1 && a !== (a = /*action*/
      ((m = d[0].area) == null ? void 0 : m.height) ?? 0) && r.value !== a && (r.value = a);
    },
    d(d) {
      d && S(e), c = !1, u();
    }
  };
}
f(fM, "create_if_block_10$4");
function dM(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("div"), t = E("button"), t.innerHTML = '<i class="fa-solid fa-arrow-up-right-dots svelte-ucrfrz" data-tooltip="A5E.ConfigureAreaScaling" data-tooltip-direction="UP"></i>', b(t, "class", "scaling-button svelte-ucrfrz"), b(e, "class", "a5e-field-group scaling-button-wrapper svelte-ucrfrz");
    },
    m(l, r) {
      T(l, e, r), A(e, t), s || (n = V(t, "click", tt(
        /*onClickScalingButton*/
        i[4]
      )), s = !0);
    },
    p: ee,
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(dM, "create_if_block_9$7");
function ete(i) {
  let e;
  function t(l, r) {
    var o, a, c, u;
    return !/*action*/
    ((a = (o = l[0].area) == null ? void 0 : o.scaling) != null && a.step) || /*action*/
    ((u = (c = l[0].area) == null ? void 0 : c.scaling) == null ? void 0 : u.step) === 1 ? lte : ite;
  }
  f(t, "select_block_type_3");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("small"), n.c();
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    d(l) {
      l && S(e), n.d();
    }
  };
}
f(ete, "create_if_block_7$a");
function tte(i) {
  let e;
  function t(l, r) {
    var o, a, c, u;
    return !/*action*/
    ((a = (o = l[0].area) == null ? void 0 : o.scaling) != null && a.step) || /*action*/
    ((u = (c = l[0].area) == null ? void 0 : c.scaling) == null ? void 0 : u.step) === 1 ? ote : rte;
  }
  f(t, "select_block_type_2");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("small"), n.c();
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    d(l) {
      l && S(e), n.d();
    }
  };
}
f(tte, "create_if_block_5$f");
function ste(i) {
  let e;
  function t(l, r) {
    var o, a, c, u;
    return !/*action*/
    ((a = (o = l[0].area) == null ? void 0 : o.scaling) != null && a.step) || /*action*/
    ((u = (c = l[0].area) == null ? void 0 : c.scaling) == null ? void 0 : u.step) === 1 ? cte : ate;
  }
  f(t, "select_block_type_1");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("small"), n.c();
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    d(l) {
      l && S(e), n.d();
    }
  };
}
f(ste, "create_if_block_3$r");
function nte(i) {
  let e, t = (
    /*getLocalization*/
    i[5](
      "cantrip",
      /*action*/
      i[0].area
    ) + ""
  ), s;
  return {
    c() {
      e = E("small"), s = x(t);
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*action*/
      1 && t !== (t = /*getLocalization*/
      n[5](
        "cantrip",
        /*action*/
        n[0].area
      ) + "") && _e(s, t);
    },
    d(n) {
      n && S(e);
    }
  };
}
f(nte, "create_if_block_2$G");
function ite(i) {
  let e = (
    /*getLocalization*/
    i[5](
      "steppedSpellLevel",
      /*action*/
      i[0].area
    ) + ""
  ), t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*action*/
      1 && e !== (e = /*getLocalization*/
      s[5](
        "steppedSpellLevel",
        /*action*/
        s[0].area
      ) + "") && _e(t, e);
    },
    d(s) {
      s && S(t);
    }
  };
}
f(ite, "create_else_block_2$3");
function lte(i) {
  let e = (
    /*getLocalization*/
    i[5](
      "steppedSpellLevel",
      /*action*/
      i[0].area
    ) + ""
  ), t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*action*/
      1 && e !== (e = /*getLocalization*/
      s[5](
        "steppedSpellLevel",
        /*action*/
        s[0].area
      ) + "") && _e(t, e);
    },
    d(s) {
      s && S(t);
    }
  };
}
f(lte, "create_if_block_8$8");
function rte(i) {
  let e = (
    /*getLocalization*/
    i[5](
      "steppedSpellPoint",
      /*action*/
      i[0].area
    ) + ""
  ), t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*action*/
      1 && e !== (e = /*getLocalization*/
      s[5](
        "steppedSpellPoint",
        /*action*/
        s[0].area
      ) + "") && _e(t, e);
    },
    d(s) {
      s && S(t);
    }
  };
}
f(rte, "create_else_block_1$6");
function ote(i) {
  let e = (
    /*getLocalization*/
    i[5](
      "spellPoint",
      /*action*/
      i[0].area
    ) + ""
  ), t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*action*/
      1 && e !== (e = /*getLocalization*/
      s[5](
        "spellPoint",
        /*action*/
        s[0].area
      ) + "") && _e(t, e);
    },
    d(s) {
      s && S(t);
    }
  };
}
f(ote, "create_if_block_6$e");
function ate(i) {
  let e = (
    /*getLocalization*/
    i[5](
      "steppedSpellLevel",
      /*action*/
      i[0].area
    ) + ""
  ), t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*action*/
      1 && e !== (e = /*getLocalization*/
      s[5](
        "steppedSpellLevel",
        /*action*/
        s[0].area
      ) + "") && _e(t, e);
    },
    d(s) {
      s && S(t);
    }
  };
}
f(ate, "create_else_block$w");
function cte(i) {
  let e = (
    /*getLocalization*/
    i[5](
      "spellLevel",
      /*action*/
      i[0].area
    ) + ""
  ), t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*action*/
      1 && e !== (e = /*getLocalization*/
      s[5](
        "spellLevel",
        /*action*/
        s[0].area
      ) + "") && _e(t, e);
    },
    d(s) {
      s && S(t);
    }
  };
}
f(cte, "create_if_block_4$m");
function pM(i) {
  let e, t;
  return e = new de({
    props: {
      $$slots: { default: [ute] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, action, $item, actionId*/
      2097163 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(pM, "create_if_block$1z");
function ute(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.ItemPlaceTemplate",
      checked: (
        /*action*/
        ((s = i[0].area) == null ? void 0 : s.placeTemplate) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[15]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*action*/
      1 && (r.checked = /*action*/
      ((o = n[0].area) == null ? void 0 : o.placeTemplate) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(ute, "create_default_slot_1$v");
function fte(i) {
  var H, G;
  let e, t, s, n, l, r, o, a, c, u = K("A5E.None") + "", d, p, m, g = [], h = /* @__PURE__ */ new Map(), _, y, k, v, O, P, D = oe(Object.entries(
    /*A5E*/
    i[7].areaTypes
  ));
  const I = /* @__PURE__ */ f((U) => (
    /*key*/
    U[17]
  ), "get_key");
  for (let U = 0; U < D.length; U += 1) {
    let q = lM(i, D, U), W = I(q);
    h.set(W, g[U] = rM(W, q));
  }
  let B = (
    /*action*/
    ((H = i[0].area) == null ? void 0 : H.shape) && oM(i)
  ), F = (
    /*action*/
    ((G = i[0].area) == null ? void 0 : G.shape) && pM(i)
  );
  return {
    c() {
      e = E("div"), t = E("input"), r = R(), o = E("label"), a = E("span"), a.innerHTML = '<i class="fas fa-times-circle"></i>', c = R(), d = x(u), m = R();
      for (let U = 0; U < g.length; U += 1)
        g[U].c();
      _ = R(), B && B.c(), y = R(), F && F.c(), k = $e(), b(t, "class", "area-shape-input svelte-ucrfrz"), b(t, "id", s = "area-" + /*actionId*/
      i[1] + "-none"), b(t, "name", n = /*actionId*/
      i[1] + "-area-shape"), t.value = null, b(t, "type", "radio"), t.checked = l = /*isEmpty*/
      i[9](
        /*action*/
        i[0].area
      ), b(a, "class", "u-text-sm"), b(o, "class", "area-shape-label svelte-ucrfrz"), b(o, "for", p = "area-" + /*actionId*/
      i[1] + "-none"), b(e, "class", "area-shape-list svelte-ucrfrz");
    },
    m(U, q) {
      T(U, e, q), A(e, t), A(e, r), A(e, o), A(o, a), A(o, c), A(o, d), A(e, m);
      for (let W = 0; W < g.length; W += 1)
        g[W] && g[W].m(e, null);
      T(U, _, q), B && B.m(U, q), T(U, y, q), F && F.m(U, q), T(U, k, q), v = !0, O || (P = V(
        t,
        "change",
        /*removeArea*/
        i[6]
      ), O = !0);
    },
    p(U, q) {
      var W, X;
      (!v || q & /*actionId*/
      2 && s !== (s = "area-" + /*actionId*/
      U[1] + "-none")) && b(t, "id", s), (!v || q & /*actionId*/
      2 && n !== (n = /*actionId*/
      U[1] + "-area-shape")) && b(t, "name", n), (!v || q & /*action*/
      1 && l !== (l = /*isEmpty*/
      U[9](
        /*action*/
        U[0].area
      ))) && (t.checked = l), (!v || q & /*actionId*/
      2 && p !== (p = "area-" + /*actionId*/
      U[1] + "-none")) && b(o, "for", p), q & /*action, actionId, item, Object, A5E*/
      135 && (D = oe(Object.entries(
        /*A5E*/
        U[7].areaTypes
      )), ce(), g = kt(g, q, I, 1, U, D, h, e, ks, rM, null, lM), ue()), /*action*/
      (W = U[0].area) != null && W.shape ? B ? (B.p(U, q), q & /*action*/
      1 && w(B, 1)) : (B = oM(U), B.c(), w(B, 1), B.m(y.parentNode, y)) : B && (ce(), C(B, 1, 1, () => {
        B = null;
      }), ue()), /*action*/
      (X = U[0].area) != null && X.shape ? F ? (F.p(U, q), q & /*action*/
      1 && w(F, 1)) : (F = pM(U), F.c(), w(F, 1), F.m(k.parentNode, k)) : F && (ce(), C(F, 1, 1, () => {
        F = null;
      }), ue());
    },
    i(U) {
      if (!v) {
        for (let q = 0; q < D.length; q += 1)
          w(g[q]);
        w(B), w(F), v = !0;
      }
    },
    o(U) {
      for (let q = 0; q < g.length; q += 1)
        C(g[q]);
      C(B), C(F), v = !1;
    },
    d(U) {
      U && (S(e), S(_), S(y), S(k));
      for (let q = 0; q < g.length; q += 1)
        g[q].d();
      B && B.d(U), F && F.d(U), O = !1, P();
    }
  };
}
f(fte, "create_default_slot$16");
function dte(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "A5E.ItemAreaShape",
      $$slots: { default: [fte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem"), z(t, "--a5e-section-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, action, $item, actionId, item*/
      2097167 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(dte, "create_fragment$2J");
function pte(i, e, t) {
  let s, n, l = ee, r = /* @__PURE__ */ f(() => (l(), l = Et(c, (D) => t(3, n = D)), c), "$$subscribe_item");
  i.$$.on_destroy.push(() => l());
  let { action: o } = e, { actionId: a } = e, { item: c } = e;
  r();
  function u() {
    let D = n.dialogs.areaScaling[a];
    D || (fl(c, n.dialogs.areaScaling[a] = new gn(n, `${n.name} Target Scaling Configuration`, x0, { actionId: a }), n), D = n.dialogs.areaScaling[a]), D.render(!0);
  }
  f(u, "onClickScalingButton");
  function d(D) {
    var I, B, F, H, G, U, q, W, X, te;
    if (s.length === 1)
      return K(`A5E.scaling.summaries.${D}.template`, {
        shape: o == null ? void 0 : o.area.shape,
        formula: ((B = (I = o == null ? void 0 : o.area.scaling) == null ? void 0 : I.formula) == null ? void 0 : B[s[0]]) ?? 0,
        property: s[0],
        unit: "feet",
        level: Li(n.system.level ?? 0),
        step: (H = (F = o.area) == null ? void 0 : F.scaling) == null ? void 0 : H.step
      });
    if (s.length === 2)
      return K(`A5E.scaling.summaries.${D}.templateMulti`, {
        shape: o == null ? void 0 : o.area.shape,
        formula1: ((U = (G = o.area.scaling) == null ? void 0 : G.formula) == null ? void 0 : U[s[0]]) ?? 0,
        formula2: ((W = (q = o.area.scaling) == null ? void 0 : q.formula) == null ? void 0 : W[s[1]]) ?? 0,
        property1: s[0],
        property2: s[1],
        unit: "feet",
        level: Li(n.system.level ?? 0),
        step: (te = (X = o.area) == null ? void 0 : X.scaling) == null ? void 0 : te.step
      });
  }
  f(d, "getLocalization");
  function p() {
    n.update({
      [`system.actions.${a}`]: { "-=area": null }
    });
  }
  f(p, "removeArea");
  const { A5E: m } = CONFIG, g = wa.getShapeProperties, { isEmpty: h } = foundry.utils, _ = /* @__PURE__ */ f(({ target: D }) => se(n, `system.actions.${a}.area.quantity`, Number(D.value)), "change_handler"), y = /* @__PURE__ */ f(({ target: D }) => se(n, `system.actions.${a}.area.radius`, Number(D.value)), "change_handler_1"), k = /* @__PURE__ */ f(({ target: D }) => se(n, `system.actions.${a}.area.length`, Number(D.value)), "change_handler_2"), v = /* @__PURE__ */ f(({ target: D }) => se(n, `system.actions.${a}.area.width`, Number(D.value)), "change_handler_3"), O = /* @__PURE__ */ f(({ target: D }) => se(n, `system.actions.${a}.area.height`, Number(D.value)), "change_handler_4"), P = /* @__PURE__ */ f(({ detail: D }) => {
    se(n, `system.actions.${a}.area.placeTemplate`, D);
  }, "updateSelection_handler");
  return i.$$set = (D) => {
    "action" in D && t(0, o = D.action), "actionId" in D && t(1, a = D.actionId), "item" in D && r(t(2, c = D.item));
  }, i.$$.update = () => {
    var D;
    i.$$.dirty & /*action*/
    1 && (s = [...g((D = o.area) == null ? void 0 : D.shape)]);
  }, [
    o,
    a,
    c,
    n,
    u,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    k,
    v,
    O,
    P
  ];
}
f(pte, "instance$2A");
const aS = class aS extends ie {
  constructor(e) {
    super(), le(this, e, pte, dte, ne, { action: 0, actionId: 1, item: 2 });
  }
};
f(aS, "AreaConfig");
let ev = aS;
function pd(i) {
  return i !== "other" && Object.keys(CONFIG.A5E.rangeDescriptors).includes(i);
}
f(pd, "isStandardRange");
function mM(i, e, t) {
  const s = i.slice();
  return s[21] = e[t][0], s[22] = e[t][1], s;
}
f(mM, "get_each_context$$");
function hM(i) {
  let e, t, s, n, l;
  return e = new De({
    props: {
      label: "A5E.IncludeUnit",
      checked: (
        /*includeUnit*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[17]
  ), s = new Me({
    props: {
      hint: (
        /*includeUnit*/
        i[3] ? "When units are selected range must be a number." : null
      ),
      $$slots: { default: [mte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), n = E("div"), L(s.$$.fragment), z(n, "display", "contents"), z(n, "--a5e-section-body-padding", "0");
    },
    m(r, o) {
      N(e, r, o), T(r, t, o), T(r, n, o), N(s, n, null), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*includeUnit*/
      8 && (a.checked = /*includeUnit*/
      r[3]), e.$set(a);
      const c = {};
      o & /*includeUnit*/
      8 && (c.hint = /*includeUnit*/
      r[3] ? "When units are selected range must be a number." : null), o & /*$$scope, id, rangeObject, includeUnit, customValue*/
      33554447 && (c.$$scope = { dirty: o, ctx: r }), s.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(s.$$.fragment, r), l = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(s.$$.fragment, r), l = !1;
    },
    d(r) {
      r && S(t), j(e, r), r && s && S(n), j(s, r);
    }
  };
}
f(hM, "create_if_block$1y");
function gM(i) {
  let e, t, s, n, l, r = oe(Object.entries(
    /*A5E*/
    i[7].distanceUnits
  )), o = [];
  for (let a = 0; a < r.length; a += 1)
    o[a] = bM(mM(i, r, a));
  return {
    c() {
      e = E("select"), t = E("option"), t.textContent = `${K("A5E.None")}`;
      for (let a = 0; a < o.length; a += 1)
        o[a].c();
      t.__value = null, qe(t, t.__value), b(e, "class", "u-w-30"), b(e, "name", s = "system.actions.$" + /*actionId*/
      i[6] + ".ranges." + /*id*/
      i[0] + ".unit");
    },
    m(a, c) {
      T(a, e, c), A(e, t);
      for (let u = 0; u < o.length; u += 1)
        o[u] && o[u].m(e, null);
      n || (l = V(
        e,
        "change",
        /*selectRangeUnit*/
        i[9]
      ), n = !0);
    },
    p(a, c) {
      if (c & /*Object, A5E, rangeObject*/
      130) {
        r = oe(Object.entries(
          /*A5E*/
          a[7].distanceUnits
        ));
        let u;
        for (u = 0; u < r.length; u += 1) {
          const d = mM(a, r, u);
          o[u] ? o[u].p(d, c) : (o[u] = bM(d), o[u].c(), o[u].m(e, null));
        }
        for (; u < o.length; u += 1)
          o[u].d(1);
        o.length = r.length;
      }
      c & /*id*/
      1 && s !== (s = "system.actions.$" + /*actionId*/
      a[6] + ".ranges." + /*id*/
      a[0] + ".unit") && b(e, "name", s);
    },
    d(a) {
      a && S(e), Le(o, a), n = !1, l();
    }
  };
}
f(gM, "create_if_block_1$12");
function bM(i) {
  let e, t = K(
    /*label*/
    i[22]
  ) + "", s, n, l;
  return {
    c() {
      e = E("option"), s = x(t), n = R(), e.__value = /*unit*/
      i[21], qe(e, e.__value), e.selected = l = /*rangeObject*/
      i[1].unit === /*unit*/
      i[21];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      o & /*rangeObject*/
      2 && l !== (l = /*rangeObject*/
      r[1].unit === /*unit*/
      r[21]) && (e.selected = l);
    },
    d(r) {
      r && S(e);
    }
  };
}
f(bM, "create_each_block$$");
function mte(i) {
  let e, t, s, n, l, r = (
    /*includeUnit*/
    i[3] && gM(i)
  );
  return {
    c() {
      e = E("div"), t = E("input"), s = R(), r && r.c(), z(t, "flex-shrink", "1"), b(t, "type", "text"), z(e, "display", "flex"), z(e, "gap", "0.5rem"), z(e, "flex-wrap", "nowrap");
    },
    m(o, a) {
      T(o, e, a), A(e, t), qe(
        t,
        /*customValue*/
        i[2]
      ), A(e, s), r && r.m(e, null), n || (l = [
        V(
          t,
          "input",
          /*input_input_handler*/
          i[18]
        ),
        V(
          t,
          "change",
          /*change_handler*/
          i[19]
        )
      ], n = !0);
    },
    p(o, a) {
      a & /*customValue*/
      4 && t.value !== /*customValue*/
      o[2] && qe(
        t,
        /*customValue*/
        o[2]
      ), /*includeUnit*/
      o[3] ? r ? r.p(o, a) : (r = gM(o), r.c(), r.m(e, null)) : r && (r.d(1), r = null);
    },
    d(o) {
      o && S(e), r && r.d(), n = !1, Ne(l);
    }
  };
}
f(mte, "create_default_slot$15");
function hte(i) {
  let e, t, s, n, l;
  e = new Ye({
    props: {
      buttons: [
        {
          classes: "fa-solid fa-trash a5e-field-wrapper__header-button--scale",
          handler: (
            /*deleteRangeIncrement*/
            i[11]
          ),
          tooltip: "Delete Range Increment"
        }
      ],
      heading: (
        /*heading*/
        i[12]
      ),
      options: (
        /*options*/
        i[13]
      ),
      selected: (
        /*selected*/
        i[4]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[16]
  );
  let r = (
    /*selected*/
    i[4] === "other" && hM(i)
  );
  return {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), r && r.c(), n = $e(), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-header-width", "100%"), z(t, "--a5e-field-wrapper-label-width", "100%"), z(t, "--a5e-header-button-color", "rgba(0, 0, 0, 0.2)"), z(t, "--a5e-header-button-color-hover", "#555");
    },
    m(o, a) {
      T(o, t, a), N(e, t, null), T(o, s, a), r && r.m(o, a), T(o, n, a), l = !0;
    },
    p(o, [a]) {
      const c = {};
      a & /*selected*/
      16 && (c.selected = /*selected*/
      o[4]), e.$set(c), /*selected*/
      o[4] === "other" ? r ? (r.p(o, a), a & /*selected*/
      16 && w(r, 1)) : (r = hM(o), r.c(), w(r, 1), r.m(n.parentNode, n)) : r && (ce(), C(r, 1, 1, () => {
        r = null;
      }), ue());
    },
    i(o) {
      l || (w(e.$$.fragment, o), w(r), l = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(r), l = !1;
    },
    d(o) {
      o && (S(s), S(n)), o && e && S(t), j(e, o), r && r.d(o);
    }
  };
}
f(hte, "create_fragment$2I");
function gte(i, e, t) {
  let s, n, { index: l } = e, { id: r } = e, { rangeObject: o } = e, a = o.range;
  const c = fe("item");
  pe(i, c, (B) => t(20, n = B));
  const u = fe("actionId"), d = CONFIG.A5E;
  function p(B) {
    pd(B) ? (t(15, a = B), t(2, k = "")) : v ? t(15, a = parseInt(B, 10)) : t(15, a = k), se(n, `system.actions.${u}.ranges.${r}.range`, a);
  }
  f(p, "updateRangeValue");
  function m(B) {
    var H, G;
    const F = (G = (H = B.target) == null ? void 0 : H.selectedOptions[0]) == null ? void 0 : G.value;
    F === "null" ? n.update({
      [`system.actions.${u}.ranges.${r}`]: { "-=unit": null }
    }) : n.update({
      [`system.actions.${u}.ranges.${r}`]: { unit: F }
    });
  }
  f(m, "selectRangeUnit");
  function g(B) {
    var H;
    ((H = B.target) == null ? void 0 : H.checked) !== !0 && n.update({
      [`system.actions.${u}.ranges.${r}`]: { "-=unit": null }
    });
  }
  f(g, "deleteRangeUnit");
  function h() {
    n.update({
      [`system.actions.${u}.ranges`]: { [`-=${r}`]: null }
    });
  }
  f(h, "deleteRangeIncrement");
  const _ = K("A5E.ItemRangeIncrement", { increment: Li(l + 1) }), y = Object.entries(CONFIG.A5E.rangeDescriptors).map(([B, F]) => {
    if (["short", "medium", "long"].includes(B)) {
      const H = CONFIG.A5E.rangeValues[B];
      return [B, `${K(F)} (${H} ft.)`];
    }
    return [B, F];
  });
  let k = pd(a) ? "" : a, v = !!o.unit;
  const O = /* @__PURE__ */ f(({ detail: B }) => p(B), "updateSelection_handler"), P = /* @__PURE__ */ f((B) => {
    t(3, v = B.detail), g(B);
  }, "updateSelection_handler_1");
  function D() {
    k = this.value, t(2, k);
  }
  f(D, "input_input_handler");
  const I = /* @__PURE__ */ f(() => p(k), "change_handler");
  return i.$$set = (B) => {
    "index" in B && t(14, l = B.index), "id" in B && t(0, r = B.id), "rangeObject" in B && t(1, o = B.rangeObject);
  }, i.$$.update = () => {
    i.$$.dirty & /*range*/
    32768 && t(4, s = pd(a) ? a : "other");
  }, [
    r,
    o,
    k,
    v,
    s,
    c,
    u,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    l,
    a,
    O,
    P,
    D,
    I
  ];
}
f(gte, "instance$2z");
const cS = class cS extends ie {
  constructor(e) {
    super(), le(this, e, gte, hte, ne, { index: 14, id: 0, rangeObject: 1 });
  }
};
f(cS, "TargetRangeIncrement");
let tv = cS;
function bte(i) {
  let e, t;
  return e = new bt({
    props: {
      $$slots: { default: [vte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, scalingMode, actionId, target, $item*/
      8219 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(bte, "create_if_block_2$F");
function _te(i) {
  let e, t;
  return e = new bt({
    props: {
      $$slots: { default: [kte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, actionId, target, $item*/
      8203 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(_te, "create_if_block_1$11");
function yte(i) {
  let e, t;
  return e = new bt({
    props: {
      heading: "Targets Increment",
      hint: "This increment will be applied automatically based on your caster level.",
      $$slots: { default: [wte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, actionId, action, $item*/
      8205 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(yte, "create_if_block$1x");
function vte(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k, v, O, P, D, I, B, F = (
    /*scalingMode*/
    i[4] === "spellPoints" ? "Points" : "Uses"
  ), H, G, U;
  return {
    c() {
      var q, W, X, te;
      e = E("section"), t = E("div"), s = E("label"), n = x("Targets Increment"), r = R(), o = E("input"), d = R(), p = E("div"), m = E("label"), g = x("Per"), _ = R(), y = E("input"), P = R(), D = E("div"), I = E("span"), B = x("Additional "), H = x(F), b(s, "for", l = /*actionId*/
      i[0] + "-targets-healing-scaling-formula"), b(s, "class", "svelte-19ywrwb"), b(o, "id", a = /*actionId*/
      i[0] + "-targets-scaling-formula"), b(o, "type", "text"), b(o, "name", c = "system.actions." + /*actionId*/
      i[0] + ".target.scaling.formula"), o.value = u = /*target*/
      ((W = (q = i[1]) == null ? void 0 : q.scaling) == null ? void 0 : W.formula) ?? 0, b(o, "class", "svelte-19ywrwb"), b(t, "class", "a5e-field-group a5e-field-group--formula"), b(m, "for", h = /*actionId*/
      i[0] + "-targets-scaling-step"), b(m, "class", "svelte-19ywrwb"), b(y, "id", k = /*actionId*/
      i[0] + "-targets-scaling-step"), z(y, "text-align", "center"), b(y, "type", "number"), b(y, "name", v = "system.actions." + /*actionId*/
      i[0] + ".target.scaling.step"), y.value = O = /*target*/
      ((te = (X = i[1]) == null ? void 0 : X.scaling) == null ? void 0 : te.step) ?? 1, b(y, "class", "svelte-19ywrwb"), b(p, "class", "a5e-field-group u-w-12"), b(I, "class", "levels svelte-19ywrwb"), b(D, "class", "a5e-field-group levels-wrapper svelte-19ywrwb"), b(e, "class", "row u-flex-wrap svelte-19ywrwb");
    },
    m(q, W) {
      T(q, e, W), A(e, t), A(t, s), A(s, n), A(t, r), A(t, o), A(e, d), A(e, p), A(p, m), A(m, g), A(p, _), A(p, y), A(e, P), A(e, D), A(D, I), A(I, B), A(I, H), G || (U = [
        V(
          o,
          "change",
          /*change_handler_3*/
          i[11]
        ),
        V(
          y,
          "change",
          /*change_handler_4*/
          i[12]
        )
      ], G = !0);
    },
    p(q, W) {
      var X, te, J, re;
      W & /*actionId*/
      1 && l !== (l = /*actionId*/
      q[0] + "-targets-healing-scaling-formula") && b(s, "for", l), W & /*actionId*/
      1 && a !== (a = /*actionId*/
      q[0] + "-targets-scaling-formula") && b(o, "id", a), W & /*actionId*/
      1 && c !== (c = "system.actions." + /*actionId*/
      q[0] + ".target.scaling.formula") && b(o, "name", c), W & /*target*/
      2 && u !== (u = /*target*/
      ((te = (X = q[1]) == null ? void 0 : X.scaling) == null ? void 0 : te.formula) ?? 0) && o.value !== u && (o.value = u), W & /*actionId*/
      1 && h !== (h = /*actionId*/
      q[0] + "-targets-scaling-step") && b(m, "for", h), W & /*actionId*/
      1 && k !== (k = /*actionId*/
      q[0] + "-targets-scaling-step") && b(y, "id", k), W & /*actionId*/
      1 && v !== (v = "system.actions." + /*actionId*/
      q[0] + ".target.scaling.step") && b(y, "name", v), W & /*target*/
      2 && O !== (O = /*target*/
      ((re = (J = q[1]) == null ? void 0 : J.scaling) == null ? void 0 : re.step) ?? 1) && y.value !== O && (y.value = O), W & /*scalingMode*/
      16 && F !== (F = /*scalingMode*/
      q[4] === "spellPoints" ? "Points" : "Uses") && _e(H, F);
    },
    d(q) {
      q && S(e), G = !1, Ne(U);
    }
  };
}
f(vte, "create_default_slot_2$m");
function kte(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k, v, O, P, D, I, B;
  return {
    c() {
      var F, H, G, U;
      e = E("section"), t = E("div"), s = E("label"), n = x("Targets Increment"), r = R(), o = E("input"), d = R(), p = E("div"), m = E("label"), g = x("Per"), _ = R(), y = E("input"), P = R(), D = E("div"), D.innerHTML = '<span class="levels svelte-19ywrwb">Levels</span>', b(s, "for", l = /*actionId*/
      i[0] + "-targets-scaling-formula"), b(s, "class", "svelte-19ywrwb"), b(o, "id", a = /*actionId*/
      i[0] + "-targets-scaling-formula"), b(o, "type", "text"), b(o, "name", c = "system.actions." + /*actionId*/
      i[0] + ".target.scaling.formula"), o.value = u = /*target*/
      ((H = (F = i[1]) == null ? void 0 : F.scaling) == null ? void 0 : H.formula) ?? 0, b(o, "class", "svelte-19ywrwb"), b(t, "class", "a5e-field-group a5e-field-group--formula a5e-field-group--spell-level svelte-19ywrwb"), b(m, "for", h = /*actionId*/
      i[0] + "targets-scaling-step"), b(m, "class", "svelte-19ywrwb"), b(y, "id", k = /*actionId*/
      i[0] + "-targets-scaling-step"), b(y, "type", "number"), b(y, "name", v = "system.actions." + /*actionId*/
      i[0] + ".target.scaling.step"), y.value = O = /*target*/
      ((U = (G = i[1]) == null ? void 0 : G.scaling) == null ? void 0 : U.step) ?? 1, b(y, "class", "svelte-19ywrwb"), b(p, "class", "a5e-field-group u-w-12 a5e-field-group--spell-level svelte-19ywrwb"), b(D, "class", "a5e-field-group levels-wrapper svelte-19ywrwb"), b(e, "class", "row u-flex-wrap svelte-19ywrwb");
    },
    m(F, H) {
      T(F, e, H), A(e, t), A(t, s), A(s, n), A(t, r), A(t, o), A(e, d), A(e, p), A(p, m), A(m, g), A(p, _), A(p, y), A(e, P), A(e, D), I || (B = [
        V(
          o,
          "change",
          /*change_handler_1*/
          i[9]
        ),
        V(
          y,
          "change",
          /*change_handler_2*/
          i[10]
        )
      ], I = !0);
    },
    p(F, H) {
      var G, U, q, W;
      H & /*actionId*/
      1 && l !== (l = /*actionId*/
      F[0] + "-targets-scaling-formula") && b(s, "for", l), H & /*actionId*/
      1 && a !== (a = /*actionId*/
      F[0] + "-targets-scaling-formula") && b(o, "id", a), H & /*actionId*/
      1 && c !== (c = "system.actions." + /*actionId*/
      F[0] + ".target.scaling.formula") && b(o, "name", c), H & /*target*/
      2 && u !== (u = /*target*/
      ((U = (G = F[1]) == null ? void 0 : G.scaling) == null ? void 0 : U.formula) ?? 0) && o.value !== u && (o.value = u), H & /*actionId*/
      1 && h !== (h = /*actionId*/
      F[0] + "targets-scaling-step") && b(m, "for", h), H & /*actionId*/
      1 && k !== (k = /*actionId*/
      F[0] + "-targets-scaling-step") && b(y, "id", k), H & /*actionId*/
      1 && v !== (v = "system.actions." + /*actionId*/
      F[0] + ".target.scaling.step") && b(y, "name", v), H & /*target*/
      2 && O !== (O = /*target*/
      ((W = (q = F[1]) == null ? void 0 : q.scaling) == null ? void 0 : W.step) ?? 1) && y.value !== O && (y.value = O);
    },
    d(F) {
      F && S(e), I = !1, Ne(B);
    }
  };
}
f(kte, "create_default_slot_1$u");
function wte(i) {
  let e, t, s, n, l;
  return {
    c() {
      var r;
      e = E("input"), b(e, "class", "a5e-input svelte-19ywrwb"), b(e, "type", "text"), b(e, "name", t = "system.actions." + /*actionId*/
      i[0] + ".target.scaling.formula"), e.value = s = /*action*/
      ((r = i[2].target.scaling) == null ? void 0 : r.formula) ?? 0;
    },
    m(r, o) {
      T(r, e, o), n || (l = V(
        e,
        "change",
        /*change_handler*/
        i[8]
      ), n = !0);
    },
    p(r, o) {
      var a;
      o & /*actionId*/
      1 && t !== (t = "system.actions." + /*actionId*/
      r[0] + ".target.scaling.formula") && b(e, "name", t), o & /*action*/
      4 && s !== (s = /*action*/
      ((a = r[2].target.scaling) == null ? void 0 : a.formula) ?? 0) && e.value !== s && (e.value = s);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(wte, "create_default_slot$14");
function $te(i) {
  let e, t, s, n, l, r, o;
  t = new Ye({
    props: {
      heading: "Scaling Mode",
      options: Ate(),
      selected: (
        /*scalingMode*/
        i[4]
      ),
      allowDeselect: !1
    }
  }), t.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  );
  const a = [yte, _te, bte], c = [];
  function u(d, p) {
    return p & /*scalingMode*/
    16 && (n = null), /*scalingMode*/
    d[4] === "cantrip" ? 0 : (
      /*scalingMode*/
      d[4] === "spellLevel" ? 1 : (n == null && (n = !!["spellPoints", "actionUses", "itemUses"].includes(
        /*scalingMode*/
        d[4]
      )), n ? 2 : -1)
    );
  }
  return f(u, "select_block_type"), ~(l = u(i, -1)) && (r = c[l] = a[l](i)), {
    c() {
      e = E("form"), L(t.$$.fragment), s = R(), r && r.c(), b(e, "class", "svelte-19ywrwb");
    },
    m(d, p) {
      T(d, e, p), N(t, e, null), A(e, s), ~l && c[l].m(e, null), o = !0;
    },
    p(d, [p]) {
      const m = {};
      p & /*scalingMode*/
      16 && (m.selected = /*scalingMode*/
      d[4]), t.$set(m);
      let g = l;
      l = u(d, p), l === g ? ~l && c[l].p(d, p) : (r && (ce(), C(c[g], 1, 1, () => {
        c[g] = null;
      }), ue()), ~l ? (r = c[l], r ? r.p(d, p) : (r = c[l] = a[l](d), r.c()), w(r, 1), r.m(e, null)) : r = null);
    },
    i(d) {
      o || (w(t.$$.fragment, d), w(r), o = !0);
    },
    o(d) {
      C(t.$$.fragment, d), C(r), o = !1;
    },
    d(d) {
      d && S(e), j(t), ~l && c[l].d();
    }
  };
}
f($te, "create_fragment$2H");
function Ate() {
  return [[null, "A5E.None"], ...Object.entries(CONFIG.A5E.targetScalingModes)];
}
f(Ate, "getTargetScalingOptions");
function Ete(i, e, t) {
  let s, n, l, r, { document: o, actionId: a } = fe("#external").application, { document: c = o, actionId: u = a } = e;
  const d = c;
  pe(i, d, (k) => t(3, r = k));
  const p = /* @__PURE__ */ f((k) => {
    se(r, `system.actions.${u}.target.scaling.mode`, k.detail);
  }, "updateSelection_handler"), m = /* @__PURE__ */ f(({ target: k }) => se(r, k.name, k.value), "change_handler"), g = /* @__PURE__ */ f(({ target: k }) => se(r, k.name, k.value), "change_handler_1"), h = /* @__PURE__ */ f(({ target: k }) => se(r, k.name, parseInt(k.value, 10)), "change_handler_2"), _ = /* @__PURE__ */ f(({ target: k }) => se(r, k.name, k.value), "change_handler_3"), y = /* @__PURE__ */ f(({ target: k }) => se(r, k.name, parseInt(k.value, 10)), "change_handler_4");
  return i.$$set = (k) => {
    "document" in k && t(6, c = k.document), "actionId" in k && t(0, u = k.actionId);
  }, i.$$.update = () => {
    var k;
    i.$$.dirty & /*$item, actionId*/
    9 && t(2, s = r.actions[u]), i.$$.dirty & /*action*/
    4 && t(1, n = s.target ?? {}), i.$$.dirty & /*target*/
    2 && t(4, l = ((k = n == null ? void 0 : n.scaling) == null ? void 0 : k.mode) ?? null);
  }, [
    u,
    n,
    s,
    r,
    l,
    d,
    c,
    p,
    m,
    g,
    h,
    _,
    y
  ];
}
f(Ete, "instance$2y");
const uS = class uS extends ie {
  constructor(e) {
    super(), le(this, e, Ete, $te, ne, { document: 6, actionId: 0 });
  }
};
f(uS, "TargetScalingDialog");
let sv = uS;
function _M(i, e, t) {
  const s = i.slice();
  return s[10] = e[t][0], s[11] = e[t][1], s;
}
f(_M, "get_each_context$_");
function yM(i, e, t) {
  const s = i.slice();
  return s[14] = e[t][0], s[15] = e[t][1], s[17] = t, s;
}
f(yM, "get_each_context_1$c");
function vM(i, e) {
  let t, s, n, l, r;
  return s = new tv({
    props: {
      index: (
        /*index*/
        e[17]
      ),
      id: (
        /*id*/
        e[14]
      ),
      rangeObject: (
        /*range*/
        e[15]
      )
    }
  }), {
    key: i,
    first: null,
    c() {
      t = E("li"), L(s.$$.fragment), n = R(), b(t, "class", "a5e-item a5e-item--action-config"), b(t, "data-range-id", l = /*id*/
      e[14]), this.first = t;
    },
    m(o, a) {
      T(o, t, a), N(s, t, null), A(t, n), r = !0;
    },
    p(o, a) {
      e = o;
      const c = {};
      a & /*action*/
      2 && (c.index = /*index*/
      e[17]), a & /*action*/
      2 && (c.id = /*id*/
      e[14]), a & /*action*/
      2 && (c.rangeObject = /*range*/
      e[15]), s.$set(c), (!r || a & /*action*/
      2 && l !== (l = /*id*/
      e[14])) && b(t, "data-range-id", l);
    },
    i(o) {
      r || (w(s.$$.fragment, o), r = !0);
    },
    o(o) {
      C(s.$$.fragment, o), r = !1;
    },
    d(o) {
      o && S(t), j(s);
    }
  };
}
f(vM, "create_each_block_1$c");
function Ste(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n, l = oe(Object.entries(
    /*action*/
    i[1].ranges ?? {}
  ));
  const r = /* @__PURE__ */ f((o) => (
    /*id*/
    o[14]
  ), "get_key");
  for (let o = 0; o < l.length; o += 1) {
    let a = yM(i, l, o), c = r(a);
    s.set(c, t[o] = vM(c, a));
  }
  return {
    c() {
      e = E("ul");
      for (let o = 0; o < t.length; o += 1)
        t[o].c();
      b(e, "class", "a5e-item-list");
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < t.length; c += 1)
        t[c] && t[c].m(e, null);
      n = !0;
    },
    p(o, a) {
      a & /*Object, action*/
      2 && (l = oe(Object.entries(
        /*action*/
        o[1].ranges ?? {}
      )), ce(), t = kt(t, a, r, 1, o, l, s, e, ks, vM, null, yM), ue());
    },
    i(o) {
      if (!n) {
        for (let a = 0; a < l.length; a += 1)
          w(t[a]);
        n = !0;
      }
    },
    o(o) {
      for (let a = 0; a < t.length; a += 1)
        C(t[a]);
      n = !1;
    },
    d(o) {
      o && S(e);
      for (let a = 0; a < t.length; a += 1)
        t[a].d();
    }
  };
}
f(Ste, "create_default_slot_2$l");
function kM(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "class", "small-input"), b(e, "type", "number"), b(e, "name", "targetQuantity"), e.value = t = /*action*/
      ((l = i[1].target) == null ? void 0 : l.quantity) ?? 1;
    },
    m(l, r) {
      T(l, e, r), s || (n = [
        V(
          e,
          "change",
          /*change_handler*/
          i[9]
        ),
        V(e, "click", qte)
      ], s = !0);
    },
    p(l, r) {
      var o;
      r & /*action*/
      2 && t !== (t = /*action*/
      ((o = l[1].target) == null ? void 0 : o.quantity) ?? 1) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, Ne(n);
    }
  };
}
f(kM, "create_if_block_8$7");
function wM(i, e) {
  let t, s = K(
    /*name*/
    e[11]
  ) + "", n, l, r;
  return {
    key: i,
    first: null,
    c() {
      var o, a;
      t = E("option"), n = x(s), l = R(), t.__value = /*key*/
      e[10], qe(t, t.__value), t.selected = r = /*action*/
      ((a = (o = e[1]) == null ? void 0 : o.target) == null ? void 0 : a.type) === /*key*/
      e[10], this.first = t;
    },
    m(o, a) {
      T(o, t, a), A(t, n), A(t, l);
    },
    p(o, a) {
      var c, u;
      e = o, a & /*action*/
      2 && r !== (r = /*action*/
      ((u = (c = e[1]) == null ? void 0 : c.target) == null ? void 0 : u.type) === /*key*/
      e[10]) && (t.selected = r);
    },
    d(o) {
      o && S(t);
    }
  };
}
f(wM, "create_each_block$_");
function $M(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("div"), t = E("button"), t.innerHTML = '<i class="fa-solid fa-arrow-up-right-dots svelte-18xdt4m" data-tooltip="A5E.ConfigureTargetScaling" data-tooltip-direction="UP"></i>', b(t, "class", "scaling-button svelte-18xdt4m"), b(e, "class", "a5e-field-group scaling-button-wrapper svelte-18xdt4m");
    },
    m(l, r) {
      T(l, e, r), A(e, t), s || (n = V(t, "click", tt(
        /*onClickTargetScalingButton*/
        i[6]
      )), s = !0);
    },
    p: ee,
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f($M, "create_if_block_7$9");
function Tte(i) {
  let e;
  function t(l, r) {
    var o, a, c, u;
    return !/*action*/
    ((a = (o = l[1].target) == null ? void 0 : o.scaling) != null && a.step) || /*action*/
    ((u = (c = l[1].target) == null ? void 0 : c.scaling) == null ? void 0 : u.step) === 1 ? Pte : Ite;
  }
  f(t, "select_block_type_3");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("small"), n.c();
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    d(l) {
      l && S(e), n.d();
    }
  };
}
f(Tte, "create_if_block_5$e");
function Cte(i) {
  let e;
  function t(l, r) {
    var o, a, c, u;
    return !/*action*/
    ((a = (o = l[1].target) == null ? void 0 : o.scaling) != null && a.step) || /*action*/
    ((u = (c = l[1].target) == null ? void 0 : c.scaling) == null ? void 0 : u.step) === 1 ? Rte : Mte;
  }
  f(t, "select_block_type_2");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("small"), n.c();
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    d(l) {
      l && S(e), n.d();
    }
  };
}
f(Cte, "create_if_block_3$q");
function Ote(i) {
  let e;
  function t(l, r) {
    var o, a, c, u;
    return !/*action*/
    ((a = (o = l[1].target) == null ? void 0 : o.scaling) != null && a.step) || /*action*/
    ((u = (c = l[1].target) == null ? void 0 : c.scaling) == null ? void 0 : u.step) === 1 ? Nte : Fte;
  }
  f(t, "select_block_type_1");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("small"), n.c();
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    d(l) {
      l && S(e), n.d();
    }
  };
}
f(Ote, "create_if_block_1$10");
function Dte(i) {
  var n, l, r;
  let e, t = K("A5E.scaling.summaries.cantrip.target", {
    formula: (
      /*action*/
      ((n = i[1].target) == null ? void 0 : n.scaling.formula) ?? 0
    ),
    targetType: (
      /*A5E*/
      i[4].targetTypesPlural[
        /*action*/
        (r = (l = i[1]) == null ? void 0 : l.target) == null ? void 0 : r.type
      ]
    )
  }) + "", s;
  return {
    c() {
      e = E("small"), s = x(t);
    },
    m(o, a) {
      T(o, e, a), A(e, s);
    },
    p(o, a) {
      var c, u, d;
      a & /*action*/
      2 && t !== (t = K("A5E.scaling.summaries.cantrip.target", {
        formula: (
          /*action*/
          ((c = o[1].target) == null ? void 0 : c.scaling.formula) ?? 0
        ),
        targetType: (
          /*A5E*/
          o[4].targetTypesPlural[
            /*action*/
            (d = (u = o[1]) == null ? void 0 : u.target) == null ? void 0 : d.type
          ]
        )
      }) + "") && _e(s, t);
    },
    d(o) {
      o && S(e);
    }
  };
}
f(Dte, "create_if_block$1w");
function Ite(i) {
  var s, n, l, r;
  let e = K("A5E.scaling.summaries.steppedUses.target", {
    formula: (
      /*action*/
      ((s = i[1].target) == null ? void 0 : s.scaling.formula) ?? 0
    ),
    step: (
      /*action*/
      (n = i[1].target) == null ? void 0 : n.scaling.step
    ),
    targetType: (
      /*A5E*/
      i[4].targetTypesPlural[
        /*action*/
        (r = (l = i[1]) == null ? void 0 : l.target) == null ? void 0 : r.type
      ]
    )
  }) + "", t;
  return {
    c() {
      t = x(e);
    },
    m(o, a) {
      T(o, t, a);
    },
    p(o, a) {
      var c, u, d, p;
      a & /*action*/
      2 && e !== (e = K("A5E.scaling.summaries.steppedUses.target", {
        formula: (
          /*action*/
          ((c = o[1].target) == null ? void 0 : c.scaling.formula) ?? 0
        ),
        step: (
          /*action*/
          (u = o[1].target) == null ? void 0 : u.scaling.step
        ),
        targetType: (
          /*A5E*/
          o[4].targetTypesPlural[
            /*action*/
            (p = (d = o[1]) == null ? void 0 : d.target) == null ? void 0 : p.type
          ]
        )
      }) + "") && _e(t, e);
    },
    d(o) {
      o && S(t);
    }
  };
}
f(Ite, "create_else_block_2$2");
function Pte(i) {
  var s, n, l;
  let e = K("A5E.scaling.summaries.uses.target", {
    formula: (
      /*action*/
      ((s = i[1].target) == null ? void 0 : s.scaling.formula) ?? 0
    ),
    targetType: (
      /*A5E*/
      i[4].targetTypesPlural[
        /*action*/
        (l = (n = i[1]) == null ? void 0 : n.target) == null ? void 0 : l.type
      ]
    )
  }) + "", t;
  return {
    c() {
      t = x(e);
    },
    m(r, o) {
      T(r, t, o);
    },
    p(r, o) {
      var a, c, u;
      o & /*action*/
      2 && e !== (e = K("A5E.scaling.summaries.uses.target", {
        formula: (
          /*action*/
          ((a = r[1].target) == null ? void 0 : a.scaling.formula) ?? 0
        ),
        targetType: (
          /*A5E*/
          r[4].targetTypesPlural[
            /*action*/
            (u = (c = r[1]) == null ? void 0 : c.target) == null ? void 0 : u.type
          ]
        )
      }) + "") && _e(t, e);
    },
    d(r) {
      r && S(t);
    }
  };
}
f(Pte, "create_if_block_6$d");
function Mte(i) {
  var s, n, l, r, o, a;
  let e = K("A5E.scaling.summaries.steppedSpellPoint.target", {
    formula: (
      /*action*/
      ((n = (s = i[1].target) == null ? void 0 : s.scaling) == null ? void 0 : n.formula) ?? 0
    ),
    step: (
      /*action*/
      (r = (l = i[1].target) == null ? void 0 : l.scaling) == null ? void 0 : r.step
    ),
    targetType: (
      /*A5E*/
      i[4].targetTypesPlural[
        /*action*/
        (a = (o = i[1]) == null ? void 0 : o.target) == null ? void 0 : a.type
      ]
    )
  }) + "", t;
  return {
    c() {
      t = x(e);
    },
    m(c, u) {
      T(c, t, u);
    },
    p(c, u) {
      var d, p, m, g, h, _;
      u & /*action*/
      2 && e !== (e = K("A5E.scaling.summaries.steppedSpellPoint.target", {
        formula: (
          /*action*/
          ((p = (d = c[1].target) == null ? void 0 : d.scaling) == null ? void 0 : p.formula) ?? 0
        ),
        step: (
          /*action*/
          (g = (m = c[1].target) == null ? void 0 : m.scaling) == null ? void 0 : g.step
        ),
        targetType: (
          /*A5E*/
          c[4].targetTypesPlural[
            /*action*/
            (_ = (h = c[1]) == null ? void 0 : h.target) == null ? void 0 : _.type
          ]
        )
      }) + "") && _e(t, e);
    },
    d(c) {
      c && S(t);
    }
  };
}
f(Mte, "create_else_block_1$5");
function Rte(i) {
  var s, n, l;
  let e = K("A5E.scaling.summaries.spellPoint.target", {
    formula: (
      /*action*/
      ((s = i[1].target) == null ? void 0 : s.scaling.formula) ?? 0
    ),
    targetType: (
      /*A5E*/
      i[4].targetTypesPlural[
        /*action*/
        (l = (n = i[1]) == null ? void 0 : n.target) == null ? void 0 : l.type
      ]
    )
  }) + "", t;
  return {
    c() {
      t = x(e);
    },
    m(r, o) {
      T(r, t, o);
    },
    p(r, o) {
      var a, c, u;
      o & /*action*/
      2 && e !== (e = K("A5E.scaling.summaries.spellPoint.target", {
        formula: (
          /*action*/
          ((a = r[1].target) == null ? void 0 : a.scaling.formula) ?? 0
        ),
        targetType: (
          /*A5E*/
          r[4].targetTypesPlural[
            /*action*/
            (u = (c = r[1]) == null ? void 0 : c.target) == null ? void 0 : u.type
          ]
        )
      }) + "") && _e(t, e);
    },
    d(r) {
      r && S(t);
    }
  };
}
f(Rte, "create_if_block_4$l");
function Fte(i) {
  var s, n, l, r, o, a;
  let e = K("A5E.scaling.summaries.steppedSpellLevel.target", {
    formula: (
      /*action*/
      ((n = (s = i[1].target) == null ? void 0 : s.scaling) == null ? void 0 : n.formula) ?? 0
    ),
    step: (
      /*action*/
      (r = (l = i[1].target) == null ? void 0 : l.scaling) == null ? void 0 : r.step
    ),
    level: Li(
      /*$item*/
      i[0].system.level
    ),
    targetType: (
      /*A5E*/
      i[4].targetTypesPlural[
        /*action*/
        (a = (o = i[1]) == null ? void 0 : o.target) == null ? void 0 : a.type
      ]
    )
  }) + "", t;
  return {
    c() {
      t = x(e);
    },
    m(c, u) {
      T(c, t, u);
    },
    p(c, u) {
      var d, p, m, g, h, _;
      u & /*action, $item*/
      3 && e !== (e = K("A5E.scaling.summaries.steppedSpellLevel.target", {
        formula: (
          /*action*/
          ((p = (d = c[1].target) == null ? void 0 : d.scaling) == null ? void 0 : p.formula) ?? 0
        ),
        step: (
          /*action*/
          (g = (m = c[1].target) == null ? void 0 : m.scaling) == null ? void 0 : g.step
        ),
        level: Li(
          /*$item*/
          c[0].system.level
        ),
        targetType: (
          /*A5E*/
          c[4].targetTypesPlural[
            /*action*/
            (_ = (h = c[1]) == null ? void 0 : h.target) == null ? void 0 : _.type
          ]
        )
      }) + "") && _e(t, e);
    },
    d(c) {
      c && S(t);
    }
  };
}
f(Fte, "create_else_block$v");
function Nte(i) {
  var s, n, l;
  let e = K("A5E.scaling.summaries.spellLevel.target", {
    formula: (
      /*action*/
      ((s = i[1].target) == null ? void 0 : s.scaling.formula) ?? 0
    ),
    level: Li(
      /*$item*/
      i[0].system.level
    ),
    targetType: (
      /*A5E*/
      i[4].targetTypesPlural[
        /*action*/
        (l = (n = i[1]) == null ? void 0 : n.target) == null ? void 0 : l.type
      ]
    )
  }) + "", t;
  return {
    c() {
      t = x(e);
    },
    m(r, o) {
      T(r, t, o);
    },
    p(r, o) {
      var a, c, u;
      o & /*action, $item*/
      3 && e !== (e = K("A5E.scaling.summaries.spellLevel.target", {
        formula: (
          /*action*/
          ((a = r[1].target) == null ? void 0 : a.scaling.formula) ?? 0
        ),
        level: Li(
          /*$item*/
          r[0].system.level
        ),
        targetType: (
          /*A5E*/
          r[4].targetTypesPlural[
            /*action*/
            (u = (c = r[1]) == null ? void 0 : c.target) == null ? void 0 : u.type
          ]
        )
      }) + "") && _e(t, e);
    },
    d(r) {
      r && S(t);
    }
  };
}
f(Nte, "create_if_block_2$E");
function jte(i) {
  var F, H, G;
  let e, t = ["creature", "object", "creatureObject"].includes(
    /*action*/
    (F = i[1].target) == null ? void 0 : F.type
  ), s, n, l, r = K("A5E.None") + "", o, a, c, u = [], d = /* @__PURE__ */ new Map(), p, m = ["creature", "object", "creatureObject"].includes(
    /*action*/
    (G = (H = i[1]) == null ? void 0 : H.target) == null ? void 0 : G.type
  ), g, h, _, y, k = t && kM(i), v = oe(Object.entries(
    /*A5E*/
    i[4].targetTypes
  ));
  const O = /* @__PURE__ */ f((U) => (
    /*key*/
    U[10]
  ), "get_key");
  for (let U = 0; U < v.length; U += 1) {
    let q = _M(i, v, U), W = O(q);
    d.set(W, u[U] = wM(W, q));
  }
  let P = m && $M(i);
  function D(U, q) {
    var W, X, te, J, re, ae, be, we;
    if (q & /*action*/
    2 && (h = null), /*action*/
    ((X = (W = U[1].target) == null ? void 0 : W.scaling) == null ? void 0 : X.mode) === "cantrip")
      return Dte;
    if (
      /*action*/
      ((J = (te = U[1].target) == null ? void 0 : te.scaling) == null ? void 0 : J.mode) === "spellLevel"
    )
      return Ote;
    if (
      /*action*/
      ((ae = (re = U[1].target) == null ? void 0 : re.scaling) == null ? void 0 : ae.mode) === "spellPoints"
    )
      return Cte;
    if (h == null && (h = !!["actionUses", "itemUses"].includes(
      /*action*/
      (we = (be = U[1].target) == null ? void 0 : be.scaling) == null ? void 0 : we.mode
    )), h)
      return Tte;
  }
  f(D, "select_block_type");
  let I = D(i, -1), B = I && I(i);
  return {
    c() {
      var U;
      e = E("div"), k && k.c(), s = R(), n = E("select"), l = E("option"), o = x(r), a = R();
      for (let q = 0; q < u.length; q += 1)
        u[q].c();
      p = R(), P && P.c(), g = R(), B && B.c(), l.__value = null, qe(l, l.__value), l.selected = c = /*isEmpty*/
      i[5](
        /*action*/
        (U = i[1]) == null ? void 0 : U.target
      ), b(n, "class", "u-w-fit"), b(e, "class", "action-config__component");
    },
    m(U, q) {
      T(U, e, q), k && k.m(e, null), A(e, s), A(e, n), A(n, l), A(l, o), A(l, a);
      for (let W = 0; W < u.length; W += 1)
        u[W] && u[W].m(n, null);
      A(e, p), P && P.m(e, null), A(e, g), B && B.m(e, null), _ || (y = V(
        n,
        "change",
        /*selectTarget*/
        i[8]
      ), _ = !0);
    },
    p(U, q) {
      var W, X, te, J;
      q & /*action*/
      2 && (t = ["creature", "object", "creatureObject"].includes(
        /*action*/
        (W = U[1].target) == null ? void 0 : W.type
      )), t ? k ? k.p(U, q) : (k = kM(U), k.c(), k.m(e, s)) : k && (k.d(1), k = null), q & /*action*/
      2 && c !== (c = /*isEmpty*/
      U[5](
        /*action*/
        (X = U[1]) == null ? void 0 : X.target
      )) && (l.selected = c), q & /*Object, A5E, action*/
      18 && (v = oe(Object.entries(
        /*A5E*/
        U[4].targetTypes
      )), u = kt(u, q, O, 1, U, v, d, n, vs, wM, null, _M)), q & /*action*/
      2 && (m = ["creature", "object", "creatureObject"].includes(
        /*action*/
        (J = (te = U[1]) == null ? void 0 : te.target) == null ? void 0 : J.type
      )), m ? P ? P.p(U, q) : (P = $M(U), P.c(), P.m(e, g)) : P && (P.d(1), P = null), I === (I = D(U, q)) && B ? B.p(U, q) : (B && B.d(1), B = I && I(U), B && (B.c(), B.m(e, null)));
    },
    d(U) {
      U && S(e), k && k.d();
      for (let q = 0; q < u.length; q += 1)
        u[q].d();
      P && P.d(), B && B.d(), _ = !1, y();
    }
  };
}
f(jte, "create_default_slot_1$t");
function Lte(i) {
  let e, t;
  return e = new de({
    props: {
      $$slots: { default: [jte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, action, $item*/
      262147 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Lte, "create_default_slot$13");
function Bte(i) {
  let e, t, s, n, l, r, o, a, c;
  return t = new Me({
    props: {
      heading: "A5E.TabRanges",
      headerButtons: [
        {
          classes: "add-button",
          label: "A5E.ButtonAddRangeIncrement",
          handler: (
            /*addRangeIncrement*/
            i[7]
          )
        }
      ],
      $$slots: { default: [Ste] },
      $$scope: { ctx: i }
    }
  }), l = new ev({
    props: {
      action: (
        /*action*/
        i[1]
      ),
      actionId: (
        /*actionId*/
        i[2]
      ),
      item: (
        /*item*/
        i[3]
      )
    }
  }), o = new Me({
    props: {
      heading: "Target",
      $$slots: { default: [Lte] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("section"), s = E("div"), L(t.$$.fragment), n = R(), L(l.$$.fragment), r = R(), a = E("div"), L(o.$$.fragment), z(s, "display", "contents"), z(s, "--a5e-section-gap", "0"), z(a, "display", "contents"), z(a, "--a5e-section-gap", "0.5rem"), b(e, "class", "a5e-page-wrapper svelte-18xdt4m");
    },
    m(u, d) {
      T(u, e, d), A(e, s), N(t, s, null), A(e, n), N(l, e, null), A(e, r), A(e, a), N(o, a, null), c = !0;
    },
    p(u, [d]) {
      const p = {};
      d & /*$$scope, action*/
      262146 && (p.$$scope = { dirty: d, ctx: u }), t.$set(p);
      const m = {};
      d & /*action*/
      2 && (m.action = /*action*/
      u[1]), l.$set(m);
      const g = {};
      d & /*$$scope, action, $item*/
      262147 && (g.$$scope = { dirty: d, ctx: u }), o.$set(g);
    },
    i(u) {
      c || (w(t.$$.fragment, u), w(l.$$.fragment, u), w(o.$$.fragment, u), c = !0);
    },
    o(u) {
      C(t.$$.fragment, u), C(l.$$.fragment, u), C(o.$$.fragment, u), c = !1;
    },
    d(u) {
      u && S(e), j(t), j(l), j(o);
    }
  };
}
f(Bte, "create_fragment$2G");
const qte = /* @__PURE__ */ f(({ target: i }) => i.select(), "click_handler$1");
function Gte(i, e, t) {
  let s, n;
  const l = fe("actionId"), r = fe("item");
  pe(i, r, (m) => t(0, n = m));
  const { A5E: o } = CONFIG, { isEmpty: a } = foundry.utils;
  function c() {
    let m = n.dialogs.targetScaling[l];
    m || (fl(r, n.dialogs.targetScaling[l] = new gn(n, `${n.name} Target Scaling Configuration`, sv, { actionId: l }), n), m = n.dialogs.targetScaling[l]), m.render(!0);
  }
  f(c, "onClickTargetScalingButton");
  function u() {
    const m = { range: "" };
    n.update({
      [`system.actions.${l}.ranges`]: {
        ...s.ranges,
        [foundry.utils.randomID()]: m
      }
    });
  }
  f(u, "addRangeIncrement");
  function d(m) {
    var h, _;
    const g = (_ = (h = m.target) == null ? void 0 : h.selectedOptions[0]) == null ? void 0 : _.value;
    g === "null" ? n.update({
      [`system.actions.${l}`]: { "-=target": null }
    }) : Jd(n, `system.actions.${l}.target.type`, g, `system.actions.${l}.target.quantity`);
  }
  f(d, "selectTarget");
  const p = /* @__PURE__ */ f(({ target: m }) => se(n, `system.actions.${l}.target.quantity`, Number(m.value || 0)), "change_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1 && t(1, s = n.actions[l]);
  }, [
    n,
    s,
    l,
    r,
    o,
    a,
    c,
    u,
    d,
    p
  ];
}
f(Gte, "instance$2x");
const fS = class fS extends ie {
  constructor(e) {
    super(), le(this, e, Gte, Bte, ne, {});
  }
};
f(fS, "ActionsTargetingTab");
let nv = fS;
function zte(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "sheet-lock fas fa-plus svelte-1i00ecv");
    },
    m(n, l) {
      T(n, e, l), t || (s = V(
        e,
        "click",
        /*click_handler*/
        i[1]
      ), t = !0);
    },
    p: ee,
    i: ee,
    o: ee,
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(zte, "create_fragment$2F");
function Hte(i) {
  const e = it();
  return [e, /* @__PURE__ */ f(() => e("add-button-clicked"), "click_handler")];
}
f(Hte, "instance$2w");
const dS = class dS extends ie {
  constructor(e) {
    super(), le(this, e, Hte, zte, ne, {});
  }
};
f(dS, "AddButton");
let iv = dS;
function RB(i) {
  const e = i.getFlag("a5e", "sheetIsLocked") ?? !0;
  i.update({ "flags.a5e.sheetIsLocked": !e });
}
f(RB, "toggleSheetLockedState");
function Ute(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", t = "sheet-lock fas " + /*sheetIsLocked*/
      (i[0] ? "fa-lock" : "fa-unlock") + " svelte-1i00ecv");
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "click",
        /*click_handler*/
        i[3]
      ), s = !0);
    },
    p(l, [r]) {
      r & /*sheetIsLocked*/
      1 && t !== (t = "sheet-lock fas " + /*sheetIsLocked*/
      (l[0] ? "fa-lock" : "fa-unlock") + " svelte-1i00ecv") && b(e, "class", t);
    },
    i: ee,
    o: ee,
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Ute, "create_fragment$2E");
function Vte(i, e, t) {
  let s, { sheetIsLocked: n } = e;
  const l = fe("actor");
  pe(i, l, (o) => t(1, s = o));
  const r = /* @__PURE__ */ f(({ target: o }) => {
    RB(s), o.blur();
  }, "click_handler");
  return i.$$set = (o) => {
    "sheetIsLocked" in o && t(0, n = o.sheetIsLocked);
  }, i.$$.update = () => {
    var o, a;
    i.$$.dirty & /*$actor*/
    2 && t(0, n = s.isOwner ? ((a = (o = s.flags) == null ? void 0 : o.a5e) == null ? void 0 : a.sheetIsLocked) ?? !0 : !0);
  }, [n, s, l, r];
}
f(Vte, "instance$2v");
const pS = class pS extends ie {
  constructor(e) {
    super(), le(this, e, Vte, Ute, ne, { sheetIsLocked: 0 });
  }
};
f(pS, "LockButton");
let lv = pS;
function AM(i) {
  let e, t;
  return {
    c() {
      e = E("i"), b(e, "class", t = "nav-icon " + /*tab*/
      i[2].icon + " svelte-lnhgnt");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*tab*/
      4 && t !== (t = "nav-icon " + /*tab*/
      s[2].icon + " svelte-lnhgnt") && b(e, "class", t);
    },
    d(s) {
      s && S(e);
    }
  };
}
f(AM, "create_if_block_1$$");
function EM(i) {
  let e = K(
    /*tab*/
    i[2].label
  ) + "", t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*tab*/
      4 && e !== (e = K(
        /*tab*/
        s[2].label
      ) + "") && _e(t, e);
    },
    d(s) {
      s && S(t);
    }
  };
}
f(EM, "create_if_block$1v");
function Wte(i) {
  let e, t, s, n, l, r = (
    /*tab*/
    i[2].icon && AM(i)
  ), o = (
    /*tab*/
    i[2].label && EM(i)
  );
  return {
    c() {
      e = E("li"), t = E("button"), r && r.c(), s = R(), o && o.c(), b(t, "class", "nav-item svelte-lnhgnt"), Q(
        t,
        "nav-item-active",
        /*tab*/
        i[2].name === /*currentTab*/
        i[0].name
      );
    },
    m(a, c) {
      T(a, e, c), A(e, t), r && r.m(t, null), A(t, s), o && o.m(t, null), n || (l = V(
        t,
        "click",
        /*click_handler*/
        i[4]
      ), n = !0);
    },
    p(a, [c]) {
      /*tab*/
      a[2].icon ? r ? r.p(a, c) : (r = AM(a), r.c(), r.m(t, s)) : r && (r.d(1), r = null), /*tab*/
      a[2].label ? o ? o.p(a, c) : (o = EM(a), o.c(), o.m(t, null)) : o && (o.d(1), o = null), c & /*tab, currentTab*/
      5 && Q(
        t,
        "nav-item-active",
        /*tab*/
        a[2].name === /*currentTab*/
        a[0].name
      );
    },
    i: ee,
    o: ee,
    d(a) {
      a && S(e), r && r.d(), o && o.d(), n = !1, l();
    }
  };
}
f(Wte, "create_fragment$2D");
function Kte(i, e, t) {
  let { currentTab: s } = e, { index: n } = e, { tab: l } = e;
  const r = it(), o = /* @__PURE__ */ f(() => r("tab-change", n), "click_handler");
  return i.$$set = (a) => {
    "currentTab" in a && t(0, s = a.currentTab), "index" in a && t(1, n = a.index), "tab" in a && t(2, l = a.tab);
  }, [s, n, l, r, o];
}
f(Kte, "instance$2u");
const mS = class mS extends ie {
  constructor(e) {
    super(), le(this, e, Kte, Wte, ne, { currentTab: 0, index: 1, tab: 2 });
  }
};
f(mS, "NavigationItem");
let rv = mS;
function SM(i, e, t) {
  const s = i.slice();
  return s[9] = e[t], s[11] = t, s;
}
f(SM, "get_each_context$Z");
function TM(i) {
  let e, t;
  return e = new rv({
    props: {
      tab: (
        /*tab*/
        i[9]
      ),
      index: (
        /*index*/
        i[11]
      ),
      currentTab: (
        /*currentTab*/
        i[0]
      )
    }
  }), e.$on(
    "tab-change",
    /*tab_change_handler*/
    i[7]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*tabs*/
      2 && (l.tab = /*tab*/
      s[9]), n & /*currentTab*/
      1 && (l.currentTab = /*currentTab*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(TM, "create_if_block_2$D");
function CM(i) {
  var n;
  let e, t, s = (
    /*tab*/
    (((n = i[9]) == null ? void 0 : n.display) ?? !0) && TM(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(l, r) {
      s && s.m(l, r), T(l, e, r), t = !0;
    },
    p(l, r) {
      var o;
      /*tab*/
      ((o = l[9]) == null ? void 0 : o.display) ?? !0 ? s ? (s.p(l, r), r & /*tabs*/
      2 && w(s, 1)) : (s = TM(l), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ce(), C(s, 1, 1, () => {
        s = null;
      }), ue());
    },
    i(l) {
      t || (w(s), t = !0);
    },
    o(l) {
      C(s), t = !1;
    },
    d(l) {
      l && S(e), s && s.d(l);
    }
  };
}
f(CM, "create_each_block$Z");
function OM(i) {
  let e, t;
  return e = new lv({}), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(OM, "create_if_block_1$_");
function DM(i) {
  let e, t;
  return e = new iv({}), e.$on(
    "add-button-clicked",
    /*add_button_clicked_handler*/
    i[8]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(DM, "create_if_block$1u");
function Yte(i) {
  let e, t, s, n, l, r = oe(
    /*tabs*/
    i[1]
  ), o = [];
  for (let d = 0; d < r.length; d += 1)
    o[d] = CM(SM(i, r, d));
  const a = /* @__PURE__ */ f((d) => C(o[d], 1, 1, () => {
    o[d] = null;
  }), "out");
  let c = (
    /*showLock*/
    i[2] && /*$actor*/
    i[4].permission !== /*observerPermissionsLevel*/
    i[6] && OM()
  ), u = (
    /*showAdd*/
    i[3] && DM(i)
  );
  return {
    c() {
      e = E("nav"), t = E("ul");
      for (let d = 0; d < o.length; d += 1)
        o[d].c();
      s = R(), c && c.c(), n = R(), u && u.c(), b(t, "class", "nav-list svelte-piut2e"), b(e, "class", "nav-wrapper svelte-piut2e");
    },
    m(d, p) {
      T(d, e, p), A(e, t);
      for (let m = 0; m < o.length; m += 1)
        o[m] && o[m].m(t, null);
      A(t, s), c && c.m(t, null), A(t, n), u && u.m(t, null), l = !0;
    },
    p(d, [p]) {
      if (p & /*tabs, currentTab*/
      3) {
        r = oe(
          /*tabs*/
          d[1]
        );
        let m;
        for (m = 0; m < r.length; m += 1) {
          const g = SM(d, r, m);
          o[m] ? (o[m].p(g, p), w(o[m], 1)) : (o[m] = CM(g), o[m].c(), w(o[m], 1), o[m].m(t, s));
        }
        for (ce(), m = r.length; m < o.length; m += 1)
          a(m);
        ue();
      }
      /*showLock*/
      d[2] && /*$actor*/
      d[4].permission !== /*observerPermissionsLevel*/
      d[6] ? c ? p & /*showLock, $actor*/
      20 && w(c, 1) : (c = OM(), c.c(), w(c, 1), c.m(t, n)) : c && (ce(), C(c, 1, 1, () => {
        c = null;
      }), ue()), /*showAdd*/
      d[3] ? u ? p & /*showAdd*/
      8 && w(u, 1) : (u = DM(d), u.c(), w(u, 1), u.m(t, null)) : u && (ce(), C(u, 1, 1, () => {
        u = null;
      }), ue());
    },
    i(d) {
      if (!l) {
        for (let p = 0; p < r.length; p += 1)
          w(o[p]);
        w(c), w(u), l = !0;
      }
    },
    o(d) {
      o = o.filter(Boolean);
      for (let p = 0; p < o.length; p += 1)
        C(o[p]);
      C(c), C(u), l = !1;
    },
    d(d) {
      d && S(e), Le(o, d), c && c.d(), u && u.d();
    }
  };
}
f(Yte, "create_fragment$2C");
function Xte(i, e, t) {
  let s, { currentTab: n } = e, { tabs: l } = e, { showLock: r = !1 } = e, { showAdd: o = !1 } = e;
  const a = fe("actor");
  pe(i, a, (p) => t(4, s = p));
  const c = CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER;
  function u(p) {
    gt.call(this, i, p);
  }
  f(u, "tab_change_handler");
  function d(p) {
    gt.call(this, i, p);
  }
  return f(d, "add_button_clicked_handler"), i.$$set = (p) => {
    "currentTab" in p && t(0, n = p.currentTab), "tabs" in p && t(1, l = p.tabs), "showLock" in p && t(2, r = p.showLock), "showAdd" in p && t(3, o = p.showAdd);
  }, [
    n,
    l,
    r,
    o,
    s,
    a,
    c,
    u,
    d
  ];
}
f(Xte, "instance$2t");
const hS = class hS extends ie {
  constructor(e) {
    super(), le(this, e, Xte, Yte, ne, {
      currentTab: 0,
      tabs: 1,
      showLock: 2,
      showAdd: 3
    });
  }
};
f(hS, "NavigationBar");
let bn = hS;
async function ab(i, e = {}) {
  var n;
  if ((n = game.modules.get("vtta-tokenizer")) != null && n.active && ["character", "npc"].includes(i.type))
    return Tokenizer == null || Tokenizer.tokenizeActor(i), null;
  const t = foundry.utils.getProperty(i, `system.actions.${e == null ? void 0 : e.actionId}.img`) ?? i.img ?? i.icon;
  return new FilePicker({
    type: "image",
    current: t,
    callback: async (l) => {
      e != null && e.actionId ? await i.update({ [`system.actions.${e == null ? void 0 : e.actionId}.img`]: l }) : (e == null ? void 0 : e.type) === "effect" ? await i.update({ icon: l }) : await i.update({ img: l });
    }
  }).browse();
}
f(ab, "editDocumentImage");
function Jte(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h;
  u = new bn({
    props: {
      currentTab: (
        /*currentTab*/
        i[2]
      ),
      tabs: (
        /*tabs*/
        i[6]
      )
    }
  }), u.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[5]
  );
  var _ = (
    /*currentTab*/
    i[2].component
  );
  function y(k, v) {
    return {};
  }
  return f(y, "switch_props"), _ && (p = nt(_, y())), {
    c() {
      var k, v, O;
      e = E("article"), t = E("header"), s = E("img"), r = R(), o = E("input"), c = R(), L(u.$$.fragment), d = R(), p && L(p.$$.fragment), b(s, "class", "item-image svelte-1g0jr8u"), ze(s.src, n = /*$item*/
      ((v = (k = i[3]) == null ? void 0 : k.actions[
        /*actionId*/
        i[0]
      ]) == null ? void 0 : v.img) ?? /*$item*/
      i[3].img) || b(s, "src", n), b(s, "alt", l = /*$item*/
      i[3].name + " image"), b(o, "class", "a5e-input a5e-input--character-name"), b(o, "type", "text"), b(o, "name", "name"), o.value = a = /*$item*/
      (O = i[3].system.actions[
        /*actionId*/
        i[0]
      ]) == null ? void 0 : O.name, b(o, "placeholder", "Action Name"), b(t, "class", "action-header svelte-1g0jr8u"), b(e, "class", "svelte-1g0jr8u");
    },
    m(k, v) {
      T(k, e, v), A(e, t), A(t, s), A(t, r), A(t, o), A(e, c), N(u, e, null), A(e, d), p && N(p, e, null), m = !0, g || (h = [
        V(
          s,
          "click",
          /*click_handler*/
          i[8]
        ),
        V(
          o,
          "change",
          /*change_handler*/
          i[9]
        )
      ], g = !0);
    },
    p(k, [v]) {
      var P, D, I;
      (!m || v & /*$item, actionId*/
      9 && !ze(s.src, n = /*$item*/
      ((D = (P = k[3]) == null ? void 0 : P.actions[
        /*actionId*/
        k[0]
      ]) == null ? void 0 : D.img) ?? /*$item*/
      k[3].img)) && b(s, "src", n), (!m || v & /*$item*/
      8 && l !== (l = /*$item*/
      k[3].name + " image")) && b(s, "alt", l), (!m || v & /*$item, actionId*/
      9 && a !== (a = /*$item*/
      (I = k[3].system.actions[
        /*actionId*/
        k[0]
      ]) == null ? void 0 : I.name) && o.value !== a) && (o.value = a);
      const O = {};
      if (v & /*currentTab*/
      4 && (O.currentTab = /*currentTab*/
      k[2]), u.$set(O), v & /*currentTab*/
      4 && _ !== (_ = /*currentTab*/
      k[2].component)) {
        if (p) {
          ce();
          const B = p;
          C(B.$$.fragment, 1, 0, () => {
            j(B, 1);
          }), ue();
        }
        _ ? (p = nt(_, y()), L(p.$$.fragment), w(p.$$.fragment, 1), N(p, e, null)) : p = null;
      }
    },
    i(k) {
      m || (w(u.$$.fragment, k), p && w(p.$$.fragment, k), m = !0);
    },
    o(k) {
      C(u.$$.fragment, k), p && C(p.$$.fragment, k), m = !1;
    },
    d(k) {
      k && S(e), j(u), p && j(p), g = !1, Ne(h);
    }
  };
}
f(Jte, "create_fragment$2B");
function Zte(i, e, t) {
  let s, { document: n, actionId: l, dialog: r } = fe("#external").application, { document: o = n, actionId: a = l, dialog: c = r } = e;
  const u = o;
  pe(i, u, (_) => t(3, s = _));
  function d(_) {
    t(2, m = p[_.detail]);
  }
  f(d, "updateCurrentTab");
  const p = [
    {
      name: "description",
      label: "A5E.ItemSheetLabelDescriptionTab",
      component: A0
    },
    {
      name: "activation",
      label: "A5E.TabActivation",
      component: _0
    },
    {
      name: "targeting",
      label: "A5E.TabTargeting",
      component: nv
    },
    {
      name: "rolls",
      label: "A5E.TabRolls",
      component: z0
    },
    {
      name: "prompts",
      label: "A5E.TabPrompts",
      component: M0
    },
    {
      name: "consumers",
      label: "A5E.TabResourceManagement",
      component: Y0
    },
    {
      name: "effects",
      label: "A5E.TabEffects",
      component: T0
    }
  ];
  let m = p[0];
  et("item", u), et("actionId", a);
  const g = /* @__PURE__ */ f(() => ab(s, { actionId: a, dialog: c }), "click_handler"), h = /* @__PURE__ */ f(({ target: _ }) => se(s, `system.actions.${a}.name`, _.value), "change_handler");
  return i.$$set = (_) => {
    "document" in _ && t(7, o = _.document), "actionId" in _ && t(0, a = _.actionId), "dialog" in _ && t(1, c = _.dialog);
  }, [
    a,
    c,
    m,
    s,
    u,
    d,
    p,
    o,
    g,
    h
  ];
}
f(Zte, "instance$2s");
const gS = class gS extends ie {
  constructor(e) {
    super(), le(this, e, Zte, Jte, ne, { document: 7, actionId: 0, dialog: 1 });
  }
  get document() {
    return this.$$.ctx[7];
  }
  set document(e) {
    this.$$set({ document: e }), Ke();
  }
  get actionId() {
    return this.$$.ctx[0];
  }
  set actionId(e) {
    this.$$set({ actionId: e }), Ke();
  }
  get dialog() {
    return this.$$.ctx[1];
  }
  set dialog(e) {
    this.$$set({ dialog: e }), Ke();
  }
};
f(gS, "ActionConfigDialog");
let ov = gS;
var wt;
const Ng = class Ng extends Xd {
  constructor(t) {
    super(t.system.actions);
    Y(this, wt, void 0);
    ye(this, wt, t);
  }
  /** ************************************************
   * Getters
   * ************************************************ */
  get count() {
    return Object.keys(M(this, wt).system.actions ?? {}).length;
  }
  get activationTypes() {
    return Object.values(M(this, wt).system.actions ?? {}).reduce((s, n) => {
      var l;
      return (l = n.activation) != null && l.type && s.add(n.activation.type), s;
    }, /* @__PURE__ */ new Set());
  }
  get hasRoll() {
    const { actions: t } = M(this, wt).system;
    return Object.values(t).some((s) => {
      var n;
      return !!((n = Object.values(s.rolls)) != null && n.length);
    });
  }
  get hasPrompt() {
    const { actions: t } = M(this, wt).system;
    return Object.values(t).some((s) => {
      var n;
      return !!((n = Object.values(s.prompts)) != null && n.length);
    });
  }
  get hasConsumer() {
    const { actions: t } = M(this, wt).system;
    return Object.values(t).some((s) => {
      var n;
      return !!((n = Object.values(s.consumers)) != null && n.length);
    });
  }
  get hasRange() {
    const { actions: t } = M(this, wt).system;
    return Object.values(t).some((s) => {
      var n;
      return !!((n = Object.values(s.ranges)) != null && n.length);
    });
  }
  /** ************************************************
   * Iterator Returns
   * ************************************************ */
  /**
   *
   * @returns {Array}
   */
  entries() {
    return Object.entries(M(this, wt).system.actions ?? {});
  }
  keys() {
    return Object.keys(M(this, wt).system.actions ?? {});
  }
  values() {
    return Object.values(M(this, wt).system.actions ?? {});
  }
  /** ************************************************
   * Get actions or subsections
   * ************************************************ */
  /**
   * @param {String} id
   */
  get(t) {
    var s;
    return (s = M(this, wt).system.actions) == null ? void 0 : s[t];
  }
  /**
   * @param {String} name
   */
  getName(t) {
    var n, l;
    const s = (n = this.entries().find(([r, o]) => o.name === t)) == null ? void 0 : n[0];
    return ((l = M(this, wt).system.actions) == null ? void 0 : l[s]) ?? null;
  }
  getRolls(t) {
    var s;
    return Object.entries(((s = this.get(t)) == null ? void 0 : s.rolls) ?? {});
  }
  getPrompts(t) {
    var s;
    return Object.entries(((s = this.get(t)) == null ? void 0 : s.prompts) ?? {});
  }
  getConsumers(t) {
    var s;
    return Object.entries(((s = this.get(t)) == null ? void 0 : s.consumers) ?? {});
  }
  /** ************************************************
   * Internal methods
   * ************************************************ */
  async add(t = {}, s = !0, n = !1) {
    return Ng.addAction(M(this, wt), t, s, n);
  }
  configure(t) {
    var l;
    const s = M(this, wt).system.actions[t].name;
    let n = M(this, wt).dialogs.actions[t];
    n || ((l = M(this, wt).dialogs.actions)[t] ?? (l[t] = new gn(
      M(this, wt),
      s,
      ov,
      { actionId: t, actionName: s },
      {
        width: 555,
        height: 592,
        resizable: !0,
        isItemDocument: !0
      }
    )), n = M(this, wt).dialogs.actions[t]), n.render(!0);
  }
  async duplicate(t) {
    const s = M(this, wt).system.actions[t];
    if (!s)
      return;
    const n = foundry.utils.duplicate(s), l = foundry.utils.randomID();
    n.name = `${n.name} (Copy)`;
    const r = Object.entries(n.prompts ?? {}).filter(([, o]) => o.type === "effect");
    if (r.length)
      for await (const [o, a] of r) {
        const c = M(this, wt).effects.get(a.effectId);
        if (!c)
          return;
        const u = foundry.utils.duplicate(c);
        foundry.utils.setProperty(u, "flags.a5e.actionId", l);
        const d = await M(this, wt).createEmbeddedDocuments("ActiveEffect", [u]);
        n.prompts[o].effectId = d[0].id;
      }
    await M(this, wt).update({
      "system.actions": {
        ...M(this, wt).system.actions,
        [l]: n
      }
    });
  }
  async remove(t) {
    const s = M(this, wt).dialogs.actions[t];
    await (s == null ? void 0 : s.close()), delete M(this, wt).dialogs.actions[t], await M(this, wt).update({
      "system.actions": {
        [`-=${t}`]: null
      }
    });
    const n = M(this, wt).effects.filter(
      (l) => l.flags.a5e.actionId === t
    );
    M(this, wt).deleteEmbeddedDocuments("ActiveEffect", n.map((l) => l.id));
  }
  /** ************************************************
   * Static Methods
   * ************************************************ */
  /**
   *
   * @param {ItemA5E} item
   * @param {Object} data
   * @param {Boolean} update
   * @returns {Action}
   */
  static async addAction(t, s = {}, n = !0, l = !1) {
    var u;
    const r = foundry.utils.mergeObject({
      name: this.getActionName(t) || "New Action",
      activation: {},
      consumers: {},
      rolls: {},
      prompts: {},
      uses: {
        value: 0,
        max: "",
        per: "",
        recharge: {
          formula: "1d6",
          rechargeType: "custom",
          rechargeAmount: "1",
          threshold: 6
        }
      }
    }, s), o = foundry.utils.randomID();
    let a = null;
    (u = t.system.uses) != null && u.max && (a = await this.addConsumer(t, [o, r], "itemUses", {}, !1)), t.type === "spell" ? a = await this.addConsumer(t, [o, r], "spell", {}, !1) : t.type === "maneuver" && (a = await this.addConsumer(t, [o, r], "resource", { resource: "exertion" }, !1)), a && (r.consumers = {
      ...r.consumers,
      ...Object.values(a)[0]
    });
    const c = {
      "system.actions": {
        ...t.system.actions,
        [o]: r
      }
    };
    return n && await t.update(c), l ? [o, c] : c;
  }
  /**
   *
   * @param {ItemA5E} item
   * @param {Array<String, Action>} action
   * @param {String} type
   * @param {Object} data
   * @param {Boolean} update
   * @returns {Object}
   */
  static async addRoll(t, s, n, l = {}, r = !0) {
    const o = {
      type: n,
      default: !0
    };
    n === "attack" && (o.attackType = "meleeWeaponAttack", o.proficient = !0), (n === "abilityCheck" || n === "savingThrow") && (o.ability = "str"), n === "skillCheck" && (o.skill = "acr", o.ability = "none"), n === "toolCheck" && (o.tool = "airVehicles", o.ability = "none");
    const a = {
      [`system.actions.${s[0]}.rolls`]: {
        ...s[1].rolls,
        [foundry.utils.randomID()]: foundry.utils.mergeObject(o, l)
      }
    };
    return r && t.update(a), a;
  }
  /**
   *
   * @param {ItemA5E} item
   * @param {Array<String, Action>} action
   * @param {String} type
   * @param {Object} data
   * @param {Boolean} update
   * @returns {Object}
   */
  static async addPrompt(t, s, n, l = {}, r = !0) {
    const o = {
      type: n,
      default: !0
    };
    (n === "savingThrow" || n === "abilityCheck") && (o.ability = "str"), n === "savingThrow" && (o.saveDC = { type: "spellcasting" }), n === "skillCheck" && (o.skill = "acr");
    const a = {
      [`system.actions.${s[0]}.prompts`]: {
        ...s[1].prompts,
        [foundry.utils.randomID()]: foundry.utils.mergeObject(o, l)
      }
    };
    return r && t.update(a), a;
  }
  /**
   *
   * @param {ItemA5E} item
   * @param {Array<String, Action>} action
   * @param {String} type
   * @param {Object} data
   * @param {Boolean} update
   * @returns {Object}
   */
  static async addConsumer(t, s, n, l = {}, r = !0) {
    var c;
    const o = {
      type: n,
      default: !0
    };
    ["ammunition", "quantity"].includes(n) && (o.itemId = "", o.quantity = 1), n === "hitDice" && (o.quantity = 1), n === "resource" && (o.resource = "", o.quantity = 1), n === "spell" && (o.mode = "variable", o.spellLevel = t.system.level ?? 1, o.points = ((c = CONFIG.A5E.spellLevelCost) == null ? void 0 : c[t.system.level]) ?? 1), ["actionUses", "itemUses"].includes(n) && (l.quantity = 1);
    const a = {
      [`system.actions.${s[0]}.consumers`]: {
        ...s[1].consumers,
        [foundry.utils.randomID()]: foundry.utils.mergeObject(o, l)
      }
    };
    return r && t.update(a), a;
  }
  static getActionName(t) {
    const s = game.settings.get("a5e", "newActionNameType");
    if (s === "action")
      return "New Action";
    if (s === "item")
      return t.name ?? "New Action";
    const n = t.type;
    if (n === "feature")
      return "Use Feature";
    if (n === "maneuver")
      return "Execute";
    if (n === "spell")
      return "Cast Spell";
    if (n === "object") {
      const { objectType: l } = t.system;
      return l === "consumable" ? "Consume" : l === "tool" ? "Use Tool" : l === "weapon" ? "Attack" : "Use Object";
    }
    return "New Action";
  }
};
wt = new WeakMap(), f(Ng, "ActionsManager");
let ri = Ng;
var us, Wn, sa, ef, Vs, jg, FB, Lg, NB, Bg, jB, qg, LB, Gg, BB, zg, qB;
const bS = class bS {
  constructor(e, t, s, n) {
    Y(this, jg);
    Y(this, Lg);
    Y(this, Bg);
    Y(this, qg);
    Y(this, Gg);
    Y(this, zg);
    Y(this, us, void 0);
    Y(this, Wn, void 0);
    Y(this, sa, void 0);
    Y(this, ef, void 0);
    Y(this, Vs, void 0);
    ye(this, us, e), ye(this, Wn, t), ye(this, sa, s), ye(this, ef, n), ye(this, Vs, {
      actor: {},
      item: {}
    });
  }
  get action() {
    return M(this, Wn).actions[M(this, sa)];
  }
  async consumeResources() {
    var r;
    const e = Object.values(((r = this.action) == null ? void 0 : r.consumers) ?? {}), {
      actionUses: t,
      hitDice: s,
      itemUses: n,
      spell: l
    } = M(this, ef);
    e.forEach((o) => {
      const a = o == null ? void 0 : o.type;
      a && (a === "actionUses" ? Z(this, jg, FB).call(this, t) : a === "hitDice" ? Z(this, Lg, NB).call(this, s) : a === "itemUses" ? Z(this, Bg, jB).call(this, n) : a === "spell" ? Z(this, zg, qB).call(this, l) : a === "resource" ? Z(this, Gg, BB).call(this, o) : ["ammunition", "quantity"].includes(a) && Z(this, qg, LB).call(this, o));
    }), await M(this, Wn).update(M(this, Vs).item), await M(this, us).update(M(this, Vs).actor);
  }
};
us = new WeakMap(), Wn = new WeakMap(), sa = new WeakMap(), ef = new WeakMap(), Vs = new WeakMap(), jg = new WeakSet(), FB = /* @__PURE__ */ f(function({ quantity: e } = {}) {
  var l;
  const t = ((l = this.action) == null ? void 0 : l.uses) ?? {};
  if (!e || (t == null ? void 0 : t.value) !== 0 && !(t != null && t.value) || !M(this, us))
    return;
  const s = at(
    (t == null ? void 0 : t.max) ?? t.value,
    M(this, us).getRollData(M(this, Wn))
  ), n = Math.clamped(t.value - e, 0, s);
  M(this, Vs).item[`system.actions.${M(this, sa)}.uses.value`] = n;
}, "#consumeActionUses"), Lg = new WeakSet(), NB = /* @__PURE__ */ f(function({ selected: e } = {}) {
  const { hitDice: t } = M(this, us).system.attributes;
  !e || !M(this, us) || (Object.entries(t ?? {}).forEach(([s, { current: n }]) => {
    const l = e[s] ?? 0;
    t[s].current = Math.max(n - l, 0);
  }), M(this, Vs).actor["system.attributes.hitDice"] = t);
}, "#consumeHitDice"), Bg = new WeakSet(), jB = /* @__PURE__ */ f(function({ quantity: e } = {}) {
  const { value: t } = M(this, Wn).system.uses;
  if (t !== 0 && !t || !e || !M(this, us))
    return;
  const s = at(
    M(this, Wn).system.uses.max ?? t,
    M(this, us).getRollData(M(this, Wn))
  );
  M(this, Vs).item["system.uses.value"] = Math.clamped(t - e, 0, s);
}, "#consumeItemUses"), qg = new WeakSet(), LB = /* @__PURE__ */ f(async function({ itemId: e, quantity: t } = {}) {
  if (!M(this, us) || e === "")
    return;
  const s = M(this, us).items.get(e);
  if (!s)
    return;
  const n = Math.max((s.system.quantity ?? 0) - t, 0);
  await M(this, us).updateEmbeddedDocuments(
    "Item",
    [{ _id: s.id, "system.quantity": n }]
  );
}, "#consumeQuantity"), Gg = new WeakSet(), BB = /* @__PURE__ */ f(function({ quantity: e, resource: t, restore: s } = {}) {
  var a;
  const n = (a = CONFIG.A5E.resourceConsumerConfig) == null ? void 0 : a[t];
  if (!M(this, us) || !t || !n)
    return;
  const { path: l, type: r } = n, o = foundry.utils.getProperty(M(this, us).system, l) ?? 0;
  r === "boolean" ? M(this, Vs).actor[`system.${l}`] = s ?? !1 : M(this, Vs).actor[`system.${l}`] = Math.max(o - e, 0);
}, "#consumeResource"), zg = new WeakSet(), qB = /* @__PURE__ */ f(function(e) {
  var l, r;
  if (!e || !M(this, us))
    return;
  const { consume: t, level: s, points: n } = e;
  if (t === "spellSlot") {
    const o = (r = (l = M(this, us).system.spellResources.slots) == null ? void 0 : l[s]) == null ? void 0 : r.current;
    M(this, Vs).actor[`system.spellResources.slots.${s}.current`] = Math.max(o - 1, 0);
  } else if (t === "spellPoint") {
    const o = M(this, us).system.spellResources.points.current;
    M(this, Vs).actor["system.spellResources.points.current"] = Math.max(o - n, 0);
  }
}, "#consumeSpellResource"), f(bS, "ResourceConsumptionManager");
let np = bS;
var na, md, Hg, GB, Ug, zB, Vg, HB, Wg, UB, Kg, VB, Yg, WB, Xg, KB, ia, hd;
const _S = class _S extends Pc {
  constructor() {
    super(...arguments);
    Y(this, na);
    Y(this, Hg);
    Y(this, Ug);
    Y(this, Vg);
    Y(this, Wg);
    Y(this, Kg);
    Y(this, Yg);
    Y(this, Xg);
    Y(this, ia);
  }
  get actions() {
    return new ri(this);
  }
  // *****************************************************************************************
  prepareDerivedData() {
    super.prepareDerivedData(), ["object", "feature"].includes(this.type) && this.prepareArmorData();
  }
  prepareArmorData() {
    const t = this.system, { baseFormula: s, maxDex: n } = t.ac ?? {};
    if (!s)
      return;
    let l = s;
    n && n > 0 && (l = s.replaceAll(/@dex\.mod|@abilities\.dex\.mod/gm, `min(@dex.mod, ${n})`)), (t == null ? void 0 : t.damagedState) === CONFIG.A5E.DAMAGED_STATES.BROKEN && (t.objectType === "armor" ? l = `10 + max(floor((${l} - 10) / 2), 1)` : l = `max(floor((${l}) / 2), 1)`), foundry.utils.setProperty(this, "system.ac.formula", l);
  }
  // *****************************************************************************************
  /**
   * A handler for activating an item. An actionId can be passed to this method to use a specific
   * action defined on the item. If there are no actions defined, this method defaults to
   * outputting the item's description.
   *
  //  * This method accepts an options object to further customize the activation process.
   *
   * @override
   * @param {string} actionId
   * @param {object options
   * @returns
   */
  async activate(t, s = {}) {
    if (!(!this.actor || !(this != null && this.actor.isOwner)))
      if (this.actions.count === 0)
        this.shareItemDescription();
      else if (this.actions.count === 1)
        Z(this, na, md).call(this, this.actions.keys()[0], s);
      else if (t)
        Z(this, na, md).call(this, t, s);
      else {
        const n = new g0(this);
        await n.render(!0);
        const l = await n.promise;
        if (!(l != null && l.actionId))
          return;
        Z(this, na, md).call(this, l.actionId, s);
      }
  }
  async showActionActivationDialog(t, s) {
    return !!(!foundry.utils.isEmpty(s == null ? void 0 : s.rolls) || !foundry.utils.isEmpty(s == null ? void 0 : s.prompts) || new Set(
      Object.values((s == null ? void 0 : s.consumers) ?? {}).map((l) => l.type)
    ).intersects(CONFIG.A5E.configurableConsumers));
  }
  async recharge(t, s = !1) {
    var p, m, g, h, _, y, k, v, O, P, D, I;
    if (s || !this.actor)
      return;
    let n = at(this.system.uses.max, this.actor.getRollData(this)), l = this.system.uses.value, r = this.system.uses.recharge.formula || "1d6", o = this.system.uses.recharge.threshold ?? 6, a = ((p = this.system.uses.recharge) == null ? void 0 : p.rechargeType) || "custom", c = ((m = this.system.uses.recharge) == null ? void 0 : m.rechargeAmount) || "1", u = "system.uses.value";
    if (t) {
      const B = this.actions[t];
      n = at(((g = B.uses) == null ? void 0 : g.max) ?? "", this.actor.getRollData(this)), l = ((h = B.uses) == null ? void 0 : h.value) ?? 0, r = ((y = (_ = B.uses) == null ? void 0 : _.recharge) == null ? void 0 : y.formula) || "1d6", o = ((v = (k = B.uses) == null ? void 0 : k.recharge) == null ? void 0 : v.threshold) ?? 6, a = ((P = (O = B.uses) == null ? void 0 : O.recharge) == null ? void 0 : P.rechargeType) || "custom", c = ((I = (D = B.uses) == null ? void 0 : D.recharge) == null ? void 0 : I.rechargeAmount) || "1", u = `system.actions.${t}.uses.value`;
    }
    const d = await new Roll(r, this.actor.getRollData(this)).evaluate({ async: !0 });
    if (d.toMessage(), !(d.total < o))
      if (a === "min")
        await this.update({ [u]: 0 });
      else if (a === "max")
        await this.update({ [u]: n });
      else {
        const B = await new Roll(
          c,
          this.actor.getRollData(this)
        ).evaluate({ async: !0 });
        await this.update({ [u]: Math.min(n, l + B.total) });
      }
  }
  /** @inheritdoc */
  async _preCreate(t, s, n) {
    await super._preCreate(t, s, n);
  }
  async _preUpdate(t, s, n) {
    foundry.utils.getProperty(t, "system.objectType") && await this._preUpdateObjectType(), super._onUpdate(t, s, n);
  }
  async _onCreate(t, s, n) {
    super._onCreate(t, s, n);
  }
  async _onDelete(t, s, n) {
    super._onDelete(t, s, n);
  }
};
na = new WeakSet(), md = /* @__PURE__ */ f(async function(t, s) {
  var g, h, _, y, k, v, O, P, D;
  let n;
  const l = this.actions[t];
  if (s.skipRollDialog ? n = Z(this, Ug, zB).call(this, t, s) : n = await Z(this, Hg, GB).call(this, t, s), !n)
    return null;
  n.rolls ?? (n.rolls = []), n.rolls.push((n == null ? void 0 : n.attack) ?? {});
  const o = await new $r({
    actor: this.actor,
    item: this,
    consumers: n.consumers ?? {},
    damageBonuses: n.damageBonuses ?? {},
    healingBonuses: n.healingBonuses ?? {},
    rolls: n.rolls ?? {}
  }).prepareRolls(), a = new wa(
    this.actor,
    this,
    l,
    n.consumers ?? {}
  ), c = a.validateBaseTemplateData();
  n.placeTemplate && c && await a.placeActionTemplates(), await new np(
    this.actor,
    this,
    t,
    n.consumers ?? {}
  ).consumeResources();
  const d = {
    user: (g = game.user) == null ? void 0 : g.id,
    flavor: l.name ? `${this.name}: ${l.name}` : this.name,
    speaker: ChatMessage.getSpeaker({ actor: this }),
    type: o.length ? CONST.CHAT_MESSAGE_TYPES.ROLL : CONST.CHAT_MESSAGE_TYPES.OTHER,
    sound: CONFIG.sounds.dice,
    rolls: o.map(({ roll: I }) => I),
    rollMode: n.visibilityMode ?? game.settings.get("core", "rollMode"),
    flags: {
      a5e: {
        actorId: this.actor.uuid,
        itemId: this.uuid,
        cardType: "item",
        castingLevel: ((_ = (h = n.consumers) == null ? void 0 : h.spell) == null ? void 0 : _.level) ?? this.system.level ?? null,
        img: l.img ?? this.img ?? "icons/svg/item-bag.svg",
        name: this.name,
        actionName: l.name,
        actionDescription: (y = l == null ? void 0 : l.descriptionOutputs) != null && y.includes("action") ? await TextEditor.enrichHTML(l.description, {
          async: !0,
          secrets: this.isOwner,
          relativeTo: this,
          rollData: ((k = this == null ? void 0 : this.actor) == null ? void 0 : k.getRollData(this)) ?? {}
        }) : null,
        itemDescription: ((v = l == null ? void 0 : l.descriptionOutputs) == null ? void 0 : v.includes("item")) ?? !0 ? await TextEditor.enrichHTML(this.system.description, {
          async: !0,
          secrets: this.isOwner,
          relativeTo: this,
          rollData: ((O = this == null ? void 0 : this.actor) == null ? void 0 : O.getRollData(this)) ?? {}
        }) : null,
        unidentifiedDescription: ((P = l == null ? void 0 : l.descriptionOutputs) == null ? void 0 : P.includes("item")) ?? !0 ? await TextEditor.enrichHTML(this.system.unidentifiedDescription, {
          async: !0,
          secrets: this.isOwner,
          relativeTo: this,
          rollData: ((D = this == null ? void 0 : this.actor) == null ? void 0 : D.getRollData(this)) ?? {}
        }) : null,
        prompts: n.prompts,
        rollData: o.map(({ roll: I, ...B }) => B),
        summaryData: Of(this, l, {
          hideAttunementData: !0,
          hideCraftingComponents: !0,
          hidePrice: !0,
          hideRarity: !0,
          hideSpellClasses: !0,
          hideSpellComponents: !0,
          hideSpellLevel: !0
        })
      }
    },
    content: "<article></article>"
  };
  ChatMessage.applyRollMode(d, n.visibilityMode ?? game.settings.get("core", "rollMode"));
  const p = await ChatMessage.create(d);
  return n.prompts.reduce((I, { type: B, effectId: F }) => {
    var H, G;
    if (B === "effect") {
      const U = this.effects.get(F);
      if (!U || !((G = (H = U.flags) == null ? void 0 : H.a5e) != null && G.applyToSelf))
        return I;
      I.push(U);
    }
    return I;
  }, []).forEach((I) => I.transferEffect(this.actor)), Hooks.callAll("a5e.itemActivate", this, {
    actionId: t,
    action: l,
    dialog: n,
    options: s,
    rolls: o,
    validTemplate: c
  }), p;
}, "#activateAction"), Hg = new WeakSet(), GB = /* @__PURE__ */ f(async function(t, s) {
  const n = new m0({
    actionId: t,
    options: s,
    actorDocument: this.actor,
    itemDocument: this
  });
  return n.render(!0), n.promise;
}, "#showActionActivationPrompt"), Ug = new WeakSet(), zB = /* @__PURE__ */ f(function(t, s) {
  var m;
  const n = this.actions[t];
  if (!n)
    return null;
  const l = fB(n.rolls), r = Z(this, Vg, HB).call(this, l.attack, s), o = Z(this, Wg, UB).call(this, cB(n.consumers)), { damageBonuses: a, healingBonuses: c } = Z(this, Kg, VB).call(this, this.actor, l), u = Z(this, Xg, KB).call(this, l), d = Z(this, Yg, WB).call(this, n.prompts), p = game.settings.get("a5e", "placeItemTemplateDefault") || ((m = n == null ? void 0 : n.area) == null ? void 0 : m.placeTemplate) || !1;
  return {
    attack: r,
    consumers: o,
    damageBonuses: a,
    healingBonuses: c,
    placeTemplate: p,
    prompts: d,
    rolls: u
  };
}, "#getDefaultActionActivationData"), Vg = new WeakSet(), HB = /* @__PURE__ */ f(function(t, s) {
  var u, d, p, m;
  if (!t)
    return {};
  const { actor: n } = this, l = t[0][1], r = aB(n, this, l), o = (u = n.RollOverrideManager) == null ? void 0 : u.getExpertiseDice(
    `attackTypes.${l.attackType}`,
    s.expertiseDie ?? 0
  ), a = (d = n.RollOverrideManager) == null ? void 0 : d.getRollOverride(
    `attackTypes.${l.attackType}`,
    s.rollMode ?? CONFIG.A5E.ROLL_MODE.NORMAL
  ), c = si(n, {
    ability: r,
    attackBonus: l == null ? void 0 : l.bonus,
    attackType: l == null ? void 0 : l.attackType,
    expertiseDie: o,
    item: this,
    proficient: (l == null ? void 0 : l.proficient) ?? !0,
    rollMode: a,
    situationalMods: s.situationalMods,
    selectedAttackBonuses: (m = (p = this.parent) == null ? void 0 : p.BonusesManager) == null ? void 0 : m.getDefaultSelections(
      "attacks",
      { item: this, attackType: l == null ? void 0 : l.attackType }
    ),
    type: "attack"
  });
  return {
    bonus: l.bonus ?? "",
    critThreshold: l.critThreshold ?? 20,
    type: "attack",
    attackType: l.attackType ?? "meleeWeaponAttack",
    ability: r,
    rollMode: a,
    formula: c
  };
}, "#getDefaultAttackRollData"), Wg = new WeakSet(), UB = /* @__PURE__ */ f(function(t) {
  var d, p, m, g, h, _, y, k, v, O;
  const s = {}, n = Z(this, ia, hd).call(this, t, "actionUses");
  foundry.utils.isEmpty(n) || (s.quantity = (n == null ? void 0 : n.quantity) ?? 1, s.baseUses = (n == null ? void 0 : n.quantity) ?? 1);
  const l = {}, r = Z(this, ia, hd).call(this, t, "hitDice");
  if (!foundry.utils.isEmpty(r)) {
    const P = ob(this.parent).reduce(
      (D, { die: I, total: B }) => (B > 0 && D.push(I), D),
      []
    );
    l.selected = Object.fromEntries(
      P.map((D, I) => [D, I === 0 ? 1 : 0])
    ), l.default = r.default;
  }
  const o = {}, a = Z(this, ia, hd).call(this, t, "itemUses");
  foundry.utils.isEmpty(a) || (o.quantity = (a == null ? void 0 : a.quantity) ?? 1, o.baseUses = (a == null ? void 0 : a.quantity) ?? 1);
  const c = {}, u = ((p = (d = Object.values(t.spell ?? {})) == null ? void 0 : d[0]) == null ? void 0 : p[1]) ?? {};
  if (!foundry.utils.isEmpty(u)) {
    const P = u.mode ?? "variable", D = Object.entries(((h = (g = (m = this.parent) == null ? void 0 : m.system) == null ? void 0 : g.spellResources) == null ? void 0 : h.slots) ?? {}).reduce(
      (U, [q, W]) => (W.max > 0 && W.current > 0 && U.push(q), U),
      []
    );
    c.consume = P === "pointsOnly" ? "spellPoint" : D.length > 0 ? "spellSlot" : "spellPoint", (((_ = this.system) == null ? void 0 : _.level) === null || ((y = this.system) == null ? void 0 : y.level) === void 0) && (c.consume = "noConsume");
    const I = u.spellLevel ?? ((k = this.system) == null ? void 0 : k.level) ?? 1, B = Math.min(...D.map(Number)), F = c.consume === "noConsume" ? I : Math.max(I, B), H = u.points ?? CONFIG.A5E.spellLevelCost[F] ?? 1;
    c.basePoints = H, c.baseLevel = F, c.level = F, c.points = H;
    const G = (O = (v = this.parent) == null ? void 0 : v.spellBooks) == null ? void 0 : O.get(this.system.spellBook);
    G != null && G.disableSpellConsumers && (c.consume = "noConsume");
  }
  return {
    actionUses: s,
    hitDice: l,
    itemUses: o,
    spell: c
  };
}, "#getDefaultConsumerData"), Kg = new WeakSet(), VB = /* @__PURE__ */ f(function(t, s) {
  const n = t.BonusesManager.prepareGlobalDamageBonuses(this, s), l = t.BonusesManager.prepareGlobalHealingBonuses(this, s), r = n.reduce((a, [, c]) => ((c.default ?? !0) && a.push(c), a), []), o = l.reduce((a, [, c]) => ((c.default ?? !0) && a.push(c), a), []);
  return { damageBonuses: r, healingBonuses: o };
}, "#getDefaultBonuses"), Yg = new WeakSet(), WB = /* @__PURE__ */ f(function(t) {
  const s = uB(t, this);
  return Object.entries(s).reduce((n, [l, r]) => (n.push(...r.reduce((o, [, a]) => (l === "savingThrow" && (a.dc = W5(this.actor, this, a.saveDC)), (a.default ?? !0) && o.push(a), o), [])), n), []);
}, "#getDefaultPrompts"), Xg = new WeakSet(), KB = /* @__PURE__ */ f(function(t) {
  return Object.entries(t).reduce((s, [n, l]) => (n === "attack" || s.push(...l.reduce((r, [, o]) => ((o.default ?? !0) && r.push(o), r), [])), s), []);
}, "#getDefaultRollData"), ia = new WeakSet(), hd = /* @__PURE__ */ f(function(t, s) {
  if (foundry.utils.isEmpty(t == null ? void 0 : t[s]))
    return null;
  const [, n] = Object.values(t[s]);
  return n;
}, "#getConsumerFromPreparedConsumers"), f(_S, "ItemA5e");
let $a = _S;
const yS = class yS extends $a {
  prepareBaseData() {
    super.prepareBaseData(), this.grants = new _a(this);
  }
  _preCreate(e, t, s) {
    if (s._id !== game.userId) {
      super._preCreate(e, t, s);
      return;
    }
    if (this.parent && this.parent.documentName === "Actor") {
      const n = this.parent;
      t.keepId = !0, t.noHook || n.grants.createInitialGrants(this, !0);
    }
    super._preCreate(e, t, s);
  }
  async _onCreate(e, t, s) {
    super._onCreate(e, t, s);
  }
  async _onDelete(e, t, s) {
    var l;
    if (super._onDelete(e, t, s), !this.parent || ((l = this.parent) == null ? void 0 : l.documentName) !== "Actor")
      return;
    await this.parent.grants.removeGrantsByItem(this.uuid);
  }
};
f(yS, "FeatureItemA5e");
let av = yS;
var Sn, Tn, la, tf, sf;
const vS = class vS extends Map {
  constructor(t, s, n) {
    super();
    Y(this, Sn, void 0);
    Y(this, Tn, void 0);
    Y(this, la, void 0);
    Y(this, tf, "A5E.validations.warnings.duplicateSubDocument");
    Y(this, sf, "A5E.validations.warnings.invalidSubDocument");
    if (!(t instanceof Item))
      throw Error("SubDocumentManager: Document must be an instance of Item!");
    if (typeof s != "string")
      throw Error("SubDocumentManager: Attribute is required!");
    if (typeof t.system[s] != "object")
      throw Error(`SubDocumentManager: Document must have 'system.${s}'`);
    if (ye(this, Sn, t), ye(this, Tn, s), n) {
      const { validate: l, duplicateWarning: r, validateWarning: o } = n;
      typeof l == "function" && ye(this, la, l), typeof r == "string" && ye(this, tf, r), typeof o == "string" && ye(this, sf, o);
    }
    Object.entries(t.system[s]).forEach(([l, r]) => {
      super.set(l, r);
    });
  }
  /** ************************************************
   * Iterator Returns
   * ************************************************ */
  get documents() {
    return [...this.entries()];
  }
  /**
   * @deprecated Use `get` instead
   */
  getUuid(t) {
    const s = this.get(t);
    return s ? s[1] : void 0;
  }
  getIdByUuid(t) {
    const s = this.documents.find(([, n]) => n.uuid === t);
    return s ? s[0] : void 0;
  }
  /** ************************************************
  *               Internal methods
  * ************************************************ */
  async clean() {
    const t = {};
    for await (const [s, n] of Object.entries(M(this, Sn).system[M(this, Tn)]))
      await fromUuid(n.uuid) || (t[`system.${M(this, Tn)}.-=${s}`] = null);
    await M(this, Sn).update(t);
  }
  cleanSync() {
    const t = {};
    for (const [s, n] of Object.entries(M(this, Sn).system[M(this, Tn)]))
      fromUuidSync(n.uuid) || (t[`system.${M(this, Tn)}.-=${s}`] = null);
    M(this, Sn).update(t);
  }
  /** ************************************************
  *               External methods
  * ************************************************ */
  async add(t, s = {}) {
    var o;
    const n = this.getIdByUuid(t);
    if (n)
      return ui.notifications.warn(M(this, tf)), !1;
    const l = await fromUuid(t);
    if (M(this, la) && !M(this, la).call(this, l))
      return ui.notifications.warn(M(this, sf)), !1;
    foundry.utils.mergeObject(s, { uuid: t }), (l == null ? void 0 : l.type) === "object" && (s.quantity = ((o = l == null ? void 0 : l.system) == null ? void 0 : o.quantity) ?? 1);
    const r = n || foundry.utils.randomID();
    return await M(this, Sn).update({ [`system.${M(this, Tn)}.${r}`]: s }), !0;
  }
  // @ts-ignore
  async delete(t) {
    const s = this.getIdByUuid(t);
    return s ? (await M(this, Sn).update({ [`system.${M(this, Tn)}.-=${s}`]: null }), super.delete(s), !0) : !1;
  }
  async deleteDocuments(t) {
    const s = t.map((l) => this.getIdByUuid(l)).filter((l) => l);
    if (s.length === 0)
      return !1;
    const n = {};
    return s.forEach((l) => {
      n[`system.${M(this, Tn)}.-=${l}`] = null;
    }), await M(this, Sn).update(n), !0;
  }
};
Sn = new WeakMap(), Tn = new WeakMap(), la = new WeakMap(), tf = new WeakMap(), sf = new WeakMap(), f(vS, "SubItemManager");
let cv = vS;
var F5, N5;
const kS = class kS extends cv {
  constructor() {
    super(...arguments);
    Y(this, F5, "A5E.validations.warnings.duplicateSubObjectDocument");
    Y(this, N5, "A5E.validations.warnings.invalidSubObjectDocument");
  }
  // constructor(doc: any, attribute: string, options: any) {
  //   super(doc, attribute, options);
  //   // TODO: Add custom options here
  // }
  /** ************************************************
  *               Internal methods
  * ************************************************ */
  /** ************************************************
  *               External methods
  * ************************************************ */
  /** ************************************************
  *               Container methods
  * ************************************************ */
  static async createContainerOnActor(t, s) {
    var d, p;
    await ((d = s.containerItems) == null ? void 0 : d.clean());
    const n = s.toObject();
    n.system.items = {}, n.system.containerId = null;
    const l = (p = await t.createEmbeddedDocuments("Item", [n])) == null ? void 0 : p[0], r = Object.values(s.system.items), o = [], a = [];
    for await (const { quantityOverride: m, sourceUuid: g, uuid: h } of r) {
      let _ = await fromUuid(h) ?? await fromUuid(g);
      if (_) {
        if (_.system.objectType === "container") {
          a.push(_);
          continue;
        }
        _ = _.toObject(), _.system.containerId = l.uuid, m && (_.system.quantity = m ?? _.system.quantityOverride), o.push(_);
      }
    }
    const c = await Promise.all(
      a.map((m) => this.createContainerOnActor(t, m))
    );
    return [...await t.createEmbeddedDocuments("Item", o), ...c].forEach((m) => m.updateContainer(l.uuid)), l;
  }
  static async createContainerOnSideBar(t, s) {
    var d, p;
    await ((d = t.containerItems) == null ? void 0 : d.clean());
    const n = t.toObject();
    n.system.items = {}, n.system.containerId = null, n.folder = s;
    const l = (p = await Item.createDocuments([n])) == null ? void 0 : p[0], r = Object.values(t.system.items), o = [], a = [];
    for await (const { quantityOverride: m, sourceUuid: g, uuid: h } of r) {
      let _ = await fromUuid(h) ?? await fromUuid(g);
      if (_) {
        if (_.system.objectType === "container") {
          a.push(_);
          continue;
        }
        _ = _.toObject(), _.system.containerId = l.uuid, _.folder = s, m && (_.system.quantity = m ?? _.system.quantityOverride), o.push(_);
      }
    }
    const c = await Promise.all(
      a.map((m) => this.createContainerOnSideBar(m, s))
    );
    return [...await Item.createDocuments(o), ...c].forEach((m) => m.updateContainer(l.uuid)), l;
  }
};
F5 = new WeakMap(), N5 = new WeakMap(), f(kS, "SubObjectManager");
let Dr = kS;
const wS = class wS extends foundry.abstract.TypeDataModel {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return {
      isValid: new e.BooleanField({ initial: !0 }),
      isOptional: new e.BooleanField({ initial: !1 }),
      quantityOverride: new e.NumberField({ initial: 0, integer: !0, min: 0 }),
      sourceUuid: new e.StringField({ initial: "" }),
      uuid: new e.StringField({ required: !0, initial: "" })
    };
  }
};
f(wS, "SubObjectField");
let uv = wS;
const $S = class $S extends $a {
  get weight() {
    return this.system.weight;
  }
  // TODO: Container Rework - Add a solid fix at some point
  get containerItemNames() {
    return this.containerItems ? this.containerItems.documents.reduce((t, [, s]) => {
      const n = fromUuidSync(s.uuid);
      if (!n)
        return t;
      t.push(n.name);
      const l = n.containerItemNames.split(", ");
      return l.length > 0 && t.push(...l), t;
    }, []).join(", ") : "";
  }
  prepareBaseData() {
    super.prepareBaseData(), this.system.objectType === "container" && (this.system.items = Object.entries(this.system.items ?? {}).reduce((e, [t, s]) => (e[t] = new uv(s), e), {}));
  }
  prepareDerivedData() {
    super.prepareDerivedData(), this.system.objectType === "container" && this.prepareContainer();
  }
  prepareContainer() {
    foundry.utils.setProperty(this, "containerItems", new Dr(
      this,
      "items",
      { validate: (e) => e.type === "object" }
    ));
  }
  /**
   * @override
   * @returns
   */
  async duplicateItem() {
    return this.system.objectType !== "container" ? super.duplicateItem() : this.actor ? await Dr.createContainerOnActor(this.parent, this) : null;
  }
  async toggleAttunement() {
    await this.update({
      "system.attuned": !this.system.attuned
    });
  }
  async toggleDamagedState() {
    const t = (this.system.damagedState + 1) % 3;
    await this.update({
      "system.damagedState": t
    });
  }
  async toggleEquippedState() {
    if (!this.actor)
      return;
    let t = (this.system.equippedState + 1) % 3;
    if (t === CONFIG.A5E.EQUIPPED_STATES.EQUIPPED && this.system.objectType === "armor") {
      const { hasArmor: s, hasUnderArmor: n } = this.parent.items.reduce((r, o) => (o.system.equippedState !== CONFIG.A5E.EQUIPPED_STATES.EQUIPPED || o.system.objectType !== "armor" || (o.system.materialProperties.includes("underarmor") ? r.hasUnderArmor = !0 : r.hasArmor = !0), r), { hasArmor: !1, hasUnderArmor: !1 }), l = this.system.materialProperties.includes("underarmor");
      (l && n || !l && s) && (t = 0), t === 0 && ui.notifications.warn(game.i18n.localize("A5E.armorClass.armorAlreadyEquipped"));
    }
    t === 2 && this.system.objectType === "shield" && (this.parent.items.filter((n) => n.system.equippedState === CONFIG.A5E.EQUIPPED_STATES.EQUIPPED && n.system.objectType === "shield").length >= 2 && (t = 0), t === 0 && ui.notifications.warn(game.i18n.localize("A5E.armorClass.shieldAlreadyEquipped"))), await this.update({
      "system.equippedState": t
    });
  }
  async toggleUnidentified() {
    await this.update({
      "system.unidentified": !this.system.unidentified
    });
  }
  async updateContainer(e) {
    var n, l, r;
    if (e === this.uuid)
      return;
    if (!e) {
      const o = await fromUuid(this.system.containerId);
      if (!o)
        return;
      await this.update({ "system.containerId": "" }), await o.containerItems.delete(this.uuid);
      return;
    }
    const t = await fromUuid(this.system.containerId);
    t && await t.containerItems.delete(this.uuid);
    const s = await fromUuid(e);
    !s || ((n = s == null ? void 0 : s.system) == null ? void 0 : n.objectType) !== "container" || ((l = s == null ? void 0 : s.parent) == null ? void 0 : l.id) !== ((r = this.parent) == null ? void 0 : r.id) || (await this.update({ "system.containerId": e }), await s.containerItems.add(this.uuid));
  }
  /** @inheritdoc */
  async _preCreate(e, t, s) {
    await super._preCreate(e, t, s);
  }
  async _preUpdate(e, t, s) {
    foundry.utils.getProperty(e, "system.objectType") && await this._preUpdateObjectType(), super._onUpdate(e, t, s);
  }
  async _preUpdateObjectType() {
    if (this.system.objectType !== "container")
      return;
    const e = {}, t = Object.entries(this.system.items ?? {});
    for await (const [s, n] of t) {
      e[`system.items.-=${s}`] = null;
      const l = await fromUuid(n.uuid);
      l && await l.update({ "system.containerId": "" });
    }
    await this.update(e);
  }
  async _onCreate(e, t, s) {
    if (super._onCreate(e, t, s), s !== game.userId)
      return;
    await fromUuid(this.system.containerId) || await this.update({ "system.containerId": "" });
    const l = {};
    Object.entries(this.system.actions ?? {}).forEach(([o, a]) => {
      Object.entries(a.consumers ?? {}).forEach(([u, d]) => {
        d.type === "quantity" && (l[`system.actions.${o}.consumers.${u}.itemId`] = this._id);
      });
    }), await this.update(l);
  }
  async _onDelete(e, t, s) {
    var l, r;
    if (!this.parent)
      return;
    if (this.system.objectType === "container") {
      const a = Object.values(this.system.items).map(({ uuid: c }) => fromUuidSync(c)).map((c) => ({ _id: c.id, "system.containerId": "" }));
      await ((l = this.parent) == null ? void 0 : l.updateEmbeddedDocuments("Item", a));
    }
    const n = await fromUuid(this.system.containerId);
    n && await ((r = n == null ? void 0 : n.containerItems) == null ? void 0 : r.delete(this.uuid)), super._onDelete(e, t, s);
  }
};
f($S, "ObjectItemA5e");
let fv = $S;
const AS = class AS extends $a {
  get spellBook() {
    return this.system.spellBook;
  }
  async togglePrepared() {
    if (!this.type === "spell" || !this.actor)
      return;
    const t = (Number(this.system.prepared) + 1) % 3;
    await this.update({
      "system.prepared": t
    });
  }
  // eslint-disable-next-line consistent-return
  _preCreate(e, t, s) {
    var n, l;
    if (!((n = e.system) != null && n.spellBook) && ((l = this.parent) == null ? void 0 : l.documentName) === "Actor")
      return ui.notifications.error("You must select a spell book to create a spell."), !1;
    super._preCreate(e, t, s);
  }
};
f(AS, "SpellItemA5e");
let dv = AS;
function Qte(i) {
  i.Actor = {
    documentClasses: {
      character: wy,
      npc: $y
    }
  }, i.Item = {
    documentClasses: {
      feature: av,
      object: fv,
      spell: dv,
      background: Ml,
      class: l0,
      culture: Ml,
      destiny: Ml,
      heritage: Ml
    }
  };
}
f(Qte, "registerDocumentConfig");
function xte(i) {
  i.encounterElements = {
    acid: {
      name: "A5E.encounterElements.acid",
      description: "<p>A creature that touches acid takes 5 (2d4) acid damage. When a creature first enters into an area of acid or starts its turn there, it takes 10 (4d4) ongoing acid damage. A creature submerged in acid takes 25 (10d4) ongoing acid damage. This damage persists for 3 rounds after the creature leaves the acid. A creature ends all ongoing damage from mundane acid by using its action to wipe away the corrosive liquid.</p>",
      crModifier: 2
    },
    brownMold: {
      name: "A5E.encounterElements.brownMold",
      description: `<p>Brown mold subsists on heat, drawing away warmth from the environment and creatures around it. Most patches of brown mold have only a 10-foot radius, but the temperature in a 30-foot radius around it is unnaturally cold.</p>
      <p>When a creature moves within 5 feet of the brown mold for the first time on a turn or starts its turn there, it makes a DC 12 Constitution saving throw, taking 22 (4d10) cold damage on a failure, or half damage on a success.</p>
      <p>Brown mold is not only immune to fire damage but rapidly grows when exposed to flames. When any source of fire — the effects of a spell like fire bolt, a lit torch, and so on—happens within 5 feet of a patch of brown mold, the brown mold rapidly expands to surround it in a 10-foot radius. However, any amount of cold damage instantly destroys a patch of brown mold.</p>`,
      crModifier: 2
    },
    crowd: {
      name: "A5E.encounterElements.crowd",
      description: `<p>Throngs of humanoids are difficult terrain, and a creature surrounded by a crowd has disadvantage on hearing- and sight-based checks to perceive outside of it.</p>
      <p>In addition, making attacks in a crowd risks collateral damage and the wrath of the throng. When a creature attacks from within a crowd or attacks a target within a crowd, on a miss by 10 or more the attack hits a crowd member and the creature makes a Deception, Intimidation, or Persuasion check (DC 13 + 2 per previous check) to convince the crowd not to attack it. On a failure, the crowd transforms into a commoner mob and attacks, fighting until the creature is reduced to 0 hit points or the commoner mob is bloodied.</p>`,
      crModifier: 1
    },
    darkness: {
      name: "A5E.encounterElements.darkness",
      description: "<p>Darkness comes in two varieties: magical and nonmagical. In nonmagical darkness, creatures with darkvision can see out to the range specified by that trait as if it were dim light. In magical darkness, all vision is blocked. Creatures without darkvision cannot see in mundane or magical darkness. In addition, a frightened creature unable to see because of magical darkness is rattled.</p>",
      crModifier: 0.5
    },
    denseSmoke: {
      name: "A5E.encounterElements.denseSmoke",
      description: "<p>Creatures and objects in an area of dense smoke are heavily obscured. When a creature that needs to breathe starts its turn in an area of dense smoke, if it is not holding its breath it makes a Constitution saving throw (DC 10 + 1 per round previous turn in the dense smoke, maximum DC 20) or it begins to suffocate (see Chapter 7: Adventuring, in the Adventurer’s Handbook). A creature that covers its mouth and nose with a damp cloth has advantage on this save. Finally, smell-based checks to perceive or track creatures that have spent more than 1 round in an area of dense smoke have advantage until the creature finishes a long rest or takes at least 10 minutes to clean the smoke from itself.</p>",
      crModifier: 1
    },
    extremeCold: {
      name: "A5E.encounterElements.extremeCold",
      description: `<p>At the end of every hour a creature is exposed to temperatures at or below 0° Fahrenheit (–18° Celsius), it makes a DC 10 Constitution saving throw or suffers a level of fatigue. Resistance to cold damage, immunity to cold damage, or wearing cold weather gear grants an automatic success on this save. Creatures native to an extreme cold environment also automatically succeed on their saving throw.</p>
      <p>Saving throws made against effects or spells that deal cold damage have disadvantage.</p>`,
      crModifier: 1
    },
    extremeHeat: {
      name: "A5E.encounterElements.extremeHeat",
      description: `<p>At the end of every hour a creature is exposed to temperatures at or above 100° Fahrenheit (38 Celsius), it makes a Constitution saving throw (DC 4 + 1 per hour spent in extreme heat) or suffers a level of fatigue. Resistance to fire damage, immunity to fire damage, or keeping a light pack (less than half carrying capacity) grants an automatic success on this save, whereas a creature wearing medium armor, heavy armor, or heavy clothing has disadvantage. Creatures native to an extreme heat environment also automatically succeed on their saving throw.</p>
      <p>Saving throws made against effects or spells that deal fire damage have disadvantage.</p>`,
      crModifier: 1
    },
    falling30: {
      name: "A5E.encounterElements.falling30",
      description: "<p>The quickest way to severe harm (or even death) is from falling. Whether from a rooftop, cliff’s edge, treetop, or flying mount, falling can deal a devastating amount of damage. When a creature falls, it takes 1d6 bludgeoning damage for every 10 feet it falls (maximum 20d6) and lands prone.</p> equal to the distance it falls divided by 5).</p>",
      crModifier: 1
    },
    falling60: {
      name: "A5E.encounterElements.falling60",
      description: "<p>The quickest way to severe harm (or even death) is from falling. Whether from a rooftop, cliff’s edge, treetop, or flying mount, falling can deal a devastating amount of damage. When a creature falls, it takes 1d6 bludgeoning damage for every 10 feet it falls (maximum 20d6) and lands prone.</p> equal to the distance it falls divided by 5).</p>",
      crModifier: 2
    },
    falling90: {
      name: "A5E.encounterElements.falling90",
      description: "<p>The quickest way to severe harm (or even death) is from falling. Whether from a rooftop, cliff’s edge, treetop, or flying mount, falling can deal a devastating amount of damage. When a creature falls, it takes 1d6 bludgeoning damage for every 10 feet it falls (maximum 20d6) and lands prone.</p> equal to the distance it falls divided by 5).</p>",
      crModifier: 3
    },
    falling120: {
      name: "A5E.encounterElements.falling120",
      description: "<p>The quickest way to severe harm (or even death) is from falling. Whether from a rooftop, cliff’s edge, treetop, or flying mount, falling can deal a devastating amount of damage. When a creature falls, it takes 1d6 bludgeoning damage for every 10 feet it falls (maximum 20d6) and lands prone.</p> equal to the distance it falls divided by 5).</p>",
      crModifier: 4
    },
    fire: {
      name: "A5E.encounterElements.fire",
      description: "<p>An area of fire sheds bright light to 10 feet beyond its edges and dim light an additional 10 feet. A creature that touches fire takes 7 (2d6) ongoing fire damage. A creature may end ongoing damage from mundane fire by spending an action to extinguish the flames. Smoke and heat shimmer lightly obscure anything within or on the other side of an area of fire.</p>",
      crModifier: 2
    },
    frigidWater: {
      name: "A5E.encounterElements.frigidWater",
      description: "<p>After being in frigid water for a number of minutes equal to its Constitution score, a creature makes a DC 10 Constitution saving throw at the end of each minute or it suffers a level of fatigue. Resistance or immunity to cold damage grants an automatic success on this save. Creatures native to an extreme cold environment also automatically succeed on their saving throw.",
      crModifier: 1
    },
    greenSlime: {
      name: "A5E.encounterElements.greenSlime",
      description: `<p>This sticky, vibrantly green, slopping slime clings to and mercilessly eats away at flesh, plants, and even metal.</p>
      <p>Green slime covers a 5-foot square area or larger, though rarely greater in size than a 20-foot radius. Although it is alive and able to sense with blindsight to a range of 30 feet, green slime has no Intelligence or other ability scores. When green slime senses movement underneath it, it drops towards the ground. A creature in the green slime’s area makes a DC 10 Dexterity saving throw, becoming slimed on a failure.</p>
      <p>A slimed creature takes 5 (1d10) ongoing acid damage until the green slime is scraped off with an action. Green slime is destroyed by sunlight, any feature, spell, or trait that cures disease, or any amount of cold, fire, or radiant damage. Wood or metal exposed to green slime instead takes 11 (2d10) acid damage.</p>`,
      crModifier: 1
    },
    heavyPrecipitation: {
      name: "A5E.encounterElements.heavyPrecipitation",
      description: "<p>Heavy snowfall makes an area lightly obscured, and Perception checks relying on sight are made with disadvantage. Heavy rain has the same effects, also affecting Perception checks that rely on hearing and extinguishing any open flames.</p>",
      crModifier: 0.5
    },
    highGravity: {
      name: "A5E.encounterElements.highGravity",
      description: "<p>The ranges of ranged weapons are halved, as are all jump distances. When a creature makes its first attack in a round using a weapon that does not have the dual-wielding property, it makes a DC 12 Athletics check or subtracts 1d4 from its attack rolls for 1 round. Falling damage is treated as twice the distance in the area and there is no maximum amount of damage that can be taken from a fall. For every hour spent in the area, a creature not acclimated to it makes a Constitution saving throw (DC 8 + the number of hours spent in the area) or gain a level of fatigue (maximum 4 levels of fatigue).</p>",
      crModifier: 2
    },
    lava: {
      name: "A5E.encounterElements.lava",
      description: "<p>A creature that touches lava takes 16 (3d10) ongoing fire damage. When a creature first enters into an area of lava or starts its turn there, it takes 33 (6d10) ongoing fire damage. A creature submerged in lava takes 55 (10d10) ongoing fire damage. This damage persists for 4 rounds after the creature leaves the lava. A creature ends all ongoing damage from lava by using its action to wipe away the molten rock.</p>",
      crModifier: 4
    },
    lowGravity: {
      name: "A5E.encounterElements.lowGravity",
      description: "<p>The ranges of ranged weapons are doubled, as are all jump distances. Falling damage is treated as half the distance in the area. In addition, damage from bludgeoning weapons is reduced by half.</p>",
      crModifier: -1
    },
    magnetizedOre: {
      name: "A5E.encounterElements.magnetizedOre",
      description: `<p>Magnetized ore wreaks havoc on the use of compasses or any natural sense of direction, making both useless within 500 feet.</p>
      <p>While within 50 feet of magnetized ore, a creature wearing heavy armor made from metal or attacking with a metal weapon has disadvantage on its attack rolls, Strength and Dexterity checks, and saving throws made against fatigue.</p>`,
      crModifier: 0.5
    },
    memoryCrystals: {
      name: "A5E.encounterElements.memoryCrystals",
      description: `<p>Recognizing a memory crystal for what it is requires a DC 20 Arcana check. When a creature with prepared spells is within 30 feet of a memory crystal, at the start of its turn it must make a DC 15 spellcasting ability check or lose one randomly determined prepared spell.</p>
      <p>When destroyed (DC 17 Strength check, AC 7, 2 hit points) a memory crystal explodes with dangerous magic in a 10-foot radius. Each creature in the area makes a DC 20 Charisma saving throw, taking 14 (4d6) psychic damage on a failed save, or half as much damage on a successful one.</p>
      <p>An area filled with memory crystals requires a creature to succeed on a DC 8 Acrobatics check at the end of each of its turns to avoid breaking any of the dangerous gemstones.</p>`,
      crModifier: 0.5
    },
    miringGround: {
      name: "A5E.encounterElements.miringGround",
      description: "<p>Sludge, tar, or sufficiently deep and sticky mud can provide real danger to creatures caught in them. Miring ground is difficult terrain. In addition, when a creature starts its turn in miring ground, it begins to sink and makes an Athletics check (DC 12 + 2 per round spent in the area) to continue moving. On a failure, its Speed is reduced by 10 feet. When this reduces a creature’s Speed to 5 feet or less it begins sinking 1 foot deeper into the miring ground at the end of each of its turns. A sinking creature can be freed with an Athletics check equal to the DC of its last failed check against the miring ground. A sinking creature that becomes submerged begins suffocating if it is unable to hold its breath. Any creature trying to aid a sinking creature must have a solid surface to stand on or a fly speed, but can use ropes or similar means to do so at a distance.</p>",
      crModifier: 3
    },
    poisonousPlants: {
      name: "A5E.encounterElements.poisonousPlants",
      description: `<p>Spotting the telltale signs of dangerous vegetation requires a DC 15 Nature check. Poisonous plants can be as sparse as a few shrubs or as pervasive as fields of harmful groundcover.</p>
      <p>When a creature starts its turn within the area or enters the area for the first time on a turn, it makes a DC 10 Constitution saving throw, taking 3 (1d6) poison damage on a failure, or half damage on a success.</p>`,
      crModifier: 1
    },
    rushingLiquid: {
      name: "A5E.encounterElements.rushingLiquid",
      description: "<p>Standing in rushing liquid halves the speed of a creature moving against the current and doubles the speed of creatures moving with it. At the start of each of its turns, a creature in knee-high rushing liquid makes an Acrobatics or Athletics check to keep its footing. On a failure, it is knocked prone and moves a number of feet in the direction of the current equal to the amount it failed the check by (rounded up to the nearest 5 feet). The check is DC 11 if the rushing liquid is knee-high, DC 14 if waist-high, DC 17 if chest-high, and DC 20 if the creature's feet cannot touch the bottom. A creature moving with the current has disadvantage on this check. A creature driven into a solid object by the current (such as a rock) takes damage as if it had fallen a number of feet equal to the distance it was moved by the current (minimum 1d6 bludgeoning, piercing, or slashing damage). Standing up from prone in rushing liquid requires an Acrobatics or Athletics check with a DC equal to DC to keep footing. A creature that loses its footing is considered underwater (see below) until it regains its footing.</p>",
      crModifier: 2
    },
    strongWinds: {
      name: "A5E.encounterElements.strongWinds",
      description: "<p>Ranged weapon attacks and Perception checks that rely on hearing have disadvantage in high winds. In addition, it extinguishes any open flames, disperses fogs and smoke, and forces any flying creature to land before the end of its turn or fall.</p>",
      crModifier: 0.5
    },
    underwater: {
      name: "A5E.encounterElements.underwater",
      description: "<p>A creature that cannot breathe water begins to suffocate underwater once it cannot hold its breath. In addition, creatures without swim speeds have disadvantage on attacks made using any weapon other than a dagger, dueling dagger, javelin, shortsword, spear, or trident. Ranged weapon attacks automatically miss beyond their normal range underwater, and bludgeoning and fire damage are halved. A creature that takes damage while holding its breath underwater must succeed on a concentration check or immediately begin suffocating as if its breath had run out.</p>",
      crModifier: 1
    },
    vacuum: {
      name: "A5E.encounterElements.vacuum",
      description: "<p>An area of vacuum has no air, so creatures that need to breathe must use another source of air or begin to suffocate once they cannot hold their breath. In addition, the area carries no sound, so hearing-based checks made to perceive automatically fail and spells with vocalized components cannot be cast. A creature with its own air supply may cast spells with vocalized components, but still cannot hear. Vacuum is also utterly chilling, dealing 11 (3d6) cold damage to a creature at the start of each of its turns in the area.</p>",
      crModifier: 3
    },
    webs: {
      name: "A5E.encounterElements.webs",
      description: `<p>Whether created by massive insects or swarms of smaller creatures, these sticky strands ensnare and capture creatures that fall afoul of them. An area of webs is difficult terrain, and when a creature starts its turn within the area or enters the area for the first time on a turn, it makes a DC 12 Dexterity saving throw or becomes restrained. Restrained creatures can use an action to make a DC 12 Acrobatics or Athletics check, escaping on a success.</p>
      <p>A 10-foot cube of webs has AC 10, 15 hit points, vulnerability to fire, and immunity to bludgeoning, piercing, and psychic damage.</p>`,
      crModifier: 0.5
    },
    yellowMold: {
      name: "A5E.encounterElements.yellowMold",
      description: `<p>This sickeningly yellow mold only grows in dark places and is extremely sensitive to movement nearby.</p>
      <p>Yellow mold covers a 10-foot radius area. When a creature moves within 30 feet of a patch of yellow mold, at the start of its turn spores are released and it makes a DC 15 Constitution saving throw. On a failure, the creature takes 11 (2d10) ongoing poison damage and becomes poisoned for 1 minute, continuing to take ongoing damage until it is no longer poisoned. At the end of each of its turns, the poisoned creature can repeat the saving throw, ending the effect on itself on a success.</p>
      <p>Yellow mold is destroyed by sunlight or any amount of fire damage.</p>`,
      crModifier: 2
    }
  };
}
f(xte, "registerEncounterElements");
function ese(i) {
  i.effectKeyGroups = {
    abilityChecks: {
      label: "A5E.effects.groups.abilityChecks",
      items: [
        "flags.a5e.effects.rollMode.abilityCheck.all",
        "flags.a5e.effects.rollMode.abilityCheck.cha",
        "flags.a5e.effects.rollMode.abilityCheck.con",
        "flags.a5e.effects.rollMode.abilityCheck.dex",
        "flags.a5e.effects.rollMode.abilityCheck.int",
        "flags.a5e.effects.rollMode.abilityCheck.str",
        "flags.a5e.effects.rollMode.abilityCheck.wis",
        "system.abilities.cha.check.bonus",
        "system.abilities.cha.check.expertiseDice",
        "system.abilities.cha.value",
        "system.abilities.con.check.bonus",
        "system.abilities.con.check.expertiseDice",
        "system.abilities.con.value",
        "system.abilities.dex.check.bonus",
        "system.abilities.dex.check.expertiseDice",
        "system.abilities.dex.value",
        "system.abilities.int.check.bonus",
        "system.abilities.int.check.expertiseDice",
        "system.abilities.int.value",
        "system.abilities.str.check.bonus",
        "system.abilities.str.check.expertiseDice",
        "system.abilities.str.value",
        "system.abilities.wis.check.bonus",
        "system.abilities.wis.check.expertiseDice",
        "system.abilities.wis.value"
      ]
    },
    ac: {
      label: "A5E.effects.groups.ac",
      items: [
        "system.attributes.ac.baseFormula",
        "system.attributes.ac.changes.bonuses.value",
        "system.attributes.ac.value"
      ]
    },
    attackRollModes: {
      label: "A5E.effects.groups.attackRollModes",
      items: [
        "flags.a5e.effects.rollMode.attack.all",
        "flags.a5e.effects.rollMode.attack.meleeSpellAttack",
        "flags.a5e.effects.rollMode.attack.meleeWeaponAttack",
        "flags.a5e.effects.rollMode.attack.rangedSpellAttack",
        "flags.a5e.effects.rollMode.attack.rangedWeaponAttack"
      ]
    },
    attunement: {
      label: "A5E.effects.groups.attunement",
      items: [
        "system.attributes.attunement.current",
        "system.attributes.attunement.max"
      ]
    },
    bonuses: {
      label: "A5E.effects.groups.bonuses",
      items: [
        "flags.a5e.effects.bonuses.abilities",
        "flags.a5e.effects.bonuses.attacks",
        "flags.a5e.effects.bonuses.damage",
        "flags.a5e.effects.bonuses.healing",
        "flags.a5e.effects.bonuses.skills",
        "system.bonuses.abilities.check",
        "system.bonuses.abilities.save",
        "system.bonuses.abilities.skill",
        "system.bonuses.maneuverDC",
        "system.bonuses.spellDC"
      ]
    },
    conditions: {
      label: "A5E.effects.groups.conditions",
      items: [
        "flags.a5e.effects.statusConditions",
        "system.attributes.fatigue",
        "system.attributes.strife"
      ]
    },
    currency: {
      label: "A5E.effects.groups.currency",
      items: [
        "system.currency.cp",
        "system.currency.ep",
        "system.currency.gp",
        "system.currency.pp",
        "system.currency.sp"
      ]
    },
    creatureTraits: {
      label: "A5E.effects.groups.creatureTraits",
      items: [
        "system.traits.size",
        "system.details.creatureTypes",
        "system.details.isSwarm"
      ]
    },
    deathSaves: {
      label: "A5E.effects.groups.deathSaves",
      items: [
        "flags.a5e.deathSaveThreshold",
        "flags.a5e.effects.rollMode.deathSave",
        "system.attributes.death.failure",
        "system.attributes.death.success"
      ]
    },
    exertion: {
      label: "A5E.effects.groups.exertion",
      items: [
        "system.attributes.exertion.current",
        "system.attributes.exertion.max",
        "system.attributes.exertion.recoverOnRest"
      ]
    },
    hitDice: {
      label: "A5E.effects.groups.hitDice",
      items: [
        "system.attributes.hitDice.d20.current",
        "system.attributes.hitDice.d20.total",
        "system.attributes.hitDice.d12.current",
        "system.attributes.hitDice.d12.total",
        "system.attributes.hitDice.d10.current",
        "system.attributes.hitDice.d10.total",
        "system.attributes.hitDice.d6.current",
        "system.attributes.hitDice.d6.total",
        "system.attributes.hitDice.d8.current",
        "system.attributes.hitDice.d8.total",
        "system.attributes.hitDice.d4.current",
        "system.attributes.hitDice.d4.total"
      ]
    },
    hitPoints: {
      label: "A5E.effects.groups.hitPoints",
      items: [
        "system.attributes.hp.baseMax",
        "system.attributes.hp.bonus",
        "system.attributes.hp.value",
        "system.attributes.hp.max",
        "system.attributes.hp.temp"
      ]
    },
    initiative: {
      label: "A5E.effects.groups.initiative",
      items: [
        "flags.a5e.effects.rollMode.initiative",
        "flags.a5e.effects.bonuses.initiative",
        "system.attributes.initiative.ability",
        "system.attributes.initiative.expertiseDice"
      ]
    },
    movement: {
      label: "A5E.effects.groups.movement",
      items: [
        "flags.a5e.effects.movement.allDistances",
        "flags.a5e.effects.movement.allUnits",
        "system.attributes.movement.burrow.distance",
        "system.attributes.movement.burrow.unit",
        "system.attributes.movement.climb.distance",
        "system.attributes.movement.climb.unit",
        "system.attributes.movement.fly.distance",
        "system.attributes.movement.fly.unit",
        "system.attributes.movement.swim.distance",
        "system.attributes.movement.swim.unit",
        "system.attributes.movement.traits.hover",
        "system.attributes.movement.walk.distance",
        "system.attributes.movement.walk.unit"
      ]
    },
    proficiencies: {
      label: "A5E.effects.groups.proficiencies",
      items: [
        "system.proficiencies.armor",
        "system.proficiencies.languages",
        "system.proficiencies.tools",
        "system.proficiencies.weapons"
      ]
    },
    resistancesVulnerabilitiesImmunities: {
      label: "A5E.effects.groups.resistancesVulnerabilitiesImmunities",
      items: [
        "flags.a5e.effects.conditionImmunities.all",
        "flags.a5e.effects.damageImmunities.all",
        "flags.a5e.effects.damageResistances.all",
        "flags.a5e.effects.damageVulnerabilities.all",
        "system.traits.conditionImmunities",
        "system.traits.damageImmunities",
        "system.traits.damageResistances",
        "system.traits.damageVulnerabilities"
      ]
    },
    resources: {
      label: "A5E.effects.groups.resources",
      items: [
        "system.resources.primary.hideMax",
        "system.resources.primary.label",
        "system.resources.primary.max",
        "system.resources.primary.per",
        "system.resources.primary.recharge.formula",
        "system.resources.primary.recharge.threshold",
        "system.resources.primary.value",
        "system.resources.quaternary.hideMax",
        "system.resources.quaternary.label",
        "system.resources.quaternary.max",
        "system.resources.quaternary.per",
        "system.resources.quaternary.recharge.formula",
        "system.resources.quaternary.recharge.threshold",
        "system.resources.quaternary.value",
        "system.resources.secondary.hideMax",
        "system.resources.secondary.label",
        "system.resources.secondary.max",
        "system.resources.secondary.per",
        "system.resources.secondary.recharge.formula",
        "system.resources.secondary.recharge.threshold",
        "system.resources.secondary.value",
        "system.resources.tertiary.hideMax",
        "system.resources.tertiary.label",
        "system.resources.tertiary.max",
        "system.resources.tertiary.per",
        "system.resources.tertiary.recharge.formula",
        "system.resources.tertiary.recharge.threshold",
        "system.resources.tertiary.value"
      ]
    },
    savingThrows: {
      label: "A5E.effects.groups.savingThrows",
      items: [
        "flags.a5e.effects.rollMode.abilitySave.all",
        "flags.a5e.effects.rollMode.abilitySave.cha",
        "flags.a5e.effects.rollMode.abilitySave.con",
        "flags.a5e.effects.rollMode.abilitySave.dex",
        "flags.a5e.effects.rollMode.abilitySave.int",
        "flags.a5e.effects.rollMode.abilitySave.str",
        "flags.a5e.effects.rollMode.abilitySave.wis",
        "flags.a5e.effects.rollMode.concentration",
        "system.abilities.cha.save.bonus",
        "system.abilities.cha.save.expertiseDice",
        "system.abilities.cha.save.proficient",
        "system.abilities.con.save.bonus",
        "system.abilities.con.save.concentrationBonus",
        "system.abilities.con.save.expertiseDice",
        "system.abilities.con.save.proficient",
        "system.abilities.dex.save.bonus",
        "system.abilities.dex.save.expertiseDice",
        "system.abilities.dex.save.proficient",
        "system.abilities.int.save.bonus",
        "system.abilities.int.save.expertiseDice",
        "system.abilities.int.save.proficient",
        "system.abilities.str.save.bonus",
        "system.abilities.str.save.expertiseDice",
        "system.abilities.str.save.proficient",
        "system.abilities.wis.save.bonus",
        "system.abilities.wis.save.expertiseDice",
        "system.abilities.wis.save.proficient"
      ]
    },
    senses: {
      label: "A5E.effects.groups.senses",
      items: [
        "flags.a5e.effects.senses.allDistances",
        "flags.a5e.effects.senses.allUnits",
        "system.attributes.senses.blindsight.distance",
        "system.attributes.senses.blindsight.unit",
        "system.attributes.senses.blindsight.otherwiseBlind",
        "system.attributes.senses.darkvision.distance",
        "system.attributes.senses.darkvision.unit",
        "system.attributes.senses.tremorsense.distance",
        "system.attributes.senses.tremorsense.unit",
        "system.attributes.senses.truesight.distance",
        "system.attributes.senses.truesight.unit"
      ]
    },
    skills: {
      label: "A5E.effects.groups.skills",
      items: [
        "flags.a5e.effects.rollMode.skillCheck.all",
        "flags.a5e.effects.rollMode.skillCheck.acr",
        "flags.a5e.effects.rollMode.skillCheck.ani",
        "flags.a5e.effects.rollMode.skillCheck.arc",
        "flags.a5e.effects.rollMode.skillCheck.ath",
        "flags.a5e.effects.rollMode.skillCheck.cul",
        "flags.a5e.effects.rollMode.skillCheck.dec",
        "flags.a5e.effects.rollMode.skillCheck.eng",
        "flags.a5e.effects.rollMode.skillCheck.his",
        "flags.a5e.effects.rollMode.skillCheck.ins",
        "flags.a5e.effects.rollMode.skillCheck.inv",
        "flags.a5e.effects.rollMode.skillCheck.itm",
        "flags.a5e.effects.rollMode.skillCheck.med",
        "flags.a5e.effects.rollMode.skillCheck.nat",
        "flags.a5e.effects.rollMode.skillCheck.per",
        "flags.a5e.effects.rollMode.skillCheck.prc",
        "flags.a5e.effects.rollMode.skillCheck.prf",
        "flags.a5e.effects.rollMode.skillCheck.rel",
        "flags.a5e.effects.rollMode.skillCheck.slt",
        "flags.a5e.effects.rollMode.skillCheck.ste",
        "flags.a5e.effects.rollMode.skillCheck.sur",
        "system.skills.acr.ability",
        "system.skills.acr.bonuses.check",
        "system.skills.acr.bonuses.passive",
        "system.skills.acr.expertiseDice",
        "system.skills.acr.minRoll",
        "system.skills.acr.proficient",
        "system.skills.acr.specialties",
        "system.skills.acr.value",
        "system.skills.ani.ability",
        "system.skills.ani.bonuses.check",
        "system.skills.ani.bonuses.passive",
        "system.skills.ani.expertiseDice",
        "system.skills.ani.minRoll",
        "system.skills.ani.proficient",
        "system.skills.ani.specialties",
        "system.skills.ani.value",
        "system.skills.arc.ability",
        "system.skills.arc.bonuses.check",
        "system.skills.arc.bonuses.passive",
        "system.skills.arc.expertiseDice",
        "system.skills.arc.minRoll",
        "system.skills.arc.proficient",
        "system.skills.arc.specialties",
        "system.skills.arc.value",
        "system.skills.ath.ability",
        "system.skills.ath.bonuses.check",
        "system.skills.ath.bonuses.passive",
        "system.skills.ath.expertiseDice",
        "system.skills.ath.minRoll",
        "system.skills.ath.proficient",
        "system.skills.ath.specialties",
        "system.skills.ath.value",
        "system.skills.cul.ability",
        "system.skills.cul.bonuses.check",
        "system.skills.cul.bonuses.passive",
        "system.skills.cul.expertiseDice",
        "system.skills.cul.minRoll",
        "system.skills.cul.proficient",
        "system.skills.cul.specialties",
        "system.skills.cul.value",
        "system.skills.dec.ability",
        "system.skills.dec.bonuses.check",
        "system.skills.dec.bonuses.passive",
        "system.skills.dec.expertiseDice",
        "system.skills.dec.minRoll",
        "system.skills.dec.proficient",
        "system.skills.dec.specialties",
        "system.skills.dec.value",
        "system.skills.eng.ability",
        "system.skills.eng.bonuses.check",
        "system.skills.eng.bonuses.passive",
        "system.skills.eng.expertiseDice",
        "system.skills.eng.minRoll",
        "system.skills.eng.proficient",
        "system.skills.eng.specialties",
        "system.skills.eng.value",
        "system.skills.his.ability",
        "system.skills.his.bonuses.check",
        "system.skills.his.bonuses.passive",
        "system.skills.his.expertiseDice",
        "system.skills.his.minRoll",
        "system.skills.his.proficient",
        "system.skills.his.specialties",
        "system.skills.his.value",
        "system.skills.ins.ability",
        "system.skills.ins.bonuses.check",
        "system.skills.ins.bonuses.passive",
        "system.skills.ins.expertiseDice",
        "system.skills.ins.minRoll",
        "system.skills.ins.proficient",
        "system.skills.ins.specialties",
        "system.skills.ins.value",
        "system.skills.itm.ability",
        "system.skills.itm.bonuses.check",
        "system.skills.itm.bonuses.passive",
        "system.skills.itm.expertiseDice",
        "system.skills.itm.minRoll",
        "system.skills.itm.proficient",
        "system.skills.itm.specialties",
        "system.skills.itm.value",
        "system.skills.inv.ability",
        "system.skills.inv.bonuses.check",
        "system.skills.inv.bonuses.passive",
        "system.skills.inv.expertiseDice",
        "system.skills.inv.minRoll",
        "system.skills.inv.proficient",
        "system.skills.inv.specialties",
        "system.skills.inv.value",
        "system.skills.med.ability",
        "system.skills.med.bonuses.check",
        "system.skills.med.bonuses.passive",
        "system.skills.med.expertiseDice",
        "system.skills.med.minRoll",
        "system.skills.med.proficient",
        "system.skills.med.specialties",
        "system.skills.med.value",
        "system.skills.nat.ability",
        "system.skills.nat.bonuses.check",
        "system.skills.nat.bonuses.passive",
        "system.skills.nat.expertiseDice",
        "system.skills.nat.minRoll",
        "system.skills.nat.proficient",
        "system.skills.nat.specialties",
        "system.skills.nat.value",
        "system.skills.prc.ability",
        "system.skills.prc.bonuses.check",
        "system.skills.prc.bonuses.passive",
        "system.skills.prc.expertiseDice",
        "system.skills.prc.minRoll",
        "system.skills.prc.proficient",
        "system.skills.prc.specialties",
        "system.skills.prc.value",
        "system.skills.prf.ability",
        "system.skills.prf.bonuses.check",
        "system.skills.prf.bonuses.passive",
        "system.skills.prf.expertiseDice",
        "system.skills.prf.minRoll",
        "system.skills.prf.proficient",
        "system.skills.prf.specialties",
        "system.skills.prf.value",
        "system.skills.per.ability",
        "system.skills.per.bonuses.check",
        "system.skills.per.bonuses.passive",
        "system.skills.per.expertiseDice",
        "system.skills.per.minRoll",
        "system.skills.per.proficient",
        "system.skills.per.specialties",
        "system.skills.per.value",
        "system.skills.rel.ability",
        "system.skills.rel.bonuses.check",
        "system.skills.rel.bonuses.passive",
        "system.skills.rel.expertiseDice",
        "system.skills.rel.minRoll",
        "system.skills.rel.proficient",
        "system.skills.rel.specialties",
        "system.skills.rel.value",
        "system.skills.slt.ability",
        "system.skills.slt.bonuses.check",
        "system.skills.slt.bonuses.passive",
        "system.skills.slt.expertiseDice",
        "system.skills.slt.minRoll",
        "system.skills.slt.proficient",
        "system.skills.slt.specialties",
        "system.skills.slt.value",
        "system.skills.ste.ability",
        "system.skills.ste.bonuses.check",
        "system.skills.ste.bonuses.passive",
        "system.skills.ste.expertiseDice",
        "system.skills.ste.minRoll",
        "system.skills.ste.proficient",
        "system.skills.ste.specialties",
        "system.skills.ste.value",
        "system.skills.sur.ability",
        "system.skills.sur.bonuses.check",
        "system.skills.sur.bonuses.passive",
        "system.skills.sur.expertiseDice",
        "system.skills.sur.minRoll",
        "system.skills.sur.proficient",
        "system.skills.sur.specialties",
        "system.skills.sur.value"
      ]
    },
    spellResources: {
      label: "A5E.effects.groups.spellResources",
      items: [
        "system.spellResources.points.current",
        "system.spellResources.points.max",
        "system.spellResources.slots.1.current",
        "system.spellResources.slots.1.max",
        "system.spellResources.slots.2.current",
        "system.spellResources.slots.2.max",
        "system.spellResources.slots.3.current",
        "system.spellResources.slots.3.max",
        "system.spellResources.slots.4.current",
        "system.spellResources.slots.4.max",
        "system.spellResources.slots.5.current",
        "system.spellResources.slots.5.max",
        "system.spellResources.slots.6.current",
        "system.spellResources.slots.6.max",
        "system.spellResources.slots.7.current",
        "system.spellResources.slots.7.max",
        "system.spellResources.slots.8.current",
        "system.spellResources.slots.8.max",
        "system.spellResources.slots.9.current",
        "system.spellResources.slots.9.max"
      ]
    },
    token: {
      label: "A5E.effects.groups.token",
      items: [
        "@token.width",
        "@token.height"
      ]
    },
    tokenLight: {
      label: "A5E.effects.groups.tokenLight",
      items: [
        "@token.light.alpha",
        "@token.light.angle",
        "@token.light.animation.intensity",
        "@token.light.animation.reverse",
        "@token.light.animation.speed",
        "@token.light.animation.type",
        "@token.light.attenuation",
        "@token.light.bright",
        "@token.light.color",
        "@token.light.coloration",
        "@token.light.contrast",
        "@token.light.darkness.min",
        "@token.light.darkness.max",
        "@token.light.dim",
        "@token.light.luminosity",
        "@token.light.saturation",
        "@token.light.shadows"
      ]
    },
    tokenTexture: {
      label: "A5E.effects.groups.tokenTexture",
      items: [
        "@token.texture.src",
        "@token.scaleX",
        "@token.scaleY"
      ]
    },
    other: {
      label: "A5E.effects.groups.other",
      items: []
    }
  };
}
f(ese, "registerEffectGroupConfig");
function tse(i) {
  i.effectsKeyLocalizations = {
    "flags.a5e.deathSaveThreshold": "A5E.effects.keys.flags.deathSaveThreshold",
    "flags.a5e.effects.bonuses.abilities": "A5E.effects.keys.bonuses.ability",
    "flags.a5e.effects.bonuses.attacks": "A5E.effects.keys.bonuses.attacks",
    "flags.a5e.effects.bonuses.damage": "A5E.effects.keys.bonuses.damage",
    "flags.a5e.effects.bonuses.healing": "A5E.effects.keys.bonuses.healing",
    "flags.a5e.effects.bonuses.initiative": "A5E.effects.keys.bonuses.initiative",
    "flags.a5e.effects.bonuses.skills": "A5E.effects.keys.bonuses.skill",
    "flags.a5e.effects.conditionImmunities.all": "A5E.effects.keys.flags.conditionImmunities.all",
    "flags.a5e.effects.damageImmunities.all": "A5E.effects.keys.flags.damageImmunities.all",
    "flags.a5e.effects.damageResistances.all": "A5E.effects.keys.flags.damageResistances.all",
    "flags.a5e.effects.damageVulnerabilities.all": "A5E.effects.keys.flags.damageVulnerabilities.all",
    "flags.a5e.effects.movement.allDistances": "A5E.effects.keys.flags.movement.allDistances",
    "flags.a5e.effects.movement.allUnits": "A5E.effects.keys.flags.movement.allUnits",
    "flags.a5e.effects.expertiseDie": "A5E.effects.keys.flags.expertiseDie",
    "flags.a5e.effects.statusConditions": "A5E.effects.keys.flags.statusConditions",
    "flags.a5e.effects.grants.rollMode.attack.all": "A5E.effects.keys.flags.grantsRollMode.all",
    "flags.a5e.effects.grants.rollMode.attack.meleeSpellAttack": "A5E.effects.keys.flags.grantsRollMode.meleeSpellAttack",
    "flags.a5e.effects.grants.rollMode.attack.meleeWeaponAttack": "A5E.effects.keys.flags.grantsRollMode.meleeWeaponAttack",
    "flags.a5e.effects.grants.rollMode.attack.rangedSpellAttack": "A5E.effects.keys.flags.grantsRollMode.rangedSpellAttack",
    "flags.a5e.effects.grants.rollMode.attack.rangedWeaponAttack": "A5E.effects.keys.flags.grantsRollMode.rangedWeaponAttack",
    "flags.a5e.effects.rollMode.abilityCheck.all": "A5E.effects.keys.flags.rollMode.abilityChecks.all",
    "flags.a5e.effects.rollMode.abilityCheck.cha": "A5E.effects.keys.flags.rollMode.abilityChecks.cha",
    "flags.a5e.effects.rollMode.abilityCheck.con": "A5E.effects.keys.flags.rollMode.abilityChecks.con",
    "flags.a5e.effects.rollMode.abilityCheck.dex": "A5E.effects.keys.flags.rollMode.abilityChecks.dex",
    "flags.a5e.effects.rollMode.abilityCheck.int": "A5E.effects.keys.flags.rollMode.abilityChecks.int",
    "flags.a5e.effects.rollMode.abilityCheck.str": "A5E.effects.keys.flags.rollMode.abilityChecks.str",
    "flags.a5e.effects.rollMode.abilityCheck.wis": "A5E.effects.keys.flags.rollMode.abilityChecks.wis",
    "flags.a5e.effects.rollMode.abilitySave.all": "A5E.effects.keys.flags.rollMode.savingThrows.all",
    "flags.a5e.effects.rollMode.abilitySave.cha": "A5E.effects.keys.flags.rollMode.savingThrows.cha",
    "flags.a5e.effects.rollMode.abilitySave.con": "A5E.effects.keys.flags.rollMode.savingThrows.con",
    "flags.a5e.effects.rollMode.abilitySave.dex": "A5E.effects.keys.flags.rollMode.savingThrows.dex",
    "flags.a5e.effects.rollMode.abilitySave.int": "A5E.effects.keys.flags.rollMode.savingThrows.int",
    "flags.a5e.effects.rollMode.abilitySave.str": "A5E.effects.keys.flags.rollMode.savingThrows.str",
    "flags.a5e.effects.rollMode.abilitySave.wis": "A5E.effects.keys.flags.rollMode.savingThrows.wis",
    "flags.a5e.effects.rollMode.attack.all": "A5E.effects.keys.flags.rollMode.attack.all",
    "flags.a5e.effects.rollMode.attack.meleeSpellAttack": "A5E.effects.keys.flags.rollMode.attack.meleeSpellAttack",
    "flags.a5e.effects.rollMode.attack.meleeWeaponAttack": "A5E.effects.keys.flags.rollMode.attack.meleeWeaponAttack",
    "flags.a5e.effects.rollMode.attack.rangedSpellAttack": "A5E.effects.keys.flags.rollMode.attack.rangedSpellAttack",
    "flags.a5e.effects.rollMode.attack.rangedWeaponAttack": "A5E.effects.keys.flags.rollMode.attack.rangedWeaponAttack",
    "flags.a5e.effects.rollMode.concentration": "A5E.effects.keys.flags.rollMode.concentration",
    "flags.a5e.effects.rollMode.deathSave": "A5E.effects.keys.flags.rollMode.deathSave",
    "flags.a5e.effects.rollMode.initiative": "A5E.effects.keys.flags.rollMode.initiative",
    "flags.a5e.effects.rollMode.skillCheck.all": "A5E.effects.keys.flags.rollMode.skillChecks.all",
    "flags.a5e.effects.rollMode.skillCheck.acr": "A5E.effects.keys.flags.rollMode.skillChecks.acr",
    "flags.a5e.effects.rollMode.skillCheck.ani": "A5E.effects.keys.flags.rollMode.skillChecks.ani",
    "flags.a5e.effects.rollMode.skillCheck.arc": "A5E.effects.keys.flags.rollMode.skillChecks.arc",
    "flags.a5e.effects.rollMode.skillCheck.ath": "A5E.effects.keys.flags.rollMode.skillChecks.ath",
    "flags.a5e.effects.rollMode.skillCheck.cul": "A5E.effects.keys.flags.rollMode.skillChecks.cul",
    "flags.a5e.effects.rollMode.skillCheck.dec": "A5E.effects.keys.flags.rollMode.skillChecks.dec",
    "flags.a5e.effects.rollMode.skillCheck.eng": "A5E.effects.keys.flags.rollMode.skillChecks.eng",
    "flags.a5e.effects.rollMode.skillCheck.his": "A5E.effects.keys.flags.rollMode.skillChecks.his",
    "flags.a5e.effects.rollMode.skillCheck.ins": "A5E.effects.keys.flags.rollMode.skillChecks.ins",
    "flags.a5e.effects.rollMode.skillCheck.inv": "A5E.effects.keys.flags.rollMode.skillChecks.inv",
    "flags.a5e.effects.rollMode.skillCheck.itm": "A5E.effects.keys.flags.rollMode.skillChecks.itm",
    "flags.a5e.effects.rollMode.skillCheck.med": "A5E.effects.keys.flags.rollMode.skillChecks.med",
    "flags.a5e.effects.rollMode.skillCheck.nat": "A5E.effects.keys.flags.rollMode.skillChecks.nat",
    "flags.a5e.effects.rollMode.skillCheck.per": "A5E.effects.keys.flags.rollMode.skillChecks.per",
    "flags.a5e.effects.rollMode.skillCheck.prc": "A5E.effects.keys.flags.rollMode.skillChecks.prc",
    "flags.a5e.effects.rollMode.skillCheck.prf": "A5E.effects.keys.flags.rollMode.skillChecks.prf",
    "flags.a5e.effects.rollMode.skillCheck.rel": "A5E.effects.keys.flags.rollMode.skillChecks.rel",
    "flags.a5e.effects.rollMode.skillCheck.slt": "A5E.effects.keys.flags.rollMode.skillChecks.slt",
    "flags.a5e.effects.rollMode.skillCheck.ste": "A5E.effects.keys.flags.rollMode.skillChecks.ste",
    "flags.a5e.effects.rollMode.skillCheck.sur": "A5E.effects.keys.flags.rollMode.skillChecks.sur",
    "flags.a5e.effects.senses.allDistances": "A5E.effects.keys.flags.senses.allDistances",
    "flags.a5e.effects.senses.allUnits": "A5E.effects.keys.flags.senses.allUnits",
    "system.abilities.cha.check.bonus": "A5E.effects.keys.abilities.charismaCheckBonus",
    "system.abilities.cha.check.expertiseDice": "A5E.effects.keys.abilities.charismaCheckExpertiseDice",
    "system.abilities.cha.save.bonus": "A5E.effects.keys.abilities.charismaSaveBonus",
    "system.abilities.cha.save.expertiseDice": "A5E.effects.keys.abilities.charismaSaveExpertiseDice",
    "system.abilities.cha.save.proficient": "A5E.effects.keys.abilities.charismaSaveProficiency",
    "system.abilities.cha.value": "A5E.effects.keys.abilities.charismaValue",
    "system.abilities.con.check.bonus": "A5E.effects.keys.abilities.constitutionCheckBonus",
    "system.abilities.con.check.expertiseDice": "A5E.effects.keys.abilities.constitutionCheckExpertiseDice",
    "system.abilities.con.save.bonus": "A5E.effects.keys.abilities.constitutionSaveBonus",
    "system.abilities.con.save.concentrationBonus": "A5E.effects.keys.abilities.constitutionSaveConcentrationBonus",
    "system.abilities.con.save.expertiseDice": "A5E.effects.keys.abilities.constitutionSaveExpertiseDice",
    "system.abilities.con.save.proficient": "A5E.effects.keys.abilities.constitutionSaveProficiency",
    "system.abilities.con.value": "A5E.effects.keys.abilities.constitutionValue",
    "system.abilities.dex.check.bonus": "A5E.effects.keys.abilities.dexterityCheckBonus",
    "system.abilities.dex.check.expertiseDice": "A5E.effects.keys.abilities.dexterityCheckExpertiseDice",
    "system.abilities.dex.save.bonus": "A5E.effects.keys.abilities.dexteritySaveBonus",
    "system.abilities.dex.save.expertiseDice": "A5E.effects.keys.abilities.dexteritySaveExpertiseDice",
    "system.abilities.dex.save.proficient": "A5E.effects.keys.abilities.dexteritySaveProficiency",
    "system.abilities.dex.value": "A5E.effects.keys.abilities.dexterityValue",
    "system.abilities.int.check.bonus": "A5E.effects.keys.abilities.intelligenceCheckBonus",
    "system.abilities.int.check.expertiseDice": "A5E.effects.keys.abilities.intelligenceCheckExpertiseDice",
    "system.abilities.int.save.bonus": "A5E.effects.keys.abilities.intelligenceSaveBonus",
    "system.abilities.int.save.expertiseDice": "A5E.effects.keys.abilities.intelligenceSaveExpertiseDice",
    "system.abilities.int.save.proficient": "A5E.effects.keys.abilities.intelligenceSaveProficiency",
    "system.abilities.int.value": "A5E.effects.keys.abilities.intelligenceValue",
    "system.abilities.str.check.bonus": "A5E.effects.keys.abilities.strengthCheckBonus",
    "system.abilities.str.check.expertiseDice": "A5E.effects.keys.abilities.strengthCheckExpertiseDice",
    "system.abilities.str.save.bonus": "A5E.effects.keys.abilities.strengthSaveBonus",
    "system.abilities.str.save.expertiseDice": "A5E.effects.keys.abilities.strengthSaveExpertiseDice",
    "system.abilities.str.save.proficient": "A5E.effects.keys.abilities.strengthSaveProficiency",
    "system.abilities.str.value": "A5E.effects.keys.abilities.strengthValue",
    "system.abilities.wis.check.bonus": "A5E.effects.keys.abilities.wisdomCheckBonus",
    "system.abilities.wis.check.expertiseDice": "A5E.effects.keys.abilities.wisdomCheckExpertiseDice",
    "system.abilities.wis.save.bonus": "A5E.effects.keys.abilities.wisdomSaveBonus",
    "system.abilities.wis.save.expertiseDice": "A5E.effects.keys.abilities.wisdomSaveExpertiseDice",
    "system.abilities.wis.save.proficient": "A5E.effects.keys.abilities.wisdomSaveProficiency",
    "system.abilities.wis.value": "A5E.effects.keys.abilities.wisdomValue",
    "system.attributes.ac.baseFormula": "A5E.effects.keys.armorClass.baseFormula",
    "system.attributes.ac.changes.bonuses.value": "A5E.effects.keys.armorClass.bonuses",
    "system.attributes.ac.value": "A5E.effects.keys.armorClass.value",
    "system.attributes.attunement.current": "A5E.effects.keys.attunementCurrent",
    "system.attributes.attunement.max": "A5E.effects.keys.attunementMax",
    "system.attributes.casterLevel": "A5E.effects.keys.casterLevel",
    "system.attributes.death.failure": "A5E.effects.keys.deathSaveFailures",
    "system.attributes.death.success": "A5E.effects.keys.deathSaveSuccesses",
    "system.attributes.exertion.current": "A5E.effects.keys.exertionCurrent",
    "system.attributes.exertion.max": "A5E.effects.keys.exertionMax",
    "system.attributes.exertion.recoverOnRest": "A5E.effects.keys.recoverExertionOnShortRest",
    "system.attributes.fatigue": "A5E.effects.keys.fatigue",
    "system.attributes.hitDice.d20.current": "A5E.effects.keys.hitDice.d20Current",
    "system.attributes.hitDice.d20.total": "A5E.effects.keys.hitDice.d20Max",
    "system.attributes.hitDice.d12.current": "A5E.effects.keys.hitDice.d12Current",
    "system.attributes.hitDice.d12.total": "A5E.effects.keys.hitDice.d12Max",
    "system.attributes.hitDice.d10.current": "A5E.effects.keys.hitDice.d10Current",
    "system.attributes.hitDice.d10.total": "A5E.effects.keys.hitDice.d10Max",
    "system.attributes.hitDice.d6.current": "A5E.effects.keys.hitDice.d6Current",
    "system.attributes.hitDice.d6.total": "A5E.effects.keys.hitDice.d6Max",
    "system.attributes.hitDice.d8.current": "A5E.effects.keys.hitDice.d8Current",
    "system.attributes.hitDice.d8.total": "A5E.effects.keys.hitDice.d8Max",
    "system.attributes.hitDice.d4.current": "A5E.effects.keys.hitDice.d4Current",
    "system.attributes.hitDice.d4.total": "A5E.effects.keys.hitDice.d4Max",
    "system.attributes.hp.baseMax": "A5E.effects.keys.hitPoints.baseMax",
    "system.attributes.hp.bonus": "A5E.effects.keys.hitPoints.bonus",
    "system.attributes.hp.value": "A5E.effects.keys.hitPoints.current",
    "system.attributes.hp.max": "A5E.effects.keys.hitPoints.max",
    "system.attributes.hp.temp": "A5E.effects.keys.hitPoints.temp",
    "system.attributes.initiative.ability": "A5E.effects.keys.initiativeAbility",
    "system.attributes.initiative.expertiseDice": "A5E.effects.keys.initiativeExpertiseDice",
    "system.attributes.inspiration": "A5E.effects.keys.inspiration",
    "system.attributes.maneuverDC": "A5E.effects.keys.maneuverDC",
    "system.attributes.movement.burrow.distance": "A5E.effects.keys.movement.burrowDistance",
    "system.attributes.movement.burrow.unit": "A5E.effects.keys.movement.burrowUnit",
    "system.attributes.movement.climb.distance": "A5E.effects.keys.movement.climbDistance",
    "system.attributes.movement.climb.unit": "A5E.effects.keys.movement.climbUnit",
    "system.attributes.movement.fly.distance": "A5E.effects.keys.movement.flyDistance",
    "system.attributes.movement.fly.unit": "A5E.effects.keys.movement.flyUnit",
    "system.attributes.movement.swim.distance": "A5E.effects.keys.movement.swimDistance",
    "system.attributes.movement.swim.unit": "A5E.effects.keys.movement.swimUnit",
    "system.attributes.movement.traits.hover": "A5E.effects.keys.movement.hover",
    "system.attributes.movement.walk.distance": "A5E.effects.keys.movement.walkDistance",
    "system.attributes.movement.walk.unit": "A5E.effects.keys.movement.walkUnit",
    "system.attributes.prof": "A5E.effects.keys.proficiencyBonus",
    "system.attributes.senses.blindsight.distance": "A5E.effects.keys.vision.blindsightDistance",
    "system.attributes.senses.blindsight.unit": "A5E.effects.keys.vision.blindsightUnit",
    "system.attributes.senses.blindsight.otherwiseBlind": "A5E.effects.keys.vision.blindsightOtherwiseBlind",
    "system.attributes.senses.darkvision.distance": "A5E.effects.keys.vision.darkvisionDistance",
    "system.attributes.senses.darkvision.unit": "A5E.effects.keys.vision.darkvisionUnit",
    "system.attributes.senses.tremorsense.distance": "A5E.effects.keys.vision.tremorsenseDistance",
    "system.attributes.senses.tremorsense.unit": "A5E.effects.keys.vision.tremorsenseUnit",
    "system.attributes.senses.truesight.distance": "A5E.effects.keys.vision.truesightDistance",
    "system.attributes.senses.truesight.unit": "A5E.effects.keys.vision.truesightUnit",
    "system.attributes.spellcasting": "A5E.effects.keys.spellcastingAbility",
    "system.attributes.spellDC": "A5E.effects.keys.spellDC",
    "system.attributes.strife": "A5E.effects.keys.strife",
    "system.bonuses.abilities.check": "A5E.effects.keys.bonuses.check",
    "system.bonuses.abilities.save": "A5E.effects.keys.bonuses.save",
    "system.bonuses.abilities.skill": "A5E.effects.keys.bonuses.skill",
    "system.bonuses.maneuverDC": "A5E.effects.keys.bonuses.maneuverDC",
    "system.bonuses.spellDC": "A5E.effects.keys.bonuses.spellDC",
    "system.currency.cp": "A5E.effects.keys.currency.cp",
    "system.currency.ep": "A5E.effects.keys.currency.ep",
    "system.currency.gp": "A5E.effects.keys.currency.gp",
    "system.currency.pp": "A5E.effects.keys.currency.pp",
    "system.currency.sp": "A5E.effects.keys.currency.sp",
    "system.details.creatureTypes": "A5E.effects.keys.details.creatureTypes",
    "system.details.cr": "A5E.effects.keys.details.cr",
    "system.details.elite": "A5E.effects.keys.details.elite",
    "system.details.isSwarm": "A5E.effects.keys.details.isSwarm",
    "system.proficiencies.armor": "A5E.effects.keys.proficiencies.armor",
    "system.proficiencies.languages": "A5E.effects.keys.proficiencies.languages",
    "system.proficiencies.tools": "A5E.effects.keys.proficiencies.tools",
    "system.proficiencies.weapons": "A5E.effects.keys.proficiencies.weapons",
    "system.resources.primary.hideMax": "A5E.effects.keys.resources.primary.hideMax",
    "system.resources.primary.label": "A5E.effects.keys.resources.primary.label",
    "system.resources.primary.max": "A5E.effects.keys.resources.primary.max",
    "system.resources.primary.per": "A5E.effects.keys.resources.primary.per",
    "system.resources.primary.recharge.formula": "A5E.effects.keys.resources.primary.rechargeFormula",
    "system.resources.primary.recharge.threshold": "A5E.effects.keys.resources.primary.rechargeThreshold",
    "system.resources.primary.value": "A5E.effects.keys.resources.primary.value",
    "system.resources.quaternary.hideMax": "A5E.effects.keys.resources.quaternary.hideMax",
    "system.resources.quaternary.label": "A5E.effects.keys.resources.quaternary.label",
    "system.resources.quaternary.max": "A5E.effects.keys.resources.quaternary.max",
    "system.resources.quaternary.per": "A5E.effects.keys.resources.quaternary.per",
    "system.resources.quaternary.recharge.formula": "A5E.effects.keys.resources.quaternary.rechargeFormula",
    "system.resources.quaternary.recharge.threshold": "A5E.effects.keys.resources.quaternary.rechargeThreshold",
    "system.resources.quaternary.value": "A5E.effects.keys.resources.quaternary.value",
    "system.resources.secondary.hideMax": "A5E.effects.keys.resources.secondary.hideMax",
    "system.resources.secondary.label": "A5E.effects.keys.resources.secondary.label",
    "system.resources.secondary.max": "A5E.effects.keys.resources.secondary.max",
    "system.resources.secondary.per": "A5E.effects.keys.resources.secondary.per",
    "system.resources.secondary.recharge.formula": "A5E.effects.keys.resources.secondary.rechargeFormula",
    "system.resources.secondary.recharge.threshold": "A5E.effects.keys.resources.secondary.rechargeThreshold",
    "system.resources.secondary.value": "A5E.effects.keys.resources.secondary.value",
    "system.resources.tertiary.hideMax": "A5E.effects.keys.resources.tertiary.hideMax",
    "system.resources.tertiary.label": "A5E.effects.keys.resources.tertiary.label",
    "system.resources.tertiary.max": "A5E.effects.keys.resources.tertiary.max",
    "system.resources.tertiary.per": "A5E.effects.keys.resources.tertiary.per",
    "system.resources.tertiary.recharge.formula": "A5E.effects.keys.resources.tertiary.rechargeFormula",
    "system.resources.tertiary.recharge.threshold": "A5E.effects.keys.resources.tertiary.rechargeThreshold",
    "system.resources.tertiary.value": "A5E.effects.keys.resources.tertiary.value",
    "system.skills.acr.ability": "A5E.effects.keys.skills.acr.defaultAbility",
    "system.skills.acr.bonuses.check": "A5E.effects.keys.skills.acr.checkBonus",
    "system.skills.acr.bonuses.passive": "A5E.effects.keys.skills.acr.passiveBonus",
    "system.skills.acr.expertiseDice": "A5E.effects.keys.skills.acr.expertiseDice",
    "system.skills.acr.minRoll": "A5E.effects.keys.skills.acr.minRoll",
    "system.skills.acr.proficient": "A5E.effects.keys.skills.acr.proficient",
    "system.skills.acr.specialties": "A5E.effects.keys.skills.acr.specialties",
    "system.skills.acr.value": "A5E.effects.keys.skills.acr.value",
    "system.skills.ani.ability": "A5E.effects.keys.skills.ani.defaultAbility",
    "system.skills.ani.bonuses.check": "A5E.effects.keys.skills.ani.checkBonus",
    "system.skills.ani.bonuses.passive": "A5E.effects.keys.skills.ani.passiveBonus",
    "system.skills.ani.expertiseDice": "A5E.effects.keys.skills.ani.expertiseDice",
    "system.skills.ani.minRoll": "A5E.effects.keys.skills.ani.minRoll",
    "system.skills.ani.proficient": "A5E.effects.keys.skills.ani.proficient",
    "system.skills.ani.specialties": "A5E.effects.keys.skills.ani.specialties",
    "system.skills.ani.value": "A5E.effects.keys.skills.ani.value",
    "system.skills.arc.ability": "A5E.effects.keys.skills.arc.defaultAbility",
    "system.skills.arc.bonuses.check": "A5E.effects.keys.skills.arc.checkBonus",
    "system.skills.arc.bonuses.passive": "A5E.effects.keys.skills.arc.passiveBonus",
    "system.skills.arc.expertiseDice": "A5E.effects.keys.skills.arc.expertiseDice",
    "system.skills.arc.minRoll": "A5E.effects.keys.skills.arc.minRoll",
    "system.skills.arc.proficient": "A5E.effects.keys.skills.arc.proficient",
    "system.skills.arc.specialties": "A5E.effects.keys.skills.arc.specialties",
    "system.skills.arc.value": "A5E.effects.keys.skills.arc.value",
    "system.skills.ath.ability": "A5E.effects.keys.skills.ath.defaultAbility",
    "system.skills.ath.bonuses.check": "A5E.effects.keys.skills.ath.checkBonus",
    "system.skills.ath.bonuses.passive": "A5E.effects.keys.skills.ath.passiveBonus",
    "system.skills.ath.expertiseDice": "A5E.effects.keys.skills.ath.expertiseDice",
    "system.skills.ath.minRoll": "A5E.effects.keys.skills.ath.minRoll",
    "system.skills.ath.proficient": "A5E.effects.keys.skills.ath.proficient",
    "system.skills.ath.specialties": "A5E.effects.keys.skills.ath.specialties",
    "system.skills.ath.value": "A5E.effects.keys.skills.ath.value",
    "system.skills.cul.ability": "A5E.effects.keys.skills.cul.defaultAbility",
    "system.skills.cul.bonuses.check": "A5E.effects.keys.skills.cul.checkBonus",
    "system.skills.cul.bonuses.passive": "A5E.effects.keys.skills.cul.passiveBonus",
    "system.skills.cul.expertiseDice": "A5E.effects.keys.skills.cul.expertiseDice",
    "system.skills.cul.minRoll": "A5E.effects.keys.skills.cul.minRoll",
    "system.skills.cul.proficient": "A5E.effects.keys.skills.cul.proficient",
    "system.skills.cul.specialties": "A5E.effects.keys.skills.cul.specialties",
    "system.skills.cul.value": "A5E.effects.keys.skills.cul.value",
    "system.skills.dec.ability": "A5E.effects.keys.skills.dec.defaultAbility",
    "system.skills.dec.bonuses.check": "A5E.effects.keys.skills.dec.checkBonus",
    "system.skills.dec.bonuses.passive": "A5E.effects.keys.skills.dec.passiveBonus",
    "system.skills.dec.expertiseDice": "A5E.effects.keys.skills.dec.expertiseDice",
    "system.skills.dec.minRoll": "A5E.effects.keys.skills.dec.minRoll",
    "system.skills.dec.proficient": "A5E.effects.keys.skills.dec.proficient",
    "system.skills.dec.specialties": "A5E.effects.keys.skills.dec.specialties",
    "system.skills.dec.value": "A5E.effects.keys.skills.dec.value",
    "system.skills.eng.ability": "A5E.effects.keys.skills.eng.defaultAbility",
    "system.skills.eng.bonuses.check": "A5E.effects.keys.skills.eng.checkBonus",
    "system.skills.eng.bonuses.passive": "A5E.effects.keys.skills.eng.passiveBonus",
    "system.skills.eng.expertiseDice": "A5E.effects.keys.skills.eng.expertiseDice",
    "system.skills.eng.minRoll": "A5E.effects.keys.skills.eng.minRoll",
    "system.skills.eng.proficient": "A5E.effects.keys.skills.eng.proficient",
    "system.skills.eng.specialties": "A5E.effects.keys.skills.eng.specialties",
    "system.skills.eng.value": "A5E.effects.keys.skills.eng.value",
    "system.skills.his.ability": "A5E.effects.keys.skills.his.defaultAbility",
    "system.skills.his.bonuses.check": "A5E.effects.keys.skills.his.checkBonus",
    "system.skills.his.bonuses.passive": "A5E.effects.keys.skills.his.passiveBonus",
    "system.skills.his.expertiseDice": "A5E.effects.keys.skills.his.expertiseDice",
    "system.skills.his.minRoll": "A5E.effects.keys.skills.his.minRoll",
    "system.skills.his.proficient": "A5E.effects.keys.skills.his.proficient",
    "system.skills.his.specialties": "A5E.effects.keys.skills.his.specialties",
    "system.skills.his.value": "A5E.effects.keys.skills.his.value",
    "system.skills.ins.ability": "A5E.effects.keys.skills.ins.defaultAbility",
    "system.skills.ins.bonuses.check": "A5E.effects.keys.skills.ins.checkBonus",
    "system.skills.ins.bonuses.passive": "A5E.effects.keys.skills.ins.passiveBonus",
    "system.skills.ins.expertiseDice": "A5E.effects.keys.skills.ins.expertiseDice",
    "system.skills.ins.minRoll": "A5E.effects.keys.skills.ins.minRoll",
    "system.skills.ins.proficient": "A5E.effects.keys.skills.ins.proficient",
    "system.skills.ins.specialties": "A5E.effects.keys.skills.ins.specialties",
    "system.skills.ins.value": "A5E.effects.keys.skills.ins.value",
    "system.skills.itm.ability": "A5E.effects.keys.skills.itm.defaultAbility",
    "system.skills.itm.bonuses.check": "A5E.effects.keys.skills.itm.checkBonus",
    "system.skills.itm.bonuses.passive": "A5E.effects.keys.skills.itm.passiveBonus",
    "system.skills.itm.expertiseDice": "A5E.effects.keys.skills.itm.expertiseDice",
    "system.skills.itm.minRoll": "A5E.effects.keys.skills.itm.minRoll",
    "system.skills.itm.proficient": "A5E.effects.keys.skills.itm.proficient",
    "system.skills.itm.specialties": "A5E.effects.keys.skills.itm.specialties",
    "system.skills.itm.value": "A5E.effects.keys.skills.itm.value",
    "system.skills.inv.ability": "A5E.effects.keys.skills.inv.defaultAbility",
    "system.skills.inv.bonuses.check": "A5E.effects.keys.skills.inv.checkBonus",
    "system.skills.inv.bonuses.passive": "A5E.effects.keys.skills.inv.passiveBonus",
    "system.skills.inv.expertiseDice": "A5E.effects.keys.skills.inv.expertiseDice",
    "system.skills.inv.minRoll": "A5E.effects.keys.skills.inv.minRoll",
    "system.skills.inv.proficient": "A5E.effects.keys.skills.inv.proficient",
    "system.skills.inv.specialties": "A5E.effects.keys.skills.inv.specialties",
    "system.skills.inv.value": "A5E.effects.keys.skills.inv.value",
    "system.skills.med.ability": "A5E.effects.keys.skills.med.defaultAbility",
    "system.skills.med.bonuses.check": "A5E.effects.keys.skills.med.checkBonus",
    "system.skills.med.bonuses.passive": "A5E.effects.keys.skills.med.passiveBonus",
    "system.skills.med.expertiseDice": "A5E.effects.keys.skills.med.expertiseDice",
    "system.skills.med.minRoll": "A5E.effects.keys.skills.med.minRoll",
    "system.skills.med.proficient": "A5E.effects.keys.skills.med.proficient",
    "system.skills.med.specialties": "A5E.effects.keys.skills.med.specialties",
    "system.skills.med.value": "A5E.effects.keys.skills.med.value",
    "system.skills.nat.ability": "A5E.effects.keys.skills.nat.defaultAbility",
    "system.skills.nat.bonuses.check": "A5E.effects.keys.skills.nat.checkBonus",
    "system.skills.nat.bonuses.passive": "A5E.effects.keys.skills.nat.passiveBonus",
    "system.skills.nat.expertiseDice": "A5E.effects.keys.skills.nat.expertiseDice",
    "system.skills.nat.minRoll": "A5E.effects.keys.skills.nat.minRoll",
    "system.skills.nat.proficient": "A5E.effects.keys.skills.nat.proficient",
    "system.skills.nat.specialties": "A5E.effects.keys.skills.nat.specialties",
    "system.skills.nat.value": "A5E.effects.keys.skills.nat.value",
    "system.skills.prc.ability": "A5E.effects.keys.skills.prc.defaultAbility",
    "system.skills.prc.bonuses.check": "A5E.effects.keys.skills.prc.checkBonus",
    "system.skills.prc.bonuses.passive": "A5E.effects.keys.skills.prc.passiveBonus",
    "system.skills.prc.expertiseDice": "A5E.effects.keys.skills.prc.expertiseDice",
    "system.skills.prc.minRoll": "A5E.effects.keys.skills.prc.minRoll",
    "system.skills.prc.proficient": "A5E.effects.keys.skills.prc.proficient",
    "system.skills.prc.specialties": "A5E.effects.keys.skills.prc.specialties",
    "system.skills.prc.value": "A5E.effects.keys.skills.prc.value",
    "system.skills.prf.ability": "A5E.effects.keys.skills.prf.defaultAbility",
    "system.skills.prf.bonuses.check": "A5E.effects.keys.skills.prf.checkBonus",
    "system.skills.prf.bonuses.passive": "A5E.effects.keys.skills.prf.passiveBonus",
    "system.skills.prf.expertiseDice": "A5E.effects.keys.skills.prf.expertiseDice",
    "system.skills.prf.minRoll": "A5E.effects.keys.skills.prf.minRoll",
    "system.skills.prf.proficient": "A5E.effects.keys.skills.prf.proficient",
    "system.skills.prf.specialties": "A5E.effects.keys.skills.prf.specialties",
    "system.skills.prf.value": "A5E.effects.keys.skills.prf.value",
    "system.skills.per.ability": "A5E.effects.keys.skills.per.defaultAbility",
    "system.skills.per.bonuses.check": "A5E.effects.keys.skills.per.checkBonus",
    "system.skills.per.bonuses.passive": "A5E.effects.keys.skills.per.passiveBonus",
    "system.skills.per.expertiseDice": "A5E.effects.keys.skills.per.expertiseDice",
    "system.skills.per.minRoll": "A5E.effects.keys.skills.per.minRoll",
    "system.skills.per.proficient": "A5E.effects.keys.skills.per.proficient",
    "system.skills.per.specialties": "A5E.effects.keys.skills.per.specialties",
    "system.skills.per.value": "A5E.effects.keys.skills.per.value",
    "system.skills.rel.ability": "A5E.effects.keys.skills.rel.defaultAbility",
    "system.skills.rel.bonuses.check": "A5E.effects.keys.skills.rel.checkBonus",
    "system.skills.rel.bonuses.passive": "A5E.effects.keys.skills.rel.passiveBonus",
    "system.skills.rel.expertiseDice": "A5E.effects.keys.skills.rel.expertiseDice",
    "system.skills.rel.minRoll": "A5E.effects.keys.skills.rel.minRoll",
    "system.skills.rel.proficient": "A5E.effects.keys.skills.rel.proficient",
    "system.skills.rel.specialties": "A5E.effects.keys.skills.rel.specialties",
    "system.skills.rel.value": "A5E.effects.keys.skills.rel.value",
    "system.skills.slt.ability": "A5E.effects.keys.skills.slt.defaultAbility",
    "system.skills.slt.bonuses.check": "A5E.effects.keys.skills.slt.checkBonus",
    "system.skills.slt.bonuses.passive": "A5E.effects.keys.skills.slt.passiveBonus",
    "system.skills.slt.expertiseDice": "A5E.effects.keys.skills.slt.expertiseDice",
    "system.skills.slt.minRoll": "A5E.effects.keys.skills.slt.minRoll",
    "system.skills.slt.proficient": "A5E.effects.keys.skills.slt.proficient",
    "system.skills.slt.specialties": "A5E.effects.keys.skills.slt.specialties",
    "system.skills.slt.value": "A5E.effects.keys.skills.slt.value",
    "system.skills.ste.ability": "A5E.effects.keys.skills.ste.defaultAbility",
    "system.skills.ste.bonuses.check": "A5E.effects.keys.skills.ste.checkBonus",
    "system.skills.ste.bonuses.passive": "A5E.effects.keys.skills.ste.passiveBonus",
    "system.skills.ste.expertiseDice": "A5E.effects.keys.skills.ste.expertiseDice",
    "system.skills.ste.minRoll": "A5E.effects.keys.skills.ste.minRoll",
    "system.skills.ste.proficient": "A5E.effects.keys.skills.ste.proficient",
    "system.skills.ste.specialties": "A5E.effects.keys.skills.ste.specialties",
    "system.skills.ste.value": "A5E.effects.keys.skills.ste.value",
    "system.skills.sur.ability": "A5E.effects.keys.skills.sur.defaultAbility",
    "system.skills.sur.bonuses.check": "A5E.effects.keys.skills.sur.checkBonus",
    "system.skills.sur.bonuses.passive": "A5E.effects.keys.skills.sur.passiveBonus",
    "system.skills.sur.expertiseDice": "A5E.effects.keys.skills.sur.expertiseDice",
    "system.skills.sur.minRoll": "A5E.effects.keys.skills.sur.minRoll",
    "system.skills.sur.proficient": "A5E.effects.keys.skills.sur.proficient",
    "system.skills.sur.specialties": "A5E.effects.keys.skills.sur.specialties",
    "system.skills.sur.value": "A5E.effects.keys.skills.sur.value",
    "system.spellResources.points.current": "A5E.effects.keys.spellResources.currentSpellPoints",
    "system.spellResources.points.max": "A5E.effects.keys.spellResources.maxSpellPoints",
    "system.spellResources.slots.1.current": "A5E.effects.keys.spellResources.currentLevel1Slots",
    "system.spellResources.slots.1.max": "A5E.effects.keys.spellResources.maxLevel1Slots",
    "system.spellResources.slots.2.current": "A5E.effects.keys.spellResources.currentLevel2Slots",
    "system.spellResources.slots.2.max": "A5E.effects.keys.spellResources.maxLevel2Slots",
    "system.spellResources.slots.3.current": "A5E.effects.keys.spellResources.currentLevel3Slots",
    "system.spellResources.slots.3.max": "A5E.effects.keys.spellResources.maxLevel3Slots",
    "system.spellResources.slots.4.current": "A5E.effects.keys.spellResources.currentLevel4Slots",
    "system.spellResources.slots.4.max": "A5E.effects.keys.spellResources.maxLevel4Slots",
    "system.spellResources.slots.5.current": "A5E.effects.keys.spellResources.currentLevel5Slots",
    "system.spellResources.slots.5.max": "A5E.effects.keys.spellResources.maxLevel5Slots",
    "system.spellResources.slots.6.current": "A5E.effects.keys.spellResources.currentLevel6Slots",
    "system.spellResources.slots.6.max": "A5E.effects.keys.spellResources.maxLevel6Slots",
    "system.spellResources.slots.7.current": "A5E.effects.keys.spellResources.currentLevel7Slots",
    "system.spellResources.slots.7.max": "A5E.effects.keys.spellResources.maxLevel7Slots",
    "system.spellResources.slots.8.current": "A5E.effects.keys.spellResources.currentLevel8Slots",
    "system.spellResources.slots.8.max": "A5E.effects.keys.spellResources.maxLevel8Slots",
    "system.spellResources.slots.9.current": "A5E.effects.keys.spellResources.currentLevel9Slots",
    "system.spellResources.slots.9.max": "A5E.effects.keys.spellResources.maxLevel9Slots",
    "system.supply": "A5E.effects.keys.supply",
    "system.traits.conditionImmunities": "A5E.effects.keys.traits.conditionImmunities",
    "system.traits.damageImmunities": "A5E.effects.keys.traits.damageImmunities",
    "system.traits.damageResistances": "A5E.effects.keys.traits.damageResistances",
    "system.traits.damageVulnerabilities": "A5E.effects.keys.traits.damageVulnerabilities",
    "system.traits.size": "A5E.effects.keys.traits.size",
    "@token.light.alpha": "A5E.effects.keys.token.light.alpha",
    "@token.light.angle": "A5E.effects.keys.token.light.angle",
    "@token.light.animation.intensity": "A5E.effects.keys.token.light.animation.intensity",
    "@token.light.animation.reverse": "A5E.effects.keys.token.light.animation.reverse",
    "@token.light.animation.speed": "A5E.effects.keys.token.light.animation.speed",
    "@token.light.animation.type": "A5E.effects.keys.token.light.animation.type",
    "@token.light.attenuation": "A5E.effects.keys.token.light.attenuation",
    "@token.light.bright": "A5E.effects.keys.token.light.bright",
    "@token.light.color": "A5E.effects.keys.token.light.color",
    "@token.light.coloration": "A5E.effects.keys.token.light.coloration",
    "@token.light.contrast": "A5E.effects.keys.token.light.contrast",
    "@token.light.darkness.min": "A5E.effects.keys.token.light.darkness.min",
    "@token.light.darkness.max": "A5E.effects.keys.token.light.darkness.max",
    "@token.light.dim": "A5E.effects.keys.token.light.dim",
    "@token.light.luminosity": "A5E.effects.keys.token.light.luminosity",
    "@token.light.saturation": "A5E.effects.keys.token.light.saturation",
    "@token.light.shadows": "A5E.effects.keys.token.light.shadows",
    "@token.texture.src": "A5E.effects.keys.token.texture.src",
    "@token.texture.scaleX": "A5E.effects.keys.token.texture.scaleX",
    "@token.texture.scaleY": "A5E.effects.keys.token.texture.scaleY",
    "@token.width": "A5E.effects.keys.token.width",
    "@token.height": "A5E.effects.keys.token.height"
  };
}
f(tse, "registerEffectLocalizationConfig");
function sse(i) {
  const e = {};
  Object.entries(i.abilityActivationTypes).forEach(([t, s]) => {
    e[t] = {
      label: s,
      key: "system.activation.type",
      type: "action",
      truthValue: "or"
    };
  }), i.filters = {
    features: {
      activationCost: {
        label: "A5E.FilterLabelActivationCost",
        filters: { ...e }
      }
    },
    maneuvers: {
      activationCost: {
        label: "A5E.FilterLabelActivationCost",
        filters: { ...e }
      },
      traditions: {
        label: "A5E.FilterLabelManueverTraditions",
        filters: {}
      },
      miscellaneous: {
        label: "A5E.FilterLabelMiscellaneous",
        filters: {
          concentration: {
            label: "A5E.ConditionConcentration",
            key: "system.concentration",
            type: "boolean"
          },
          stance: {
            label: "Stance",
            key: "system.isStance",
            type: "boolean"
          }
        }
      }
    },
    objects: {
      activationCost: {
        label: "A5E.FilterLabelActivationCost",
        filters: { ...e }
      },
      rarity: {
        label: "A5E.FilterLabelRarity",
        filters: {}
      },
      miscellaneous: {
        label: "A5E.FilterLabelMiscellaneous",
        filters: {
          attuned: { label: "A5E.Attuned", key: "system.attuned", type: "boolean" },
          bulky: { label: "A5E.ItemBulky", key: "system.bulky", type: "boolean" },
          2: { label: "A5E.ItemEquipped", key: "system.equippedState", type: "value" },
          // For Equipped State
          plotItem: { label: "A5E.PlotItem", key: "system.plotItem", type: "boolean" },
          requiresAttunement: { label: "A5E.AttunementRequired", key: "system.requiredAttunement", type: "boolean" }
        }
      }
    },
    spells: {
      activationCost: {
        label: "A5E.FilterLabelActivationCost",
        filters: { ...e }
      },
      components: {
        label: "A5E.FilterLabelSpellComponents",
        filters: {
          material: {
            label: "A5E.SpellComponentMaterial",
            key: "system.components.material",
            type: "boolean"
          },
          seen: {
            label: "A5E.SpellComponentSeen",
            key: "system.components.seen",
            type: "boolean"
          },
          vocalized: {
            label: "A5E.SpellComponentVocalized",
            key: "system.components.vocalized",
            type: "boolean"
          }
        }
      },
      miscellaneous: {
        label: "A5E.FilterLabelMiscellaneous",
        filters: {
          concentration: {
            label: "A5E.ConditionConcentration",
            key: "system.concentration",
            type: "boolean"
          },
          ritual: {
            label: "A5E.SpellRitual",
            key: "system.ritual",
            type: "boolean"
          },
          prepared: {
            label: "A5E.SpellPrepared",
            key: "system.prepared",
            type: "boolean"
          }
        }
      },
      primarySpellSchools: {
        label: "A5E.FilterLabelPrimarySpellSchools",
        filters: {}
      }
    }
  }, Object.entries(i.maneuverTraditions).forEach(([t, s]) => {
    i.filters.maneuvers.traditions.filters[t] = {
      label: s,
      key: "system.tradition",
      type: "value",
      truthValue: "or"
    };
  }), Object.entries(i.itemRarity).forEach(([t, s]) => {
    i.filters.objects.rarity.filters[t] = {
      label: s,
      key: "system.rarity",
      type: "value"
    };
  }), Object.entries(i.spellSchools.primary).forEach(([t, s]) => {
    i.filters.spells.primarySpellSchools.filters[t] = {
      label: s,
      key: "system.schools.primary",
      type: "value",
      truthValue: "or"
    };
  });
}
f(sse, "registerFilterConfig");
function nse(i) {
  i.itemGrants = {
    ability: "A5E.grants.headings.ability",
    attack: "A5E.grants.headings.attack",
    damage: "A5E.grants.headings.damage",
    exertion: "A5E.grants.headings.exertion",
    expertiseDice: "A5E.grants.headings.expertiseDice",
    feature: "A5E.grants.headings.feature",
    healing: "A5E.grants.headings.healing",
    hitPoint: "A5E.grants.headings.hitPoint",
    item: "A5E.grants.headings.item",
    initiative: "A5E.grants.headings.initiative",
    movement: "A5E.grants.headings.movement",
    proficiency: "A5E.grants.headings.proficiency",
    rollOverride: "A5E.grants.headings.rollOverride",
    senses: "A5E.grants.headings.senses",
    skill: "A5E.grants.headings.skill",
    skillSpecialty: "A5E.grants.headings.skillSpecialty",
    trait: "A5E.grants.headings.trait"
  };
}
f(nse, "registerGrantsConfig");
function ise(i) {
  i.moduleIncompatibilities = {
    "a5e-aces-necromancy-vol-1": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-arcane-sniper": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-concentrator": {
      reason: "The A5e concentrator module is no longer working correctly, and its functionality will soon be part of the core system.",
      priority: "medium"
    },
    "a5e-confidence-mage": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-dnd5e-srd-content": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-extra-credits": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-fancy-compendia": {
      reason: "The updated compendium sheets are now included in the A5e system without any need for a module and include several new features. We highly recommend you disable this module to take full advantage of those new features.",
      priority: "medium"
    },
    "a5e-fiery-justice": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-field-engineer": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-mortalist": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-motif-classes": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-spells-from-the-forgotten-vault": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-spiritualist": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-thematic-toolkit-arcane-avenger": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-thematic-toolkit-burning-gloom": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-thematic-toolkit-carry-the-darkness": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-thematic-toolkit-cultist": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-thematic-toolkit-hazardous-knowledge": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-thematic-toolkit-itinerant": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-thematic-toolkit-judge-jury-and-executioner": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-thematic-toolkit-master-of-ceremonies": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-thematic-toolkit-scrapper": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-thematic-toolkit-storyteller": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-thematic-toolkit-thunder-of-war": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-thematic-toolkit-venomous-shadow": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    "a5e-toil-and-trouble": {
      reason: "The content from this module is included in the core system packs, and the module is no longer necessary.",
      priority: "low"
    },
    dae: {
      reason: "All of DAE's features are already part of the A5e system's Active Effects implementation. Using DAE will give you a worse experience than having it turned off.",
      priority: "high"
    },
    "gamemaster-title-editor": {
      reason: "The system already provides settings to configure a GM's title, so this module is unnecessary in the A5e system. It may also conflict with the system's built-in configuration options.",
      priority: "medium"
    },
    "party-overview": {
      reason: "The system already includes an interface to display summary statistics for an adventuring party that provides far more functionality than the Party Overview module.",
      priority: "low"
    }
  };
}
f(ise, "registerModuleIncompatibilities");
function lse(i) {
  i.PRELOCALIZED_KEYS = [
    "DICE_ROLL_MODES",
    "abilities",
    "abilityAbbreviations",
    "abilityActivationTypes",
    "abilityActivationTypesPlural",
    "actionOptions",
    "actorSizes",
    "ammunitionProperties",
    "areaTypes",
    "armor",
    "armorModes",
    "armorProperties",
    "attackTypes",
    "characterClasses",
    "classSpellLists",
    "classes",
    "classes5e",
    "conditions",
    "creatureTypes",
    "damageTypes",
    "distanceAbbreviations",
    "distanceUnits",
    "effectsKeyLocalizations",
    "featureTypes",
    "healingTypes",
    "itemRarity",
    "itemTypes",
    "languages",
    "maneuverDegrees",
    "maneuverTraditions",
    "materialProperties",
    "movement",
    "movementAbbreviations",
    "objectTypes",
    "objectTypesPlural",
    "rangeDescriptors",
    "resourceRecoveryOptions",
    "rollModes",
    "saveDCOptions",
    "senses",
    "shieldProperties",
    "shieldTypes",
    "skills",
    "skillSpecialties.acr",
    "skillSpecialties.ani",
    "skillSpecialties.arc",
    "skillSpecialties.ath",
    "skillSpecialties.cul",
    "skillSpecialties.dec",
    "skillSpecialties.eng",
    "skillSpecialties.his",
    "skillSpecialties.ins",
    "skillSpecialties.itm",
    "skillSpecialties.inv",
    "skillSpecialties.med",
    "skillSpecialties.nat",
    "skillSpecialties.prc",
    "skillSpecialties.prf",
    "skillSpecialties.per",
    "skillSpecialties.rel",
    "skillSpecialties.slt",
    "skillSpecialties.ste",
    "skillSpecialties.sur",
    "spellComponents",
    "spellComponentAbbreviations",
    "spellConsumerModes",
    "spellLevels",
    "spellSchools.primary",
    "spellSchools.secondary",
    "targetTypes",
    "targetTypesPlural",
    "timePeriods",
    "timePeriodsPlural",
    "visionUnits",
    "tools.artisansTools",
    "tools.gamingSets",
    "tools.musicalInstruments",
    "tools.miscellaneous",
    "tools.vehicles",
    "toolsPlural.artisansTools",
    "toolsPlural.gamingSets",
    "toolsPlural.musicalInstruments",
    "toolsPlural.miscellaneous",
    "toolsPlural.vehicles",
    "weapons.simple",
    "weapons.martial",
    "weapons.rare",
    "weaponsPlural.simple",
    "weaponsPlural.martial",
    "weaponsPlural.rare",
    "weaponProperties"
  ];
}
f(lse, "registerPreLocalizationProperties");
function rse(i) {
  i.premiumContent = {
    acesAdventuringGuides: {
      name: "Ace's Adventuring Guides",
      releases: [{
        title: "Ace's Guide to Necromancy",
        url: "https://bit.ly/3TWSVkh"
      }]
    },
    anthonyAlipio: {
      name: "Anthony Alipio",
      releases: [
        {
          title: "The Sugar Crumb Fairy",
          url: "https://bit.ly/3Zs8nI4"
        },
        {
          title: "Til Undeath Do Us Part",
          url: "https://bit.ly/3SBRDwn"
        }
      ]
    },
    dmSarah: {
      name: "DM Sarah",
      releases: [{
        title: "Stranger Sights: Challenges for 5e and Advanced 5e",
        url: "https://bit.ly/3zR5Uf0"
      }]
    },
    enPublishing: {
      name: "EN Publishing",
      releases: [{
        title: "Memories of Holdenshire",
        url: "https://bit.ly/3A8wlgq"
      }]
    },
    joshGentry: {
      name: "Josh Gentry",
      releases: [
        {
          title: "Crests of Destiny",
          url: "https://bit.ly/3T1BE7O"
        },
        {
          title: "Dose of Dungeonpunk - The Talos Heritage",
          url: "https://bit.ly/3fe9CaB"
        },
        {
          title: "Slice of Psionics - The Elan Heritage",
          url: "https://bit.ly/3CDh3R1"
        }
      ]
    },
    plantWitchPress: {
      name: "Plant Witch Press",
      releases: [{
        title: "Toil and Trouble",
        url: "https://bit.ly/3HE10VQ"
      }]
    },
    purpleMartinGames: {
      name: "Purple Martin Games",
      releases: [
        {
          title: "MoAR: Battlemages",
          url: "https://bit.ly/41HQd4G"
        },
        {
          title: "MoAR: Complete",
          url: "https://bit.ly/4b7Fsyi"
        },
        {
          title: "MoAR: Elements",
          url: "https://bit.ly/3XIvKfE"
        },
        {
          title: "MoAR: Intrigue",
          url: "https://bit.ly/3uIMyFQ"
        },
        {
          title: "MoAR: Light & Dark",
          url: "https://bit.ly/3T9pQ3s"
        },
        {
          title: "MoAR: Wilderness",
          url: "https://bit.ly/3xisyKN"
        },
        {
          title: "Thematic Toolkit: Folk of the Court",
          url: "https://bit.ly/48SVn1R"
        },
        {
          title: "Thematic Toolkit: Itinerant",
          url: "https://bit.ly/3Sidh7p"
        }
      ]
    },
    roguesCollection: {
      name: "The Rogue's Collection",
      releases: [
        {
          title: "Eclipsa Records - Armaments: Confidential",
          url: "https://bit.ly/3Om8W1y"
        },
        {
          title: "Legends of Strength",
          url: "https://bit.ly/3UnXINY"
        },
        {
          title: "Primal Sorcery",
          url: "https://bit.ly/3SBPS24"
        }
      ]
    },
    rollThemBones: {
      name: "Roll them Bones",
      releases: [{
        title: "Extra Credit and Deeper Mysteries",
        url: "https://bit.ly/47UnJaV"
      }]
    },
    speaksAndSpells: {
      name: "Speaks & Spells Publishing",
      releases: [{
        title: "The Arcane Exterminator: An Artificer Archetype and Magic Item Compendium",
        url: "https://bit.ly/49fTzA3"
      }]
    },
    steampunkette: {
      name: "Steampunkette",
      releases: [{
        title: "Paranormal Power",
        url: "https://bit.ly/49bS1XH"
      }]
    },
    wolfworksPress: {
      name: "Wolfworks Press",
      releases: [{
        title: "Handbook of Heritages",
        url: "https://bit.ly/3PPfarX"
      }]
    }
  }, i.products = {
    acesAdventuringGuideToNecromancy: {
      abbreviation: "AAGtN",
      affiliate: !0,
      publisher: "acesAdventuringGuides",
      title: "Ace's Adventuring Guide to Necromancy",
      url: "https://bit.ly/4bez8oK"
    },
    acesAdventuringGuideToNecromancySupplement: {
      abbreviation: "AAGtN:S",
      affiliate: !0,
      publisher: "acesAdventuringGuides",
      title: "Ace's Adventuring Guide to Necromancy: A Supplement",
      url: "https://bit.ly/3HQ17gV"
    },
    adventurersGuide: {
      abbreviation: "AG",
      affiliate: !0,
      publisher: "enPublishing",
      title: "Level Up: Adventurer's Guide",
      url: "https://bit.ly/3w15Iua"
    },
    adventuresInZeitgeist: {
      abbreviation: "AiZ",
      affiliate: !0,
      publisher: "enPublishing",
      title: "Level Up: Adventures in ZEITGEIST",
      url: "https://bit.ly/3u99LnT"
    },
    agentOfTheMagus: {
      abbreviation: "AotM",
      affiliate: !1,
      publisher: "ravine",
      title: "Agent of the Magus",
      url: "https://ravine.itch.io/a5e-subclass01-magus"
    },
    arcaneSniper: {
      abbreviation: "AS",
      affiliate: !0,
      publisher: "purpleMartinGames",
      title: "Arcane Sniper",
      url: "https://bit.ly/3I3t0SW"
    },
    confidenceMage: {
      abbreviation: "ConfMage",
      affiliate: !0,
      publisher: "purpleMartinGames",
      title: "Confidence Mage",
      url: "https://preview.drivethrurpg.com/en/product/403897/confidence-mage-a5e?affiliate_id=1388381"
    },
    deepMagic1: {
      abbreviation: "DM Vol.1",
      affiliate: !0,
      publisher: "koboldPress",
      title: "Deep Magic Volume 1",
      url: "https://bit.ly/3TfgMvP"
    },
    deepMagic2: {
      abbreviation: "DM Vol.2",
      affiliate: !1,
      publisher: "koboldPress",
      title: "Deep Magic Volume 2",
      url: "https://bit.ly/3v2z4Zf"
    },
    doseOfDungeonpunk: {
      abbreviation: "DOD:TH",
      affiliate: !0,
      publisher: "joshGentry",
      title: "Dose of Dungeonpunk - The Talos Heritage",
      url: "https://bit.ly/4bo5FsM"
    },
    dungeonDelversGuide: {
      abbreviation: "DDG",
      affiliate: !0,
      publisher: "enPublishing",
      title: "Level Up: Dungeon Delver's Guide",
      url: "https://bit.ly/4bLImsK"
    },
    extraCreditAndDeeperMysteries: {
      abbreviation: "ECaDM",
      affiliate: !0,
      publisher: "rollThemBones",
      title: "Extra Credit and Deeper Mysteries",
      url: "https://bit.ly/47UnJaV"
    },
    fieldEngineer: {
      abbreviation: "FE",
      affiliate: !0,
      publisher: "purpleMartinGames",
      title: "Field Engineer",
      url: "https://bit.ly/49D4FPF"
    },
    fieryJustice: {
      abbreviation: "FJ",
      affiliate: !0,
      publisher: "purpleMartinGames",
      title: "Fiery Justice",
      url: "https://preview.drivethrurpg.com/en/product/409471/fiery-justice-a5e?affiliate_id=1388381"
    },
    gpg0: {
      abbreviation: "GPG #0",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #0",
      url: "https://bit.ly/3HMhZW5"
    },
    gpg1: {
      abbreviation: "GPG #1",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #1",
      url: "https://bit.ly/48YR8BZ"
    },
    gpg2: {
      abbreviation: "GPG #2",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #2",
      url: "https://bit.ly/49hj181"
    },
    gpg3: {
      abbreviation: "GPG #3",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #3",
      url: "https://bit.ly/49elHTS"
    },
    gpg4: {
      abbreviation: "GPG #4",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #4",
      url: "https://bit.ly/4bo5Vbe"
    },
    gpg5: {
      abbreviation: "GPG #5",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #5",
      url: "https://bit.ly/3uuw1sx"
    },
    gpg6: {
      abbreviation: "GPG #6",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #6",
      url: "https://bit.ly/3SquHyB"
    },
    gpg7: {
      abbreviation: "GPG #7",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #7",
      url: "https://bit.ly/4bEHc2h"
    },
    gpg8: {
      abbreviation: "GPG #8",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #8",
      url: "https://bit.ly/3SNRHrB"
    },
    gpg9: {
      abbreviation: "GPG #9",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #9",
      url: "https://bit.ly/3OvH2k2"
    },
    gpg10: {
      abbreviation: "GPG #10",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #10",
      url: "https://bit.ly/42JSXR0"
    },
    gpg11: {
      abbreviation: "GPG #11",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #11",
      url: "https://bit.ly/3OsnMnu"
    },
    gpg12: {
      abbreviation: "GPG #12",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #12",
      url: "https://bit.ly/3uI2SKn"
    },
    gpg13: {
      abbreviation: "GPG #13",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #13",
      url: "https://bit.ly/3T1ABHU"
    },
    gpg14: {
      abbreviation: "GPG #14",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #14",
      url: "https://bit.ly/49kSzLo"
    },
    gpg15: {
      abbreviation: "GPG #15",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #15",
      url: "https://bit.ly/49kSzLo"
    },
    gpg16: {
      abbreviation: "GPG #16",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #16",
      url: "https://bit.ly/3IqpKBv"
    },
    gpg17: {
      abbreviation: "GPG #17",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #17",
      url: "https://bit.ly/3uHrm6p"
    },
    gpg18: {
      abbreviation: "GPG #18",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #18",
      url: "https://bit.ly/48pPGaX"
    },
    gpg19: {
      abbreviation: "GPG #19",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #19",
      url: "https://bit.ly/4blqODO"
    },
    gpg20: {
      abbreviation: "GPG #20",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #20",
      url: "https://bit.ly/49OPl2F"
    },
    gpg21: {
      abbreviation: "GPG #21",
      affiliate: !0,
      publisher: "enPublishing",
      series: "gatePassGazette",
      title: "Level Up: Gate Pass Gazette Issue #21",
      url: "https://bit.ly/4c1jnCf"
    },
    hakansPamphlet: {
      abbreviation: "HPtAW",
      affiliate: !1,
      publisher: "ravine",
      title: "Hakan's Pamphlet to Arcane Weaponry",
      url: "https://ravine.itch.io/a5e-spells01-arcaneweapon"
    },
    heroesOldAndNew: {
      abbreviation: "MMM",
      affiliate: !0,
      publisher: "rollThemBones",
      title: "Heroes Old and New",
      url: "https://bit.ly/3UevPrJ"
    },
    moarComplete: {
      abbreviation: "MoAR",
      affiliate: !0,
      publisher: "purpleMartinGames",
      title: "Manual of Adventurous Resources: Complete",
      url: "https://bit.ly/4b7Fsyi"
    },
    monstrousMenagerie: {
      abbreviation: "MM",
      affiliate: !0,
      publisher: "enPublishing",
      title: "Level Up: Monstrous Menagerie",
      url: "https://bit.ly/3T1jeqJ"
    },
    mortalist: {
      abbreviation: "Mort",
      affiliate: !0,
      publisher: "purpleMartinGames",
      title: "Mortalist",
      url: "https://bit.ly/3I6n4Zj"
    },
    motifClasses: {
      abbreviation: "SA:MC",
      affiliate: !0,
      publisher: "purpleMartinGames",
      title: "System Architecture: Motif Classes",
      url: "https://bit.ly/4bgzU4N"
    },
    multiclassersManual: {
      abbreviation: "MulMan Vol. 1",
      affiliate: !0,
      publisher: "purpleMartinGames",
      title: "Multiclasser's Manual, Volume 1",
      url: "https://bit.ly/3JZTA08"
    },
    mysteriousAndMarvelousMiscellanea: {
      abbreviation: "MMM",
      affiliate: !0,
      publisher: "rollThemBones",
      title: "Mysterious and Marvelous Miscellanea",
      url: "https://bit.ly/42fLLM8"
    },
    paradigmsOfSkill: {
      abbreviation: "PoS",
      affiliate: !0,
      publisher: "plantWitchPress",
      title: "Paradigms of Skill",
      url: "https://bit.ly/3TvtZRl"
    },
    planestridersJournal: {
      abbreviation: "PJ",
      affiliate: !0,
      publisher: "enPublishing",
      title: "Planestrider's Journal",
      url: ""
    },
    ridingParsnip: {
      abbreviation: "RP",
      affiliate: !0,
      publisher: "purpleMartinGames",
      title: "Riding Parsnip",
      url: "https://bit.ly/3xh28Nk"
    },
    secretsOfTheSelkies: {
      abbreviation: "SotS",
      affiliate: !0,
      publisher: "speaksAndSpells",
      title: "Secrets of the Selkies",
      url: "https://bit.ly/3USEOix"
    },
    sinuousSentinels: {
      abbreviation: "SinSen",
      affiliate: !0,
      publisher: "purpleMartinGames",
      title: "Sinuous Sentinels",
      url: "https://bit.ly/3SSNXoy"
    },
    spellsFromTheForgottenVault: {
      abbreviation: "SftFV",
      affiliate: !0,
      publisher: "purpleMartinGames",
      title: "Spells from the Forgotten Vault",
      url: "https://bit.ly/3T8o5GU"
    },
    spiritualist: {
      abbreviation: "Spirit",
      affiliate: !0,
      publisher: "purpleMartinGames",
      title: "Spiritualist",
      url: "https://preview.drivethrurpg.com/en/product/424846/spiritualist-a5e?affiliate_id=1388381"
    },
    strangerSights: {
      abbreviation: "SS",
      affiliate: !0,
      publisher: "dmSarah",
      title: "Stranger Sights: Challenges for 5e and Advanced 5e",
      url: "https://bit.ly/3SmPaEv"
    },
    theHauntingOfCalrowRuins: {
      abbreviation: "THoCR",
      affiliate: !1,
      publisher: "enPublishing",
      title: "The Haunting of Calrow Ruins",
      url: "https://enpublishingrpg.com/products/the-haunting-of-calrow-ruins"
    },
    thematicToolkitArcaneAvenger: {
      abbreviation: "TT:AA",
      affiliate: !0,
      publisher: "purpleMartinGames",
      series: "thematicToolkit",
      title: "Thematic Toolkit: Arcane Avenger",
      url: "https://preview.drivethrurpg.com/en/product/392599/thematic-toolkit-arcane-avenger-a5e?affiliate_id=1388381"
    },
    thematicToolkitBurningGloom: {
      abbreviation: "TT:BG",
      affiliate: !0,
      publisher: "purpleMartinGames",
      series: "thematicToolkit",
      title: "Thematic Toolkit: Burning Gloom",
      url: "https://bit.ly/48XRLfm"
    },
    thematicToolkitCarryTheDarkness: {
      abbreviation: "TT:CtD",
      affiliate: !0,
      publisher: "purpleMartinGames",
      series: "thematicToolkit",
      title: "Thematic Toolkit: Carry the Darkness",
      url: "https://bit.ly/480m03Y"
    },
    thematicToolkitCultist: {
      abbreviation: "TT:Cult",
      affiliate: !0,
      publisher: "purpleMartinGames",
      series: "thematicToolkit",
      title: "Thematic Toolkit: Cultist",
      url: "https://preview.drivethrurpg.com/en/product/392588/thematic-toolkit-cultist-a5e?affiliate_id=1388381"
    },
    thematicToolkitFolkOfTheCourt: {
      abbreviation: "TT:FotC",
      affiliate: !0,
      publisher: "purpleMartinGames",
      series: "thematicToolkit",
      title: "Thematic Toolkit: Folk of the Court",
      url: "https://bit.ly/48SVn1R"
    },
    thematicToolkitHazardousKnowledge: {
      abbreviation: "TT:HK",
      affiliate: !0,
      publisher: "purpleMartinGames",
      series: "thematicToolkit",
      title: "Thematic Toolkit: Hazardous Knowledge",
      url: "https://bit.ly/4d7WzRz"
    },
    thematicToolkitItinerant: {
      abbreviation: "TT:Itin",
      affiliate: !0,
      publisher: "purpleMartinGames",
      series: "thematicToolkit",
      title: "Thematic Toolkit: Itinerant",
      url: "https://bit.ly/3Sidh7p"
    },
    thematicToolkitJudgeJuryAndExecutioner: {
      abbreviation: "TT:JJE",
      affiliate: !0,
      publisher: "purpleMartinGames",
      series: "thematicToolkit",
      title: "Thematic Toolkit: Judge, Jury, and Executioner",
      url: "https://bit.ly/42OmyZC"
    },
    thematicToolkitMasterOfCeremonies: {
      abbreviation: "TT:MoC",
      affiliate: !0,
      publisher: "purpleMartinGames",
      series: "thematicToolkit",
      title: "Thematic Toolkit: Master of Ceremonies",
      url: "https://preview.drivethrurpg.com/en/product/422460/thematic-toolkit-master-of-ceremonies-a5e?affiliate_id=1388381"
    },
    thematicToolkitScrapper: {
      abbreviation: "TT:Scrap",
      affiliate: !0,
      publisher: "purpleMartinGames",
      series: "thematicToolkit",
      title: "Thematic Toolkit: Scrapper",
      url: "https://preview.drivethrurpg.com/en/product/412017/thematic-toolkit-scrapper-a5e?affiliate_id=1388381"
    },
    thematicToolkitStoryteller: {
      abbreviation: "TT:Story",
      affiliate: !0,
      publisher: "purpleMartinGames",
      series: "thematicToolkit",
      title: "Thematic Toolkit: Storyteller",
      url: "https://preview.drivethrurpg.com/en/product/407903/thematic-toolkit-storyteller-a5e?affiliate_id=1388381"
    },
    thematicToolkitThunderOfWar: {
      abbreviation: "TT:ToW",
      affiliate: !0,
      publisher: "purpleMartinGames",
      series: "thematicToolkit",
      title: "Thematic Toolkit: Thunder of War",
      url: "https://preview.drivethrurpg.com/en/product/404207/thematic-toolkit-thunder-of-war-a5e?affiliate_id=1388381"
    },
    thematicToolkitVenomousShadow: {
      abbreviation: "TT:VS",
      affiliate: !0,
      publisher: "purpleMartinGames",
      series: "thematicToolkit",
      title: "Thematic Toolkit: Venomous Shadow",
      url: "https://preview.drivethrurpg.com/en/product/400541/thematic-toolkit-venomous-shadow-a5e?affiliate_id=1388381"
    },
    theErrantSeer: {
      abbreviation: "TES",
      affiliate: !1,
      publisher: "ravine",
      title: "The Errant Seer",
      url: "https://ravine.itch.io/a5e-subclass03-errant-seer"
    },
    theRuinStrider: {
      abbreviation: "TRS",
      affiliate: !1,
      publisher: "ravine",
      title: "The Ruin Stider",
      url: "https://ravine.itch.io/a5e-subclass02-ruin-strider"
    },
    theSpellbreaker: {
      abbreviation: "TS",
      affiliate: !1,
      publisher: "ravine",
      title: "The Spellbreaker",
      url: "https://ravine.itch.io/a5e-subclass04-spellbreaker"
    },
    toilAndTrouble: {
      abbreviation: "TaT",
      affiliate: !0,
      publisher: "plantWitchPress",
      title: "Toil and Trouble",
      url: "https://bit.ly/3HE10VQ"
    },
    toSaveAKingdom: {
      abbreviation: "TSaK",
      affiliate: !0,
      publisher: "enPublishing",
      title: "Level Up: To Save a Kingdom",
      url: "https://bit.ly/42iQKvN"
    },
    trialsAndTreasures: {
      abbreviation: "T&T",
      affiliate: !0,
      publisher: "enPublishing",
      title: "Level Up: Trials and Treasures",
      url: "https://bit.ly/3w8ha7b"
    },
    ventureForth: {
      abbreviation: "VF",
      affiliate: !0,
      publisher: "speaksAndSpells",
      title: "Venture Forth",
      url: ""
    }
  };
}
f(rse, "registerPremiumContentConfig");
function ose(i) {
  i.publishers = {
    acesAdventuringGuides: "Ace's Adventuring Guides",
    anthonyAlipio: "Anthony Alipio",
    dmSarah: "DM Sarah",
    enPublishing: "EN Publishing",
    joshGentry: "Josh Gentry",
    koboldPress: "Kobold Press",
    plantWitchPress: "Plant Witch Press",
    purpleMartinGames: "Purple Martin Games",
    ravine: "Ravine",
    rollThemBones: "Roll them Bones Gaming",
    roguesCollection: "The Rogue's Collection",
    speaksAndSpells: "Speaks and Spells Publishing",
    steampunkette: "Steampunkette",
    wolfworksPress: "Wolfworks Press"
  };
}
f(ose, "registerPublisherConfig");
function ase(i) {
  i.reducerSortMap = {
    features: {
      legendaryAction: 0,
      naturalWeapon: 1,
      class: 2,
      knack: 3,
      feat: 4,
      heritage: 5,
      culture: 6,
      background: 7,
      destiny: 8,
      boon: 9,
      other: 10
    },
    objects: {
      weapon: 0,
      armor: 1,
      shield: 2,
      ammunition: 3,
      container: 4,
      consumable: 5,
      tool: 6,
      jewelry: 7,
      clothing: 8,
      miscellaneous: 9
    }
  };
}
f(ase, "registerReducerConfig");
function cse(i) {
  i.refreshableSettings = /* @__PURE__ */ new Set([
    "automatedConditions"
  ]);
}
f(cse, "registerSettingsConfig");
function use(i) {
  i.classes = {
    adept: "A5E.characterClasses.adept",
    artificer: "A5E.characterClasses.artificer",
    artificerRevised: "A5E.characterClasses.artificerRevised",
    bard: "A5E.characterClasses.bard",
    berserker: "A5E.characterClasses.berserker",
    cleric: "A5E.characterClasses.cleric",
    druid: "A5E.characterClasses.druid",
    elementalist: "A5E.characterClasses.elementalist",
    fighter: "A5E.characterClasses.fighter",
    herald: "A5E.characterClasses.herald",
    marshal: "A5E.characterClasses.marshal",
    ranger: "A5E.characterClasses.ranger",
    rogue: "A5E.characterClasses.rogue",
    savant: "A5E.characterClasses.savant",
    sorcerer: "A5E.characterClasses.sorcerer",
    warlock: "A5E.characterClasses.warlock",
    wielder: "A5E.characterClasses.wielder",
    witch: "A5E.characterClasses.witch",
    wizard: "A5E.characterClasses.wizard"
  }, i.classes5e = {
    dnd5eArtificer: "A5E.characterClasses.artificer",
    dnd5eBarbarian: "A5E.characterClasses.barbarian",
    dnd5eBard: "A5E.characterClasses.bard",
    dnd5eCleric: "A5E.characterClasses.cleric",
    dnd5eDruid: "A5E.characterClasses.druid",
    dnd5eFighter: "A5E.characterClasses.fighter",
    dnd5eMonk: "A5E.characterClasses.monk",
    dnd5ePaladin: "A5E.characterClasses.paladin",
    dnd5eRanger: "A5E.characterClasses.ranger",
    dnd5eRogue: "A5E.characterClasses.rogue",
    dnd5eSorcerer: "A5E.characterClasses.sorcerer",
    dnd5eWarlock: "A5E.characterClasses.warlock",
    dnd5eWizard: "A5E.characterClasses.wizard"
  }, i.classLevelTypes = {
    character: "A5E.classes.levelTypes.character",
    class: "A5E.classes.levelTypes.class"
  }, i.classHPTypes = {
    average: "A5E.classes.hpTypes.average",
    roll: "A5E.classes.hpTypes.roll",
    custom: "A5E.classes.hpTypes.custom"
  }, i.casterTypes = {
    none: "A5E.None",
    fullCaster: "A5E.classes.casterTypes.fullCaster",
    halfCaster: "A5E.classes.casterTypes.halfCaster",
    halfCasterWithFirstLevel: "A5E.classes.casterTypes.halfCasterWithFirstLevel",
    tertiaryCaster: "A5E.classes.casterTypes.tertiaryCaster",
    quaternaryCaster: "A5E.classes.casterTypes.quaternaryCaster",
    artificerA5e: "A5E.classes.casterTypes.artificerA5e",
    elementalist: "A5E.classes.casterTypes.elementalist",
    warlockA5e: "A5E.classes.casterTypes.warlockA5e",
    warlock5e: "A5E.classes.casterTypes.warlock5e",
    wielder: "A5E.classes.casterTypes.wielder"
  }, i.exertionPoolTypes = {
    none: "A5E.classes.exertionPoolTypes.none",
    prof: "A5E.classes.exertionPoolTypes.prof",
    doubleProf: "A5E.classes.exertionPoolTypes.double"
  }, i.SPELL_SLOT_TABLE = {
    1: [2],
    2: [3],
    3: [4, 2],
    4: [4, 3],
    5: [4, 3, 2],
    6: [4, 3, 3],
    7: [4, 3, 3, 1],
    8: [4, 3, 3, 2],
    9: [4, 3, 3, 3, 1],
    10: [4, 3, 3, 3, 2],
    11: [4, 3, 3, 3, 2, 1],
    12: [4, 3, 3, 3, 2, 1],
    13: [4, 3, 3, 3, 2, 1, 1],
    14: [4, 3, 3, 3, 2, 1, 1],
    15: [4, 3, 3, 3, 2, 1, 1, 1],
    16: [4, 3, 3, 3, 2, 1, 1, 1],
    17: [4, 3, 3, 3, 2, 1, 1, 1, 1],
    18: [4, 3, 3, 3, 3, 1, 1, 1, 1],
    19: [4, 3, 3, 3, 3, 2, 1, 1, 1],
    20: [4, 3, 3, 3, 3, 2, 2, 1, 1]
  }, i.SPELL_POINTS_TABLE_ELEMENTALIST = {
    1: { points: 2, level: 1 },
    2: { points: 4, level: 1 },
    3: { points: 5, level: 1 },
    4: { points: 6, level: 1 },
    5: { points: 7, level: 2 },
    6: { points: 8, level: 2 },
    7: { points: 9, level: 2 },
    8: { points: 10, level: 2 },
    9: { points: 11, level: 3 },
    10: { points: 12, level: 3 },
    11: { points: 13, level: 3 },
    12: { points: 14, level: 3 },
    13: { points: 15, level: 4 },
    14: { points: 16, level: 4 },
    15: { points: 17, level: 4 },
    16: { points: 18, level: 4 },
    17: { points: 19, level: 5 },
    18: { points: 20, level: 5 },
    19: { points: 21, level: 5 },
    20: { points: 22, level: 5 }
  }, i.SPELL_POINTS_TABLE_WARLOCK = {
    1: { points: 2, level: 1 },
    2: { points: 4, level: 1 },
    3: { points: 6, level: 2 },
    4: { points: 8, level: 2 },
    5: { points: 10, level: 3 },
    6: { points: 11, level: 3 },
    7: { points: 12, level: 4 },
    8: { points: 13, level: 4 },
    9: { points: 14, level: 5 },
    10: { points: 17, level: 5 },
    11: { points: 21, level: 5 },
    12: { points: 22, level: 5 },
    13: { points: 24, level: 5 },
    14: { points: 25, level: 5 },
    15: { points: 26, level: 5 },
    16: { points: 27, level: 5 },
    17: { points: 28, level: 5 },
    18: { points: 29, level: 5 },
    19: { points: 30, level: 5 },
    20: { points: 31, level: 5 }
  }, i.PACT_SLOT_TABLE = {
    1: { slots: 1, level: 1 },
    2: { slots: 2, level: 1 },
    3: { slots: 2, level: 2 },
    4: { slots: 2, level: 2 },
    5: { slots: 2, level: 3 },
    6: { slots: 2, level: 3 },
    7: { slots: 2, level: 4 },
    8: { slots: 2, level: 4 },
    9: { slots: 2, level: 5 },
    10: { slots: 2, level: 5 },
    11: { slots: 3, level: 5 },
    12: { slots: 3, level: 5 },
    13: { slots: 3, level: 5 },
    14: { slots: 3, level: 5 },
    15: { slots: 3, level: 5 },
    16: { slots: 3, level: 5 },
    17: { slots: 4, level: 5 },
    18: { slots: 4, level: 5 },
    19: { slots: 4, level: 5 },
    20: { slots: 4, level: 5 }
  }, i.ARTIFICER_SPELL_INVENTIONS = {
    1: { count: 2, level: 1 },
    2: { count: 2, level: 1 },
    3: { count: 2, level: 1 },
    4: { count: 2, level: 1 },
    5: { count: 2, level: 2 },
    6: { count: 3, level: 2 },
    7: { count: 3, level: 2 },
    8: { count: 3, level: 2 },
    9: { count: 3, level: 3 },
    10: { count: 4, level: 3 },
    11: { count: 4, level: 3 },
    12: { count: 4, level: 3 },
    13: { count: 4, level: 4 },
    14: { count: 5, level: 4 },
    15: { count: 5, level: 4 },
    16: { count: 5, level: 4 },
    17: { count: 5, level: 5 },
    18: { count: 6, level: 5 },
    19: { count: 6, level: 5 },
    20: { count: 6, level: 5 }
  }, i.WIELDER_ARTIFACT_CHARGES = {
    1: { charges: 2, level: 1 },
    2: { charges: 4, level: 1 },
    3: { charges: 5, level: 1 },
    4: { charges: 6, level: 1 },
    5: { charges: 7, level: 2 },
    6: { charges: 8, level: 2 },
    7: { charges: 9, level: 2 },
    8: { charges: 10, level: 2 },
    9: { charges: 11, level: 3 },
    10: { charges: 12, level: 3 },
    11: { charges: 13, level: 3 },
    12: { charges: 14, level: 3 },
    13: { charges: 15, level: 4 },
    14: { charges: 16, level: 4 },
    15: { charges: 17, level: 4 },
    16: { charges: 18, level: 4 },
    17: { charges: 19, level: 5 },
    18: { charges: 20, level: 5 },
    19: { charges: 21, level: 5 },
    20: { charges: 22, level: 5 }
  }, i.casterProgression = {
    none: { type: null, config: null, reference: null },
    fullCaster: {
      type: "multiplier",
      config: i.SPELL_SLOT_TABLE,
      resource: "slots",
      multiplier: 1
    },
    halfCaster: {
      type: "multiplier",
      config: i.SPELL_SLOT_TABLE,
      resource: "slots",
      multiplier: 0.5
    },
    tertiaryCaster: {
      type: "multiplier",
      config: i.SPELL_SLOT_TABLE,
      resource: "slots",
      multiplier: 0.33
    },
    quaternaryCaster: {
      type: "multiplier",
      config: i.SPELL_SLOT_TABLE,
      resource: "slots",
      multiplier: 0.25
    },
    halfCasterWithFirstLevel: {
      type: "multiplier",
      config: i.SPELL_SLOT_TABLE,
      resource: "slots",
      multiplier: 0.5,
      roundUp: !0
    },
    artificerA5e: {
      type: "reference",
      config: i.ARTIFICER_SPELL_INVENTIONS,
      resource: "inventions"
    },
    elementalist: {
      type: "reference",
      config: i.SPELL_POINTS_TABLE_ELEMENTALIST,
      resource: "points",
      multiclassMode: "ADD"
    },
    warlockA5e: {
      type: "reference",
      config: i.SPELL_POINTS_TABLE_WARLOCK,
      resource: "points",
      multiclassMode: "ADD"
    },
    warlock5e: {
      type: "reference",
      config: i.PACT_SLOT_TABLE,
      resource: "slots"
    },
    wielder: {
      type: "reference",
      config: i.WIELDER_ARTIFACT_CHARGES,
      resource: "artifactCharges"
    }
  };
}
f(use, "registerClassesConfig");
const Ie = {};
Ie.DAMAGED_STATES = {
  INTACT: 0,
  DAMAGED: 1,
  BROKEN: 2
};
Ie.DICE_ROLL_MODES = {
  blindroll: "A5E.diceRollModes.blind",
  gmroll: "A5E.diceRollModes.gm",
  publicroll: "A5E.diceRollModes.public",
  selfroll: "A5E.diceRollModes.self"
};
Ie.CHARACTER_EXP_LEVELS = [
  0,
  300,
  900,
  2700,
  6500,
  14e3,
  23e3,
  34e3,
  48e3,
  64e3,
  85e3,
  1e5,
  12e4,
  14e4,
  165e3,
  195e3,
  225e3,
  265e3,
  305e3,
  355e3
];
Ie.CR_EXP_LEVELS = {
  0: 10,
  "1/8": 25,
  "1/4": 50,
  "1/2": 100,
  1: 200,
  2: 450,
  3: 700,
  4: 1100,
  5: 1800,
  6: 2300,
  7: 2900,
  8: 3900,
  9: 5e3,
  10: 5900,
  11: 7200,
  12: 8400,
  13: 1e4,
  14: 11500,
  15: 13e3,
  16: 15e3,
  17: 18e3,
  18: 2e4,
  19: 22e3,
  20: 25e3,
  21: 33e3,
  22: 41e3,
  23: 5e4,
  24: 62e3,
  25: 75e3,
  26: 9e4,
  27: 105e3,
  28: 12e4,
  29: 135e3,
  30: 155e3
};
Ie.EQUIPPED_STATES = {
  NOT_CARRIED: 0,
  CARRIED: 1,
  EQUIPPED: 2
};
Ie.PREPARED_STATES = {
  UNPREPARED: 0,
  PREPARED: 1,
  ALWAYS_PREPARED: 2
};
Ie.ROLL_MODE = {
  NORMAL: 0,
  ADVANTAGE: 1,
  DISADVANTAGE: -1
};
Ie.abilities = {
  str: "A5E.abilities.strength",
  dex: "A5E.abilities.dexterity",
  con: "A5E.abilities.constitution",
  int: "A5E.abilities.intelligence",
  wis: "A5E.abilities.wisdom",
  cha: "A5E.abilities.charisma"
};
Ie.abilityAbbreviations = {
  str: "A5E.abilities.abbreviations.strength",
  dex: "A5E.abilities.abbreviations.dexterity",
  con: "A5E.abilities.abbreviations.constitution",
  int: "A5E.abilities.abbreviations.intelligence",
  wis: "A5E.abilities.abbreviations.wisdom",
  cha: "A5E.abilities.abbreviations.charisma"
};
Ie.abilityActivationTypes = {
  action: "A5E.ActionActivationAction",
  bonusAction: "A5E.ActionActivationBonusAction",
  day: "A5E.DurationDay",
  hour: "A5E.DurationHour",
  lairAction: "A5E.ActionActivationLairAction",
  legendaryAction: "A5E.ActionActivationLegendaryAction",
  minute: "A5E.DurationMinute",
  none: "A5E.ActionActivationNone",
  objectInteraction: "A5E.ActionActivationObjectInteraction",
  reaction: "A5E.ActionActivationReaction",
  special: "A5E.ActionActivationSpecial"
};
Ie.abilityActivationTypesPlural = {
  action: "A5E.ActionActivationActionPlural",
  bonusAction: "A5E.ActionActivationBonusActionPlural",
  hour: "A5E.DurationHourPlural",
  lairAction: "A5E.ActionActivationLairActionPlural",
  legendaryAction: "A5E.ActionActivationLegendaryActionPlural",
  minute: "A5E.DurationMinutePlural",
  none: "A5E.ActionActivationNone",
  objectInteraction: "A5E.ActionActivationObjectInteractionPlural",
  reaction: "A5E.ActionActivationReaction",
  special: "A5E.ActionActivationSpecial"
};
Ie.actionOptions = {
  abilityCheck: "A5E.ActionOptionAbilityCheck",
  attack: "A5E.ActionOptionAttack",
  damage: "A5E.ActionOptionDamage",
  healing: "A5E.ActionOptionHealing",
  savingThrow: "A5E.ActionOptionSavingThrow"
};
Ie.actorSizes = {
  tiny: "A5E.SizeTiny",
  sm: "A5E.SizeSmall",
  med: "A5E.SizeMedium",
  lg: "A5E.SizeLarge",
  huge: "A5E.SizeHuge",
  grg: "A5E.SizeGargantuan",
  titan: "A5E.SizeTitanic"
};
Ie.originItemTypes = [
  "background",
  "culture",
  "destiny",
  "heritage"
];
Ie.alignments = {
  chaotic: "Chaotic",
  evil: "Evil",
  good: "Good",
  lawful: "Lawful",
  neutral: "Neutral"
};
Ie.ammunitionProperties = {
  explosive: "A5E.AmmunitionPropertyExplosive",
  flaming: "A5E.AmmunitionPropertyFlaming",
  punching: "A5E.AmmunitionPropertyPunching"
};
Ie.appliedArmorTypes = {
  armor: "A5E.armorClass.appliedArmorTypes.armor",
  underarmor: "A5E.armorClass.appliedArmorTypes.underarmor"
};
Ie.areaIcons = {
  circle: '<i class="fa-regular fa-circle"></i>',
  cone: '<i class="fa-solid fa-wifi"></i>',
  cube: '<i class="fa-solid fa-cube"></i>',
  cylinder: '<i class="fa-solid fa-circle"></i>',
  emanation: '<i class="fa-regular fa-circle-dot"></i>',
  line: '<i class="fa-solid fa-grip-lines"></i>',
  sphere: '<i class="fa-solid fa-meteor"></i>',
  square: '<i class="fa-regular fa-square-full"></i>',
  wall: '<i class="fa-solid fa-road-spikes"></i>'
};
Ie.areaTypes = {
  circle: "A5E.AreaCircle",
  cone: "A5E.AreaCone",
  cube: "A5E.AreaCube",
  cylinder: "A5E.AreaCylinder",
  emanation: "A5E.AreaEmanation",
  line: "A5E.AreaLine",
  sphere: "A5E.AreaSphere",
  square: "A5E.AreaSquare",
  wall: "A5E.AreaWall"
};
Ie.areaTemplates = {
  circle: "circle",
  cone: "cone",
  cube: "rect",
  cylinder: "circle",
  line: "ray",
  sphere: "circle",
  square: "rect"
};
Ie.armor = {
  light: "A5E.ArmorLight",
  medium: "A5E.ArmorMedium",
  heavy: "A5E.ArmorHeavy",
  shield: "A5E.ArmorShield"
};
Ie.ARMOR_MODES = {
  ADD: 1,
  OVERRIDE: 2
};
Ie.armorModes = {
  1: "A5E.armorClass.modes.add",
  2: "A5E.armorClass.modes.override"
};
Ie.armorProperties = {
  camouflaged: "A5E.ArmorPropertyCamouflaged",
  spiked: "A5E.ArmorPropertySpiked",
  stealthy: "A5E.objectProperties.stealthy",
  storage: "A5E.objectProperties.storage"
};
Ie.armorPlural = {
  light: "A5E.ArmorLight",
  medium: "A5E.ArmorMedium",
  heavy: "A5E.ArmorHeavy",
  shield: "A5E.ArmorShieldPlural"
};
Ie.attackTypes = {
  meleeWeaponAttack: "A5E.AttackTypeMeleeWeapon",
  rangedWeaponAttack: "A5E.AttackTypeRangedWeapon",
  meleeSpellAttack: "A5E.AttackTypeMeleeSpell",
  rangedSpellAttack: "A5E.AttackTypeRangedSpell"
};
Ie.carryCapacityMultiplier = {
  tiny: 0.5,
  sm: 1,
  med: 1,
  lg: 2,
  huge: 4,
  grg: 8,
  titan: 16
};
Ie.chatCardTypes = [
  "abilityCheck",
  "hitDice",
  "item",
  "rollTableOutput",
  "savingThrow",
  "skillCheck"
];
Ie.conditions = {
  blinded: "A5E.ConditionBlinded",
  bloodied: "A5E.ConditionBloodied",
  charmed: "A5E.ConditionCharmed",
  confused: "A5E.ConditionConfused",
  deafened: "A5E.ConditionDeafened",
  doomed: "A5E.ConditionDoomed",
  encumbered: "A5E.ConditionEncumbered",
  fatigue: "A5E.ConditionFatigue",
  frightened: "A5E.ConditionFrightened",
  grappled: "A5E.ConditionGrappled",
  incapacitated: "A5E.ConditionIncapacitated",
  invisible: "A5E.ConditionInvisible",
  paralyzed: "A5E.ConditionParalyzed",
  petrified: "A5E.ConditionPetrified",
  poisoned: "A5E.ConditionPoisoned",
  prone: "A5E.ConditionProne",
  rattled: "A5E.ConditionRattled",
  restrained: "A5E.ConditionRestrained",
  slowed: "A5E.ConditionSlowed",
  strife: "A5E.ConditionStrife",
  stunned: "A5E.ConditionStunned",
  unconscious: "A5E.ConditionUnconscious"
};
Ie.creatureTypes = {
  aberration: "A5E.CreatureAberration",
  beast: "A5E.CreatureBeast",
  celestial: "A5E.CreatureCelestial",
  construct: "A5E.CreatureConstruct",
  dragon: "A5E.CreatureDragon",
  elemental: "A5E.CreatureElemental",
  fey: "A5E.CreatureFey",
  fiend: "A5E.CreatureFiend",
  giant: "A5E.CreatureGiant",
  humanoid: "A5E.CreatureHumanoid",
  monstrosity: "A5E.CreatureMonstrosity",
  ooze: "A5E.CreatureOoze",
  plant: "A5E.CreaturePlant",
  undead: "A5E.CreatureUndead"
};
Ie.damagedStates = {
  0: "A5E.damagedState.intact",
  1: "A5E.damagedState.damaged",
  2: "A5E.damagedState.broken"
};
Ie.baseScalingModes = {
  cantrip: "A5E.scaling.modes.cantrip",
  spellLevel: "A5E.scaling.modes.spellLevel",
  spellPoints: "A5E.scaling.modes.spellPoints",
  actionUses: "A5E.scaling.modes.actionUses",
  itemUses: "A5E.scaling.modes.itemUses"
};
Ie.targetScalingModes = {
  cantrip: "A5E.scaling.modes.cantrip",
  spellLevel: "A5E.scaling.modes.spellLevel",
  spellPoints: "A5E.scaling.modes.spellPoints",
  actionUses: "A5E.scaling.modes.actionUses",
  itemUses: "A5E.scaling.modes.itemUses"
};
Ie.damageTypes = {
  acid: "A5E.damageTypes.acid",
  bludgeoning: "A5E.damageTypes.bludgeoning",
  cold: "A5E.damageTypes.cold",
  fire: "A5E.damageTypes.fire",
  force: "A5E.damageTypes.force",
  lightning: "A5E.damageTypes.lightning",
  necrotic: "A5E.damageTypes.necrotic",
  piercing: "A5E.damageTypes.piercing",
  poison: "A5E.damageTypes.poison",
  psychic: "A5E.damageTypes.psychic",
  radiant: "A5E.damageTypes.radiant",
  slashing: "A5E.damageTypes.slashing",
  thunder: "A5E.damageTypes.thunder"
};
Ie.damageColors = {
  acid: "#a9b920",
  bludgeoning: "#b9a137",
  cold: "#99d9d9",
  fire: "#f18131",
  force: "#6f599a",
  lightning: "#f9d130",
  necrotic: "#7a7e88",
  piercing: "#c13129",
  poison: "#a140a1",
  psychic: "#f95889",
  radiant: "#dfa6df",
  slashing: "#b8b8d0",
  thunder: "#e2c269"
};
Ie.defaultActorImportCompendia = {
  inventory: "a5e.a5e-adventuring-gear",
  maneuvers: "a5e.a5e-maneuvers",
  spells: "a5e.a5e-spells"
};
Ie.equippedStates = {
  0: "A5E.equippedState.notCarried",
  1: "A5E.equippedState.carried",
  2: "A5E.equippedState.equipped"
};
Ie.expertiseDiceSidesMap = {
  0: 0,
  1: 4,
  2: 6,
  3: 8,
  4: 10,
  5: 12,
  6: 20
};
Ie.featureTypes = {
  background: "A5E.FeatureBackground",
  boon: "A5E.FeatureBoon",
  class: "A5E.FeatureClass",
  culture: "A5E.FeatureCulture",
  destiny: "A5E.FeatureDestiny",
  feat: "A5E.FeatureFeat",
  heritage: "A5E.FeatureHeritage",
  knack: "A5E.FeatureKnack",
  legendaryAction: "A5E.FeatureLegendaryAction",
  naturalWeapon: "A5E.FeatureNaturalWeapon",
  other: "A5E.FeatureOther"
};
Ie.healingTypes = {
  healing: "A5E.Healing",
  temporaryHealing: "A5E.HealingTemporary"
};
Ie.healingColors = {
  healing: "#eeee9b",
  temporaryHealing: "#2fa6b1"
};
Ie.itemRarity = {
  mundane: "A5E.itemRarities.mundane",
  common: "A5E.itemRarities.common",
  uncommon: "A5E.itemRarities.uncommon",
  rare: "A5E.itemRarities.rare",
  veryRare: "A5E.itemRarities.veryRare",
  legendary: "A5E.itemRarities.legendary",
  artifact: "A5E.itemRarities.artifact"
};
Ie.itemTypes = {
  background: "TYPES.Item.background",
  culture: "TYPES.Item.culture",
  destiny: "TYPES.Item.destiny",
  feature: "TYPES.Item.feature",
  maneuver: "TYPES.Item.maneuver",
  object: "TYPES.Item.object",
  spell: "TYPES.Item.spell"
};
Ie.inventoryFilters = {
  bulk: "Bulk"
};
Ie.knackTypes = {
  adept: "Practiced Technique",
  artificer: "Field Discovery",
  bard: "Adventuring Trick",
  berserker: "Developed Talent",
  cleric: "Sign of Faith",
  druid: "Secret of Nature",
  elementalist: "Elemental Adaptation",
  fighter: "Soldiering Knack",
  herald: "Divine Lesson",
  marshal: "Lesson of War",
  ranger: "Exploration Knack",
  rogue: "Skill Trick",
  savant: "Clever Scheme",
  sorcerer: "Arcane Innovation",
  warlock: "Secret of Arcana",
  wielder: "Artifact Whisper",
  witch: "Magical Mystery",
  wizard: "Elective Study"
};
Ie.languages = {
  abyssal: "A5E.languages.abyssal",
  aquan: "A5E.languages.aquan",
  auran: "A5E.languages.auran",
  boggard: "A5E.languages.boggard",
  celestial: "A5E.languages.celestial",
  common: "A5E.languages.common",
  deep: "A5E.languages.deepSpeech",
  draconic: "A5E.languages.draconic",
  druidic: "A5E.languages.druidic",
  dwarvish: "A5E.languages.dwarvish",
  elvish: "A5E.languages.elvish",
  giant: "A5E.languages.giant",
  gnoll: "A5E.languages.gnoll",
  gnomish: "A5E.languages.gnomish",
  goblin: "A5E.languages.goblin",
  grimlock: "A5E.languages.grimlock",
  grippli: "A5E.languages.grippli",
  halfling: "A5E.languages.halfling",
  ignan: "A5E.languages.ignan",
  infernal: "A5E.languages.infernal",
  minotaur: "A5E.languages.minotaur",
  mycelial: "A5E.languages.mycelial",
  orc: "A5E.languages.orc",
  primordial: "A5E.languages.primordial",
  sylvan: "A5E.languages.sylvan",
  terran: "A5E.languages.terran",
  cant: "A5E.languages.thievesCant",
  undercommon: "A5E.languages.undercommon"
};
Ie.maneuverDegrees = {
  0: "A5E.ManeuverBasic",
  1: "A5E.ManeuverDegree1",
  2: "A5E.ManeuverDegree2",
  3: "A5E.ManeuverDegree3",
  4: "A5E.ManeuverDegree4",
  5: "A5E.ManeuverDegree5"
};
Ie.maneuverTraditions = {
  adamantMountain: "A5E.maneuverTraditions.adamantMountain",
  arcaneArtillery: "A5E.maneuverTraditions.arcaneArtillery",
  arcaneKnight: "A5E.maneuverTraditions.arcaneKnight",
  awakenedMind: "A5E.maneuverTraditions.awakenedMind",
  beastUnity: "A5E.maneuverTraditions.beastUnity",
  bitingZephyr: "A5E.maneuverTraditions.bitingZephyr",
  comedicJabs: "A5E.maneuverTraditions.comedicJabs",
  cuttingOmen: "A5E.maneuverTraditions.cuttingOmen",
  eldritchBlackguard: "A5E.maneuverTraditions.eldritchBlackguard",
  gallantHeart: "A5E.maneuverTraditions.gallantHeart",
  grindingCog: "A5E.maneuverTraditions.grindingCog",
  mirrorsGlint: "A5E.maneuverTraditions.mirrorsGlint",
  mistAndShade: "A5E.maneuverTraditions.mistAndShade",
  rapidCurrent: "A5E.maneuverTraditions.rapidCurrent",
  razorsEdge: "A5E.maneuverTraditions.razorsEdge",
  sanctifiedSteel: "A5E.maneuverTraditions.sanctifiedSteel",
  sanguineKnot: "A5E.maneuverTraditions.sanguineKnot",
  selflessSentinel: "A5E.maneuverTraditions.selflessSentinel",
  spiritedSteed: "A5E.maneuverTraditions.spiritedSteed",
  temperedIron: "A5E.maneuverTraditions.temperedIron",
  toothAndClaw: "A5E.maneuverTraditions.toothAndClaw",
  unendingWheel: "A5E.maneuverTraditions.unendingWheel",
  vipersFangs: "A5E.maneuverTraditions.vipersFangs"
};
Ie.materialProperties = {
  comfortable: "A5E.MaterialPropertyComfortable",
  feybane: "A5E.MaterialPropertyFeybane",
  flaw: "A5E.MaterialPropertyFlaw",
  fortified: "A5E.MaterialPropertyFortified",
  hardy: "A5E.MaterialPropertyHardy",
  highQuality: "A5E.MaterialPropertyHighQuality",
  lightweight: "A5E.MaterialPropertyLightweight",
  lowMaintenance: "A5E.MaterialPropertyLowMaintenance",
  rust: "A5E.MaterialPropertyRust",
  silvered: "A5E.MaterialPropertySilvered",
  underarmor: "A5E.MaterialPropertyUnderarmor",
  weighty: "A5E.MaterialPropertyWeighty",
  wild: "A5E.MaterialPropertyWild"
};
Ie.flaws = {
  bludgeoning: "A5E.damageTypes.bludgeoning",
  piercing: "A5E.damageTypes.piercing",
  slashing: "A5E.damageTypes.slashing"
};
Ie.movement = {
  walk: "A5E.MovementWalkingSpeed",
  burrow: "A5E.MovementBurrowingSpeed",
  climb: "A5E.MovementClimbingSpeed",
  fly: "A5E.MovementFlyingSpeed",
  swim: "A5E.MovementSwimmingSpeed"
};
Ie.movementAbbreviations = {
  walk: "A5E.MovementWalkingSpeedAbbr",
  burrow: "A5E.MovementBurrowingSpeedAbbr",
  climb: "A5E.MovementClimbingSpeedAbbr",
  fly: "A5E.MovementFlyingSpeedAbbr",
  swim: "A5E.MovementSwimmingSpeedAbbr"
};
Ie.distanceUnits = {
  feet: "A5E.DistanceUnitFeet",
  miles: "A5E.DistanceUnitMiles",
  meters: "A5E.DistanceUnitMeters",
  kilometers: "A5E.DistanceUnitKilometers"
};
Ie.distanceAbbreviations = {
  feet: "A5E.DistanceFeetAbbr",
  miles: "A5E.DistanceMilesAbbr",
  meters: "A5E.DistanceMetersAbbr",
  kilometers: "A5E.DistanceKilometersAbbr"
};
Ie.visionUnits = {
  ...Ie.distanceUnits,
  unlimited: "A5E.RangeUnlimited"
};
Ie.objectTypes = {
  armor: "A5E.ObjectTypeArmor",
  ammunition: "A5E.ObjectTypeAmmunition",
  clothing: "A5E.ObjectTypeClothing",
  consumable: "A5E.ObjectTypeConsumable",
  container: "A5E.ObjectTypeContainer",
  helm: "A5E.ObjectTypeHelm",
  jewelry: "A5E.ObjectTypeJewelry",
  miscellaneous: "A5E.ObjectTypeMiscellaneous",
  shield: "A5E.ObjectTypeShield",
  tool: "A5E.ObjectTypeTool",
  weapon: "A5E.ObjectTypeWeapon"
};
Ie.objectTypesPlural = {
  armor: "A5E.ObjectTypeArmorPlural",
  ammunition: "A5E.ObjectTypeAmmunition",
  clothing: "A5E.ObjectTypeClothing",
  consumable: "A5E.ObjectTypeConsumablePlural",
  container: "A5E.ObjectTypeContainerPlural",
  helm: "A5E.ObjectTypeHelmPlural",
  jewelry: "A5E.ObjectTypeJewelry",
  miscellaneous: "A5E.ObjectTypeMiscellaneous",
  shield: "A5E.ObjectTypeShieldPlural",
  tool: "A5E.ObjectTypeToolPlural",
  weapon: "A5E.ObjectTypeWeaponPlural"
};
Ie.preparedStates = {
  0: "A5E.preparedState.unprepared",
  1: "A5E.preparedState.prepared",
  2: "A5E.preparedState.alwaysPrepared"
};
Ie.rangeDescriptors = {
  self: "A5E.RangeSelf",
  touch: "A5E.RangeTouch",
  fiveFeet: "A5E.RangeFiveFeet",
  short: "A5E.RangeShort",
  medium: "A5E.RangeMedium",
  long: "A5E.RangeLong",
  other: "A5E.RangeOther"
};
Ie.rangeValues = {
  self: "A5E.RangeSelf",
  touch: "A5E.RangeTouch",
  fiveFeet: 5,
  short: 30,
  medium: 60,
  long: 120
};
Ie.resourceRecoveryOptions = {
  shortRest: "A5E.RestShort",
  longRest: "A5E.RestLong",
  recharge: "A5E.ItemRecharge",
  round: "A5E.DurationRound",
  turn: "A5E.DurationTurn",
  minute: "A5E.DurationMinute",
  hour: "A5E.DurationHour",
  day: "A5E.DurationDay",
  week: "A5E.DurationWeek",
  month: "A5E.DurationMonth",
  year: "A5E.DurationYear"
};
Ie.rollModes = {
  normal: "A5E.RollModeNormal",
  advantage: "A5E.RollModeAdvantage",
  disadvantage: "A5E.RollModeDisadvantage"
};
Ie.rollTypes = {
  abilityCheck: "Ability Check",
  attack: "Attack",
  damage: "Damage",
  healing: "Healing",
  generic: "Generic",
  savingThrow: "Saving Throw",
  skillCheck: "Skill Check",
  toolCheck: "ToolCheck"
};
Ie.saveDCOptions = {
  spellcasting: "A5E.SpellDC",
  maneuver: "A5E.ManeuverDC",
  ...Ie.abilities,
  custom: "A5E.Custom"
};
Ie.senses = {
  blindsight: "A5E.SenseBlindsight",
  darkvision: "A5E.SenseDarkvision",
  tremorsense: "A5E.SenseTremorsense",
  truesight: "A5E.SenseTruesight"
};
Ie.scrollData = {
  0: {
    attackBonus: 5,
    cost: "10 gp",
    craftingComponent: "Magical inks",
    saveDC: 13,
    rarity: "common"
  },
  1: {
    attackBonus: 5,
    cost: "25 gp",
    craftingComponent: "Magical inks",
    saveDC: 13,
    rarity: "common"
  },
  2: {
    attackBonus: 5,
    cost: "75 gp",
    craftingComponent: "Magical inks",
    saveDC: 13,
    rarity: "common"
  },
  3: {
    attackBonus: 7,
    cost: "175 gp",
    craftingComponent: "Dire wolf hide",
    saveDC: 15,
    rarity: "uncommon"
  },
  4: {
    attackBonus: 7,
    cost: "500 gp",
    craftingComponent: "Dire wolf hide",
    saveDC: 15,
    rarity: "uncommon"
  },
  5: {
    attackBonus: 9,
    cost: "1250 gp",
    craftingComponent: "Parchment infused with planar energy",
    saveDC: 17,
    rarity: "rare"
  },
  6: {
    attackBonus: 9,
    cost: "3000 gp",
    craftingComponent: "Parchment infused with planar energy",
    saveDC: 17,
    rarity: "rare"
  },
  7: {
    attackBonus: 10,
    cost: "8000 gp",
    craftingComponent: "Blank pages from a lich's spellbook",
    saveDC: 18,
    rarity: "veryRare"
  },
  8: {
    attackBonus: 10,
    cost: "20000 gp",
    craftingComponent: "Blank pages from a lich's spellbook",
    saveDC: 18,
    rarity: "veryRare"
  },
  9: {
    attackBonus: 11,
    cost: "55000 gp",
    craftingComponent: "Parchment made from a dragon's hide",
    saveDC: 19,
    rarity: "legendary"
  }
};
Ie.shieldProperties = {
  handsFree: "A5E.shieldProperties.handsFree",
  mirrored: "A5E.shieldProperties.mirrored",
  spikes: "A5E.shieldProperties.spikes"
};
Ie.shieldTypes = {
  light: "A5E.ShieldTypeLight",
  medium: "A5E.ShieldTypeMedium",
  heavy: "A5E.ShieldTypeHeavy",
  tower: "A5E.ShieldTypeTower"
};
Ie.shieldBaseACBonus = {
  light: 1,
  medium: 2,
  heavy: 2,
  tower: 2
};
Ie.spellBookTypes = {
  innate: "A5E.spellBook.types.innate",
  prepared: "A5E.spellBook.types.prepared",
  pact: "A5E.spellBook.types.pact",
  points: "A5E.spellBook.types.points",
  ritual: "A5E.spellBook.types.ritual"
};
Ie.spellComponents = {
  vocalized: "A5E.SpellComponentVocalized",
  seen: "A5E.SpellComponentSeen",
  material: "A5E.SpellComponentMaterial"
};
Ie.spellComponentAbbreviations = {
  vocalized: "A5E.SpellComponentVocalizedAbbr",
  seen: "A5E.SpellComponentSeenAbbr",
  material: "A5E.SpellComponentMaterialAbbr"
};
Ie.spellLevels = {
  0: "A5E.SpellLevel0",
  1: "A5E.SpellLevel1",
  2: "A5E.SpellLevel2",
  3: "A5E.SpellLevel3",
  4: "A5E.SpellLevel4",
  5: "A5E.SpellLevel5",
  6: "A5E.SpellLevel6",
  7: "A5E.SpellLevel7",
  8: "A5E.SpellLevel8",
  9: "A5E.SpellLevel9"
};
Ie.spellLevelCost = {
  0: 0,
  1: 2,
  2: 3,
  3: 5,
  4: 6,
  5: 7,
  6: 9,
  7: 10,
  8: 11,
  9: 13
};
Ie.spellSchools = {
  primary: {
    abjuration: "A5E.SpellSchoolAbjuration",
    conjuration: "A5E.SpellSchoolConjuration",
    divination: "A5E.SpellSchoolDivination",
    enchantment: "A5E.SpellSchoolEnchantment",
    evocation: "A5E.SpellSchoolEvocation",
    illusion: "A5E.SpellSchoolIllusion",
    necromancy: "A5E.SpellSchoolNecromancy",
    transmutation: "A5E.SpellSchoolTransmutation"
  },
  secondary: {
    acid: "A5E.SpellSchoolAcid",
    affliction: "A5E.SpellSchoolAffliction",
    air: "A5E.SpellSchoolAir",
    arcane: "A5E.SpellSchoolArcane",
    architecture: "A5E.SpellSchoolArchitecture",
    attack: "A5E.SpellSchoolAttack",
    beasts: "A5E.SpellSchoolBeasts",
    chaos: "A5E.SpellSchoolChaos",
    cold: "A5E.SpellSchoolCold",
    communication: "A5E.SpellSchoolCommunication",
    compulsion: "A5E.SpellSchoolCompulsion",
    control: "A5E.SpellSchoolControl",
    displacement: "A5E.SpellSchoolDisplacement",
    divine: "A5E.SpellSchoolDivine",
    earth: "A5E.SpellSchoolEarth",
    enhancement: "A5E.SpellSchoolEnhancement",
    evil: "A5E.SpellSchoolEvil",
    fear: "A5E.SpellSchoolFear",
    fire: "A5E.SpellSchoolFire",
    force: "A5E.SpellSchoolForce",
    good: "A5E.SpellSchoolGood",
    healing: "A5E.SpellSchoolHealing",
    hearth: "A5E.SpellSchoolHearth",
    knowledge: "A5E.SpellSchoolKnowledge",
    law: "A5E.SpellSchoolLaw",
    lightning: "A5E.SpellSchoolLightning",
    movement: "A5E.SpellSchoolMovement",
    multiclass: "A5E.SpellSchoolMulticlass",
    nature: "A5E.SpellSchoolNature",
    necrotic: "A5E.SpellSchoolNecrotic",
    negation: "A5E.SpellSchoolNegation",
    obscurement: "A5E.SpellSchoolObscurement",
    planar: "A5E.SpellSchoolPlanar",
    plants: "A5E.SpellSchoolPlants",
    poison: "A5E.SpellSchoolPoison",
    prismatic: "A5E.SpellSchoolPrismatic",
    protection: "A5E.SpellSchoolProtection",
    psionic: "A5E.SpellSchoolPsionic",
    psychic: "A5E.SpellSchoolPsychic",
    radiant: "A5E.SpellSchoolRadiant",
    scrying: "A5E.SpellSchoolScrying",
    senses: "A5E.SpellSchoolSenses",
    shadow: "A5E.SpellSchoolShadow",
    shapechanging: "A5E.SpellSchoolShapechanging",
    sound: "A5E.SpellSchoolSound",
    storm: "A5E.SpellSchoolStorm",
    summoning: "A5E.SpellSchoolSummoning",
    technological: "A5E.SpellSchoolTechnological",
    telepathy: "A5E.SpellSchoolTelepathy",
    teleportation: "A5E.SpellSchoolTeleportation",
    terrain: "A5E.SpellSchoolTerrain",
    thunder: "A5E.SpellSchoolThunder",
    time: "A5E.SpellSchoolTime",
    transformation: "A5E.SpellSchoolTransformation",
    unarmed: "A5E.SpellSchoolUnarmed",
    undead: "A5E.SpellSchoolUndead",
    utility: "A5E.SpellSchoolUtility",
    water: "A5E.SpellSchoolWater",
    weaponry: "A5E.SpellSchoolWeaponry",
    weather: "A5E.SpellSchoolWeather"
  }
};
Ie.skills = {
  acr: "A5E.skills.acrobatics",
  ani: "A5E.skills.animalHandling",
  arc: "A5E.skills.arcana",
  ath: "A5E.skills.athletics",
  cul: "A5E.skills.culture",
  dec: "A5E.skills.deception",
  eng: "A5E.skills.engineering",
  his: "A5E.skills.history",
  ins: "A5E.skills.insight",
  itm: "A5E.skills.intimidation",
  inv: "A5E.skills.investigation",
  med: "A5E.skills.medicine",
  nat: "A5E.skills.nature",
  prc: "A5E.skills.perception",
  prf: "A5E.skills.performance",
  per: "A5E.skills.persuasion",
  rel: "A5E.skills.religion",
  slt: "A5E.skills.sleightOfHand",
  ste: "A5E.skills.stealth",
  sur: "A5E.skills.survival"
};
Ie.skillCriticalTables = {
  acr: "Compendium.a5e.a5e-roll-tables.RollTable.8q8hhm2qxxpzqety",
  ani: "Compendium.a5e.a5e-roll-tables.RollTable.vmf9w8gtsdi2h45n",
  arc: "Compendium.a5e.a5e-roll-tables.RollTable.27u8uhi0v7x4dxwz",
  ath: "Compendium.a5e.a5e-roll-tables.RollTable.8q8hhm2qxxpzqety",
  cul: "Compendium.a5e.a5e-roll-tables.RollTable.27u8uhi0v7x4dxwz",
  dec: "Compendium.a5e.a5e-roll-tables.RollTable.vmf9w8gtsdi2h45n",
  eng: "Compendium.a5e.a5e-roll-tables.RollTable.27u8uhi0v7x4dxwz",
  his: "Compendium.a5e.a5e-roll-tables.RollTable.27u8uhi0v7x4dxwz",
  ins: "Compendium.a5e.a5e-roll-tables.RollTable.vmf9w8gtsdi2h45n",
  itm: "Compendium.a5e.a5e-roll-tables.RollTable.vmf9w8gtsdi2h45n",
  inv: "Compendium.a5e.a5e-roll-tables.RollTable.27u8uhi0v7x4dxwz",
  med: "Compendium.a5e.a5e-roll-tables.RollTable.66wtmckaxsjl2cay",
  nat: "Compendium.a5e.a5e-roll-tables.RollTable.27u8uhi0v7x4dxwz",
  prc: "Compendium.a5e.a5e-roll-tables.RollTable.27u8uhi0v7x4dxwz",
  prf: "Compendium.a5e.a5e-roll-tables.RollTable.vmf9w8gtsdi2h45n",
  per: "Compendium.a5e.a5e-roll-tables.RollTable.vmf9w8gtsdi2h45n",
  rel: "Compendium.a5e.a5e-roll-tables.RollTable.27u8uhi0v7x4dxwz",
  slt: "Compendium.a5e.a5e-roll-tables.RollTable.8q8hhm2qxxpzqety",
  ste: "Compendium.a5e.a5e-roll-tables.RollTable.8q8hhm2qxxpzqety",
  sur: "Compendium.a5e.a5e-roll-tables.RollTable.27u8uhi0v7x4dxwz"
};
Ie.skillFumbleTables = {
  acr: "Compendium.a5e.a5e-roll-tables.RollTable.sckaut8fmaq8l120",
  ani: "Compendium.a5e.a5e-roll-tables.RollTable.3m0vyh75nnlj42ja",
  arc: "Compendium.a5e.a5e-roll-tables.RollTable.jbjp515vtjmolbng",
  ath: "Compendium.a5e.a5e-roll-tables.RollTable.sckaut8fmaq8l120",
  cul: "Compendium.a5e.a5e-roll-tables.RollTable.jbjp515vtjmolbng",
  dec: "Compendium.a5e.a5e-roll-tables.RollTable.3m0vyh75nnlj42ja",
  eng: "Compendium.a5e.a5e-roll-tables.RollTable.jbjp515vtjmolbng",
  his: "Compendium.a5e.a5e-roll-tables.RollTable.jbjp515vtjmolbng",
  ins: "Compendium.a5e.a5e-roll-tables.RollTable.3m0vyh75nnlj42ja",
  itm: "Compendium.a5e.a5e-roll-tables.RollTable.3m0vyh75nnlj42ja",
  inv: "Compendium.a5e.a5e-roll-tables.RollTable.jbjp515vtjmolbng",
  med: "Compendium.a5e.a5e-roll-tables.RollTable.ihsspmdmmpj8cyk8",
  nat: "Compendium.a5e.a5e-roll-tables.RollTable.jbjp515vtjmolbng",
  prc: "Compendium.a5e.a5e-roll-tables.RollTable.jbjp515vtjmolbng",
  prf: "Compendium.a5e.a5e-roll-tables.RollTable.3m0vyh75nnlj42ja",
  per: "Compendium.a5e.a5e-roll-tables.RollTable.3m0vyh75nnlj42ja",
  rel: "Compendium.a5e.a5e-roll-tables.RollTable.jbjp515vtjmolbng",
  slt: "Compendium.a5e.a5e-roll-tables.RollTable.sckaut8fmaq8l120",
  ste: "Compendium.a5e.a5e-roll-tables.RollTable.sckaut8fmaq8l120",
  sur: "Compendium.a5e.a5e-roll-tables.RollTable.jbjp515vtjmolbng"
};
Ie.skillDefaultAbilities = {
  acr: "dex",
  ani: "wis",
  arc: "int",
  ath: "str",
  cul: "int",
  dec: "cha",
  eng: "int",
  his: "int",
  ins: "wis",
  itm: "cha",
  inv: "int",
  med: "wis",
  nat: "int",
  prc: "wis",
  prf: "cha",
  per: "cha",
  rel: "int",
  slt: "dex",
  ste: "dex",
  sur: "wis"
};
Ie.skillSpecialties = {
  acr: {
    balancing: "A5E.skillSpecialties.balancing",
    escapeArtistry: "A5E.skillSpecialties.escapeArtistry",
    swinging: "A5E.skillSpecialties.swinging",
    tumbling: "A5E.skillSpecialties.tumbling"
  },
  ani: {
    calming: "A5E.skillSpecialties.calming",
    driving: "A5E.skillSpecialties.driving",
    farming: "A5E.skillSpecialties.farming",
    riding: "A5E.skillSpecialties.riding",
    training: "A5E.skillSpecialties.training"
  },
  arc: {
    aberrations: "A5E.skillSpecialties.aberrations",
    artifacts: "A5E.skillSpecialties.artifacts",
    constructs: "A5E.skillSpecialties.constructs",
    detection: "A5E.skillSpecialties.detection",
    dragons: "A5E.skillSpecialties.dragons",
    elementals: "A5E.skillSpecialties.elementals",
    fey: "A5E.skillSpecialties.fey",
    forbiddenKnowledge: "A5E.skillSpecialties.forbiddenKnowledge",
    monstrosities: "A5E.skillSpecialties.monstrosities",
    oozes: "A5E.skillSpecialties.oozes",
    thePlanes: "A5E.skillSpecialties.thePlanes"
  },
  ath: {
    climbing: "A5E.skillSpecialties.climbing",
    jumping: "A5E.skillSpecialties.jumping",
    lifting: "A5E.skillSpecialties.lifting",
    martialArts: "A5E.skillSpecialties.martialArts",
    running: "A5E.skillSpecialties.running",
    swimming: "A5E.skillSpecialties.swimming",
    throwing: "A5E.skillSpecialties.throwing"
  },
  cul: {
    courtlyManners: "A5E.skillSpecialties.courtlyManners",
    cuisine: "A5E.skillSpecialties.cuisine",
    etiquette: "A5E.skillSpecialties.etiquette",
    fencingProtocol: "A5E.skillSpecialties.fencingProtocol",
    laws: "A5E.skillSpecialties.laws",
    linguistics: "A5E.skillSpecialties.linguistics",
    regionalGoods: "A5E.skillSpecialties.regionalGoods",
    streetwise: "A5E.skillSpecialties.streetwise",
    trade: "A5E.skillSpecialties.trade"
  },
  dec: {
    boasting: "A5E.skillSpecialties.boasting",
    ciphers: "A5E.skillSpecialties.ciphers",
    concealingEmotions: "A5E.skillSpecialties.concealingEmotions",
    liesOfOmission: "A5E.skillSpecialties.liesOfOmission",
    mimicry: "A5E.skillSpecialties.mimicry"
  },
  eng: {
    architecture: "A5E.skillSpecialties.architecture",
    chemistry: "A5E.skillSpecialties.chemistry",
    explosives: "A5E.skillSpecialties.explosives",
    gadgetry: "A5E.skillSpecialties.gadgetry",
    mathematics: "A5E.skillSpecialties.mathematics",
    mechanicalTraps: "A5E.skillSpecialties.mechanicalTraps",
    plumbing: "A5E.skillSpecialties.plumbing",
    siegecraft: "A5E.skillSpecialties.siegecraft"
  },
  his: {
    arts: "A5E.skillSpecialties.arts",
    empires: "A5E.skillSpecialties.empires",
    genealogy: "A5E.skillSpecialties.genealogy",
    legends: "A5E.skillSpecialties.legends",
    wars: "A5E.skillSpecialties.wars"
  },
  ins: {
    detectingLies: "A5E.skillSpecialties.detectingLies",
    readingEmotions: "A5E.skillSpecialties.readingEmotions",
    sensingMotives: "A5E.skillSpecialties.sensingMotives"
  },
  itm: {
    authority: "A5E.skillSpecialties.authority",
    ferocity: "A5E.skillSpecialties.ferocity",
    interrogation: "A5E.skillSpecialties.interrogation",
    subtleThreats: "A5E.skillSpecialties.subtleThreats",
    weaponDisplays: "A5E.skillSpecialties.weaponDisplays"
  },
  inv: {
    appraisal: "A5E.skillSpecialties.appraisal",
    deciphering: "A5E.skillSpecialties.deciphering",
    forensics: "A5E.skillSpecialties.forensics",
    gatheringRumors: "A5E.skillSpecialties.gatheringRumors",
    research: "A5E.skillSpecialties.research",
    trapfinding: "A5E.skillSpecialties.trapfinding"
  },
  med: {
    animals: "A5E.skillSpecialties.animals",
    autopsy: "A5E.skillSpecialties.autopsy",
    diseases: "A5E.skillSpecialties.diseases",
    drugs: "A5E.skillSpecialties.drugs",
    herbalism: "A5E.skillSpecialties.herbalism",
    mentalHealth: "A5E.skillSpecialties.mentalHealth",
    poisons: "A5E.skillSpecialties.poisons"
  },
  nat: {
    astronomy: "A5E.skillSpecialties.astronomy",
    beastLore: "A5E.skillSpecialties.beastLore",
    farming: "A5E.skillSpecialties.farming",
    fey: "A5E.skillSpecialties.fey",
    plantLore: "A5E.skillSpecialties.plantLore",
    weather: "A5E.skillSpecialties.weather"
  },
  prc: {
    farsight: "A5E.skillSpecialties.farsight",
    invisibleObjects: "A5E.skillSpecialties.invisibleObjects",
    listening: "A5E.skillSpecialties.listening",
    scent: "A5E.skillSpecialties.scent"
  },
  prf: {
    acting: "A5E.skillSpecialties.acting",
    composing: "A5E.skillSpecialties.composing",
    dancing: "A5E.skillSpecialties.dancing",
    fineArt: "A5E.skillSpecialties.fineArt",
    singing: "A5E.skillSpecialties.singing",
    speaking: "A5E.skillSpecialties.speaking",
    writing: "A5E.skillSpecialties.writing"
  },
  per: {
    bribery: "A5E.skillSpecialties.bribery",
    flattery: "A5E.skillSpecialties.flattery",
    leadership: "A5E.skillSpecialties.leadership",
    negotiation: "A5E.skillSpecialties.negotiation",
    peacemaking: "A5E.skillSpecialties.peacemaking"
  },
  rel: {
    alignment: "A5E.skillSpecialties.alignment",
    celestials: "A5E.skillSpecialties.celestials",
    cults: "A5E.skillSpecialties.cults",
    fiends: "A5E.skillSpecialties.fiends",
    gods: "A5E.skillSpecialties.gods",
    holySymbols: "A5E.skillSpecialties.holySymbols",
    morality: "A5E.skillSpecialties.morality",
    prophecy: "A5E.skillSpecialties.prophecy",
    relics: "A5E.skillSpecialties.relics",
    undead: "A5E.skillSpecialties.undead"
  },
  slt: {
    distraction: "A5E.skillSpecialties.distraction",
    legerdemain: "A5E.skillSpecialties.legerdemain",
    pickpocketing: "A5E.skillSpecialties.pickpocketing"
  },
  ste: {
    anonymity: "A5E.skillSpecialties.anonymity",
    camouflage: "A5E.skillSpecialties.camouflage",
    casing: "A5E.skillSpecialties.casing"
  },
  sur: {
    dungeoneering: "A5E.skillSpecialties.dungeoneering",
    foraging: "A5E.skillSpecialties.foraging",
    hunting: "A5E.skillSpecialties.hunting",
    tracking: "A5E.skillSpecialties.tracking",
    wayfinding: "A5E.skillSpecialties.wayfinding"
  }
};
Ie.targetTypes = {
  self: "A5E.TargetSelf",
  creature: "A5E.TargetCreature",
  object: "A5E.TargetObject",
  creatureObject: "A5E.TargetCreatureObject",
  other: "A5E.TargetOther"
};
Ie.targetTypesPlural = {
  self: "A5E.TargetSelf",
  creature: "A5E.TargetCreaturePlural",
  object: "A5E.TargetObjectPlural",
  creatureObject: "A5E.TargetCreatureObjectPlural",
  other: "A5E.TargetOther"
};
Ie.terrainTypes = {
  abyss: "A5E.terrainTypes.abyss",
  astralPlane: "A5E.terrainTypes.astralPlane",
  caverns: "A5E.terrainTypes.caverns",
  desert: "A5E.terrainTypes.desert",
  etherealPlane: "A5E.terrainTypes.etherealPlane",
  forest: "A5E.terrainTypes.forest",
  grassland: "A5E.terrainTypes.grassland",
  hell: "A5E.terrainTypes.hell",
  hills: "A5E.terrainTypes.hills",
  jungle: "A5E.terrainTypes.jungle",
  laboratory: "A5E.terrainTypes.laboratory",
  mountains: "A5E.terrainTypes.mountains",
  planeOfAir: "A5E.terrainTypes.planeOfAir",
  planeOfEarth: "A5E.terrainTypes.planeOfEarth",
  planeOfFire: "A5E.terrainTypes.planeOfFire",
  planeOfWater: "A5E.terrainTypes.planeOfWater",
  ruin: "A5E.terrainTypes.ruin",
  settlement: "A5E.terrainTypes.settlement",
  sewer: "A5E.terrainTypes.sewer",
  swamp: "A5E.terrainTypes.swamp",
  temple: "A5E.terrainTypes.temple",
  theBleakGate: "A5E.terrainTypes.theBleakGate",
  theDreaming: "A5E.terrainTypes.theDreaming",
  tomb: "A5E.terrainTypes.tomb",
  tundra: "A5E.terrainTypes.tundra",
  underland: "A5E.terrainTypes.underland",
  water: "A5E.terrainTypes.water"
};
Ie.timePeriods = {
  instantaneous: "A5E.DurationInstantaneous",
  round: "A5E.DurationRound",
  turn: "A5E.DurationTurn",
  second: "A5E.DurationSecond",
  minute: "A5E.DurationMinute",
  hour: "A5E.DurationHour",
  day: "A5E.DurationDay",
  week: "A5E.DurationWeek",
  month: "A5E.DurationMonth",
  year: "A5E.DurationYear",
  permanent: "A5E.DurationPermanent",
  special: "A5E.DurationSpecial"
};
Ie.timePeriodsPlural = {
  instantaneous: "A5E.DurationInstantaneous",
  round: "A5E.DurationRoundPlural",
  turn: "A5E.DurationTurnPlural",
  second: "A5E.DurationSecondPlural",
  minute: "A5E.DurationMinutePlural",
  hour: "A5E.DurationHourPlural",
  day: "A5E.DurationDayPlural",
  week: "A5E.DurationWeekPlural",
  month: "A5E.DurationMonthPlural",
  year: "A5E.DurationYearPlural",
  permanent: "A5E.DurationPermanent",
  special: "A5E.DurationSpecial"
};
Ie.tokenDimensions = {
  tiny: 0.5,
  sm: 1,
  med: 1,
  lg: 2,
  huge: 3,
  grg: 4,
  titan: 5
};
Ie.tokenHPColors = {
  damage: 16711680,
  healing: 65280,
  temp: 6737151
};
Ie.toolCategories = {
  artisansTools: "A5E.ToolsArtisanTools",
  gamingSets: "A5E.ToolsGamingSets",
  musicalInstruments: "A5E.MusicalInstruments",
  miscellaneous: "A5E.ToolsMiscellaneous",
  vehicles: "A5E.ToolsVehicles",
  other: "A5E.ToolsOther"
};
Ie.tools = {
  artisansTools: {
    alchemistsSupplies: "A5E.ToolAlchemistsSupplies",
    bookbindersKit: "A5E.ToolBookbindersKit",
    brewersSupplies: "A5E.ToolBrewersSupplies",
    calligraphersSupplies: "A5E.ToolCalligraphersSupplies",
    carpentersTools: "A5E.ToolCarpentersTools",
    cartographersTools: "A5E.ToolCartographersTools",
    cobblersTools: "A5E.ToolCobblersTools",
    cooksUtensils: "A5E.ToolCooksUtensils",
    glassblowersTools: "A5E.ToolGlassblowersTools",
    jewelersTools: "A5E.ToolJewelersTools",
    leatherworkersTools: "A5E.ToolLeatherworkersTools",
    masonsTools: "A5E.ToolMasonsTools",
    paintersSupplies: "A5E.ToolPaintersSupplies",
    pottersTools: "A5E.ToolPottersTools",
    tinkersTools: "A5E.ToolTinkersTools",
    weaversTools: "A5E.ToolWeaversTools",
    woodcarversTools: "A5E.ToolWoodcarversTools"
  },
  gamingSets: {
    diceSet: "A5E.ToolDiceSet",
    boardGameSet: "A5E.ToolBoardGameSet",
    playingCardSet: "A5E.ToolPlayingCardSet"
  },
  musicalInstruments: {
    bagpipes: "A5E.InstrumentBagpipes",
    casaba: "A5E.InstrumentCasaba",
    castanet: "A5E.InstrumentCastanet",
    drum: "A5E.InstrumentDrum",
    dulcimer: "A5E.InstrumentDulcimer",
    flute: "A5E.InstrumentFlute",
    harp: "A5E.InstrumentHarp",
    horn: "A5E.InstrumentHorn",
    lute: "A5E.InstrumentLute",
    lyre: "A5E.InstrumentLyre",
    maraca: "A5E.InstrumentMaraca",
    ocarina: "A5E.InstrumentOcarina",
    panFlute: "A5E.InstrumentPanFlute",
    trombone: "A5E.InstrumentTrombone",
    violin: "A5E.InstrumentViolin"
  },
  miscellaneous: {
    disguiseKit: "A5E.ToolDisguiseKit",
    forgeryKit: "A5E.ToolForgeryKit",
    herbalismKit: "A5E.ToolHerbalismKit",
    navigatorsTools: "A5E.ToolNavigatorsTools",
    poisonersKit: "A5E.ToolPoisonersKit",
    sewingKit: "A5E.ToolSewingKit",
    smithsTools: "A5E.ToolSmithsTools",
    thievesTools: "A5E.ToolThievesTools"
  },
  vehicles: {
    landVehicles: "A5E.VehicleLand",
    waterVehicles: "A5E.VehicleWater",
    airVehicles: "A5E.VehicleAir"
  }
};
Ie.toolsPlural = {
  artisansTools: {
    alchemistsSupplies: "A5E.ToolAlchemistsSupplies",
    bookbindersKit: "A5E.ToolBookbindersKitPlural",
    brewersSupplies: "A5E.ToolBrewersSupplies",
    calligraphersSupplies: "A5E.ToolCalligraphersSupplies",
    carpentersTools: "A5E.ToolCarpentersTools",
    cartographersTools: "A5E.ToolCartographersTools",
    cobblersTools: "A5E.ToolCobblersTools",
    cooksUtensils: "A5E.ToolCooksUtensils",
    glassblowersTools: "A5E.ToolGlassblowersTools",
    jewelersTools: "A5E.ToolJewelersTools",
    leatherworkersTools: "A5E.ToolLeatherworkersTools",
    masonsTools: "A5E.ToolMasonsTools",
    paintersSupplies: "A5E.ToolPaintersSupplies",
    pottersTools: "A5E.ToolPottersTools",
    tinkersTools: "A5E.ToolTinkersTools",
    weaversTools: "A5E.ToolWeaversTools",
    woodcarversTools: "A5E.ToolWoodcarversTools"
  },
  gamingSets: {
    diceSet: "A5E.ToolDiceSetPlural",
    boardGameSet: "A5E.ToolBoardGameSetPlural",
    playingCardSet: "A5E.ToolPlayingCardSetPlural"
  },
  musicalInstruments: {
    bagpipes: "A5E.InstrumentBagpipesPlural",
    casaba: "A5E.InstrumentCasabaPlural",
    castanet: "A5E.InstrumentCastanetPlural",
    drum: "A5E.InstrumentDrumPlural",
    dulcimer: "A5E.InstrumentDulcimerPlural",
    flute: "A5E.InstrumentFlutePlural",
    harp: "A5E.InstrumentHarpPlural",
    horn: "A5E.InstrumentHornPlural",
    lute: "A5E.InstrumentLutePlural",
    lyre: "A5E.InstrumentLyrePlural",
    maraca: "A5E.InstrumentMaracaPlural",
    ocarina: "A5E.InstrumentOcarinaPlural",
    panFlute: "A5E.InstrumentPanFlutePlural",
    trombone: "A5E.InstrumentTrombonePlural",
    violin: "A5E.InstrumentViolinPlural"
  },
  miscellaneous: {
    disguiseKit: "A5E.ToolDisguiseKitPlural",
    forgeryKit: "A5E.ToolForgeryKitPlural",
    herbalismKit: "A5E.ToolHerbalismKitPlural",
    navigatorsTools: "A5E.ToolNavigatorsToolsPlural",
    poisonersKit: "A5E.ToolPoisonersKitPlural",
    sewingKit: "A5E.ToolSewingKitPlural",
    smithsTools: "A5E.ToolSmithsToolsPlural",
    thievesTools: "A5E.ToolThievesToolsPlural"
  },
  vehicles: {
    landVehicles: "A5E.VehicleLandPlural",
    waterVehicles: "A5E.VehicleWaterPlural",
    airVehicles: "A5E.VehicleAirPlural"
  }
};
Ie.weaponCategories = {
  simple: "A5E.WeaponsSimple",
  martial: "A5E.WeaponsMartial",
  rare: "A5E.WeaponsRare",
  other: "A5E.WeaponsOther"
};
Ie.weapons = {
  simple: {
    blowgun: "A5E.WeaponBlowgun",
    club: "A5E.WeaponClub",
    dagger: "A5E.WeaponDagger",
    handaxe: "A5E.WeaponHandaxe",
    heavyCrossbow: "A5E.WeaponHeavyCrossbow",
    greatclub: "A5E.WeaponGreatclub",
    lightCrossbow: "A5E.WeaponLightCrossbow",
    mace: "A5E.WeaponMace",
    quarterstaff: "A5E.WeaponQuarterstaff",
    sickle: "A5E.WeaponSickle",
    sling: "A5E.WeaponSling",
    spear: "A5E.WeaponSpear"
  },
  martial: {
    bastardSword: "A5E.WeaponBastardSword",
    battleaxe: "A5E.WeaponBattleaxe",
    brassKnuckles: "A5E.WeaponBrassKnuckles",
    compositeBow: "A5E.WeaponCompositeBow",
    dart: "A5E.WeaponDart",
    duelingDagger: "A5E.WeaponDuelingDagger",
    flail: "A5E.WeaponFlail",
    garotte: "A5E.WeaponGarotte",
    glaive: "A5E.WeaponGlaive",
    greataxe: "A5E.WeaponGreataxe",
    greatsword: "A5E.WeaponGreatsword",
    halberd: "A5E.WeaponHalberd",
    handCrossbow: "A5E.WeaponHandCrossbow",
    javelin: "A5E.WeaponJavelin",
    lance: "A5E.WeaponLance",
    lightHammer: "A5E.WeaponLightHammer",
    longbow: "A5E.WeaponLongbow",
    longsword: "A5E.WeaponLongsword",
    maul: "A5E.WeaponMaul",
    morningstar: "A5E.WeaponMorningstar",
    net: "A5E.WeaponNet",
    pike: "A5E.WeaponPike",
    punchingDagger: "A5E.WeaponPunchingDagger",
    rapier: "A5E.WeaponRapier",
    saber: "A5E.WeaponSaber",
    scimitar: "A5E.WeaponScimitar",
    scythe: "A5E.WeaponScythe",
    shortbow: "A5E.WeaponShortbow",
    shortsword: "A5E.WeaponShortsword",
    spearThrower: "A5E.WeaponSpearThrower",
    throwingDagger: "A5E.WeaponThrowingDagger",
    trident: "A5E.WeaponTrident",
    warhammer: "A5E.WeaponWarhammer",
    warPick: "A5E.WeaponWarPick",
    whip: "A5E.WeaponWhip"
  },
  rare: {
    assassinsGauntlet: "A5E.WeaponAssassinsGauntlet",
    bootDagger: "A5E.WeaponBootDagger",
    carbine: "A5E.WeaponCarbine",
    doubleWeapon: "A5E.WeaponDoubleWeapon",
    gearedSlingshot: "A5E.WeaponGearedSlingshot",
    mercurialMaul: "A5E.WeaponMercurialMaul",
    musket: "A5E.WeaponMusket",
    pistol: "A5E.WeaponPistol",
    ratchetingCrossbow: "A5E.WeaponRatchetingCrossbow",
    revolver: "A5E.WeaponRevolver",
    ringBlade: "A5E.WeaponRingBlade",
    shotgun: "A5E.WeaponShotgun",
    spikedChain: "A5E.WeaponSpikedChain",
    swordPistol: "A5E.WeaponSwordPistol"
  }
};
Ie.weaponsPlural = {
  simple: {
    blowgun: "A5E.WeaponBlowgunPlural",
    club: "A5E.WeaponClubPlural",
    dagger: "A5E.WeaponDaggerPlural",
    handaxe: "A5E.WeaponHandaxePlural",
    heavyCrossbow: "A5E.WeaponHeavyCrossbowPlural",
    greatclub: "A5E.WeaponGreatclubPlural",
    lightCrossbow: "A5E.WeaponLightCrossbowPlural",
    mace: "A5E.WeaponMacePlural",
    quarterstaff: "A5E.WeaponQuarterstaffPlural",
    sickle: "A5E.WeaponSicklePlural",
    sling: "A5E.WeaponSlingPlural",
    spear: "A5E.WeaponSpearPlural"
  },
  martial: {
    bastardSword: "A5E.WeaponBastardSwordPlural",
    battleaxe: "A5E.WeaponBattleaxePlural",
    brassKnuckles: "A5E.WeaponBrassKnucklesPlural",
    compositeBow: "A5E.WeaponCompositeBowPlural",
    dart: "A5E.WeaponDartPlural",
    duelingDagger: "A5E.WeaponDuelingDaggerPlural",
    flail: "A5E.WeaponFlailPlural",
    garotte: "A5E.WeaponGarottePlural",
    glaive: "A5E.WeaponGlaivePlural",
    greataxe: "A5E.WeaponGreataxePlural",
    greatsword: "A5E.WeaponGreatswordPlural",
    halberd: "A5E.WeaponHalberdPlural",
    handCrossbow: "A5E.WeaponHandCrossbowPlural",
    javelin: "A5E.WeaponJavelinPlural",
    lance: "A5E.WeaponLancePlural",
    lightHammer: "A5E.WeaponLightHammerPlural",
    longbow: "A5E.WeaponLongbowPlural",
    longsword: "A5E.WeaponLongswordPlural",
    maul: "A5E.WeaponMaulPlural",
    morningstar: "A5E.WeaponMorningstarPlural",
    net: "A5E.WeaponNetPlural",
    pike: "A5E.WeaponPikePlural",
    punchingDagger: "A5E.WeaponPunchingDaggerPlural",
    rapier: "A5E.WeaponRapierPlural",
    saber: "A5E.WeaponSaberPlural",
    scimitar: "A5E.WeaponScimitarPlural",
    scythe: "A5E.WeaponScythePlural",
    shortbow: "A5E.WeaponShortbowPlural",
    shortsword: "A5E.WeaponShortswordPlural",
    spearThrower: "A5E.WeaponSpearThrowerPlural",
    throwingDagger: "A5E.WeaponThrowingDaggerPlural",
    trident: "A5E.WeaponTridentPlural",
    warhammer: "A5E.WeaponWarhammerPlural",
    warPick: "A5E.WeaponWarPickPlural",
    whip: "A5E.WeaponWhipPlural"
  },
  rare: {
    assassinsGauntlet: "A5E.WeaponAssassinsGauntletPlural",
    bootDagger: "A5E.WeaponBootDaggerPlural",
    carbine: "A5E.WeaponCarbinePlural",
    doubleWeapon: "A5E.WeaponDoubleWeaponPlural",
    gearedSlingshot: "A5E.WeaponGearedSlingshotPlural",
    mercurialMaul: "A5E.WeaponMercurialMaulPlural",
    musket: "A5E.WeaponMusketPlural",
    pistol: "A5E.WeaponPistolPlural",
    ratchetingCrossbow: "A5E.WeaponRatchetingCrossbowPlural",
    revolver: "A5E.WeaponRevolverPlural",
    ringBlade: "A5E.WeaponRingBladePlural",
    shotgun: "A5E.WeaponShotgunPlural",
    spikedChain: "A5E.WeaponSpikedChainPlural",
    swordPistol: "A5E.WeaponSwordPistolPlural"
  }
};
Ie.weaponProperties = {
  burn: "A5E.weaponProperties.burn",
  breaker: "A5E.weaponProperties.breaker",
  compounding: "A5E.weaponProperties.compounding",
  defensive: "A5E.weaponProperties.defensive",
  dualWielding: "A5E.weaponProperties.dualWielding",
  finesse: "A5E.weaponProperties.finesse",
  flamboyant: "A5E.weaponProperties.flamboyant",
  handMounted: "A5E.weaponProperties.handMounted",
  heavy: "A5E.weaponProperties.heavy",
  inaccurate: "A5E.weaponProperties.inaccurate",
  loading: "A5E.weaponProperties.loading",
  mounted: "A5E.weaponProperties.mounted",
  muzzleLoading: "A5E.weaponProperties.muzzleLoading",
  parrying: "A5E.weaponProperties.parrying",
  parryingImmunity: "A5E.weaponProperties.parryingImmunity",
  quickdraw: "A5E.weaponProperties.quickdraw",
  range: "A5E.weaponProperties.range",
  rebounding: "A5E.objectProperties.rebounding",
  reach: "A5E.weaponProperties.reach",
  rifled: "A5E.weaponProperties.rifled",
  scatter: "A5E.weaponProperties.scatter",
  shock: "A5E.weaponProperties.shock",
  simple: "A5E.weaponProperties.simple",
  stealthy: "A5E.objectProperties.stealthy",
  storage: "A5E.objectProperties.storage",
  thrown: "A5E.weaponProperties.thrown",
  triggerCharge: "A5E.weaponProperties.triggerCharge",
  trip: "A5E.weaponProperties.trip",
  twoHanded: "A5E.weaponProperties.twoHanded",
  versatile: "A5E.weaponProperties.versatile",
  vicious: "A5E.weaponProperties.vicious"
};
Ie.breakerProperties = {
  wood: "Wood",
  stone: "Stone"
};
Ie.defensiveProperties = {
  light: "Light",
  medium: "Medium",
  heavy: "Heavy"
};
Ie.versatileOptions = {
  d6: "d6",
  d8: "d8",
  d10: "d10",
  d12: "d12"
};
Qte(Ie);
use(Ie);
MH(Ie);
nse(Ie);
OH(Ie);
DH(Ie);
IH(Ie);
PH(Ie);
sse(Ie);
xte(Ie);
ese(Ie);
tse(Ie);
ise(Ie);
rse(Ie);
ose(Ie);
ase(Ie);
cse(Ie);
lse(Ie);
const ES = class ES extends C_ {
  constructor() {
    super("a5e");
    Ge(this, "settingsData");
    this.settingsData = null;
  }
  init() {
    const t = "a5e", s = { client: "client", world: "world" }, n = [
      // Actor Settings
      {
        namespace: t,
        key: "automatePrototypeTokenSize",
        options: {
          name: "A5E.settings.automatePrototypeTokenSize",
          hint: "A5E.settings.hints.automatePrototypeTokenSize",
          scope: "world",
          config: !0,
          default: !0,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "blindDeathSaves",
        options: {
          name: "A5E.settings.blindDeathSaves",
          hint: "A5E.settings.hints.blindDeathSaves",
          scope: "world",
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "collapseActionList",
        options: {
          name: "A5E.settings.collapseActionList",
          hint: "A5E.settings.hints.collapseActionList",
          scope: s.client,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "conditionFlowDirection",
        options: {
          name: "Condition Interface Flow Direction",
          hint: "Setting this option to 'Row' causes the conditions to flow alphabetically left to right, row by row. Setting this option 'Column' causes the conditions to flow alphabetically top to bottom, column by column.",
          scope: s.client,
          config: !0,
          default: "column",
          choices: {
            row: "Row",
            column: "Column"
          },
          type: String
        }
      },
      {
        namespace: t,
        key: "currencyWeight",
        options: {
          name: "A5E.settings.trackCurrencyWeight",
          hint: "A5E.settings.hints.trackCurrencyWeight",
          scope: s.world,
          config: !0,
          default: !0,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "hideDeleteConfirmation",
        options: {
          name: "A5E.settings.hideDeletionConfirmationDialog",
          hint: "A5E.settings.hints.hideDeletionConfirmationDialog",
          scope: s.client,
          config: !0,
          type: Boolean,
          default: !1
        }
      },
      {
        namespace: t,
        key: "hideActorCompendiumSelectionDialog",
        options: {
          name: "A5E.settings.hideActorCompendiumSelectionDialog",
          hint: "A5E.settings.hints.hideActorCompendiumSelectionDialog",
          scope: s.client,
          config: !0,
          type: Boolean,
          default: !1
        }
      },
      {
        namespace: t,
        key: "itemRightClickConfigure",
        options: {
          name: "A5E.settings.itemRightClickConfigure",
          hint: "A5E.settings.hints.itemRightClickConfigure",
          scope: s.client,
          config: !0,
          default: !0,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "randomizeNPCHitPoints",
        options: {
          name: "A5E.settings.randomizeNPCHitPoints",
          hint: "A5E.settings.hints.randomizeNPCHitPoints",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "reverseAltBehavior",
        options: {
          name: "A5E.settings.reverseAltBehavior",
          hint: "A5E.settings.hints.reverseAltBehavior",
          scope: s.client,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "reverseInitiativeAltBehavior",
        options: {
          name: "A5E.settings.reverseInitiativeAltBehavior",
          hint: "A5E.settings.hints.reverseInitiativeAltBehavior",
          scope: s.client,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "useNPCExpertisePassiveRulesForCharacters",
        options: {
          name: "A5E.settings.useNPCExpertisePassiveRulesForCharacters",
          hint: "A5E.settings.hints.useNPCExpertisePassiveRulesForCharacters",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      // Canvas Settings
      {
        namespace: t,
        key: "automateVisionRules",
        options: {
          name: "A5E.settings.automateVisionRules",
          hint: "A5E.settings.hints.automateVisionRules",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "diagonalRule",
        options: {
          name: "A5E.settings.diagonalRule",
          hint: "A5E.settings.hints.diagonalRule",
          scope: s.world,
          config: !0,
          default: "normal",
          type: String,
          choices: {
            normal: "A5E.settings.diagonalRuleNormal",
            euclidean: "A5E.settings.diagonalRuleEuclidean",
            5105: "A5E.settings.diagonalRuleAlternating"
          },
          onChange: (l) => {
            canvas.grid.diagonalRule = l;
          }
        }
      },
      {
        namespace: t,
        key: "placeItemTemplateDefault",
        options: {
          name: "A5E.settings.placeItemTemplateDefault",
          hint: "A5E.settings.hints.placeItemTemplateDefault",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      // Effects
      {
        namespace: t,
        key: "automatedConditions",
        options: {
          name: "A5E.settings.automateConditions",
          hint: "A5E.settings.hints.automateConditions",
          scope: s.world,
          config: !0,
          type: Array,
          default: Object.keys(Ie.conditions)
        }
      },
      {
        namespace: t,
        key: "automateBloodiedApplication",
        options: {
          name: "A5E.settings.automateBloodiedApplication",
          hint: "A5E.settings.hints.automateBloodiedApplication",
          scope: s.world,
          config: !0,
          type: Boolean,
          default: !0
        }
      },
      {
        namespace: t,
        key: "automateUnconsciousApplication",
        options: {
          name: "A5E.settings.automateUnconsciousApplication",
          hint: "A5E.settings.hints.automateUnconsciousApplication",
          scope: s.world,
          config: !0,
          type: Boolean,
          default: !0
        }
      },
      {
        namespace: t,
        key: "enableRadialEffects",
        options: {
          name: "A5E.settings.enableRadialEffects",
          hint: "A5E.settings.hints.enableRadialEffects",
          scope: s.world,
          config: !0,
          type: Boolean,
          default: !0
        }
      },
      {
        namespace: t,
        key: "customConditionIcons",
        options: {
          name: "A5E.settings.customConditionIcons",
          hint: "A5E.settings.hints.customConditionIcons",
          scope: s.world,
          config: !0,
          type: Object,
          default: {}
        }
      },
      {
        namespace: t,
        key: "effectsPanelIconSize",
        options: {
          name: "A5E.settings.effectsPanelIconSize",
          hint: "A5E.settings.hints.effectsPanelIconSize",
          scope: s.client,
          config: !0,
          type: String,
          choices: {
            small: "A5E.settings.effectsPanelIconSizeSmall",
            medium: "A5E.settings.effectsPanelIconSizeMedium",
            large: "A5E.settings.effectsPanelIconSizeLarge"
          },
          default: "medium"
        }
      },
      {
        namespace: t,
        key: "effectsPanelOffset",
        options: {
          name: "A5E.settings.effectsPanelOffset",
          hint: "A5E.settings.hints.effectsPanelOffset",
          scope: s.client,
          config: !0,
          type: Object,
          default: { top: 0, bottom: 0, right: 0 }
        }
      },
      {
        namespace: t,
        key: "showEffectsPanel",
        options: {
          name: "A5E.settings.showEffectsPanel",
          scope: s.client,
          config: !0,
          default: !0,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "removeActiveEffectsOnLongRest",
        options: {
          name: "A5E.settings.removeActiveEffectsOnLongRest",
          hint: "A5E.settings.hints.removeActiveEffectsOnLongRest",
          scope: s.world,
          config: !0,
          type: Boolean,
          default: !1
        }
      },
      // Chat Card Settings
      {
        namespace: t,
        key: "enableDamageRollColors",
        options: {
          name: "A5E.settings.enableDamageRollColors",
          hint: "A5E.settings.hints.enableDamageRollColors",
          scope: s.client,
          config: !0,
          default: !0,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "hideChatDescriptionsByDefault",
        options: {
          name: "A5E.settings.hideChatDescriptionsByDefault",
          hint: "A5E.settings.hints.hideChatDescriptionsByDefault",
          scope: s.client,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "hideRandomizedHPRolls",
        options: {
          name: "A5E.settings.hideRandomizedHPRolls",
          hint: "A5E.settings.hints.hideRandomizedHPRolls",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "protectRolls",
        options: {
          name: "A5E.settings.protectRolls",
          hint: "A5E.settings.hints.protectRolls",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "terseRollFormulae",
        options: {
          name: "A5E.settings.terseRollFormulae",
          hint: "A5E.settings.hints.terseRollFormulae",
          scope: s.client,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      // Roll Settings
      {
        namespace: t,
        key: "critCalculationMode",
        options: {
          name: "A5E.settings.critCalculationMode",
          hint: "A5E.settings.hints.critCalculationMode",
          scope: s.world,
          config: !0,
          default: "doubleAllDamage",
          type: String,
          choices: {
            doubleAllDamage: "A5E.settings.critDoubleAllDamage",
            doubleDiceDamage: "A5E.settings.critDoubleDiceDamage",
            doubleDiceQuantity: "A5E.settings.critDoubleDiceQuantity",
            doubleDiceQuantityAndMods: "A5E.settings.critDoubleDiceQuantityAndMods",
            maxDamage: "A5E.settings.critMaxDamage",
            maxDamagePlusRoll: "A5E.settings.critMaxDamagePlusRoll"
          }
        }
      },
      {
        namespace: t,
        key: "preventActionRollOnWarning",
        options: {
          name: "A5E.settings.preventActionRollOnWarning",
          hint: "A5E.settings.hints.preventActionRollOnWarning",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      // 5E Specific Settings
      {
        namespace: t,
        key: "5eStyleDeathSaves",
        options: {
          name: "A5E.settings.5eStyleDeathSaves",
          hint: "A5E.settings.hints.5eStyleDeathSaves",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "5eStyleExpertise",
        options: {
          name: "A5E.settings.5eStyleExpertise",
          hint: "A5E.settings.hints.5eStyleExpertise",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "hideA5eSkills",
        options: {
          name: "A5E.settings.hideA5eSkills",
          hint: "A5E.settings.hints.hideA5eSkills",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "hideBrokenAndDamaged",
        options: {
          name: "A5E.settings.hideBrokenAndDamaged",
          hint: "A5E.settings.hints.hideBrokenAndDamaged",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "hideExpertiseDice",
        options: {
          name: "A5E.settings.hideExpertiseDice",
          hint: "A5E.settings.hints.hideExpertiseDice",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "hideSkillSpecialties",
        options: {
          name: "A5E.settings.hideSkillSpecialties",
          hint: "A5E.settings.hints.hideSkillSpecialties",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "hideSkillCriticalPrompt",
        options: {
          name: "A5E.settings.hideSkillCriticalPrompt",
          hint: "A5E.settings.hints.hideSkillCriticalPrompt",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "replaceFatigueAndStrife",
        options: {
          name: "A5E.settings.replaceFatigueAndStrife",
          hint: "A5E.settings.hints.replaceFatigueAndStrife",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "simpleInitiative",
        options: {
          name: "A5E.settings.simpleInitiative",
          hint: "A5E.settings.hints.simpleInitiative",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "simpleRests",
        options: {
          name: "A5E.settings.simpleRests",
          hint: "A5E.settings.hints.simpleRests",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      // Party Viewer Settings
      {
        namespace: t,
        key: "playersCanAccessPartyViewer",
        options: {
          name: "A5E.settings.playersCanAccessPartyViewer",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "showActorImagesInPartyViewer",
        options: {
          name: "A5E.settings.showActorImagesInPartyViewer",
          scope: s.client,
          config: !0,
          default: !0,
          type: Boolean
        }
      },
      // Misc Settings
      {
        namespace: t,
        key: "autoApplyFancySheets",
        options: {
          name: "A5E.settings.autoApplyFancySheets",
          hint: "A5E.settings.hints.autoApplyFancySheets",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "enableCascadingDamageAndHealing",
        options: {
          name: "A5E.settings.enableCascadingDamageAndHealing",
          hint: "A5E.settings.hints.enableCascadingDamageAndHealing",
          scope: s.world,
          config: !0,
          default: !0,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "cascadingDamageAndHealingDelay",
        options: {
          name: "A5E.settings.cascadingDamageAndHealingDelay",
          hint: "A5E.settings.hints.cascadingDamageAndHealingDelay",
          scope: s.client,
          config: !0,
          default: 350,
          type: Number
        }
      },
      {
        namespace: t,
        key: "gamemasterTitle",
        options: {
          name: "A5E.settings.gamemasterTitle",
          scope: s.world,
          config: !0,
          default: "Narrator",
          type: String
        }
      },
      {
        namespace: t,
        key: "newActionNameType",
        options: {
          name: "A5E.settings.newActionNameType",
          hint: "A5E.settings.hints.newActionNameType",
          scope: s.world,
          config: !0,
          default: "system",
          type: String
        }
      },
      {
        namespace: t,
        key: "showDescriptionOnLimitedPerms",
        options: {
          name: "A5E.settings.showDescriptionOnLimitedPerms",
          hint: "A5E.settings.hints.showDescriptionOnLimitedPerms",
          scope: s.world,
          config: !0,
          default: !1,
          type: Boolean
        }
      },
      {
        namespace: t,
        key: "skillListFlowDirection",
        options: {
          name: "Skill List Flow Direction",
          hint: "Setting this option to 'Row' causes the skills to flow alphabetically left to right, row by row. Setting this option 'Column' causes the skills to flow alphabetically top to bottom, column by column.",
          scope: s.client,
          config: !0,
          default: "row",
          choices: {
            row: "Row",
            column: "Column"
          },
          type: String
        }
      },
      // Hidden system settings
      {
        namespace: t,
        key: "systemMigrationVersion",
        options: {
          name: "A5E.settings.systemMigrationVersion",
          scope: s.world,
          config: !1,
          type: String,
          default: ""
        }
      },
      {
        namespace: t,
        key: "worldSchemaVersion",
        options: {
          name: "A5E.settings.worldSchemaVersion",
          scope: s.world,
          config: !1,
          default: Dn.LATEST_SCHEMA_VERSION,
          type: Number
        }
      },
      // Encounter builder settings
      {
        namespace: t,
        key: "encounters",
        options: {
          name: "A5e.settings.encounters",
          scope: s.world,
          config: !1,
          type: Object,
          default: {
            encounters: {},
            templates: {}
          }
        }
      },
      // Party Sheet Settings
      {
        namespace: t,
        key: "parties",
        options: {
          name: "A5E.settings.parties",
          scope: s.world,
          config: !1,
          default: {
            "5Di3aRnZbNtrXq0K": {
              name: "New Party",
              actors: [],
              isLocked: !1
            }
          },
          type: Object
        }
      }
    ];
    this.registerAll(n, !1), this.settingsData = n;
  }
};
f(ES, "A5eGameSettings");
let pv = ES;
const Aa = new pv();
function fse(i, e, t) {
  return i >= 63072e3 ? `${Math.floor(i / 31536e3)} ${K("A5E.DurationYearPlural")}` : i >= 31536e3 ? `1 ${K("A5E.DurationYear")}` : i >= 1209600 ? `${Math.floor(i / 604800)} ${K("A5E.DurationWeekPlural")}` : i > 604800 ? `1 ${K("A5E.DurationWeek")}` : i >= 172800 ? `${Math.floor(i / 86400)} ${K("A5E.DurationDayPlural")}` : i > 7200 ? `${Math.floor(i / 3600)} ${K("A5E.DurationHourPlural")}` : i > 120 ? `${Math.floor(i / 60)} ${K("A5E.DurationMinutePlural")}` : i >= 12 ? `${Math.floor(i / 6)} ${K("A5E.DurationRoundPlural")}` : i >= 6 ? `1 ${K("A5E.DurationRound")}` : i >= 2 ? `${i} ${K("A5E.DurationSecondPlural")}` : i === 1 ? `1 ${K("A5E.DurationSecond")}` : K(e === 0 && t === 1 ? "Start of Turn" : "End of Turn");
}
f(fse, "getFormattedTimeFromSeconds");
function dse(i) {
  let e, t, s, n, l, r;
  return {
    c() {
      var o;
      e = E("div"), t = E("li"), s = E("img"), b(s, "class", "a5e-effect-item__icon svelte-2va7ep"), ze(s.src, n = /*icon*/
      i[2]) || b(s, "src", n), b(
        s,
        "alt",
        /*name*/
        i[4]
      ), Q(
        s,
        "a5e-effect-item__icon--svg",
        /*icon*/
        (o = i[2]) == null ? void 0 : o.endsWith(".svg")
      ), b(t, "class", "a5e-effect-item svelte-2va7ep"), b(
        t,
        "data-tooltip",
        /*tooltip*/
        i[5]
      ), b(t, "data-tooltip-direction", "LEFT"), b(t, "data-tooltip-class", "a5e-tooltip a5e-tooltip--dark a5e-tooltip--effect-summary"), z(e, "--strife", "'" + /*strife*/
      i[6] + "'"), z(e, "--fatigue", "'" + /*fatigue*/
      i[7] + "'"), z(
        e,
        "--fatigue-col",
        /*colors*/
        i[9][
          /*fatigue*/
          i[7]
        ]
      ), z(
        e,
        "--strife-col",
        /*colors*/
        i[9][
          /*strife*/
          i[6]
        ]
      ), b(e, "class", "svelte-2va7ep"), Q(e, "linked", !!/*linked*/
      i[1]), Q(
        e,
        "fatigue-counter",
        /*conditionId*/
        i[0] === "fatigue"
      ), Q(
        e,
        "strife-counter",
        /*conditionId*/
        i[0] === "strife"
      );
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(t, s), l || (r = [
        V(
          t,
          "click",
          /*click_handler*/
          i[13]
        ),
        V(
          t,
          "auxclick",
          /*auxclick_handler*/
          i[14]
        )
      ], l = !0);
    },
    p(o, [a]) {
      var c;
      a & /*icon*/
      4 && !ze(s.src, n = /*icon*/
      o[2]) && b(s, "src", n), a & /*name*/
      16 && b(
        s,
        "alt",
        /*name*/
        o[4]
      ), a & /*icon*/
      4 && Q(
        s,
        "a5e-effect-item__icon--svg",
        /*icon*/
        (c = o[2]) == null ? void 0 : c.endsWith(".svg")
      ), a & /*tooltip*/
      32 && b(
        t,
        "data-tooltip",
        /*tooltip*/
        o[5]
      ), a & /*strife*/
      64 && z(e, "--strife", "'" + /*strife*/
      o[6] + "'"), a & /*fatigue*/
      128 && z(e, "--fatigue", "'" + /*fatigue*/
      o[7] + "'"), a & /*fatigue*/
      128 && z(
        e,
        "--fatigue-col",
        /*colors*/
        o[9][
          /*fatigue*/
          o[7]
        ]
      ), a & /*strife*/
      64 && z(
        e,
        "--strife-col",
        /*colors*/
        o[9][
          /*strife*/
          o[6]
        ]
      ), a & /*linked*/
      2 && Q(e, "linked", !!/*linked*/
      o[1]), a & /*conditionId*/
      1 && Q(
        e,
        "fatigue-counter",
        /*conditionId*/
        o[0] === "fatigue"
      ), a & /*conditionId*/
      1 && Q(
        e,
        "strife-counter",
        /*conditionId*/
        o[0] === "strife"
      );
    },
    i: ee,
    o: ee,
    d(o) {
      o && S(e), l = !1, Ne(r);
    }
  };
}
f(dse, "create_fragment$2A");
function pse(i, e, t) {
  let s, n, l, r, { actor: o } = e, { description: a } = e, { conditionId: c } = e, { linked: u = null } = e, { icon: d } = e, { _id: p } = e, { name: m } = e;
  function g() {
    const F = o == null ? void 0 : o.effects.get(p), H = (F == null ? void 0 : F.duration) ?? {};
    let G = '<p class="u-flex u-gap-xs u-align-center a5e-tag a5e-tag--active a5e-tag--tight">';
    G += '<i class="fa-regular fa-clock"></i>';
    const { startTime: U, seconds: q, rounds: W, turns: X } = H;
    if (!q && !W && !X)
      return G += "Infinite</p>", G;
    let te = q;
    W === 1 && X === 1 ? te = 0 : W >= 1 && (te = W * 6), te ?? (te = 0);
    const J = U + te - game.time.worldTime;
    return J <= 0 && !X ? '<p class="a5e-tag a5e-tag--red a5e-tag--tight">Expired</p>' : (G += `${q ? "Remaining: " : ""} ${fse(J, W, X)}`, G += "</p>", G);
  }
  f(g, "getEffectDuration");
  function h() {
    let F = '<div class="u-flex u-flex-row-reverse u-gap-md u-text-xs">';
    return F += s, c ? F += `<p class="a5e-tag a5e-tag--active a5e-tag--tight">
                Condition
                </p>` : F += `<p class="a5e-tag a5e-tag--active a5e-tag--tight">
                Active Effect
                </p>`, u && (F += `<p class="a5e-tag a5e-tag--active a5e-tag--tight">
                Applied by: ${P == null ? void 0 : P[u]}
                </p>`), F += "</div>", F;
  }
  f(h, "getEffectNotes");
  function _(F) {
    if (a)
      return a;
    const { fatigue: H, strife: G } = F.system.attributes;
    return m === K("A5E.Exhaustion") ? K(`A5E.tracks.exhaustion.hints.${H}`) : c === "fatigue" ? K(`A5E.tracks.fatigue.hints.${H}`) : c === "strife" ? K(`A5E.tracks.strife.hints.${G}`) : "";
  }
  f(_, "getEffectDescription");
  function y(F) {
    const { fatigue: H, strife: G } = F.system.attributes;
    return c === "fatigue" ? `${m} (${H}) ` : c === "strife" ? `${m} (${G}) ` : m;
  }
  f(y, "getEffectName");
  function k() {
    return u ? "" : c === "fatigue" || c === "strife" ? `
                <small class="a5e-tooltip__note">
                    Right click to remove a level of ${c}.
                </small>
            ` : `
            <small class="a5e-tooltip__note">
                Right click the icon to remove this ${c ? "condition" : "effect"}.
            </small>
        `;
  }
  f(k, "getEffectRemovalNote");
  const v = it(), O = {
    1: "#919f00",
    2: "#a09200",
    3: "#af8300",
    4: "#bd7100",
    5: "#cb5c00",
    6: "#d63f00",
    7: "#e00006"
  }, { conditions: P } = CONFIG.A5E, D = Hooks.on("updateWorldTime", () => t(12, s = g()));
  Nt(() => Hooks.off("updateWorldTime", D));
  const I = /* @__PURE__ */ f(() => v("increaseCounter", p), "click_handler"), B = /* @__PURE__ */ f(() => u ?? v("deleteEffect", p), "auxclick_handler");
  return i.$$set = (F) => {
    "actor" in F && t(10, o = F.actor), "description" in F && t(11, a = F.description), "conditionId" in F && t(0, c = F.conditionId), "linked" in F && t(1, u = F.linked), "icon" in F && t(2, d = F.icon), "_id" in F && t(3, p = F._id), "name" in F && t(4, m = F.name);
  }, i.$$.update = () => {
    i.$$.dirty & /*actor*/
    1024 && t(12, s = g()), i.$$.dirty & /*actor*/
    1024 && t(7, n = (o == null ? void 0 : o.system.attributes.fatigue) ?? 0), i.$$.dirty & /*actor*/
    1024 && t(6, l = (o == null ? void 0 : o.system.attributes.strife) ?? 0), i.$$.dirty & /*actor, duration*/
    5120 && t(5, r = `
        <h3 class="a5e-tooltip__heading">${y(o)}</h3>
        ${_(o)}
        ${k()}
        ${h()}
    `);
  }, [
    c,
    u,
    d,
    p,
    m,
    r,
    l,
    n,
    v,
    O,
    o,
    a,
    s,
    I,
    B
  ];
}
f(pse, "instance$2r");
const SS = class SS extends ie {
  constructor(e) {
    super(), le(this, e, pse, dse, ne, {
      actor: 10,
      description: 11,
      conditionId: 0,
      linked: 1,
      icon: 2,
      _id: 3,
      name: 4
    });
  }
};
f(SS, "A5EEffectsPanelEffect");
let mv = SS;
function IM(i, e, t) {
  const s = i.slice();
  return s[21] = e[t].description, s[22] = e[t].flags, s[23] = e[t].icon, s[24] = e[t]._id, s[25] = e[t].name, s[26] = e[t].statuses, s;
}
f(IM, "get_each_context$Y");
function PM(i) {
  let e, t, s = [], n = /* @__PURE__ */ new Map(), l, r = oe(
    /*effects*/
    i[2]
  );
  const o = /* @__PURE__ */ f((a) => (
    /*_id*/
    a[24]
  ), "get_key");
  for (let a = 0; a < r.length; a += 1) {
    let c = IM(i, r, a), u = o(c);
    n.set(u, s[a] = MM(u, c));
  }
  return {
    c() {
      e = E("article"), t = E("ul");
      for (let a = 0; a < s.length; a += 1)
        s[a].c();
      b(t, "class", "a5e-effect-list svelte-1dhlpjm"), b(e, "id", "a5e-effects-panel"), b(e, "class", "a5e-effects-panel svelte-1dhlpjm"), z(
        e,
        "--top",
        /*panelTop*/
        i[7] + "px"
      ), z(
        e,
        "--left",
        /*panelLeft*/
        i[6] + "px"
      ), z(
        e,
        "--bottom",
        /*panelBottom*/
        i[5] + "px"
      );
    },
    m(a, c) {
      T(a, e, c), A(e, t);
      for (let u = 0; u < s.length; u += 1)
        s[u] && s[u].m(t, null);
      l = !0;
    },
    p(a, c) {
      c & /*$actor, effects, removeEffect, increaseCounter, maxIconsPerColumn, iconSize*/
      4886 && (r = oe(
        /*effects*/
        a[2]
      ), ce(), s = kt(s, c, o, 1, a, r, n, t, ks, MM, null, IM), ue()), (!l || c & /*panelTop*/
      128) && z(
        e,
        "--top",
        /*panelTop*/
        a[7] + "px"
      ), (!l || c & /*panelLeft*/
      64) && z(
        e,
        "--left",
        /*panelLeft*/
        a[6] + "px"
      ), (!l || c & /*panelBottom*/
      32) && z(
        e,
        "--bottom",
        /*panelBottom*/
        a[5] + "px"
      );
    },
    i(a) {
      if (!l) {
        for (let c = 0; c < r.length; c += 1)
          w(s[c]);
        l = !0;
      }
    },
    o(a) {
      for (let c = 0; c < s.length; c += 1)
        C(s[c]);
      l = !1;
    },
    d(a) {
      a && S(e);
      for (let c = 0; c < s.length; c += 1)
        s[c].d();
    }
  };
}
f(PM, "create_if_block$1t");
function MM(i, e) {
  var c, u;
  let t, s, n, l, r;
  function o() {
    return (
      /*deleteEffect_handler*/
      e[15](
        /*_id*/
        e[24]
      )
    );
  }
  f(o, "deleteEffect_handler");
  function a() {
    return (
      /*increaseCounter_handler*/
      e[16](
        /*_id*/
        e[24]
      )
    );
  }
  return f(a, "increaseCounter_handler"), s = new mv({
    props: {
      actor: (
        /*$actor*/
        e[1]
      ),
      description: (
        /*description*/
        e[21]
      ),
      icon: (
        /*icon*/
        e[23]
      ),
      _id: (
        /*_id*/
        e[24]
      ),
      name: (
        /*name*/
        e[25]
      ),
      conditionId: (
        /*statuses*/
        e[26].first()
      ),
      linked: (
        /*flags*/
        ((u = (c = e[22]) == null ? void 0 : c.a5e) == null ? void 0 : u.source) ?? null
      )
    }
  }), s.$on("deleteEffect", o), s.$on("increaseCounter", a), {
    key: i,
    first: null,
    c() {
      t = $e(), n = E("div"), L(s.$$.fragment), z(n, "display", "contents"), z(n, "--icon-size", l = /*effects*/
      e[2].length > /*maxIconsPerColumn*/
      e[12] ? (
        /*iconSize*/
        e[4][0]
      ) : (
        /*iconSize*/
        e[4][1]
      )), this.first = t;
    },
    m(d, p) {
      T(d, t, p), T(d, n, p), N(s, n, null), r = !0;
    },
    p(d, p) {
      var g, h;
      e = d, p & /*effects, iconSize*/
      20 && l !== (l = /*effects*/
      e[2].length > /*maxIconsPerColumn*/
      e[12] ? (
        /*iconSize*/
        e[4][0]
      ) : (
        /*iconSize*/
        e[4][1]
      )) && z(n, "--icon-size", l);
      const m = {};
      p & /*$actor*/
      2 && (m.actor = /*$actor*/
      e[1]), p & /*effects*/
      4 && (m.description = /*description*/
      e[21]), p & /*effects*/
      4 && (m.icon = /*icon*/
      e[23]), p & /*effects*/
      4 && (m._id = /*_id*/
      e[24]), p & /*effects*/
      4 && (m.name = /*name*/
      e[25]), p & /*effects*/
      4 && (m.conditionId = /*statuses*/
      e[26].first()), p & /*effects*/
      4 && (m.linked = /*flags*/
      ((h = (g = e[22]) == null ? void 0 : g.a5e) == null ? void 0 : h.source) ?? null), s.$set(m);
    },
    i(d) {
      r || (w(s.$$.fragment, d), r = !0);
    },
    o(d) {
      C(s.$$.fragment, d), r = !1;
    },
    d(d) {
      d && S(t), d && s && S(n), j(s, d);
    }
  };
}
f(MM, "create_each_block$Y");
function mse(i) {
  let e, t, s = (
    /*token*/
    i[0] && /*$actor*/
    i[1] && /*effects*/
    i[2].length && PM(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, [l]) {
      /*token*/
      n[0] && /*$actor*/
      n[1] && /*effects*/
      n[2].length ? s ? (s.p(n, l), l & /*token, $actor, effects*/
      7 && w(s, 1)) : (s = PM(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ce(), C(s, 1, 1, () => {
        s = null;
      }), ue());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f(mse, "create_fragment$2z");
function hse() {
  var s;
  const i = parseFloat(((s = document.getElementsByTagName("html").style) == null ? void 0 : s.fontSize) ?? 16), { clientHeight: e } = document.documentElement;
  return (e - 5 - 8 * i - 2.5 * i) / (3.25 * i);
}
f(hse, "getMaxEffectIconsPerColumn");
function Db(i) {
  return i * parseFloat(getComputedStyle(document.documentElement).fontSize);
}
f(Db, "convertRemToPixels");
function gse(i) {
  if (i === "small")
    return ["2rem", "2rem"];
  if (i === "medium")
    return ["2rem", "2.5rem"];
  if (i === "large")
    return ["2.5rem", "3rem"];
}
f(gse, "getIconSize");
function bse(i, e, t) {
  var H, G;
  let s, n, l, r, o, a, c, u = ee, d = /* @__PURE__ */ f(() => (u(), u = Et(o, (U) => t(1, c = U)), o), "$$subscribe_actor"), p, m;
  i.$$.on_destroy.push(() => u());
  function g(U) {
    var X, te;
    const q = c.effects.get(U), W = q.statuses;
    if (W.size === 1) {
      if ((X = I[W.first()]) != null && X.some((ae) => D.includes(ae)))
        return;
      const J = W.first(), re = q.icon;
      return (te = v == null ? void 0 : v.object) == null ? void 0 : te._removeStatusEffect({ id: J, src: re });
    }
    q.delete();
  }
  f(g, "removeEffect");
  function h(U) {
    var X;
    const q = c.effects.get(U), W = q.statuses;
    if (W.size === 1 && ["fatigue", "strife"].includes(W.first())) {
      const te = W.first(), J = q.icon;
      return (X = v == null ? void 0 : v.object) == null ? void 0 : X._addStatusEffect({ id: te, src: J });
    }
  }
  f(h, "increaseCounter");
  function _() {
    var U;
    return o == null || o.destroy(), v ? new Bt((v == null ? void 0 : v.actor) ?? ((U = game.user) == null ? void 0 : U.character) ?? null) : null;
  }
  f(_, "getReactiveActor");
  let y = Aa.getStore("effectsPanelOffset");
  pe(i, y, (U) => t(14, m = U));
  let k = Aa.getStore("effectsPanelIconSize");
  pe(i, k, (U) => t(13, p = U));
  let v = ((H = canvas.tokens.controlled.at(0)) == null ? void 0 : H.document) ?? null;
  const O = hse(), P = Hooks.on("controlToken", () => {
    var U;
    t(0, v = ((U = canvas.tokens.controlled.at(0)) == null ? void 0 : U.document) ?? null);
  });
  Nt(() => {
    Hooks.off("controlToken", P);
  });
  let D = ((G = v == null ? void 0 : v.object) == null ? void 0 : G._getActiveConditions()) ?? [];
  const I = CONFIG.statusEffects.reduce(
    (U, q) => {
      var W;
      return (W = q == null ? void 0 : q.statuses) != null && W.length && q.statuses.forEach((X) => {
        U[X] ?? (U[X] = []), U[X].push(q.id);
      }), U;
    },
    {}
  ), B = /* @__PURE__ */ f((U) => g(U), "deleteEffect_handler"), F = /* @__PURE__ */ f((U) => h(U), "increaseCounter_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$panelOffset*/
    16384 && t(7, s = Db(4) + (m.top ?? 0)), i.$$.dirty & /*$panelOffset*/
    16384 && t(6, n = Db(-0.5) - (m.right ?? 0)), i.$$.dirty & /*$panelOffset*/
    16384 && t(5, l = Db(4) + 5 + (m.bottom ?? 0)), i.$$.dirty & /*$panelIconSize*/
    8192 && t(4, r = gse(p)), i.$$.dirty & /*token*/
    1 && d(t(3, o = _())), i.$$.dirty & /*$actor, token*/
    3 && t(2, a = [...(c == null ? void 0 : c.temporaryEffects) || [], ...(v == null ? void 0 : v.effects) || []].filter((U) => {
      var q;
      return !((q = U.statuses.first()) != null && q.startsWith("generic"));
    }).sort((U, q) => U.name.localeCompare(q.name)));
  }, [
    v,
    c,
    a,
    o,
    r,
    l,
    n,
    s,
    g,
    h,
    y,
    k,
    O,
    p,
    m,
    B,
    F
  ];
}
f(bse, "instance$2q");
const TS = class TS extends ie {
  constructor(e) {
    super(), le(this, e, bse, mse, ne, {});
  }
};
f(TS, "A5EEffectsPanel");
let hv = TS;
function _se() {
  const i = document.body.querySelector("#ui-right");
  i && new hv({
    target: i
  });
}
f(_se, "renderEffectsPanel");
function yse() {
  (game.settings.get("a5e", "showEffectsPanel") ?? !0) && _se();
}
f(yse, "canvasReady");
function vse(i, e, t) {
  e.fromCompendium || kse(i, t);
}
f(vse, "createActor");
async function kse(i, e) {
  if (game.user.id !== e || i.items.find((l) => l.type === "maneuver" && l.system.degree === 0))
    return;
  const n = [
    "Compendium.a5e.a5e-maneuvers.9umrahwm68f81d7l",
    "Compendium.a5e.a5e-maneuvers.jewmp4pzrg9cdui9",
    "Compendium.a5e.a5e-maneuvers.c0bv7fsy2akld5lp",
    "Compendium.a5e.a5e-maneuvers.zzg7j7cb0vkgctwi",
    "Compendium.a5e.a5e-maneuvers.210ihnnejao46r20",
    "Compendium.a5e.a5e-maneuvers.md35qozzy2fxy2o6"
  ];
  try {
    const l = await Promise.all(n.map((r) => fromUuid(r)));
    await i.createEmbeddedDocuments("Item", l), console.info(`Added Manuevers to ${i.name}`);
  } catch (l) {
    console.error(l), console.error(`Error while adding Manuevers to ${i.name}`);
  }
}
f(kse, "addBasicManuevers");
async function wse(i, e) {
  var r, o;
  const { actor: t } = i, s = game.users.get(e);
  if (!t || !game.user.isGM || game.user !== s || t.type !== "npc" || !game.settings.get("a5e", "randomizeNPCHitPoints") || (o = (r = t.flags) == null ? void 0 : r.a5e) != null && o.disableRandomizedHP)
    return;
  const { hitPointFormula: n } = t;
  if (n === null)
    return;
  const l = new Roll(n);
  game.settings.get("a5e", "hideRandomizedHPRolls") ? await l.evaluate({ async: !0 }) : await l.toMessage(
    { flavor: `Rolling hit points for ${i.name}.` },
    { rollMode: "gmroll" }
  ), t.update({
    "system.attributes.hp": {
      baseMax: l.total,
      value: l.total
    }
  });
}
f(wse, "rollTokenHitDie");
async function $se(i, e, t) {
  wse(i, t);
}
f($se, "createToken");
const CS = class CS extends Ms {
  initialize() {
    this.filters.add((e) => e.system.favorite);
  }
};
f(CS, "FavoriteMapReducer");
let gv = CS;
const OS = class OS extends Ms {
  initialize() {
    this.filters.add((e) => ["feature", "background", "culture", "destiny", "heritage", "class", "subclass"].includes(e.type)), this.sort.set((e, t) => e.sort - t.sort), this._types = {}, Object.keys(CONFIG.A5E.featureTypes).forEach((e) => {
      this._types[e] = this.derived.create(e);
    }), Object.entries(this._types).forEach(([e, t]) => {
      t.filters.add((s) => s.system.featureType === e || s.type === e);
    }), this._types.Uncategorized = this.derived.create("uncategorized"), this._types.Uncategorized.filters.add((e) => e.system.featureType === "");
  }
};
f(OS, "FeatureMapReducer");
let bv = OS;
const DS = class DS extends Ms {
  initialize() {
    this.filters.add((e) => e.type === "maneuver"), this.sort.set((e, t) => e.sort - t.sort), this._degrees = {}, Object.keys(CONFIG.A5E.maneuverDegrees).forEach((e) => {
      this._degrees[e] = this.derived.create(e);
    }), Object.entries(this._degrees).forEach(([e, t]) => {
      t.filters.add((s) => parseInt(s.system.degree, 10) === Number(e));
    });
  }
};
f(DS, "ManeuverMapReducer");
let _v = DS;
const IS = class IS extends Ms {
  initialize() {
    this.filters.add((e) => e.type === "object"), this.sort.set((e, t) => e.sort - t.sort), this._types = {}, Object.keys(CONFIG.A5E.objectTypes).forEach((e) => {
      this._types[e] = this.derived.create(e);
    }), Object.entries(this._types).forEach(([e, t]) => {
      if (e === "armor") {
        t.filters.add((s) => !s.system.containerId && ["armor", "shield", "helm"].includes(s.system.objectType));
        return;
      }
      t.filters.add((s) => {
        var n;
        return s.system.objectType === e && !((n = s.system) != null && n.containerId);
      });
    }), delete this._types.shield, delete this._types.helm, this._types.Uncategorized = this.derived.create("uncategorized"), this._types.Uncategorized.filters.add((e) => e.system.objectType === "");
  }
};
f(IS, "ObjectMapReducer");
let yv = IS;
const PS = class PS extends Ms {
  initialize() {
    var t;
    this.filters.add((s) => s.type === "spell"), this.sort.set((s, n) => s.sort - n.sort), this._books = {};
    const e = (t = [...this.data][0]) == null ? void 0 : t.parent;
    e && (this._books.none = this.derived.create("none"), [...e.spellBooks.keys()].forEach((s) => {
      var n;
      (n = this._books)[s] ?? (n[s] = this.derived.create(s));
    }), Object.entries(this._books).forEach(([s, n]) => {
      n.filters.add((l) => (l.system.spellBook ? l.system.spellBook : "none") === s), n._levels = {}, Object.keys(CONFIG.A5E.spellLevels).forEach((l) => {
        n._levels[l] = n.derived.create(l);
      }), Object.entries(n._levels).forEach(([l, r]) => {
        r.filters.add((o) => parseInt(o.system.level, 10) === parseInt(l, 10));
      });
    }));
  }
};
f(PS, "SpellMapReducer");
let vv = PS;
var nf, lf, rf, of, af, cf;
const MS = class MS extends Bt {
  constructor(t, s) {
    super(t, s);
    Y(this, nf, void 0);
    Y(this, lf, void 0);
    Y(this, rf, void 0);
    Y(this, of, void 0);
    Y(this, af, void 0);
    Y(this, cf, void 0);
    ye(this, nf, this.embedded.create(ActiveEffect, by)), ye(this, lf, this.embedded.create(Item, gv)), ye(this, rf, this.embedded.create(Item, bv)), ye(this, of, this.embedded.create(Item, _v)), ye(this, af, this.embedded.create(Item, yv)), ye(this, cf, this.embedded.create(Item, vv));
  }
  get activeEffects() {
    return M(this, nf);
  }
  get favorites() {
    return M(this, lf);
  }
  get features() {
    return M(this, rf);
  }
  get maneuvers() {
    return M(this, of);
  }
  get objects() {
    return M(this, af);
  }
  get spells() {
    return M(this, cf);
  }
};
nf = new WeakMap(), lf = new WeakMap(), rf = new WeakMap(), of = new WeakMap(), af = new WeakMap(), cf = new WeakMap(), f(MS, "ActorDocument");
let kv = MS;
function no(i, e) {
  const t = i.overrides ?? {};
  return !!foundry.utils.getProperty(t, e);
}
f(no, "determineIfPropertyModifiedByEffect");
function RM(i, e, t) {
  const s = i.slice();
  return s[16] = e[t], s;
}
f(RM, "get_each_context$X");
function FM(i, e, t) {
  const s = i.slice();
  return s[19] = e[t][0], s[20] = e[t][1], s;
}
f(FM, "get_each_context_1$b");
function Ase(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input svelte-pu131g"), b(e, "type", "text"), b(e, "name", "system.bonuses.maneuverDC"), e.value = t = /*$actor*/
      i[0].system.bonuses.maneuverDC, e.disabled = /*disableManeuverDC*/
      i[2];
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[9]
      ), s = !0);
    },
    p(l, r) {
      r & /*$actor*/
      1 && t !== (t = /*$actor*/
      l[0].system.bonuses.maneuverDC) && e.value !== t && (e.value = t), r & /*disableManeuverDC*/
      4 && (e.disabled = /*disableManeuverDC*/
      l[2]);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Ase, "create_default_slot_3$j");
function Ese(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input svelte-pu131g"), b(e, "type", "text"), b(e, "name", "system.bonuses.spellDC"), e.value = t = /*$actor*/
      i[0].system.bonuses.spellDC, e.disabled = /*disableSpellDC*/
      i[1];
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      r & /*$actor*/
      1 && t !== (t = /*$actor*/
      l[0].system.bonuses.spellDC) && e.value !== t && (e.value = t), r & /*disableSpellDC*/
      2 && (e.disabled = /*disableSpellDC*/
      l[1]);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Ese, "create_default_slot_2$k");
function Sse(i) {
  let e, t, s, n, l;
  return t = new de({
    props: {
      heading: "A5E.ManeuverDCBonus",
      showWarning: (
        /*disableManeuverDC*/
        i[2]
      ),
      warning: "A5E.validations.warnings.modifiedByEffect",
      $$slots: { default: [Ase] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      heading: "A5E.SpellDCBonus",
      showWarning: (
        /*disableSpellDC*/
        i[1]
      ),
      warning: "A5E.validations.warnings.modifiedByEffect",
      $$slots: { default: [Ese] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("div"), L(t.$$.fragment), s = R(), L(n.$$.fragment), b(e, "class", "global-bonus-container svelte-pu131g");
    },
    m(r, o) {
      T(r, e, o), N(t, e, null), A(e, s), N(n, e, null), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*disableManeuverDC*/
      4 && (a.showWarning = /*disableManeuverDC*/
      r[2]), o & /*$$scope, $actor, disableManeuverDC*/
      8388613 && (a.$$scope = { dirty: o, ctx: r }), t.$set(a);
      const c = {};
      o & /*disableSpellDC*/
      2 && (c.showWarning = /*disableSpellDC*/
      r[1]), o & /*$$scope, $actor, disableSpellDC*/
      8388611 && (c.$$scope = { dirty: o, ctx: r }), n.$set(c);
    },
    i(r) {
      l || (w(t.$$.fragment, r), w(n.$$.fragment, r), l = !0);
    },
    o(r) {
      C(t.$$.fragment, r), C(n.$$.fragment, r), l = !1;
    },
    d(r) {
      r && S(e), j(t), j(n);
    }
  };
}
f(Sse, "create_default_slot_1$s");
function NM(i) {
  let e, t, s, n, l, r, o, a, c, u, d;
  function p() {
    return (
      /*click_handler*/
      i[11](
        /*id*/
        i[19],
        /*bonusType*/
        i[16]
      )
    );
  }
  f(p, "click_handler");
  function m() {
    return (
      /*click_handler_1*/
      i[12](
        /*id*/
        i[19],
        /*bonusType*/
        i[16]
      )
    );
  }
  f(m, "click_handler_1");
  function g() {
    return (
      /*click_handler_2*/
      i[13](
        /*id*/
        i[19],
        /*bonusType*/
        i[16]
      )
    );
  }
  return f(g, "click_handler_2"), {
    c() {
      e = E("ul"), t = E("li"), s = E("button"), n = R(), l = E("li"), r = E("button"), o = R(), a = E("li"), c = E("button"), b(s, "class", "action-button fas fa-cog svelte-pu131g"), b(s, "data-tooltip", "A5E.ButtonToolTipConfigure"), b(s, "data-tooltip-direction", "UP"), b(r, "class", "action-button fa-solid fa-clone svelte-pu131g"), b(r, "data-tooltip", "A5E.ButtonToolTipDuplicate"), b(r, "data-tooltip-direction", "UP"), b(c, "class", "action-button delete-button fas fa-trash svelte-pu131g"), b(c, "data-tooltip", "A5E.ButtonToolTipDelete"), b(c, "data-tooltip-direction", "UP"), b(e, "class", "bonus-buttons svelte-pu131g");
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(t, s), A(e, n), A(e, l), A(l, r), A(e, o), A(e, a), A(a, c), u || (d = [
        V(s, "click", We(p)),
        V(r, "click", We(m)),
        V(c, "click", We(g))
      ], u = !0);
    },
    p(h, _) {
      i = h;
    },
    d(h) {
      h && S(e), u = !1, Ne(d);
    }
  };
}
f(NM, "create_if_block$1s");
function jM(i, e) {
  let t, s, n, l, r, o = (
    /*bonus*/
    (e[20].label || /*getDefaultBonusName*/
    e[5](
      /*bonusType*/
      e[16]
    )) + ""
  ), a, c, u = !no(
    /*$actor*/
    e[0],
    `system.bonuses.${/*bonusType*/
    e[16]}.${/*id*/
    e[19]}`
  ), d, p, m, g = u && NM(e);
  function h() {
    return (
      /*auxclick_handler*/
      e[14](
        /*bonusType*/
        e[16],
        /*id*/
        e[19]
      )
    );
  }
  return f(h, "auxclick_handler"), {
    key: i,
    first: null,
    c() {
      t = E("li"), s = E("img"), l = R(), r = E("h3"), a = x(o), c = R(), g && g.c(), d = R(), b(s, "class", "a5e-item__img"), ze(s.src, n = /*bonus*/
      e[20].img) || b(s, "src", n), b(s, "alt", ""), b(r, "class", "a5e-item__name"), b(t, "class", "a5e-item a5e-item--bonus"), this.first = t;
    },
    m(_, y) {
      T(_, t, y), A(t, s), A(t, l), A(t, r), A(r, a), A(t, c), g && g.m(t, null), A(t, d), p || (m = V(t, "auxclick", h), p = !0);
    },
    p(_, y) {
      e = _, y & /*$actor*/
      1 && !ze(s.src, n = /*bonus*/
      e[20].img) && b(s, "src", n), y & /*$actor*/
      1 && o !== (o = /*bonus*/
      (e[20].label || /*getDefaultBonusName*/
      e[5](
        /*bonusType*/
        e[16]
      )) + "") && _e(a, o), y & /*$actor*/
      1 && (u = !no(
        /*$actor*/
        e[0],
        `system.bonuses.${/*bonusType*/
        e[16]}.${/*id*/
        e[19]}`
      )), u ? g ? g.p(e, y) : (g = NM(e), g.c(), g.m(t, d)) : g && (g.d(1), g = null);
    },
    d(_) {
      _ && S(t), g && g.d(), p = !1, m();
    }
  };
}
f(jM, "create_each_block_1$b");
function Tse(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n, l = oe(Object.entries(
    /*$actor*/
    i[0].system.bonuses[
      /*bonusType*/
      i[16]
    ] ?? {}
  ));
  const r = /* @__PURE__ */ f((o) => (
    /*id*/
    o[19]
  ), "get_key");
  for (let o = 0; o < l.length; o += 1) {
    let a = FM(i, l, o), c = r(a);
    s.set(c, t[o] = jM(c, a));
  }
  return {
    c() {
      e = E("ul");
      for (let o = 0; o < t.length; o += 1)
        t[o].c();
      n = R(), b(e, "class", "a5e-item-list");
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < t.length; c += 1)
        t[c] && t[c].m(e, null);
      T(o, n, a);
    },
    p(o, a) {
      a & /*rightClickConfigure, $actor, bonusCategories, Object, getDefaultBonusName*/
      417 && (l = oe(Object.entries(
        /*$actor*/
        o[0].system.bonuses[
          /*bonusType*/
          o[16]
        ] ?? {}
      )), t = kt(t, a, r, 1, o, l, s, e, vs, jM, null, FM));
    },
    d(o) {
      o && (S(e), S(n));
      for (let a = 0; a < t.length; a += 1)
        t[a].d();
    }
  };
}
f(Tse, "create_default_slot$12");
function LM(i) {
  let e, t, s;
  function n() {
    return (
      /*func*/
      i[15](
        /*bonusType*/
        i[16]
      )
    );
  }
  return f(n, "func"), e = new Me({
    props: {
      headerClasses: Object.values(
        /*$actor*/
        i[0].system.bonuses[
          /*bonusType*/
          i[16]
        ] ?? {}
      ).length ? "a5e-section-header--flat-bottom" : "",
      heading: (
        /*getBonusSectionHeader*/
        i[3](
          /*bonusType*/
          i[16]
        )
      ),
      headerButtons: [
        {
          label: (
            /*getAddButtonLabelForBonus*/
            i[4](
              /*bonusType*/
              i[16]
            )
          ),
          handler: n
        }
      ],
      $$slots: { default: [Tse] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-gap", "0");
    },
    m(l, r) {
      T(l, t, r), N(e, t, null), s = !0;
    },
    p(l, r) {
      i = l;
      const o = {};
      r & /*$actor*/
      1 && (o.headerClasses = Object.values(
        /*$actor*/
        i[0].system.bonuses[
          /*bonusType*/
          i[16]
        ] ?? {}
      ).length ? "a5e-section-header--flat-bottom" : ""), r & /*$actor*/
      1 && (o.headerButtons = [
        {
          label: (
            /*getAddButtonLabelForBonus*/
            i[4](
              /*bonusType*/
              i[16]
            )
          ),
          handler: n
        }
      ]), r & /*$$scope, $actor*/
      8388609 && (o.$$scope = { dirty: r, ctx: i }), e.$set(o);
    },
    i(l) {
      s || (w(e.$$.fragment, l), s = !0);
    },
    o(l) {
      C(e.$$.fragment, l), s = !1;
    },
    d(l) {
      l && e && S(t), j(e, l);
    }
  };
}
f(LM, "create_each_block$X");
function Cse(i) {
  let e, t, s, n, l;
  t = new Me({
    props: {
      heading: "Global Bonuses",
      hint: "All of the fields in this section accept any values valid in roll formulae.",
      $$slots: { default: [Sse] },
      $$scope: { ctx: i }
    }
  });
  let r = oe(
    /*bonusCategories*/
    i[7]
  ), o = [];
  for (let c = 0; c < r.length; c += 1)
    o[c] = LM(RM(i, r, c));
  const a = /* @__PURE__ */ f((c) => C(o[c], 1, 1, () => {
    o[c] = null;
  }), "out");
  return {
    c() {
      e = E("section"), s = E("div"), L(t.$$.fragment), n = R();
      for (let c = 0; c < o.length; c += 1)
        o[c].c();
      z(s, "display", "contents"), z(s, "--a5e-section-body-gap", "0.5rem"), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--item-list");
    },
    m(c, u) {
      T(c, e, u), A(e, s), N(t, s, null), A(e, n);
      for (let d = 0; d < o.length; d += 1)
        o[d] && o[d].m(e, null);
      l = !0;
    },
    p(c, [u]) {
      const d = {};
      if (u & /*$$scope, disableSpellDC, $actor, disableManeuverDC*/
      8388615 && (d.$$scope = { dirty: u, ctx: c }), t.$set(d), u & /*Object, $actor, bonusCategories, getBonusSectionHeader, getAddButtonLabelForBonus, rightClickConfigure, getDefaultBonusName*/
      441) {
        r = oe(
          /*bonusCategories*/
          c[7]
        );
        let p;
        for (p = 0; p < r.length; p += 1) {
          const m = RM(c, r, p);
          o[p] ? (o[p].p(m, u), w(o[p], 1)) : (o[p] = LM(m), o[p].c(), w(o[p], 1), o[p].m(e, null));
        }
        for (ce(), p = r.length; p < o.length; p += 1)
          a(p);
        ue();
      }
    },
    i(c) {
      if (!l) {
        w(t.$$.fragment, c);
        for (let u = 0; u < r.length; u += 1)
          w(o[u]);
        l = !0;
      }
    },
    o(c) {
      C(t.$$.fragment, c), o = o.filter(Boolean);
      for (let u = 0; u < o.length; u += 1)
        C(o[u]);
      l = !1;
    },
    d(c) {
      c && S(e), j(t), Le(o, c);
    }
  };
}
f(Cse, "create_fragment$2y");
function Ose(i, e, t) {
  let s, n, l;
  function r(v) {
    var O;
    return K(((O = CONFIG.A5E.bonusLabels[v]) == null ? void 0 : O.sectionHeader) ?? v);
  }
  f(r, "getBonusSectionHeader");
  function o(v) {
    var O;
    return K(((O = CONFIG.A5E.bonusLabels[v]) == null ? void 0 : O.addButton) ?? v);
  }
  f(o, "getAddButtonLabelForBonus");
  function a(v) {
    var O;
    return K(((O = CONFIG.A5E.bonusLabels[v]) == null ? void 0 : O.defaultName) ?? v);
  }
  f(a, "getDefaultBonusName");
  const c = fe("actor");
  pe(i, c, (v) => t(0, l = v));
  const u = Object.keys(CONFIG.A5E.bonusTypes);
  let d = game.settings.get("a5e", "itemRightClickConfigure") ?? !0;
  const p = /* @__PURE__ */ f(({ target: v }) => se(l, v.name, v.value), "change_handler"), m = /* @__PURE__ */ f(({ target: v }) => se(l, v.name, v.value), "change_handler_1"), g = /* @__PURE__ */ f((v, O) => l.configureBonus(v, O), "click_handler"), h = /* @__PURE__ */ f((v, O) => l.duplicateBonus(v, O), "click_handler_1"), _ = /* @__PURE__ */ f((v, O) => l.deleteBonus(v, O), "click_handler_2"), y = /* @__PURE__ */ f((v, O) => {
    d && !no(l, `system.bonuses.${v}.${O}`) && l.configureBonus(O, v);
  }, "auxclick_handler"), k = /* @__PURE__ */ f((v) => l.addBonus(v), "func");
  return i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    1 && t(2, s = no(l, "system.bonuses.maneuverDC")), i.$$.dirty & /*$actor*/
    1 && t(1, n = no(l, "system.bonuses.spellDC"));
  }, [
    l,
    n,
    s,
    r,
    o,
    a,
    c,
    u,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    k
  ];
}
f(Ose, "instance$2p");
const RS = class RS extends ie {
  constructor(e) {
    super(), le(this, e, Ose, Cse, ne, {});
  }
};
f(RS, "ActorBonusesPage");
let wv = RS;
function Dse(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), e.value = t = /*resource*/
      i[2].label;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[6]
      ), s = !0);
    },
    p(l, r) {
      r & /*resource*/
      4 && t !== (t = /*resource*/
      l[2].label) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Dse, "create_default_slot_6$9");
function BM(i) {
  let e, t;
  return e = new de({
    props: {
      heading: "A5E.GenericResourceMaxFormula",
      $$slots: { default: [Ise] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, resource, $actor, source*/
      4103 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(BM, "create_if_block_1$Z");
function Ise(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), e.value = t = /*resource*/
      i[2].max;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[7]
      ), s = !0);
    },
    p(l, r) {
      r & /*resource*/
      4 && t !== (t = /*resource*/
      l[2].max) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Ise, "create_default_slot_5$c");
function Pse(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.GenericResourceHideMax",
      checked: (
        /*resource*/
        i[2].hideMax ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[8]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*resource*/
      4 && (l.checked = /*resource*/
      s[2].hideMax ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Pse, "create_default_slot_4$d");
function Mse(i) {
  let e, t, s, n, l;
  e = new de({
    props: {
      heading: "A5E.Label",
      $$slots: { default: [Dse] },
      $$scope: { ctx: i }
    }
  });
  let r = !/*resource*/
  i[2].hideMax && BM(i);
  return n = new de({
    props: {
      $$slots: { default: [Pse] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), r && r.c(), s = R(), L(n.$$.fragment);
    },
    m(o, a) {
      N(e, o, a), T(o, t, a), r && r.m(o, a), T(o, s, a), N(n, o, a), l = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$$scope, resource, $actor, source*/
      4103 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c), /*resource*/
      o[2].hideMax ? r && (ce(), C(r, 1, 1, () => {
        r = null;
      }), ue()) : r ? (r.p(o, a), a & /*resource*/
      4 && w(r, 1)) : (r = BM(o), r.c(), w(r, 1), r.m(s.parentNode, s));
      const u = {};
      a & /*$$scope, resource, $actor, source*/
      4103 && (u.$$scope = { dirty: a, ctx: o }), n.$set(u);
    },
    i(o) {
      l || (w(e.$$.fragment, o), w(r), w(n.$$.fragment, o), l = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(r), C(n.$$.fragment, o), l = !1;
    },
    d(o) {
      o && (S(t), S(s)), j(e, o), r && r.d(o), j(n, o);
    }
  };
}
f(Mse, "create_default_slot_3$i");
function qM(i) {
  let e, t, s, n;
  return e = new de({
    props: {
      heading: "A5E.ItemRechargeFormula",
      $$slots: { default: [Rse] },
      $$scope: { ctx: i }
    }
  }), s = new de({
    props: {
      heading: "A5E.ItemRechargeThreshold",
      $$slots: { default: [Fse] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$$scope, resource, $actor, source*/
      4103 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$$scope, resource, $actor, source*/
      4103 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(qM, "create_if_block$1r");
function Rse(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), e.value = t = /*resource*/
      i[2].recharge.formula, b(e, "placeholder", "1d6");
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_2*/
        i[10]
      ), s = !0);
    },
    p(l, r) {
      r & /*resource*/
      4 && t !== (t = /*resource*/
      l[2].recharge.formula) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Rse, "create_default_slot_2$j");
function Fse(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input u-text-center"), b(e, "type", "number"), e.value = t = /*resource*/
      i[2].recharge.threshold;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_3*/
        i[11]
      ), s = !0);
    },
    p(l, r) {
      r & /*resource*/
      4 && t !== (t = /*resource*/
      l[2].recharge.threshold) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Fse, "create_default_slot_1$r");
function Nse(i) {
  let e, t, s, n;
  e = new Ye({
    props: {
      heading: "A5E.RecoverResourceAt",
      options: (
        /*recoveryOptions*/
        i[4]
      ),
      selected: (
        /*resource*/
        i[2].per
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[9]
  );
  let l = (
    /*resource*/
    i[2].per === "recharge" && qM(i)
  );
  return {
    c() {
      L(e.$$.fragment), t = R(), l && l.c(), s = $e();
    },
    m(r, o) {
      N(e, r, o), T(r, t, o), l && l.m(r, o), T(r, s, o), n = !0;
    },
    p(r, o) {
      const a = {};
      o & /*resource*/
      4 && (a.selected = /*resource*/
      r[2].per), e.$set(a), /*resource*/
      r[2].per === "recharge" ? l ? (l.p(r, o), o & /*resource*/
      4 && w(l, 1)) : (l = qM(r), l.c(), w(l, 1), l.m(s.parentNode, s)) : l && (ce(), C(l, 1, 1, () => {
        l = null;
      }), ue());
    },
    i(r) {
      n || (w(e.$$.fragment, r), w(l), n = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(l), n = !1;
    },
    d(r) {
      r && (S(t), S(s)), j(e, r), l && l.d(r);
    }
  };
}
f(Nse, "create_default_slot$11");
function jse(i) {
  let e, t, s, n, l, r;
  return e = new Me({
    props: {
      $$slots: { default: [Mse] },
      $$scope: { ctx: i }
    }
  }), n = new Me({
    props: {
      heading: "Recovery Configuration",
      $$slots: { default: [Nse] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), l = E("div"), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-padding", "0.75rem"), z(t, "--a5e-section-body-gap", "0.75rem"), z(t, "--a5e-section-margin", "0 0 0.25rem 0"), z(l, "display", "contents"), z(l, "--a5e-section-body-gap", "0.75rem"), z(l, "--a5e-section-padding", "0 0.75rem 0.75rem 0.75rem");
    },
    m(o, a) {
      T(o, t, a), N(e, t, null), T(o, s, a), T(o, l, a), N(n, l, null), r = !0;
    },
    p(o, [a]) {
      const c = {};
      a & /*$$scope, resource, $actor, source*/
      4103 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const u = {};
      a & /*$$scope, resource, $actor, source*/
      4103 && (u.$$scope = { dirty: a, ctx: o }), n.$set(u);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(n.$$.fragment, o), r = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(n.$$.fragment, o), r = !1;
    },
    d(o) {
      o && S(s), o && e && S(t), j(e, o), o && n && S(l), j(n, o);
    }
  };
}
f(jse, "create_fragment$2x");
function Lse(i, e, t) {
  let s, n, { document: l, source: r } = fe("#external").application, { document: o = l, source: a = r } = e;
  const c = o;
  pe(i, c, (y) => t(1, n = y));
  const u = Object.entries(CONFIG.A5E.resourceRecoveryOptions), d = /* @__PURE__ */ f(({ target: y }) => se(n, `system.resources.${a}.label`, y.value), "change_handler"), p = /* @__PURE__ */ f(({ target: y }) => {
    ka(y.value), se(n, `system.resources.${a}.max`, y.value);
  }, "change_handler_1"), m = /* @__PURE__ */ f(({ detail: y }) => {
    se(n, `system.resources.${a}.hideMax`, y);
  }, "updateSelection_handler"), g = /* @__PURE__ */ f((y) => se(n, `system.resources.${a}.per`, y.detail), "updateSelection_handler_1"), h = /* @__PURE__ */ f(({ target: y }) => {
    ka(y.value), se(n, `system.resources.${a}.recharge.formula`, y.value);
  }, "change_handler_2"), _ = /* @__PURE__ */ f(({ target: y }) => se(n, `system.resources.${a}.recharge.threshold`, Number(y.value)), "change_handler_3");
  return i.$$set = (y) => {
    "document" in y && t(5, o = y.document), "source" in y && t(0, a = y.source);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, source*/
    3 && t(2, s = n.system.resources[a]);
  }, [
    a,
    n,
    s,
    c,
    u,
    o,
    d,
    p,
    m,
    g,
    h,
    _
  ];
}
f(Lse, "instance$2o");
const FS = class FS extends ie {
  constructor(e) {
    super(), le(this, e, Lse, jse, ne, { document: 5, source: 0 });
  }
};
f(FS, "GenericActorResourceConfigDialog");
let $v = FS;
function GM(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), e.innerHTML = '<i class="fas fa-gear svelte-ca6gzr"></i>', b(e, "class", "resource-setting svelte-ca6gzr");
    },
    m(n, l) {
      T(n, e, l), t || (s = V(
        e,
        "click",
        /*configureResource*/
        i[6]
      ), t = !0);
    },
    p: ee,
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(GM, "create_if_block_3$p");
function zM(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), e.innerHTML = '<i class="fas fa-dice svelte-ca6gzr"></i>', b(e, "class", "resource-setting svelte-ca6gzr"), b(e, "data-tooltip", "Recharge Resource"), b(e, "data-tooltip-direction", "UP");
    },
    m(n, l) {
      T(n, e, l), t || (s = V(
        e,
        "click",
        /*click_handler*/
        i[10]
      ), t = !0);
    },
    p: ee,
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(zM, "create_if_block_2$C");
function HM(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "a5e-button resource-btn fas fa-minus svelte-ca6gzr"), b(e, "type", "button"), e.disabled = t = /*resource*/
      i[0].value === 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "click",
        /*decrementResource*/
        i[8]
      ), s = !0);
    },
    p(l, r) {
      r & /*resource*/
      1 && t !== (t = /*resource*/
      l[0].value === 0) && (e.disabled = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(HM, "create_if_block_1$Y");
function Bse(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("span"), e.textContent = "/", t = R(), s = E("input"), b(e, "class", "resource-seperator"), b(s, "type", "number"), b(s, "name", n = "system.resources." + /*source*/
      i[1] + ".max"), s.value = l = at(
        /*resource*/
        i[0].max ?? 0,
        /*$actor*/
        i[3].getRollData()
      ), b(s, "class", "a5e-input a5e-input--inline-item a5e-input--small resource-number-input svelte-ca6gzr"), b(s, "placeholder", "0"), s.disabled = !0;
    },
    m(r, o) {
      T(r, e, o), T(r, t, o), T(r, s, o);
    },
    p(r, o) {
      o & /*source*/
      2 && n !== (n = "system.resources." + /*source*/
      r[1] + ".max") && b(s, "name", n), o & /*resource, $actor*/
      9 && l !== (l = at(
        /*resource*/
        r[0].max ?? 0,
        /*$actor*/
        r[3].getRollData()
      )) && s.value !== l && (s.value = l);
    },
    d(r) {
      r && (S(e), S(t), S(s));
    }
  };
}
f(Bse, "create_else_block$u");
function qse(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "a5e-button resource-btn fas fa-plus svelte-ca6gzr"), b(e, "type", "button");
    },
    m(n, l) {
      T(n, e, l), t || (s = V(
        e,
        "click",
        /*incrementResource*/
        i[7]
      ), t = !0);
    },
    p: ee,
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(qse, "create_if_block$1q");
function Gse(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k = !/*sheetIsLocked*/
  i[2] && GM(i), v = (
    /*showRechargeButton*/
    i[4] && zM(i)
  ), O = (
    /*resource*/
    i[0].hideMax && HM(i)
  );
  function P(B, F) {
    return (
      /*resource*/
      B[0].hideMax ? qse : Bse
    );
  }
  f(P, "select_block_type");
  let D = P(i), I = D(i);
  return {
    c() {
      e = E("li"), t = E("header"), s = E("input"), o = R(), k && k.c(), a = R(), v && v.c(), c = R(), u = E("div"), O && O.c(), d = R(), p = E("input"), h = R(), I.c(), b(s, "type", "text"), b(s, "name", n = "system.resources." + /*source*/
      i[1] + ".label"), s.value = l = /*resource*/
      i[0].label, b(s, "class", "a5e-input a5e-input--slim resource-label svelte-ca6gzr"), b(s, "placeholder", r = K(`A5E.Resources${/*source*/
      i[1].capitalize()}`)), s.disabled = /*sheetIsLocked*/
      i[2], b(t, "class", "resource-header svelte-ca6gzr"), b(p, "class", "a5e-input a5e-input--inline-item a5e-input--small resource-number-input svelte-ca6gzr"), b(p, "type", "number"), b(p, "name", m = "system.resources." + /*source*/
      i[1] + ".value"), p.value = g = /*resource*/
      i[0].value, b(p, "placeholder", "0"), b(p, "min", "0"), Q(p, "disable-pointer-events", !/*$actor*/
      i[3].isOwner), b(u, "class", "resource-value-container svelte-ca6gzr"), b(e, "class", "resource svelte-ca6gzr");
    },
    m(B, F) {
      T(B, e, F), A(e, t), A(t, s), A(t, o), k && k.m(t, null), A(t, a), v && v.m(t, null), A(e, c), A(e, u), O && O.m(u, null), A(u, d), A(u, p), A(u, h), I.m(u, null), _ || (y = [
        V(
          s,
          "change",
          /*change_handler*/
          i[9]
        ),
        V(
          p,
          "change",
          /*change_handler_1*/
          i[11]
        )
      ], _ = !0);
    },
    p(B, [F]) {
      F & /*source*/
      2 && n !== (n = "system.resources." + /*source*/
      B[1] + ".label") && b(s, "name", n), F & /*resource*/
      1 && l !== (l = /*resource*/
      B[0].label) && s.value !== l && (s.value = l), F & /*source*/
      2 && r !== (r = K(`A5E.Resources${/*source*/
      B[1].capitalize()}`)) && b(s, "placeholder", r), F & /*sheetIsLocked*/
      4 && (s.disabled = /*sheetIsLocked*/
      B[2]), /*sheetIsLocked*/
      B[2] ? k && (k.d(1), k = null) : k ? k.p(B, F) : (k = GM(B), k.c(), k.m(t, a)), /*showRechargeButton*/
      B[4] ? v ? v.p(B, F) : (v = zM(B), v.c(), v.m(t, null)) : v && (v.d(1), v = null), /*resource*/
      B[0].hideMax ? O ? O.p(B, F) : (O = HM(B), O.c(), O.m(u, d)) : O && (O.d(1), O = null), F & /*source*/
      2 && m !== (m = "system.resources." + /*source*/
      B[1] + ".value") && b(p, "name", m), F & /*resource*/
      1 && g !== (g = /*resource*/
      B[0].value) && p.value !== g && (p.value = g), F & /*$actor*/
      8 && Q(p, "disable-pointer-events", !/*$actor*/
      B[3].isOwner), D === (D = P(B)) && I ? I.p(B, F) : (I.d(1), I = D(B), I && (I.c(), I.m(u, null)));
    },
    i: ee,
    o: ee,
    d(B) {
      B && S(e), k && k.d(), v && v.d(), O && O.d(), I.d(), _ = !1, Ne(y);
    }
  };
}
f(Gse, "create_fragment$2w");
function zse(i, e, t) {
  let s, n, l, { resource: r } = e, { source: o } = e;
  const a = fe("actor");
  pe(i, a, (_) => t(3, l = _));
  function c() {
    let _ = l.dialogs.genericResources[o];
    _ || (fl(a, l.dialogs.genericResources[o] = new gn(l, `${l.name}: Generic Resource Dialog`, $v, { source: o }), l), _ = l.dialogs.genericResources[o]), _.render(!0);
  }
  f(c, "configureResource");
  function u() {
    t(0, r.value = Math.max(r.value + 1, 0), r), se(l, `system.resources.${o}.value`, Number(r.value));
  }
  f(u, "incrementResource");
  function d() {
    t(0, r.value = Math.max(r.value - 1, 0), r), se(l, `system.resources.${o}.value`, Number(r.value));
  }
  f(d, "decrementResource");
  function p(_, y) {
    if (!y || r.per !== "recharge")
      return !1;
    if (r.hideMax)
      return !0;
    const k = at(r.max, l.getRollData());
    return r.value < k;
  }
  f(p, "canRecharge");
  const m = /* @__PURE__ */ f(({ target: _ }) => se(l, _.name, _.value), "change_handler"), g = /* @__PURE__ */ f(() => l.rechargeGenericResource(o), "click_handler"), h = /* @__PURE__ */ f(({ target: _ }) => se(l, _.name, Number(_.value)), "change_handler_1");
  return i.$$set = (_) => {
    "resource" in _ && t(0, r = _.resource), "source" in _ && t(1, o = _.source);
  }, i.$$.update = () => {
    var _, y;
    i.$$.dirty & /*resource*/
    1 && t(0, r), i.$$.dirty & /*$actor*/
    8 && t(2, s = l.isOwner ? ((y = (_ = l.flags) == null ? void 0 : _.a5e) == null ? void 0 : y.sheetIsLocked) ?? !0 : !0), i.$$.dirty & /*$actor, sheetIsLocked*/
    12 && t(4, n = p(l, s));
  }, [
    r,
    o,
    s,
    l,
    n,
    a,
    c,
    u,
    d,
    m,
    g,
    h
  ];
}
f(zse, "instance$2n");
const NS = class NS extends ie {
  constructor(e) {
    super(), le(this, e, zse, Gse, ne, { resource: 0, source: 1 });
  }
};
f(NS, "GenericActorResource");
let Av = NS;
const Mi = It({ Alt: !1, Control: !1, Shift: !1 });
function Bi(i, { reverseAlt: e = !1 } = {}) {
  const { Shift: t, Control: s, Alt: n } = i, l = game.settings.get("a5e", "reverseAltBehavior");
  let r = t ? CONFIG.A5E.ROLL_MODE.ADVANTAGE : CONFIG.A5E.ROLL_MODE.NORMAL;
  r = s ? CONFIG.A5E.ROLL_MODE.DISADVANTAGE : r;
  let o = l ? !n : n;
  return o = e ? !o : o, {
    skipRollDialog: o,
    rollMode: r
  };
}
f(Bi, "getKeyPressAsOptions");
function UM(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("div"), t = E("i"), b(t, "class", "track-icon track-icon--description-button fa-regular fa-file-lines svelte-3xt71t"), b(t, "data-tooltip", s = `Share ${/*action*/
      i[0] ? "Action" : "Item"} Description`), b(t, "data-tooltip-direction", "UP"), b(e, "class", "track svelte-3xt71t");
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = V(t, "click", We(
        /*showDescription*/
        i[5]
      )), n = !0);
    },
    p(r, o) {
      o & /*action*/
      1 && s !== (s = `Share ${/*action*/
      r[0] ? "Action" : "Item"} Description`) && b(t, "data-tooltip", s);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(UM, "create_if_block_1$X");
function VM(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g;
  return {
    c() {
      e = E("div"), t = E("i"), s = R(), n = E("ul"), l = E("li"), r = E("button"), o = R(), a = E("li"), c = E("button"), u = R(), d = E("li"), p = E("button"), b(t, "class", "track-icon fa-solid fa-ellipsis-vertical svelte-3xt71t"), b(r, "class", "action-button fas fa-cog svelte-3xt71t"), b(r, "data-tooltip", "A5E.ButtonToolTipConfigure"), b(r, "data-tooltip-direction", "UP"), b(c, "class", "action-button fa-solid fa-clone svelte-3xt71t"), b(c, "data-tooltip", "A5E.ButtonToolTipDuplicate"), b(c, "data-tooltip-direction", "UP"), b(p, "class", "action-button delete-button fas fa-trash svelte-3xt71t"), b(p, "data-tooltip", "A5E.ButtonToolTipDelete"), b(p, "data-tooltip-direction", "UP"), b(n, "class", "track-items svelte-3xt71t"), b(e, "class", "track svelte-3xt71t");
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(e, s), A(e, n), A(n, l), A(l, r), A(n, o), A(n, a), A(a, c), A(n, u), A(n, d), A(d, p), m || (g = [
        V(r, "click", We(
          /*onConfigure*/
          i[2]
        )),
        V(c, "click", We(
          /*onDuplicate*/
          i[4]
        )),
        V(p, "click", We(
          /*onDelete*/
          i[3]
        )),
        V(e, "click", We(
          /*click_handler*/
          i[9]
        ))
      ], m = !0);
    },
    p: ee,
    d(h) {
      h && S(e), m = !1, Ne(g);
    }
  };
}
f(VM, "create_if_block$1p");
function Hse(i) {
  let e, t, s = (
    /*sheetIsLocked*/
    i[1] && UM(i)
  ), n = !/*sheetIsLocked*/
  i[1] && VM(i);
  return {
    c() {
      s && s.c(), e = R(), n && n.c(), t = $e();
    },
    m(l, r) {
      s && s.m(l, r), T(l, e, r), n && n.m(l, r), T(l, t, r);
    },
    p(l, [r]) {
      /*sheetIsLocked*/
      l[1] ? s ? s.p(l, r) : (s = UM(l), s.c(), s.m(e.parentNode, e)) : s && (s.d(1), s = null), /*sheetIsLocked*/
      l[1] ? n && (n.d(1), n = null) : n ? n.p(l, r) : (n = VM(l), n.c(), n.m(t.parentNode, t));
    },
    i: ee,
    o: ee,
    d(l) {
      l && (S(e), S(t)), s && s.d(l), n && n.d(l);
    }
  };
}
f(Hse, "create_fragment$2v");
function Use(i, e, t) {
  let s, n, { item: l } = e, { action: r = null } = e;
  async function o() {
    if (r) {
      await l.actions.configure(r);
      return;
    }
    l.configureItem();
  }
  f(o, "onConfigure");
  async function a() {
    let m;
    if (r) {
      await l.actions.remove(r);
      return;
    }
    if (!game.settings.get("a5e", "hideDeleteConfirmation")) {
      const g = new Rc(l);
      if (await g.render(!0), m = await g.promise, !m || !m.confirmDeletion)
        return;
    }
    await game.settings.set("a5e", "hideDeleteConfirmation", (m == null ? void 0 : m.hideDeleteConfirmation) ?? game.settings.get("a5e", "hideDeleteConfirmation")), l.delete();
  }
  f(a, "onDelete");
  async function c() {
    if (r) {
      await l.actions.duplicate(r);
      return;
    }
    l.duplicateItem();
  }
  f(c, "onDuplicate");
  function u() {
    l.shareItemDescription(l.actions.get(r));
  }
  f(u, "showDescription");
  const d = fe("actor");
  pe(i, d, (m) => t(8, n = m));
  function p(m) {
    gt.call(this, i, m);
  }
  return f(p, "click_handler"), i.$$set = (m) => {
    "item" in m && t(7, l = m.item), "action" in m && t(0, r = m.action);
  }, i.$$.update = () => {
    var m, g;
    i.$$.dirty & /*$actor*/
    256 && t(1, s = n.isOwner ? ((g = (m = n.flags) == null ? void 0 : m.a5e) == null ? void 0 : g.sheetIsLocked) ?? !0 : !0);
  }, [
    r,
    s,
    o,
    a,
    c,
    u,
    d,
    l,
    n,
    p
  ];
}
f(Use, "instance$2m");
const jS = class jS extends ie {
  constructor(e) {
    super(), le(this, e, Use, Hse, ne, { item: 7, action: 0 });
  }
};
f(jS, "ItemActionButtons");
let Ev = jS;
function WM(i, e, t) {
  const s = i.slice();
  return s[38] = e[t].name, s[39] = e[t].id, s;
}
f(WM, "get_each_context$W");
function KM(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), t = x(
        /*activationCost*/
        i[3]
      ), b(e, "class", "action-button action-button--activation-cost svelte-5ppn6e"), b(
        e,
        "data-tooltip",
        /*activationCostLabel*/
        i[6]
      ), b(e, "data-tooltip-direction", "UP");
    },
    m(l, r) {
      T(l, e, r), A(e, t), s || (n = V(e, "auxclick", We(
        /*onConfigure*/
        i[14]
      )), s = !0);
    },
    p(l, r) {
      r[0] & /*activationCost*/
      8 && _e(
        t,
        /*activationCost*/
        l[3]
      ), r[0] & /*activationCostLabel*/
      64 && b(
        e,
        "data-tooltip",
        /*activationCostLabel*/
        l[6]
      );
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(KM, "create_if_block_22");
function YM(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "action-button action-button--stance fa-solid fa-street-view svelte-5ppn6e"), b(e, "data-tooltip", "A5E.ManeuverIsStance"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(YM, "create_if_block_21");
function XM(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "action-button action-button--bloodied fa-solid fa-droplet svelte-5ppn6e"), b(e, "data-tooltip", "A5E.RequiresBloodied"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(XM, "create_if_block_20");
function JM(i) {
  let e, t, s, n = [], l = /* @__PURE__ */ new Map(), r, o, a, c = oe(
    /*ammunitionItems*/
    i[8]
  );
  const u = /* @__PURE__ */ f((d) => (
    /*id*/
    d[39]
  ), "get_key");
  for (let d = 0; d < c.length; d += 1) {
    let p = WM(i, c, d), m = u(p);
    l.set(m, n[d] = ZM(m, p));
  }
  return {
    c() {
      e = E("select"), t = E("option");
      for (let d = 0; d < n.length; d += 1)
        n[d].c();
      t.__value = "", qe(t, t.__value), t.selected = s = /*selectedAmmo*/
      i[5] === "", b(e, "id", r = /*$actor*/
      i[4].id + "-" + /*item*/
      i[0].id + "-ammunition"), b(e, "class", "ammunition-selector svelte-5ppn6e");
    },
    m(d, p) {
      T(d, e, p), A(e, t);
      for (let m = 0; m < n.length; m += 1)
        n[m] && n[m].m(e, null);
      o || (a = [
        V(t, "click", We(
          /*click_handler_1*/
          i[29]
        )),
        V(e, "click", We(
          /*click_handler*/
          i[27]
        )),
        V(
          e,
          "change",
          /*updateAmmunition*/
          i[11]
        )
      ], o = !0);
    },
    p(d, p) {
      p[0] & /*selectedAmmo*/
      32 && s !== (s = /*selectedAmmo*/
      d[5] === "") && (t.selected = s), p[0] & /*ammunitionItems, selectedAmmo*/
      288 && (c = oe(
        /*ammunitionItems*/
        d[8]
      ), n = kt(n, p, u, 1, d, c, l, e, vs, ZM, null, WM)), p[0] & /*$actor, item*/
      17 && r !== (r = /*$actor*/
      d[4].id + "-" + /*item*/
      d[0].id + "-ammunition") && b(e, "id", r);
    },
    d(d) {
      d && S(e);
      for (let p = 0; p < n.length; p += 1)
        n[p].d();
      o = !1, Ne(a);
    }
  };
}
f(JM, "create_if_block_19");
function ZM(i, e) {
  let t, s = (
    /*name*/
    e[38] + ""
  ), n, l, r, o, a, c;
  return {
    key: i,
    first: null,
    c() {
      t = E("option"), n = x(s), l = R(), t.__value = r = /*id*/
      e[39], qe(t, t.__value), t.selected = o = /*selectedAmmo*/
      e[5] === /*id*/
      e[39], this.first = t;
    },
    m(u, d) {
      T(u, t, d), A(t, n), A(t, l), a || (c = V(t, "click", We(
        /*click_handler_2*/
        e[28]
      )), a = !0);
    },
    p(u, d) {
      e = u, d[0] & /*ammunitionItems*/
      256 && s !== (s = /*name*/
      e[38] + "") && _e(n, s), d[0] & /*ammunitionItems*/
      256 && r !== (r = /*id*/
      e[39]) && (t.__value = r, qe(t, t.__value)), d[0] & /*selectedAmmo, ammunitionItems*/
      288 && o !== (o = /*selectedAmmo*/
      e[5] === /*id*/
      e[39]) && (t.selected = o);
    },
    d(u) {
      u && S(t), a = !1, c();
    }
  };
}
f(ZM, "create_each_block$W");
function Vse(i) {
  let e, t, s = (
    /*hasRecharge*/
    i[12](
      /*item*/
      i[0]
    )
  ), n = s && QM(i);
  return {
    c() {
      e = E("div"), t = E("div"), n && n.c(), b(t, "class", "button-wrapper svelte-5ppn6e"), b(e, "class", "indicator-container");
    },
    m(l, r) {
      T(l, e, r), A(e, t), n && n.m(t, null);
    },
    p(l, r) {
      r[0] & /*item*/
      1 && (s = /*hasRecharge*/
      l[12](
        /*item*/
        l[0]
      )), s ? n ? n.p(l, r) : (n = QM(l), n.c(), n.m(t, null)) : n && (n.d(1), n = null);
    },
    d(l) {
      l && S(e), n && n.d();
    }
  };
}
f(Vse, "create_else_block$t");
function Wse(i) {
  var h;
  let e, t, s, n, l, r, o, a = (
    /*hasRecharge*/
    i[12](
      /*item*/
      i[0]
    )
  ), c = (
    /*item*/
    i[0].type === "spell" && xM(i)
  ), u = (
    /*item*/
    (i[0].type === "feature" || /*item*/
    i[0].type === "maneuver") && l6(i)
  ), d = (
    /*flags*/
    (((h = i[10].a5e) == null ? void 0 : h.showFavoritesSection) ?? !0) && o6(i)
  ), p = (
    /*item*/
    i[0].type === "object" && a6(i)
  ), m = (
    /*item*/
    i[0].type === "spell" && f6(i)
  ), g = a && d6(i);
  return {
    c() {
      e = E("div"), c && c.c(), t = R(), u && u.c(), s = R(), n = E("div"), d && d.c(), l = R(), p && p.c(), r = R(), m && m.c(), o = R(), g && g.c(), b(n, "class", "button-wrapper svelte-5ppn6e"), b(e, "class", "indicator-wrapper svelte-5ppn6e");
    },
    m(_, y) {
      T(_, e, y), c && c.m(e, null), A(e, t), u && u.m(e, null), A(e, s), A(e, n), d && d.m(n, null), A(n, l), p && p.m(n, null), A(n, r), m && m.m(n, null), A(n, o), g && g.m(n, null);
    },
    p(_, y) {
      var k;
      /*item*/
      _[0].type === "spell" ? c ? c.p(_, y) : (c = xM(_), c.c(), c.m(e, t)) : c && (c.d(1), c = null), /*item*/
      _[0].type === "feature" || /*item*/
      _[0].type === "maneuver" ? u ? u.p(_, y) : (u = l6(_), u.c(), u.m(e, s)) : u && (u.d(1), u = null), /*flags*/
      ((k = _[10].a5e) == null ? void 0 : k.showFavoritesSection) ?? !0 ? d ? d.p(_, y) : (d = o6(_), d.c(), d.m(n, l)) : d && (d.d(1), d = null), /*item*/
      _[0].type === "object" ? p ? p.p(_, y) : (p = a6(_), p.c(), p.m(n, r)) : p && (p.d(1), p = null), /*item*/
      _[0].type === "spell" ? m ? m.p(_, y) : (m = f6(_), m.c(), m.m(n, o)) : m && (m.d(1), m = null), y[0] & /*item*/
      1 && (a = /*hasRecharge*/
      _[12](
        /*item*/
        _[0]
      )), a ? g ? g.p(_, y) : (g = d6(_), g.c(), g.m(n, null)) : g && (g.d(1), g = null);
    },
    d(_) {
      _ && S(e), c && c.d(), u && u.d(), d && d.d(), p && p.d(), m && m.d(), g && g.d();
    }
  };
}
f(Wse, "create_if_block_2$B");
function QM(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "action-button fas fa-dice svelte-5ppn6e"), b(e, "data-tooltip", t = /*rechargeState*/
      i[7] ? "A5E.ButtonToolTipCharged" : "A5E.ButtonToolTipRecharge"), b(e, "data-tooltip-direction", "UP"), Q(
        e,
        "active",
        /*rechargeState*/
        i[7]
      );
    },
    m(l, r) {
      T(l, e, r), s || (n = V(e, "click", We(
        /*click_handler_12*/
        i[36]
      )), s = !0);
    },
    p(l, r) {
      r[0] & /*rechargeState*/
      128 && t !== (t = /*rechargeState*/
      l[7] ? "A5E.ButtonToolTipCharged" : "A5E.ButtonToolTipRecharge") && b(e, "data-tooltip", t), r[0] & /*rechargeState*/
      128 && Q(
        e,
        "active",
        /*rechargeState*/
        l[7]
      );
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(QM, "create_if_block_18");
function xM(i) {
  let e, t, s, n, l, r = (
    /*item*/
    i[0].system.components.vocalized && e6()
  ), o = (
    /*item*/
    i[0].system.components.seen && t6()
  ), a = (
    /*item*/
    i[0].system.components.material && s6()
  ), c = (
    /*item*/
    i[0].system.concentration && n6()
  ), u = (
    /*item*/
    i[0].system.ritual && i6()
  );
  return {
    c() {
      e = E("div"), r && r.c(), t = R(), o && o.c(), s = R(), a && a.c(), n = R(), c && c.c(), l = R(), u && u.c(), b(e, "class", "component-wrapper svelte-5ppn6e");
    },
    m(d, p) {
      T(d, e, p), r && r.m(e, null), A(e, t), o && o.m(e, null), A(e, s), a && a.m(e, null), A(e, n), c && c.m(e, null), A(e, l), u && u.m(e, null);
    },
    p(d, p) {
      /*item*/
      d[0].system.components.vocalized ? r || (r = e6(), r.c(), r.m(e, t)) : r && (r.d(1), r = null), /*item*/
      d[0].system.components.seen ? o || (o = t6(), o.c(), o.m(e, s)) : o && (o.d(1), o = null), /*item*/
      d[0].system.components.material ? a || (a = s6(), a.c(), a.m(e, n)) : a && (a.d(1), a = null), /*item*/
      d[0].system.concentration ? c || (c = n6(), c.c(), c.m(e, l)) : c && (c.d(1), c = null), /*item*/
      d[0].system.ritual ? u || (u = i6(), u.c(), u.m(e, null)) : u && (u.d(1), u = null);
    },
    d(d) {
      d && S(e), r && r.d(), o && o.d(), a && a.d(), c && c.d(), u && u.d();
    }
  };
}
f(xM, "create_if_block_12$2");
function e6(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellComponentVocalizedAbbr")}`, b(e, "class", "component svelte-5ppn6e"), b(e, "data-tooltip", "A5E.SpellComponentVocalized"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(e6, "create_if_block_17");
function t6(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellComponentSeenAbbr")}`, b(e, "class", "component svelte-5ppn6e"), b(e, "data-tooltip", "A5E.SpellComponentSeen"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(t6, "create_if_block_16");
function s6(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellComponentMaterialAbbr")}`, b(e, "class", "component svelte-5ppn6e"), b(e, "data-tooltip", "A5E.SpellComponentMaterial"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(s6, "create_if_block_15");
function n6(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellConcentrationAbbr")}`, b(e, "class", "component svelte-5ppn6e"), b(e, "data-tooltip", "A5E.SpellConcentration"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(n6, "create_if_block_14");
function i6(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellRitualAbbr")}`, b(e, "class", "component svelte-5ppn6e"), b(e, "data-tooltip", "A5E.SpellRitual"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(i6, "create_if_block_13$1");
function l6(i) {
  let e, t = (
    /*item*/
    i[0].system.concentration && r6()
  );
  return {
    c() {
      e = E("div"), t && t.c(), b(e, "class", "component-wrapper svelte-5ppn6e");
    },
    m(s, n) {
      T(s, e, n), t && t.m(e, null);
    },
    p(s, n) {
      /*item*/
      s[0].system.concentration ? t || (t = r6(), t.c(), t.m(e, null)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && S(e), t && t.d();
    }
  };
}
f(l6, "create_if_block_10$3");
function r6(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellConcentrationAbbr")}`, b(e, "class", "component svelte-5ppn6e"), b(e, "data-tooltip", "A5E.SpellConcentration"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(r6, "create_if_block_11$2");
function o6(i) {
  let e, t, s;
  return {
    c() {
      var n;
      e = E("button"), b(e, "class", "action-button fas fa-star svelte-5ppn6e"), b(e, "data-tooltip", "A5E.ButtonToolTipFavorite"), b(e, "data-tooltip-direction", "UP"), Q(
        e,
        "active",
        /*item*/
        ((n = i[0].system) == null ? void 0 : n.favorite) ?? !1
      );
    },
    m(n, l) {
      T(n, e, l), t || (s = V(e, "click", We(
        /*click_handler_6*/
        i[30]
      )), t = !0);
    },
    p(n, l) {
      var r;
      l[0] & /*item*/
      1 && Q(
        e,
        "active",
        /*item*/
        ((r = n[0].system) == null ? void 0 : r.favorite) ?? !1
      );
    },
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(o6, "create_if_block_9$6");
function a6(i) {
  var o;
  let e, t, s, n = (
    /*item*/
    i[0].system.requiresAttunement && c6(i)
  ), l = !/*item*/
  ((o = i[0].system) != null && o.containerId) && u6(i), r = !/*hideBrokenAndDamaged*/
  i[22] && Kse(i);
  return {
    c() {
      n && n.c(), e = R(), l && l.c(), t = R(), r && r.c(), s = $e();
    },
    m(a, c) {
      n && n.m(a, c), T(a, e, c), l && l.m(a, c), T(a, t, c), r && r.m(a, c), T(a, s, c);
    },
    p(a, c) {
      var u;
      /*item*/
      a[0].system.requiresAttunement ? n ? n.p(a, c) : (n = c6(a), n.c(), n.m(e.parentNode, e)) : n && (n.d(1), n = null), /*item*/
      (u = a[0].system) != null && u.containerId ? l && (l.d(1), l = null) : l ? l.p(a, c) : (l = u6(a), l.c(), l.m(t.parentNode, t)), /*hideBrokenAndDamaged*/
      a[22] || r.p(a, c);
    },
    d(a) {
      a && (S(e), S(t), S(s)), n && n.d(a), l && l.d(a), r && r.d(a);
    }
  };
}
f(a6, "create_if_block_5$d");
function c6(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "action-button fa-solid fa-link svelte-5ppn6e"), b(e, "data-tooltip", t = /*item*/
      i[0].system.attuned ? K("A5E.ButtonToolTipBreakAttunement", { item: (
        /*item*/
        i[0].name
      ) }) : K("A5E.ButtonToolTipAttune", { item: (
        /*item*/
        i[0].name
      ) })), b(e, "data-tooltip-direction", "UP"), Q(
        e,
        "active",
        /*item*/
        i[0].system.attuned
      );
    },
    m(l, r) {
      T(l, e, r), s || (n = V(e, "click", We(
        /*click_handler_7*/
        i[31]
      )), s = !0);
    },
    p(l, r) {
      r[0] & /*item*/
      1 && t !== (t = /*item*/
      l[0].system.attuned ? K("A5E.ButtonToolTipBreakAttunement", { item: (
        /*item*/
        l[0].name
      ) }) : K("A5E.ButtonToolTipAttune", { item: (
        /*item*/
        l[0].name
      ) })) && b(e, "data-tooltip", t), r[0] & /*item*/
      1 && Q(
        e,
        "active",
        /*item*/
        l[0].system.attuned
      );
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(c6, "create_if_block_8$6");
function u6(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "action-button fas svelte-5ppn6e"), b(e, "data-tooltip", t = /*equippedStates*/
      i[18][
        /*item*/
        i[0].system.equippedState ?? 0
      ]), b(e, "data-tooltip-direction", "UP"), Q(
        e,
        "fa-shield-alt",
        /*item*/
        i[0].system.equippedState === /*EQUIPPED_STATES*/
        i[19].EQUIPPED
      ), Q(
        e,
        "fa-person-carry-box",
        /*item*/
        i[0].system.equippedState === /*EQUIPPED_STATES*/
        i[19].CARRIED
      ), Q(
        e,
        "fa-tents",
        /*item*/
        i[0].system.equippedState === /*EQUIPPED_STATES*/
        i[19].NOT_CARRIED
      ), Q(e, "active", [
        /*EQUIPPED_STATES*/
        i[19].EQUIPPED,
        /*EQUIPPED_STATES*/
        i[19].CARRIED
      ].includes(
        /*item*/
        i[0].system.equippedState
      ));
    },
    m(l, r) {
      T(l, e, r), s || (n = V(e, "click", We(
        /*click_handler_8*/
        i[32]
      )), s = !0);
    },
    p(l, r) {
      r[0] & /*item*/
      1 && t !== (t = /*equippedStates*/
      l[18][
        /*item*/
        l[0].system.equippedState ?? 0
      ]) && b(e, "data-tooltip", t), r[0] & /*item, EQUIPPED_STATES*/
      524289 && Q(
        e,
        "fa-shield-alt",
        /*item*/
        l[0].system.equippedState === /*EQUIPPED_STATES*/
        l[19].EQUIPPED
      ), r[0] & /*item, EQUIPPED_STATES*/
      524289 && Q(
        e,
        "fa-person-carry-box",
        /*item*/
        l[0].system.equippedState === /*EQUIPPED_STATES*/
        l[19].CARRIED
      ), r[0] & /*item, EQUIPPED_STATES*/
      524289 && Q(
        e,
        "fa-tents",
        /*item*/
        l[0].system.equippedState === /*EQUIPPED_STATES*/
        l[19].NOT_CARRIED
      ), r[0] & /*EQUIPPED_STATES, item*/
      524289 && Q(e, "active", [
        /*EQUIPPED_STATES*/
        l[19].EQUIPPED,
        /*EQUIPPED_STATES*/
        l[19].CARRIED
      ].includes(
        /*item*/
        l[0].system.equippedState
      ));
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(u6, "create_if_block_7$8");
function Kse(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "action-button fas svelte-5ppn6e"), b(e, "data-tooltip", t = /*damagedStates*/
      i[16][
        /*item*/
        i[0].system.damagedState ?? 0
      ]), b(e, "data-tooltip-direction", "UP"), Q(
        e,
        "fa-heart",
        /*item*/
        i[0].system.damagedState === /*DAMAGED_STATES*/
        i[17].INTACT
      ), Q(
        e,
        "fa-heart-crack",
        /*item*/
        i[0].system.damagedState === /*DAMAGED_STATES*/
        i[17].DAMAGED
      ), Q(
        e,
        "fa-heart-pulse",
        /*item*/
        i[0].system.damagedState === /*DAMAGED_STATES*/
        i[17].BROKEN
      ), Q(e, "active", [
        /*DAMAGED_STATES*/
        i[17].DAMAGED,
        /*DAMAGED_STATES*/
        i[17].BROKEN
      ].includes(
        /*item*/
        i[0].system.damagedState
      ));
    },
    m(l, r) {
      T(l, e, r), s || (n = V(e, "click", We(
        /*click_handler_9*/
        i[33]
      )), s = !0);
    },
    p(l, r) {
      r[0] & /*item*/
      1 && t !== (t = /*damagedStates*/
      l[16][
        /*item*/
        l[0].system.damagedState ?? 0
      ]) && b(e, "data-tooltip", t), r[0] & /*item, DAMAGED_STATES*/
      131073 && Q(
        e,
        "fa-heart",
        /*item*/
        l[0].system.damagedState === /*DAMAGED_STATES*/
        l[17].INTACT
      ), r[0] & /*item, DAMAGED_STATES*/
      131073 && Q(
        e,
        "fa-heart-crack",
        /*item*/
        l[0].system.damagedState === /*DAMAGED_STATES*/
        l[17].DAMAGED
      ), r[0] & /*item, DAMAGED_STATES*/
      131073 && Q(
        e,
        "fa-heart-pulse",
        /*item*/
        l[0].system.damagedState === /*DAMAGED_STATES*/
        l[17].BROKEN
      ), r[0] & /*DAMAGED_STATES, item*/
      131073 && Q(e, "active", [
        /*DAMAGED_STATES*/
        l[17].DAMAGED,
        /*DAMAGED_STATES*/
        l[17].BROKEN
      ].includes(
        /*item*/
        l[0].system.damagedState
      ));
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Kse, "create_if_block_6$c");
function f6(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "action-button fas svelte-5ppn6e"), b(e, "data-tooltip", t = /*preparedStates*/
      i[20][Number(
        /*item*/
        i[0].system.prepared ?? 0
      )]), b(e, "data-tooltip-direction", "UP"), Q(e, "fa-book", [
        /*PREPARED_STATES*/
        i[21].UNPREPARED,
        /*PREPARED_STATES*/
        i[21].PREPARED
      ].includes(Number(
        /*item*/
        i[0].system.prepared ?? 0
      ))), Q(e, "fa-book-sparkles", Number(
        /*item*/
        i[0].system.prepared ?? 0
      ) === /*PREPARED_STATES*/
      i[21].ALWAYS_PREPARED), Q(e, "active", [
        /*PREPARED_STATES*/
        i[21].PREPARED,
        /*PREPARED_STATES*/
        i[21].ALWAYS_PREPARED
      ].includes(Number(
        /*item*/
        i[0].system.prepared ?? 0
      )));
    },
    m(l, r) {
      T(l, e, r), s || (n = V(e, "click", We(
        /*click_handler_10*/
        i[34]
      )), s = !0);
    },
    p(l, r) {
      r[0] & /*item*/
      1 && t !== (t = /*preparedStates*/
      l[20][Number(
        /*item*/
        l[0].system.prepared ?? 0
      )]) && b(e, "data-tooltip", t), r[0] & /*PREPARED_STATES, item*/
      2097153 && Q(e, "fa-book", [
        /*PREPARED_STATES*/
        l[21].UNPREPARED,
        /*PREPARED_STATES*/
        l[21].PREPARED
      ].includes(Number(
        /*item*/
        l[0].system.prepared ?? 0
      ))), r[0] & /*item, PREPARED_STATES*/
      2097153 && Q(e, "fa-book-sparkles", Number(
        /*item*/
        l[0].system.prepared ?? 0
      ) === /*PREPARED_STATES*/
      l[21].ALWAYS_PREPARED), r[0] & /*PREPARED_STATES, item*/
      2097153 && Q(e, "active", [
        /*PREPARED_STATES*/
        l[21].PREPARED,
        /*PREPARED_STATES*/
        l[21].ALWAYS_PREPARED
      ].includes(Number(
        /*item*/
        l[0].system.prepared ?? 0
      )));
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(f6, "create_if_block_4$k");
function d6(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "action-button fas fa-dice svelte-5ppn6e"), b(e, "data-tooltip", t = /*rechargeState*/
      i[7] ? "A5E.ButtonToolTipCharged" : "A5E.ButtonToolTipRecharge"), b(e, "data-tooltip-direction", "UP"), Q(
        e,
        "active",
        /*rechargeState*/
        i[7]
      );
    },
    m(l, r) {
      T(l, e, r), s || (n = V(e, "click", We(
        /*click_handler_11*/
        i[35]
      )), s = !0);
    },
    p(l, r) {
      r[0] & /*rechargeState*/
      128 && t !== (t = /*rechargeState*/
      l[7] ? "A5E.ButtonToolTipCharged" : "A5E.ButtonToolTipRecharge") && b(e, "data-tooltip", t), r[0] & /*rechargeState*/
      128 && Q(
        e,
        "active",
        /*rechargeState*/
        l[7]
      );
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(d6, "create_if_block_3$o");
function p6(i) {
  let e, t, s, n, l, r;
  return {
    c() {
      e = E("div"), t = E("input"), b(t, "class", "number-input svelte-5ppn6e"), b(t, "id", s = /*actor*/
      i[15].id + "-" + /*item*/
      i[0].id + "-quantity"), b(t, "type", "number"), b(t, "name", "system.quantity"), t.value = n = /*item*/
      i[0].system.quantity, b(t, "min", "0"), b(e, "class", "quantity-wrapper svelte-5ppn6e");
    },
    m(o, a) {
      T(o, e, a), A(e, t), l || (r = [
        V(t, "click", We(
          /*click_handler_3*/
          i[26]
        )),
        V(
          t,
          "change",
          /*updateField*/
          i[13]
        )
      ], l = !0);
    },
    p(o, a) {
      a[0] & /*item*/
      1 && s !== (s = /*actor*/
      o[15].id + "-" + /*item*/
      o[0].id + "-quantity") && b(t, "id", s), a[0] & /*item*/
      1 && n !== (n = /*item*/
      o[0].system.quantity) && t.value !== n && (t.value = n);
    },
    d(o) {
      o && S(e), l = !1, Ne(r);
    }
  };
}
f(p6, "create_if_block_1$W");
function m6(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g;
  return {
    c() {
      e = E("div"), t = E("input"), o = R(), a = E("span"), a.textContent = "/", c = R(), u = E("input"), b(t, "class", "number-input svelte-5ppn6e"), b(t, "id", s = /*actor*/
      i[15].id + "-" + /*item*/
      i[0].id + "-current-uses"), b(t, "type", "number"), b(t, "name", n = /*uses*/
      i[9][
        /*usesType*/
        i[23]
      ].updatePath + ".value"), t.value = l = /*uses*/
      i[9][
        /*usesType*/
        i[23]
      ].value, b(t, "min", "0"), b(t, "max", r = /*uses*/
      i[9][
        /*usesType*/
        i[23]
      ].max), b(u, "class", "number-input svelte-5ppn6e"), b(u, "type", "number"), b(u, "name", d = /*uses*/
      i[9][
        /*usesType*/
        i[23]
      ].updatePath + ".max"), u.value = p = /*uses*/
      i[9][
        /*usesType*/
        i[23]
      ].max, u.disabled = !0, b(e, "class", "uses-wrapper svelte-5ppn6e");
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(e, o), A(e, a), A(e, c), A(e, u), m || (g = [
        V(t, "click", We(
          /*click_handler_4*/
          i[25]
        )),
        V(
          t,
          "change",
          /*updateField*/
          i[13]
        ),
        V(u, "click", We(
          /*click_handler_5*/
          i[24]
        ))
      ], m = !0);
    },
    p(h, _) {
      _[0] & /*item*/
      1 && s !== (s = /*actor*/
      h[15].id + "-" + /*item*/
      h[0].id + "-current-uses") && b(t, "id", s), _[0] & /*uses*/
      512 && n !== (n = /*uses*/
      h[9][
        /*usesType*/
        h[23]
      ].updatePath + ".value") && b(t, "name", n), _[0] & /*uses*/
      512 && l !== (l = /*uses*/
      h[9][
        /*usesType*/
        h[23]
      ].value) && t.value !== l && (t.value = l), _[0] & /*uses*/
      512 && r !== (r = /*uses*/
      h[9][
        /*usesType*/
        h[23]
      ].max) && b(t, "max", r), _[0] & /*uses*/
      512 && d !== (d = /*uses*/
      h[9][
        /*usesType*/
        h[23]
      ].updatePath + ".max") && b(u, "name", d), _[0] & /*uses*/
      512 && p !== (p = /*uses*/
      h[9][
        /*usesType*/
        h[23]
      ].max) && u.value !== p && (u.value = p);
    },
    d(h) {
      h && S(e), m = !1, Ne(g);
    }
  };
}
f(m6, "create_if_block$1o");
function Yse(i) {
  var I, B, F, H, G, U;
  let e, t, s = (
    /*action*/
    (((I = i[1]) == null ? void 0 : I.name) ?? /*item*/
    i[0].name) + ""
  ), n, l, r, o, a, c = Uf(
    /*item*/
    i[0],
    /*action*/
    i[1]
  ), u, d, p, m, g = (
    /*activationCost*/
    i[3] && /*item*/
    (((B = i[0].actions) == null ? void 0 : B.count) === 1 || /*action*/
    i[1]) && KM(i)
  ), h = !/*action*/
  i[1] && /*item*/
  i[0].system.isStance && YM(), _ = !/*action*/
  i[1] && /*item*/
  i[0].system.requiresBloodied && XM(), y = c && JM(i);
  function k(q, W) {
    return (
      /*action*/
      q[1] ? Vse : Wse
    );
  }
  f(k, "select_block_type");
  let v = k(i), O = v(i), P = !/*actionId*/
  i[2] && /*item*/
  ((F = i[0]) == null ? void 0 : F.type) === "object" && p6(i), D = (!/*actionId*/
  i[2] && /*item*/
  ((G = (H = i[0].system) == null ? void 0 : H.uses) == null ? void 0 : G.max) || /*action*/
  i[1] && /*action*/
  ((U = i[1].uses) == null ? void 0 : U.max)) && m6(i);
  return {
    c() {
      e = E("div"), t = E("div"), n = x(s), l = R(), g && g.c(), r = R(), h && h.c(), o = R(), _ && _.c(), a = R(), y && y.c(), u = R(), O.c(), d = R(), P && P.c(), p = R(), D && D.c(), m = $e(), b(t, "class", "name svelte-5ppn6e"), b(e, "class", "name-wrapper svelte-5ppn6e"), Q(e, "name-wrapper--ammunition", Uf(
        /*item*/
        i[0],
        /*action*/
        i[1]
      ));
    },
    m(q, W) {
      T(q, e, W), A(e, t), A(t, n), A(t, l), g && g.m(t, null), A(t, r), h && h.m(t, null), A(t, o), _ && _.m(t, null), A(e, a), y && y.m(e, null), T(q, u, W), O.m(q, W), T(q, d, W), P && P.m(q, W), T(q, p, W), D && D.m(q, W), T(q, m, W);
    },
    p(q, W) {
      var X, te, J, re, ae, be;
      W[0] & /*action, item*/
      3 && s !== (s = /*action*/
      (((X = q[1]) == null ? void 0 : X.name) ?? /*item*/
      q[0].name) + "") && _e(n, s), /*activationCost*/
      q[3] && /*item*/
      (((te = q[0].actions) == null ? void 0 : te.count) === 1 || /*action*/
      q[1]) ? g ? g.p(q, W) : (g = KM(q), g.c(), g.m(t, r)) : g && (g.d(1), g = null), !/*action*/
      q[1] && /*item*/
      q[0].system.isStance ? h || (h = YM(), h.c(), h.m(t, o)) : h && (h.d(1), h = null), !/*action*/
      q[1] && /*item*/
      q[0].system.requiresBloodied ? _ || (_ = XM(), _.c(), _.m(t, null)) : _ && (_.d(1), _ = null), W[0] & /*item, action*/
      3 && (c = Uf(
        /*item*/
        q[0],
        /*action*/
        q[1]
      )), c ? y ? y.p(q, W) : (y = JM(q), y.c(), y.m(e, null)) : y && (y.d(1), y = null), W[0] & /*item, action*/
      3 && Q(e, "name-wrapper--ammunition", Uf(
        /*item*/
        q[0],
        /*action*/
        q[1]
      )), v === (v = k(q)) && O ? O.p(q, W) : (O.d(1), O = v(q), O && (O.c(), O.m(d.parentNode, d))), !/*actionId*/
      q[2] && /*item*/
      ((J = q[0]) == null ? void 0 : J.type) === "object" ? P ? P.p(q, W) : (P = p6(q), P.c(), P.m(p.parentNode, p)) : P && (P.d(1), P = null), !/*actionId*/
      q[2] && /*item*/
      ((ae = (re = q[0].system) == null ? void 0 : re.uses) != null && ae.max) || /*action*/
      q[1] && /*action*/
      ((be = q[1].uses) != null && be.max) ? D ? D.p(q, W) : (D = m6(q), D.c(), D.m(m.parentNode, m)) : D && (D.d(1), D = null);
    },
    i: ee,
    o: ee,
    d(q) {
      q && (S(e), S(u), S(d), S(p), S(m)), g && g.d(), h && h.d(), _ && _.d(), y && y.d(), O.d(q), P && P.d(q), D && D.d(q);
    }
  };
}
f(Yse, "create_fragment$2u");
function Xse(i, e) {
  var s, n, l, r;
  let t = e;
  if (!i.actions || ((s = i.actions) == null ? void 0 : s.count) === 0)
    return "";
  switch (((n = i.actions) == null ? void 0 : n.count) === 1 && (t = i.actions.values()[0]), (l = t == null ? void 0 : t.activation) == null ? void 0 : l.type) {
    case "action":
      return "A";
    case "bonusAction":
      return "B";
    case "legendaryAction":
      const o = (r = t == null ? void 0 : t.activation) == null ? void 0 : r.cost;
      return o === 1 || o === 0 ? "L" : `${o}L`;
    case "reaction":
      return "R";
    default:
      return "";
  }
}
f(Xse, "getActivationCost");
function Jse(i) {
  switch (i) {
    case "A":
      return "Action";
    case "B":
      return "Bonus Action";
    case "L":
      return "Legendary Action";
    case "R":
      return "Reaction";
    default:
      return "";
  }
}
f(Jse, "getActivationCostLabel");
function Zse(i, e) {
  var n, l;
  let t = e;
  if (!i.actions || ((n = i.actions) == null ? void 0 : n.count) === 0)
    return "";
  ((l = i.actions) == null ? void 0 : l.count) === 1 && (t = i.actions.values()[0]);
  const s = Object.entries((t == null ? void 0 : t.consumers) ?? {}).find(([r, o]) => (o == null ? void 0 : o.type) === "ammunition");
  return s ? s[1].itemId : "";
}
f(Zse, "getSelectedAmmo");
function Uf(i, e) {
  let t = e;
  return !i.actions || i.actions.count === 0 ? !1 : (i.actions.count === 1 && (t = i.actions.values()[0]), Object.entries((t == null ? void 0 : t.consumers) ?? {}).filter(([s, n]) => (n == null ? void 0 : n.type) === "ammunition").length);
}
f(Uf, "hasAmmunition");
function Qse(i, e, t) {
  let s, n, l, r, o, a, c, u, { item: d } = e, { action: p } = e, { actionId: m } = e;
  function g(Ae) {
    var Pe, rt, Te;
    let Fe = m;
    const Ve = (rt = (Pe = Ae.target) == null ? void 0 : Pe.selectedOptions[0]) == null ? void 0 : rt.value;
    if (!d.actions || d.actions.count === 0)
      return;
    d.actions.count === 1 && (Fe = d.actions.keys()[0]);
    const [je] = Object.entries(((Te = d.actions[Fe]) == null ? void 0 : Te.consumers) ?? {}).find(([Ee, Be]) => (Be == null ? void 0 : Be.type) === "ammunition");
    je && se(d, `system.actions.${Fe}.consumers.${je}.itemId`, Ve);
  }
  f(g, "updateAmmunition");
  function h(Ae) {
    var Fe, Ve, je;
    return m ? ((Fe = p.uses) == null ? void 0 : Fe.per) === "recharge" : ((je = (Ve = Ae.system) == null ? void 0 : Ve.uses) == null ? void 0 : je.per) === "recharge";
  }
  f(h, "hasRecharge");
  function _(Ae) {
    Ae.preventDefault();
    const { target: Fe } = Ae;
    se(d, Fe.name, Number(Fe.value));
  }
  f(_, "updateField");
  function y() {
    var Fe, Ve, je;
    if (!G)
      return;
    if (m) {
      (Fe = d.actions) == null || Fe.configure(m);
      return;
    }
    const Ae = (Ve = d.actions.keys()) == null ? void 0 : Ve[0];
    if (!Ae) {
      d.configureItem();
      return;
    }
    (je = d.actions) == null || je.configure(Ae);
  }
  f(y, "onConfigure");
  const k = fe("actor");
  pe(i, k, (Ae) => t(4, u = Ae));
  const { damagedStates: v, DAMAGED_STATES: O, equippedStates: P, EQUIPPED_STATES: D, preparedStates: I, PREPARED_STATES: B } = CONFIG.A5E;
  let F = game.settings.get("a5e", "hideBrokenAndDamaged"), H = m ? "action" : "item", G = game.settings.get("a5e", "itemRightClickConfigure") ?? !1;
  function U(Ae) {
    gt.call(this, i, Ae);
  }
  f(U, "click_handler_5");
  function q(Ae) {
    gt.call(this, i, Ae);
  }
  f(q, "click_handler_4");
  function W(Ae) {
    gt.call(this, i, Ae);
  }
  f(W, "click_handler_3");
  function X(Ae) {
    gt.call(this, i, Ae);
  }
  f(X, "click_handler");
  function te(Ae) {
    gt.call(this, i, Ae);
  }
  f(te, "click_handler_2");
  function J(Ae) {
    gt.call(this, i, Ae);
  }
  f(J, "click_handler_1");
  const re = /* @__PURE__ */ f(() => d.toggleFavorite(), "click_handler_6"), ae = /* @__PURE__ */ f(() => d.toggleAttunement(), "click_handler_7"), be = /* @__PURE__ */ f(() => d.toggleEquippedState(), "click_handler_8"), we = /* @__PURE__ */ f(() => d.toggleDamagedState(), "click_handler_9"), ve = /* @__PURE__ */ f(() => d.togglePrepared(), "click_handler_10"), me = /* @__PURE__ */ f(() => d.recharge(m, r), "click_handler_11"), he = /* @__PURE__ */ f(() => d.recharge(m, r), "click_handler_12");
  return i.$$set = (Ae) => {
    "item" in Ae && t(0, d = Ae.item), "action" in Ae && t(1, p = Ae.action), "actionId" in Ae && t(2, m = Ae.actionId);
  }, i.$$.update = () => {
    var Ae, Fe, Ve, je, Pe, rt, Te, Ee, Be, Ce, Re, Oe;
    i.$$.dirty[0] & /*$actor*/
    16 && t(10, s = u.flags), i.$$.dirty[0] & /*action, $actor, item, actionId*/
    23 && t(9, n = {
      action: {
        value: p ? (Ae = p.uses) == null ? void 0 : Ae.value : 0,
        max: p ? at(((Fe = p.uses) == null ? void 0 : Fe.max) ?? 0, u.getRollData(d)) : 0,
        updatePath: `system.actions.${m}.uses`
      },
      item: {
        value: ((je = (Ve = d.system) == null ? void 0 : Ve.uses) == null ? void 0 : je.value) ?? 0,
        max: at(((rt = (Pe = d.system) == null ? void 0 : Pe.uses) == null ? void 0 : rt.max) ?? 0, u.getRollData(d)),
        updatePath: "system.uses"
      }
    }), i.$$.dirty[0] & /*$actor*/
    16 && t(8, l = u.items.filter((Je) => Je.type === "object" && Je.system.objectType === "ammunition").map((Je) => ({ name: Je.name, id: Je.id })).sort((Je, Xe) => Je.name.toLowerCase().localeCompare(Xe.name.toLowerCase()))), i.$$.dirty[0] & /*actionId, action, item*/
    7 && t(7, r = m ? ((Te = p.uses) == null ? void 0 : Te.max) == ((Ee = p.uses) == null ? void 0 : Ee.value) : ((Ce = (Be = d.system) == null ? void 0 : Be.uses) == null ? void 0 : Ce.max) == ((Oe = (Re = d.system) == null ? void 0 : Re.uses) == null ? void 0 : Oe.value)), i.$$.dirty[0] & /*item, action*/
    3 && t(3, o = Xse(d, p)), i.$$.dirty[0] & /*activationCost*/
    8 && t(6, a = Jse(o)), i.$$.dirty[0] & /*item, action*/
    3 && t(5, c = Zse(d, p));
  }, [
    d,
    p,
    m,
    o,
    u,
    c,
    a,
    r,
    l,
    n,
    s,
    g,
    h,
    _,
    y,
    k,
    v,
    O,
    P,
    D,
    I,
    B,
    F,
    H,
    U,
    q,
    W,
    X,
    te,
    J,
    re,
    ae,
    be,
    we,
    ve,
    me,
    he
  ];
}
f(Qse, "instance$2l");
const LS = class LS extends ie {
  constructor(e) {
    super(), le(this, e, Qse, Yse, ne, { item: 0, action: 1, actionId: 2 }, null, [-1, -1]);
  }
};
f(LS, "ItemInnerWrapper");
let Sv = LS;
function h6(i, e, t) {
  const s = i.slice();
  return s[25] = e[t][0], s[26] = e[t][1], s;
}
f(h6, "get_each_context$V");
function g6(i, e, t) {
  const s = i.slice();
  return s[25] = e[t][0], s[3] = e[t][1], s;
}
f(g6, "get_each_context_1$a");
function b6(i) {
  let e, t;
  return e = new Ev({
    props: {
      action: (
        /*actionId*/
        i[2]
      ),
      item: (
        /*item*/
        i[1]
      )
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*actionId*/
      4 && (l.action = /*actionId*/
      s[2]), n & /*item*/
      2 && (l.item = /*item*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(b6, "create_if_block_6$b");
function _6(i) {
  let e, t, s, n, l;
  const r = [ene, xse], o = [];
  function a(c, u) {
    return !/*isGM*/
    c[14] && /*item*/
    c[1].type === "object" && /*item*/
    c[1].system.unidentified ? 0 : 1;
  }
  return f(a, "select_block_type"), t = a(i), s = o[t] = r[t](i), {
    c() {
      e = E("div"), s.c(), b(e, "class", "description-wrapper svelte-1xtnxm6");
    },
    m(c, u) {
      T(c, e, u), o[t].m(e, null), l = !0;
    },
    p(c, u) {
      let d = t;
      t = a(c), t === d ? o[t].p(c, u) : (ce(), C(o[d], 1, 1, () => {
        o[d] = null;
      }), ue(), s = o[t], s ? s.p(c, u) : (s = o[t] = r[t](c), s.c()), w(s, 1), s.m(e, null));
    },
    i(c) {
      l || (w(s), c && is(() => {
        l && (n || (n = dl(e, Ec, {}, !0)), n.run(1));
      }), l = !0);
    },
    o(c) {
      C(s), c && (n || (n = dl(e, Ec, {}, !1)), n.run(0)), l = !1;
    },
    d(c) {
      c && S(e), o[t].d(), c && n && n.end();
    }
  };
}
f(_6, "create_if_block_2$A");
function xse(i) {
  let e = Object.values(
    /*summaryData*/
    i[5]
  ).some(Boolean), t, s, n, l, r = e && y6(i);
  return {
    c() {
      r && r.c(), t = R(), s = new As(!1), n = $e(), s.a = n;
    },
    m(o, a) {
      r && r.m(o, a), T(o, t, a), s.m(
        /*description*/
        i[7],
        o,
        a
      ), T(o, n, a), l = !0;
    },
    p(o, a) {
      a & /*summaryData*/
      32 && (e = Object.values(
        /*summaryData*/
        o[5]
      ).some(Boolean)), e ? r ? (r.p(o, a), a & /*summaryData*/
      32 && w(r, 1)) : (r = y6(o), r.c(), w(r, 1), r.m(t.parentNode, t)) : r && (ce(), C(r, 1, 1, () => {
        r = null;
      }), ue()), (!l || a & /*description*/
      128) && s.p(
        /*description*/
        o[7]
      );
    },
    i(o) {
      l || (w(r), l = !0);
    },
    o(o) {
      C(r), l = !1;
    },
    d(o) {
      o && (S(t), S(n), s.d()), r && r.d(o);
    }
  };
}
f(xse, "create_else_block$s");
function ene(i) {
  let e, t = (
    /*item*/
    (i[1].system.unidentifiedDescription ?? K("A5E.NoUnidentifiedDescription")) + ""
  ), s;
  return {
    c() {
      e = new As(!1), s = $e(), e.a = s;
    },
    m(n, l) {
      e.m(t, n, l), T(n, s, l);
    },
    p(n, l) {
      l & /*item*/
      2 && t !== (t = /*item*/
      (n[1].system.unidentifiedDescription ?? K("A5E.NoUnidentifiedDescription")) + "") && e.p(t);
    },
    i: ee,
    o: ee,
    d(n) {
      n && (S(s), e.d());
    }
  };
}
f(ene, "create_if_block_3$n");
function y6(i) {
  let e, t, s, n, l;
  e = new va({
    props: { summaryData: (
      /*summaryData*/
      i[5]
    ) }
  });
  let r = (
    /*description*/
    i[7] && v6()
  );
  return {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), r && r.c(), n = $e(), z(t, "display", "contents"), z(t, "--margin-bottom", "0.375rem");
    },
    m(o, a) {
      T(o, t, a), N(e, t, null), T(o, s, a), r && r.m(o, a), T(o, n, a), l = !0;
    },
    p(o, a) {
      const c = {};
      a & /*summaryData*/
      32 && (c.summaryData = /*summaryData*/
      o[5]), e.$set(c), /*description*/
      o[7] ? r || (r = v6(), r.c(), r.m(n.parentNode, n)) : r && (r.d(1), r = null);
    },
    i(o) {
      l || (w(e.$$.fragment, o), l = !0);
    },
    o(o) {
      C(e.$$.fragment, o), l = !1;
    },
    d(o) {
      o && (S(s), S(n)), o && e && S(t), j(e, o), r && r.d(o);
    }
  };
}
f(y6, "create_if_block_4$j");
function v6(i) {
  let e;
  return {
    c() {
      e = E("hr"), b(e, "class", "a5e-rule"), z(e, "margin-block", "0.5rem");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(v6, "create_if_block_5$c");
function k6(i) {
  var o, a;
  let e, t = [], s = /* @__PURE__ */ new Map(), n, l = oe(
    /*item*/
    ((a = (o = i[1]) == null ? void 0 : o.actions) == null ? void 0 : a.entries()) ?? []
  );
  const r = /* @__PURE__ */ f((c) => (
    /*id*/
    c[25]
  ), "get_key");
  for (let c = 0; c < l.length; c += 1) {
    let u = g6(i, l, c), d = r(u);
    s.set(d, t[c] = w6(d, u));
  }
  return {
    c() {
      e = E("ul");
      for (let c = 0; c < t.length; c += 1)
        t[c].c();
      b(e, "class", "a5e-item-list a5e-item-list--sub-items");
    },
    m(c, u) {
      T(c, e, u);
      for (let d = 0; d < t.length; d += 1)
        t[d] && t[d].m(e, null);
      n = !0;
    },
    p(c, u) {
      var d, p;
      u & /*item*/
      2 && (l = oe(
        /*item*/
        ((p = (d = c[1]) == null ? void 0 : d.actions) == null ? void 0 : p.entries()) ?? []
      ), ce(), t = kt(t, u, r, 1, c, l, s, e, ks, w6, null, g6), ue());
    },
    i(c) {
      if (!n) {
        for (let u = 0; u < l.length; u += 1)
          w(t[u]);
        n = !0;
      }
    },
    o(c) {
      for (let u = 0; u < t.length; u += 1)
        C(t[u]);
      n = !1;
    },
    d(c) {
      c && S(e);
      for (let u = 0; u < t.length; u += 1)
        t[u].d();
    }
  };
}
f(k6, "create_if_block_1$V");
function w6(i, e) {
  let t, s, n;
  return s = new K5({
    props: {
      item: (
        /*item*/
        e[1]
      ),
      action: (
        /*action*/
        e[3]
      ),
      actionId: (
        /*id*/
        e[25]
      )
    }
  }), {
    key: i,
    first: null,
    c() {
      t = $e(), L(s.$$.fragment), this.first = t;
    },
    m(l, r) {
      T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      e = l;
      const o = {};
      r & /*item*/
      2 && (o.item = /*item*/
      e[1]), r & /*item*/
      2 && (o.action = /*action*/
      e[3]), r & /*item*/
      2 && (o.actionId = /*id*/
      e[25]), s.$set(o);
    },
    i(l) {
      n || (w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(s, l);
    }
  };
}
f(w6, "create_each_block_1$a");
function $6(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n, l = oe(
    /*containerItems*/
    i[8]
  );
  const r = /* @__PURE__ */ f((o) => (
    /*id*/
    o[25]
  ), "get_key");
  for (let o = 0; o < l.length; o += 1) {
    let a = h6(i, l, o), c = r(a);
    s.set(c, t[o] = A6(c, a));
  }
  return {
    c() {
      e = E("ul");
      for (let o = 0; o < t.length; o += 1)
        t[o].c();
      b(e, "class", "a5e-item-list a5e-item-list--sub-items");
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < t.length; c += 1)
        t[c] && t[c].m(e, null);
      n = !0;
    },
    p(o, a) {
      a & /*containerItems*/
      256 && (l = oe(
        /*containerItems*/
        o[8]
      ), ce(), t = kt(t, a, r, 1, o, l, s, e, ks, A6, null, h6), ue());
    },
    i(o) {
      if (!n) {
        for (let a = 0; a < l.length; a += 1)
          w(t[a]);
        n = !0;
      }
    },
    o(o) {
      for (let a = 0; a < t.length; a += 1)
        C(t[a]);
      n = !1;
    },
    d(o) {
      o && S(e);
      for (let a = 0; a < t.length; a += 1)
        t[a].d();
    }
  };
}
f($6, "create_if_block$1n");
function A6(i, e) {
  let t, s, n;
  return s = new K5({ props: { item: (
    /*child*/
    e[26]
  ) } }), {
    key: i,
    first: null,
    c() {
      t = $e(), L(s.$$.fragment), this.first = t;
    },
    m(l, r) {
      T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      e = l;
      const o = {};
      r & /*containerItems*/
      256 && (o.item = /*child*/
      e[26]), s.$set(o);
    },
    i(l) {
      n || (w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(s, l);
    }
  };
}
f(A6, "create_each_block$V");
function tne(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k, v;
  u = new Sv({
    props: {
      actionId: (
        /*actionId*/
        i[2]
      ),
      action: (
        /*action*/
        i[3]
      ),
      item: (
        /*item*/
        i[1]
      )
    }
  });
  let O = (
    /*$actor*/
    i[4].isOwner && b6(i)
  ), P = (
    /*showDescription*/
    i[0] && _6(i)
  ), D = (
    /*showActionList*/
    i[6] && k6(i)
  ), I = (
    /*containerItems*/
    i[8].length && $6(i)
  );
  return {
    c() {
      var B, F, H;
      e = E("li"), t = E("button"), s = E("img"), r = R(), o = E("img"), c = R(), L(u.$$.fragment), d = R(), O && O.c(), m = R(), P && P.c(), g = R(), D && D.c(), h = R(), I && I.c(), _ = $e(), b(s, "class", "a5e-item__image"), ze(s.src, n = /*action*/
      ((B = i[3]) == null ? void 0 : B.img) ?? /*item*/
      i[1].img ?? "icons/svg/item-bag.svg") || b(s, "src", n), b(s, "alt", l = /*action*/
      ((F = i[3]) == null ? void 0 : F.name) ?? /*item*/
      i[1].name), b(o, "class", "a5e-item__image--die"), ze(o.src, a = "/icons/svg/d20.svg") || b(o, "src", a), b(o, "alt", "Roll"), b(t, "class", "a5e-item__roll-button svelte-1xtnxm6"), Q(
        t,
        "a5e-item__roll-button--shift",
        /*$pressedKeysStore*/
        i[9].Shift
      ), Q(
        t,
        "a5e-item__roll-button--ctrl",
        /*$pressedKeysStore*/
        i[9].Control
      ), Q(t, "disable-pointer-events", !/*$actor*/
      i[4].isOwner), b(e, "class", "a5e-item"), b(e, "draggable", "true"), b(e, "data-document-uuid", p = /*item*/
      i[1].uuid), Q(e, "a5e-item--highlight", Number(
        /*item*/
        i[1].system.prepared ?? 0
      ) === /*A5E*/
      i[11].PREPARED_STATES.PREPARED || /*item*/
      i[1].system.equippedState === /*A5E*/
      i[11].EQUIPPED_STATES.EQUIPPED && !/*item*/
      ((H = i[1].system) != null && H.containerId)), Q(e, "a5e-item--purple-highlight", Number(
        /*item*/
        i[1].system.prepared ?? 0
      ) === /*A5E*/
      i[11].PREPARED_STATES.ALWAYS_PREPARED), Q(
        e,
        "a5e-item--red-highlight",
        /*item*/
        i[1].system.requiresBloodied
      );
    },
    m(B, F) {
      T(B, e, F), A(e, t), A(t, s), A(t, r), A(t, o), A(e, c), N(u, e, null), A(e, d), O && O.m(e, null), T(B, m, F), P && P.m(B, F), T(B, g, F), D && D.m(B, F), T(B, h, F), I && I.m(B, F), T(B, _, F), y = !0, k || (v = [
        V(t, "click", We(
          /*click_handler*/
          i[19]
        )),
        V(
          e,
          "dragstart",
          /*onDragStart*/
          i[17]
        ),
        V(e, "drop", We(tt(
          /*drop_handler*/
          i[20]
        ))),
        V(
          e,
          "click",
          /*click_handler_1*/
          i[21]
        ),
        V(
          e,
          "auxclick",
          /*auxclick_handler*/
          i[22]
        )
      ], k = !0);
    },
    p(B, [F]) {
      var G, U, q;
      (!y || F & /*action, item*/
      10 && !ze(s.src, n = /*action*/
      ((G = B[3]) == null ? void 0 : G.img) ?? /*item*/
      B[1].img ?? "icons/svg/item-bag.svg")) && b(s, "src", n), (!y || F & /*action, item*/
      10 && l !== (l = /*action*/
      ((U = B[3]) == null ? void 0 : U.name) ?? /*item*/
      B[1].name)) && b(s, "alt", l), (!y || F & /*$pressedKeysStore*/
      512) && Q(
        t,
        "a5e-item__roll-button--shift",
        /*$pressedKeysStore*/
        B[9].Shift
      ), (!y || F & /*$pressedKeysStore*/
      512) && Q(
        t,
        "a5e-item__roll-button--ctrl",
        /*$pressedKeysStore*/
        B[9].Control
      ), (!y || F & /*$actor*/
      16) && Q(t, "disable-pointer-events", !/*$actor*/
      B[4].isOwner);
      const H = {};
      F & /*actionId*/
      4 && (H.actionId = /*actionId*/
      B[2]), F & /*action*/
      8 && (H.action = /*action*/
      B[3]), F & /*item*/
      2 && (H.item = /*item*/
      B[1]), u.$set(H), /*$actor*/
      B[4].isOwner ? O ? (O.p(B, F), F & /*$actor*/
      16 && w(O, 1)) : (O = b6(B), O.c(), w(O, 1), O.m(e, null)) : O && (ce(), C(O, 1, 1, () => {
        O = null;
      }), ue()), (!y || F & /*item*/
      2 && p !== (p = /*item*/
      B[1].uuid)) && b(e, "data-document-uuid", p), (!y || F & /*Number, item, A5E*/
      2050) && Q(e, "a5e-item--highlight", Number(
        /*item*/
        B[1].system.prepared ?? 0
      ) === /*A5E*/
      B[11].PREPARED_STATES.PREPARED || /*item*/
      B[1].system.equippedState === /*A5E*/
      B[11].EQUIPPED_STATES.EQUIPPED && !/*item*/
      ((q = B[1].system) != null && q.containerId)), (!y || F & /*Number, item, A5E*/
      2050) && Q(e, "a5e-item--purple-highlight", Number(
        /*item*/
        B[1].system.prepared ?? 0
      ) === /*A5E*/
      B[11].PREPARED_STATES.ALWAYS_PREPARED), (!y || F & /*item*/
      2) && Q(
        e,
        "a5e-item--red-highlight",
        /*item*/
        B[1].system.requiresBloodied
      ), /*showDescription*/
      B[0] ? P ? (P.p(B, F), F & /*showDescription*/
      1 && w(P, 1)) : (P = _6(B), P.c(), w(P, 1), P.m(g.parentNode, g)) : P && (ce(), C(P, 1, 1, () => {
        P = null;
      }), ue()), /*showActionList*/
      B[6] ? D ? (D.p(B, F), F & /*showActionList*/
      64 && w(D, 1)) : (D = k6(B), D.c(), w(D, 1), D.m(h.parentNode, h)) : D && (ce(), C(D, 1, 1, () => {
        D = null;
      }), ue()), /*containerItems*/
      B[8].length ? I ? (I.p(B, F), F & /*containerItems*/
      256 && w(I, 1)) : (I = $6(B), I.c(), w(I, 1), I.m(_.parentNode, _)) : I && (ce(), C(I, 1, 1, () => {
        I = null;
      }), ue());
    },
    i(B) {
      y || (w(u.$$.fragment, B), w(O), w(P), w(D), w(I), y = !0);
    },
    o(B) {
      C(u.$$.fragment, B), C(O), C(P), C(D), C(I), y = !1;
    },
    d(B) {
      B && (S(e), S(m), S(g), S(h), S(_)), j(u), O && O.d(), P && P.d(B), D && D.d(B), I && I.d(B), k = !1, Ne(v);
    }
  };
}
f(tne, "create_fragment$2t");
function sne(i, e, t) {
  let s, n, l, r, o, a, c;
  pe(i, Mi, (U) => t(9, c = U));
  let { item: u } = e, { action: d = null } = e, { actionId: p = null } = e, { showDescription: m = !1 } = e;
  const g = fe("actor");
  pe(i, g, (U) => t(4, a = U));
  const { A5E: h } = CONFIG, _ = it();
  let y = game.settings.get("a5e", "itemRightClickConfigure") ?? !1, k = game.user.isGM;
  function v(U, q, W) {
    var X, te, J;
    return U ? !1 : ((X = q.actions) == null ? void 0 : X.count) < 2 ? (J = (te = q.actions) == null ? void 0 : te.values()) == null ? void 0 : J.some((re) => {
      var ae, be;
      return ((ae = re.uses) == null ? void 0 : ae.value) || ((be = re.uses) == null ? void 0 : be.max);
    }) : !(game.settings.get("a5e", "collapseActionList") && W);
  }
  f(v, "determineActionListVisibility");
  function O() {
    const U = Bi(c);
    u.activate(p, U);
  }
  f(O, "onItemActivate");
  async function P() {
    var U;
    if (p) {
      await ((U = u.actions) == null ? void 0 : U.configure(p));
      return;
    }
    u.configureItem();
  }
  f(P, "onConfigure");
  function D(U) {
    const q = u.toDragData();
    if (q)
      return q.actorId = u == null ? void 0 : u.parent.id, q.actionId = p, U.dataTransfer.setData("text/plain", JSON.stringify(q));
  }
  f(D, "onDragStart");
  async function I() {
    return await TextEditor.enrichHTML(p ? d.description : u.system.description, {
      async: !0,
      secrets: u.isOwner,
      relativeTo: u,
      rollData: (a == null ? void 0 : a.getRollData(this)) ?? {}
    }) ?? K("A5E.NoDescription");
  }
  f(I, "getDescription");
  const B = /* @__PURE__ */ f(({ target: U }) => {
    U.blur(), O();
  }, "click_handler"), F = /* @__PURE__ */ f((U) => _("dropObject", U), "drop_handler"), H = /* @__PURE__ */ f(() => {
    t(0, m = !m);
  }, "click_handler_1"), G = /* @__PURE__ */ f(() => {
    y && P();
  }, "auxclick_handler");
  return i.$$set = (U) => {
    "item" in U && t(1, u = U.item), "action" in U && t(3, d = U.action), "actionId" in U && t(2, p = U.actionId), "showDescription" in U && t(0, m = U.showDescription);
  }, i.$$.update = () => {
    var U, q, W;
    i.$$.dirty & /*item, $actor*/
    18 && t(8, s = (((U = u == null ? void 0 : u.containerItems) == null ? void 0 : U.documents) ?? []).reduce(
      (X, [te, J]) => {
        var ae;
        const re = fromUuidSync(J.uuid);
        return !re || ((ae = re.parent) == null ? void 0 : ae.id) !== a.id || X.push([te, re]), X;
      },
      []
    )), i.$$.dirty & /*item*/
    2 && t(7, n = I().then((X) => t(7, n = X)).catch((X) => t(7, n = X))), i.$$.dirty & /*$actor*/
    16 && t(18, l = a.isOwner ? ((W = (q = a.flags) == null ? void 0 : q.a5e) == null ? void 0 : W.sheetIsLocked) ?? !0 : !0), i.$$.dirty & /*action, item, sheetIsLocked*/
    262154 && t(6, r = v(d, u, l)), i.$$.dirty & /*item, action*/
    10 && t(5, o = Of(u, d));
  }, [
    m,
    u,
    p,
    d,
    a,
    o,
    r,
    n,
    s,
    c,
    g,
    h,
    _,
    y,
    k,
    O,
    P,
    D,
    l,
    B,
    F,
    H,
    G
  ];
}
f(sne, "instance$2k");
var uf;
let K5 = (uf = class extends ie {
  constructor(e) {
    super(), le(this, e, sne, tne, ne, {
      item: 1,
      action: 3,
      actionId: 2,
      showDescription: 0
    });
  }
}, f(uf, "Item"), uf);
function E6(i, e, t) {
  const s = i.slice();
  s[12] = e[t];
  const n = (
    /*slot*/
    s[12] > /*spellResources*/
    s[2].slots[
      /*level*/
      s[0].toString()
    ].current
  );
  return s[13] = n, s;
}
f(E6, "get_each_context$U");
function S6(i) {
  let e;
  function t(l, r) {
    return (
      /*sheetIsLocked*/
      l[1] ? ine : nne
    );
  }
  f(t, "select_block_type");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("div"), n.c(), b(e, "class", "spell-slot-wrapper svelte-6v47hj"), Q(
        e,
        "spell-slot-wrapper--locked",
        /*sheetIsLocked*/
        i[1]
      );
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null))), r & /*sheetIsLocked*/
      2 && Q(
        e,
        "spell-slot-wrapper--locked",
        /*sheetIsLocked*/
        l[1]
      );
    },
    d(l) {
      l && S(e), n.d();
    }
  };
}
f(S6, "create_if_block$1m");
function nne(i) {
  let e, t, s, n, l, r, o;
  return {
    c() {
      e = E("input"), n = x(`
            /
            `), l = E("input"), b(e, "class", "number-input svelte-6v47hj"), b(e, "type", "number"), b(e, "name", t = "system.spellResources.slots." + /*level*/
      i[0] + ".current"), e.value = s = /*spellResources*/
      i[2].slots[
        /*level*/
        i[0].toString()
      ].current, b(e, "placeholder", "0"), b(e, "min", "0"), Q(e, "disable-pointer-events", !/*$actor*/
      i[3].isOwner), b(l, "class", "number-input svelte-6v47hj"), b(l, "type", "number"), l.value = /*maxSpellSlots*/
      i[4], b(l, "placeholder", "0"), b(l, "min", "0");
    },
    m(a, c) {
      T(a, e, c), T(a, n, c), T(a, l, c), r || (o = [
        V(
          e,
          "change",
          /*change_handler*/
          i[9]
        ),
        V(
          l,
          "change",
          /*change_handler_1*/
          i[10]
        )
      ], r = !0);
    },
    p(a, c) {
      c & /*level*/
      1 && t !== (t = "system.spellResources.slots." + /*level*/
      a[0] + ".current") && b(e, "name", t), c & /*spellResources, level*/
      5 && s !== (s = /*spellResources*/
      a[2].slots[
        /*level*/
        a[0].toString()
      ].current) && e.value !== s && (e.value = s), c & /*$actor*/
      8 && Q(e, "disable-pointer-events", !/*$actor*/
      a[3].isOwner), c & /*maxSpellSlots*/
      16 && l.value !== /*maxSpellSlots*/
      a[4] && (l.value = /*maxSpellSlots*/
      a[4]);
    },
    d(a) {
      a && (S(e), S(n), S(l)), r = !1, Ne(o);
    }
  };
}
f(nne, "create_else_block$r");
function ine(i) {
  let e, t = oe(Array.from({ length: (
    /*maxSpellSlots*/
    i[4]
  ) }, C6)), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = T6(E6(i, t, n));
  return {
    c() {
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      e = $e();
    },
    m(n, l) {
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(n, l);
      T(n, e, l);
    },
    p(n, l) {
      if (l & /*Array, maxSpellSlots, spellResources, level, $actor, updateSpellSlots*/
      157) {
        t = oe(Array.from({ length: (
          /*maxSpellSlots*/
          n[4]
        ) }, C6));
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = E6(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = T6(o), s[r].c(), s[r].m(e.parentNode, e));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && S(e), Le(s, n);
    }
  };
}
f(ine, "create_if_block_1$U");
function T6(i) {
  let e, t, s;
  function n() {
    return (
      /*click_handler*/
      i[8](
        /*slot*/
        i[12]
      )
    );
  }
  return f(n, "click_handler"), {
    c() {
      e = E("button"), e.innerHTML = '<i class="a5e-spell-slot__icon fa-solid fa-star svelte-6v47hj"></i> ', b(e, "class", "a5e-spell-slot svelte-6v47hj"), Q(
        e,
        "a5e-spell-slot--expended",
        /*slotExpended*/
        i[13]
      ), Q(e, "disable-pointer-events", !/*$actor*/
      i[3].isOwner);
    },
    m(l, r) {
      T(l, e, r), t || (s = V(e, "click", n), t = !0);
    },
    p(l, r) {
      i = l, r & /*Array, maxSpellSlots, spellResources, level*/
      21 && Q(
        e,
        "a5e-spell-slot--expended",
        /*slotExpended*/
        i[13]
      ), r & /*$actor*/
      8 && Q(e, "disable-pointer-events", !/*$actor*/
      i[3].isOwner);
    },
    d(l) {
      l && S(e), t = !1, s();
    }
  };
}
f(T6, "create_each_block$U");
function lne(i) {
  let e, t = (
    /*level*/
    i[0] && /*level*/
    i[0] !== "0" && S6(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, [n]) {
      /*level*/
      s[0] && /*level*/
      s[0] !== "0" ? t ? t.p(s, n) : (t = S6(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    i: ee,
    o: ee,
    d(s) {
      s && S(e), t && t.d(s);
    }
  };
}
f(lne, "create_fragment$2s");
const C6 = /* @__PURE__ */ f((i, e) => e + 1, "func$4");
function rne(i, e, t) {
  let s, n, l, r, { level: o = 0 } = e;
  const a = fe("actor");
  pe(i, a, (h) => t(3, r = h));
  function c() {
    var h, _, y;
    return r.type !== "character" ? (h = s.slots[o.toString()]) == null ? void 0 : h.max : n ? (_ = s.slots[o.toString()]) == null ? void 0 : _.max : (y = s.slots[o.toString()]) == null ? void 0 : y.override;
  }
  f(c, "getMaxSpellSlots");
  function u(h) {
    const _ = r.type === "character" ? `system.spellResources.slots.${o}.override` : `system.spellResources.slots.${o}.max`;
    se(r, _, h);
  }
  f(u, "updateSpellSlotMax");
  function d(h, _) {
    let y = _;
    _ <= s.slots[h.toString()].current && (y = _ - 1), r.update({
      [`system.spellResources.slots.${h}.current`]: y
    });
  }
  f(d, "updateSpellSlots");
  const p = /* @__PURE__ */ f((h) => d(o, h), "click_handler"), m = /* @__PURE__ */ f(({ target: h }) => se(r, h.name, Number(h.value)), "change_handler"), g = /* @__PURE__ */ f(({ target: h }) => u(Number(h.value)), "change_handler_1");
  return i.$$set = (h) => {
    "level" in h && t(0, o = h.level);
  }, i.$$.update = () => {
    var h, _;
    i.$$.dirty & /*$actor*/
    8 && t(2, s = r.system.spellResources), i.$$.dirty & /*$actor*/
    8 && t(1, n = r.isOwner ? ((_ = (h = r.flags) == null ? void 0 : h.a5e) == null ? void 0 : _.sheetIsLocked) ?? !0 : !0), i.$$.dirty & /*spellResources, sheetIsLocked*/
    6 && t(4, l = c());
  }, [
    o,
    n,
    s,
    r,
    l,
    a,
    u,
    d,
    p,
    m,
    g
  ];
}
f(rne, "instance$2j");
const BS = class BS extends ie {
  constructor(e) {
    super(), le(this, e, rne, lne, ne, { level: 0 });
  }
};
f(BS, "SpellSlots");
let Tv = BS;
function O6(i, e, t) {
  const s = i.slice();
  return s[18] = e[t], s;
}
f(O6, "get_each_context$T");
function D6(i) {
  let e, t, s, n, l, r, o, a, c, u = (
    /*icon*/
    i[0] && I6(i)
  );
  function d(k, v) {
    return (
      /*type*/
      k[4] === "favorites" ? ane : one
    );
  }
  f(d, "select_block_type");
  let p = d(i), m = p(i), g = (
    /*type*/
    i[4] === "spellLevels" && /*showSpellSlots*/
    i[8] && P6(i)
  ), h = (
    /*type*/
    i[4] === "spellLevels" && /*showSpellPoints*/
    i[7] && M6(i)
  ), _ = (
    /*showQuantity*/
    i[6] && R6()
  ), y = (
    /*showUses*/
    i[9] && F6()
  );
  return {
    c() {
      e = E("header"), t = E("h3"), s = E("div"), u && u.c(), n = R(), m.c(), l = R(), g && g.c(), r = R(), h && h.c(), o = R(), _ && _.c(), a = R(), y && y.c(), b(t, "class", "a5e-section-header__heading a5e-section-header__heading--name svelte-8isinv"), b(e, "class", "a5e-section-header a5e-section-header--item-list"), z(
        e,
        "--a5e-section-heading-template-areas",
        /*headingTemplateConfiguration*/
        i[11].areas
      ), z(
        e,
        "--a5e-section-heading-template-columns",
        /*headingTemplateConfiguration*/
        i[11].columns
      ), Q(e, "a5e-section-header--flat-bottom", [.../*items*/
      i[3]].length);
    },
    m(k, v) {
      T(k, e, v), A(e, t), A(t, s), u && u.m(s, null), A(s, n), m.m(s, null), A(t, l), g && g.m(t, null), A(t, r), h && h.m(t, null), A(e, o), _ && _.m(e, null), A(e, a), y && y.m(e, null), c = !0;
    },
    p(k, v) {
      /*icon*/
      k[0] ? u ? u.p(k, v) : (u = I6(k), u.c(), u.m(s, n)) : u && (u.d(1), u = null), p === (p = d(k)) && m ? m.p(k, v) : (m.d(1), m = p(k), m && (m.c(), m.m(s, null))), /*type*/
      k[4] === "spellLevels" && /*showSpellSlots*/
      k[8] ? g ? (g.p(k, v), v & /*type, showSpellSlots*/
      272 && w(g, 1)) : (g = P6(k), g.c(), w(g, 1), g.m(t, r)) : g && (ce(), C(g, 1, 1, () => {
        g = null;
      }), ue()), /*type*/
      k[4] === "spellLevels" && /*showSpellPoints*/
      k[7] ? h ? h.p(k, v) : (h = M6(k), h.c(), h.m(t, null)) : h && (h.d(1), h = null), /*showQuantity*/
      k[6] ? _ || (_ = R6(), _.c(), _.m(e, a)) : _ && (_.d(1), _ = null), /*showUses*/
      k[9] ? y || (y = F6(), y.c(), y.m(e, null)) : y && (y.d(1), y = null), (!c || v & /*headingTemplateConfiguration*/
      2048) && z(
        e,
        "--a5e-section-heading-template-areas",
        /*headingTemplateConfiguration*/
        k[11].areas
      ), (!c || v & /*headingTemplateConfiguration*/
      2048) && z(
        e,
        "--a5e-section-heading-template-columns",
        /*headingTemplateConfiguration*/
        k[11].columns
      ), (!c || v & /*items*/
      8) && Q(e, "a5e-section-header--flat-bottom", [.../*items*/
      k[3]].length);
    },
    i(k) {
      c || (w(g), c = !0);
    },
    o(k) {
      C(g), c = !1;
    },
    d(k) {
      k && S(e), u && u.d(), m.d(), g && g.d(), h && h.d(), _ && _.d(), y && y.d();
    }
  };
}
f(D6, "create_if_block$1l");
function I6(i) {
  let e, t;
  return {
    c() {
      e = E("i"), b(e, "class", t = ni(
        /*icon*/
        i[0]
      ) + " svelte-8isinv");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*icon*/
      1 && t !== (t = ni(
        /*icon*/
        s[0]
      ) + " svelte-8isinv") && b(e, "class", t);
    },
    d(s) {
      s && S(e);
    }
  };
}
f(I6, "create_if_block_6$a");
function one(i) {
  let e = K(
    /*A5E*/
    (i[14][
      /*type*/
      i[4]
    ] ?? {})[
      /*label*/
      i[1]
    ] ?? /*label*/
    i[1]
  ) + "", t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*type, label*/
      18 && e !== (e = K(
        /*A5E*/
        (s[14][
          /*type*/
          s[4]
        ] ?? {})[
          /*label*/
          s[1]
        ] ?? /*label*/
        s[1]
      ) + "") && _e(t, e);
    },
    d(s) {
      s && S(t);
    }
  };
}
f(one, "create_else_block$q");
function ane(i) {
  let e = K(
    /*label*/
    i[1]
  ) + "", t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*label*/
      2 && e !== (e = K(
        /*label*/
        s[1]
      ) + "") && _e(t, e);
    },
    d(s) {
      s && S(t);
    }
  };
}
f(ane, "create_if_block_5$b");
function P6(i) {
  let e, t;
  return e = new Tv({ props: { level: (
    /*level*/
    i[2]
  ) } }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*level*/
      4 && (l.level = /*level*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(P6, "create_if_block_4$i");
function M6(i) {
  let e = K("A5E.SpellPointsCost", {
    cost: (
      /*A5E*/
      i[14].spellLevelCost[
        /*level*/
        i[2]
      ]
    )
  }) + "", t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*level*/
      4 && e !== (e = K("A5E.SpellPointsCost", {
        cost: (
          /*A5E*/
          s[14].spellLevelCost[
            /*level*/
            s[2]
          ]
        )
      }) + "") && _e(t, e);
    },
    d(s) {
      s && S(t);
    }
  };
}
f(M6, "create_if_block_3$m");
function R6(i) {
  let e;
  return {
    c() {
      e = E("h3"), e.textContent = "Quantity", b(e, "class", "a5e-section-header__heading a5e-section-header__heading--center a5e-section-header__heading--quantity svelte-8isinv");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(R6, "create_if_block_2$z");
function F6(i) {
  let e;
  return {
    c() {
      e = E("h3"), e.textContent = "Uses", b(e, "class", "a5e-section-header__heading a5e-section-header__heading--center a5e-section-header__heading--uses svelte-8isinv");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(F6, "create_if_block_1$T");
function N6(i, e) {
  let t, s, n, l, r, o;
  return s = new K5({
    props: {
      item: (
        /*item*/
        e[18]
      ),
      showDescription: (
        /*showDescription*/
        e[5]
      )
    }
  }), s.$on(
    "dropObject",
    /*dropObject_handler*/
    e[16]
  ), {
    key: i,
    first: null,
    c() {
      t = $e(), n = E("div"), L(s.$$.fragment), z(n, "display", "contents"), z(n, "--itemTemplateAreas", l = /*itemTemplateConfiguration*/
      e[10].areas), z(n, "--itemTemplateColumns", r = /*itemTemplateConfiguration*/
      e[10].columns), this.first = t;
    },
    m(a, c) {
      T(a, t, c), T(a, n, c), N(s, n, null), o = !0;
    },
    p(a, c) {
      e = a, c & /*itemTemplateConfiguration*/
      1024 && l !== (l = /*itemTemplateConfiguration*/
      e[10].areas) && z(n, "--itemTemplateAreas", l), c & /*itemTemplateConfiguration*/
      1024 && r !== (r = /*itemTemplateConfiguration*/
      e[10].columns) && z(n, "--itemTemplateColumns", r);
      const u = {};
      c & /*items*/
      8 && (u.item = /*item*/
      e[18]), c & /*showDescription*/
      32 && (u.showDescription = /*showDescription*/
      e[5]), s.$set(u);
    },
    i(a) {
      o || (w(s.$$.fragment, a), o = !0);
    },
    o(a) {
      C(s.$$.fragment, a), o = !1;
    },
    d(a) {
      a && S(t), a && s && S(n), j(s, a);
    }
  };
}
f(N6, "create_each_block$T");
function cne(i) {
  let e, t, s, n = [], l = /* @__PURE__ */ new Map(), r, o = !/*type*/
  (i[4] === "featureTypes" && /*$actor*/
  i[12].type === "npc") && D6(i), a = oe([.../*items*/
  i[3]]);
  const c = /* @__PURE__ */ f((u) => {
    var d;
    return (
      /*item*/
      (d = u[18]) == null ? void 0 : d.id
    );
  }, "get_key");
  for (let u = 0; u < a.length; u += 1) {
    let d = O6(i, a, u), p = c(d);
    l.set(p, n[u] = N6(p, d));
  }
  return {
    c() {
      e = E("section"), o && o.c(), t = R(), s = E("ul");
      for (let u = 0; u < n.length; u += 1)
        n[u].c();
      b(s, "class", "a5e-item-list"), b(e, "class", "category-container");
    },
    m(u, d) {
      T(u, e, d), o && o.m(e, null), A(e, t), A(e, s);
      for (let p = 0; p < n.length; p += 1)
        n[p] && n[p].m(s, null);
      r = !0;
    },
    p(u, [d]) {
      /*type*/
      u[4] === "featureTypes" && /*$actor*/
      u[12].type === "npc" ? o && (ce(), C(o, 1, 1, () => {
        o = null;
      }), ue()) : o ? (o.p(u, d), d & /*type, $actor*/
      4112 && w(o, 1)) : (o = D6(u), o.c(), w(o, 1), o.m(e, t)), d & /*items, showDescription, onDropObject, itemTemplateConfiguration*/
      33832 && (a = oe([.../*items*/
      u[3]]), ce(), n = kt(n, d, c, 1, u, a, l, s, ks, N6, null, O6), ue());
    },
    i(u) {
      if (!r) {
        w(o);
        for (let d = 0; d < a.length; d += 1)
          w(n[d]);
        r = !0;
      }
    },
    o(u) {
      C(o);
      for (let d = 0; d < n.length; d += 1)
        C(n[d]);
      r = !1;
    },
    d(u) {
      u && S(e), o && o.d();
      for (let d = 0; d < n.length; d += 1)
        n[d].d();
    }
  };
}
f(cne, "create_fragment$2r");
function une(i, e) {
  let t = "name", s = "1fr";
  return i ? e ? (t = "name quantity uses", s = "1fr 4rem 6.25rem") : (t = "name uses", s = "1fr 6.25rem") : e && (t = "name quantity", s = "1fr 4rem"), t += " menu", s += " 2rem", { areas: `"${t}"`, columns: s };
}
f(une, "getHeadingTemplateConfiguration");
function fne(i, e) {
  let t = "icon name indicators", s = "min-content 1fr min-content";
  return i ? e ? (t = "icon name indicators quantity uses", s = "min-content 1fr min-content 4rem 6.25rem") : (t = "icon name indicators uses", s = "min-content 1fr min-content 6.25rem") : e && (t = "icon name indicators quantity", s = "min-content 1fr min-content 4rem"), t += " menu", s += " 2rem", { areas: `"${t}"`, columns: s };
}
f(fne, "getItemTemplateConfiguration");
function dne(i, e, t) {
  let s, n, l, { icon: r = null } = e, { label: o } = e, { level: a = 0 } = e, { items: c } = e, { type: u } = e, { showDescription: d = !1 } = e, { showQuantity: p = !1 } = e, { showSpellPoints: m = !1 } = e, { showSpellSlots: g = !1 } = e, { showUses: h = !1 } = e;
  const _ = fe("actor");
  pe(i, _, (P) => t(12, l = P));
  const y = fe("sheet"), { A5E: k } = CONFIG;
  async function v(P, D) {
    var q;
    const I = JSON.parse(P.dataTransfer.getData("text/plain")).uuid, B = await fromUuid(I), H = P.target.closest(".a5e-item").getAttribute("data-document-uuid"), G = await fromUuid(H);
    if (((q = G == null ? void 0 : G.system) == null ? void 0 : q.objectType) === "container") {
      y._onDrop(P, { containerUuid: G.uuid });
      return;
    }
    if (!D.includes(B))
      return y._onDrop(P);
    const U = SortingHelpers.performIntegerSort(B, { target: G, siblings: D });
    l.updateEmbeddedDocuments("Item", U.map(({ target: W, update: X }) => ({ _id: W.id, sort: X.sort })));
  }
  f(v, "onDropObject");
  const O = /* @__PURE__ */ f(({ detail: P }) => v(P, [...c]), "dropObject_handler");
  return i.$$set = (P) => {
    "icon" in P && t(0, r = P.icon), "label" in P && t(1, o = P.label), "level" in P && t(2, a = P.level), "items" in P && t(3, c = P.items), "type" in P && t(4, u = P.type), "showDescription" in P && t(5, d = P.showDescription), "showQuantity" in P && t(6, p = P.showQuantity), "showSpellPoints" in P && t(7, m = P.showSpellPoints), "showSpellSlots" in P && t(8, g = P.showSpellSlots), "showUses" in P && t(9, h = P.showUses);
  }, i.$$.update = () => {
    i.$$.dirty & /*showUses, showQuantity*/
    576 && t(11, s = une(h, p)), i.$$.dirty & /*showUses, showQuantity*/
    576 && t(10, n = fne(h, p));
  }, [
    r,
    o,
    a,
    c,
    u,
    d,
    p,
    m,
    g,
    h,
    n,
    s,
    l,
    _,
    k,
    v,
    O
  ];
}
f(dne, "instance$2i");
const qS = class qS extends ie {
  constructor(e) {
    super(), le(this, e, dne, cne, ne, {
      icon: 0,
      label: 1,
      level: 2,
      items: 3,
      type: 4,
      showDescription: 5,
      showQuantity: 6,
      showSpellPoints: 7,
      showSpellSlots: 8,
      showUses: 9
    });
  }
};
f(qS, "ItemCategory");
let gl = qS;
function Qn(i) {
  return ((i == null ? void 0 : i.toString()) ?? "").replaceAll("-", "−");
}
f(Qn, "replaceHyphenWithMinusSign");
function j6(i) {
  let e, t, s = Cc(
    /*skill*/
    i[2].expertiseDice,
    !1
  ) + "", n, l;
  return {
    c() {
      e = E("span"), t = x("("), n = x(s), l = x(")"), b(e, "class", "u-text-xs");
    },
    m(r, o) {
      T(r, e, o), A(e, t), A(e, n), A(e, l);
    },
    p(r, o) {
      o & /*skill*/
      4 && s !== (s = Cc(
        /*skill*/
        r[2].expertiseDice,
        !1
      ) + "") && _e(n, s);
    },
    d(r) {
      r && S(e);
    }
  };
}
f(j6, "create_if_block_2$y");
function L6(i) {
  let e, t, s = (
    /*skill*/
    i[2].passive + ""
  ), n, l, r;
  return {
    c() {
      e = E("span"), t = x("("), n = x(s), l = x(")"), b(e, "class", "skill__passive svelte-1posc01"), b(e, "data-tooltip", r = K("A5E.SkillPassiveScore", {
        skill: (
          /*skills*/
          i[13][
            /*key*/
            i[1]
          ]
        )
      })), b(e, "data-tooltip-direction", "UP");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(e, n), A(e, l);
    },
    p(o, a) {
      a & /*skill*/
      4 && s !== (s = /*skill*/
      o[2].passive + "") && _e(n, s), a & /*key*/
      2 && r !== (r = K("A5E.SkillPassiveScore", {
        skill: (
          /*skills*/
          o[13][
            /*key*/
            o[1]
          ]
        )
      })) && b(e, "data-tooltip", r);
    },
    d(o) {
      o && S(e);
    }
  };
}
f(L6, "create_if_block_1$S");
function B6(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "fas fa-cog skill__config-button svelte-1posc01"), b(e, "data-tooltip", t = K("A5E.SkillConfigurationTooltip", {
        skill: (
          /*skills*/
          i[13][
            /*key*/
            i[1]
          ]
        )
      })), b(e, "data-tooltip-direction", "UP");
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "click",
        /*click_handler*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      r & /*key*/
      2 && t !== (t = K("A5E.SkillConfigurationTooltip", {
        skill: (
          /*skills*/
          l[13][
            /*key*/
            l[1]
          ]
        )
      })) && b(e, "data-tooltip", t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(B6, "create_if_block$1k");
function pne(i) {
  var I;
  let e, t, s, n, l, r, o, a = (
    /*skills*/
    i[13][
      /*key*/
      i[1]
    ] + ""
  ), c, u, d, p, m, g = Qn(
    /*showDeterministicBonus*/
    i[14] ? (
      /*skillBonus*/
      i[7] + /*abilityBonus*/
      i[8]
    ) : (
      /*skillBonus*/
      i[7]
    )
  ) + "", h, _, y, k, v, O = (
    /*skill*/
    i[2].expertiseDice && !/*hideExpertiseDice*/
    i[12] && j6(i)
  ), P = (
    /*$actor*/
    (((I = i[4].flags.a5e) == null ? void 0 : I.showPassiveScores) ?? !0) && L6(i)
  ), D = !/*sheetIsLocked*/
  i[5] && B6(i);
  return {
    c() {
      e = E("li"), t = E("button"), s = R(), n = E("button"), r = R(), o = E("h3"), c = x(a), u = R(), O && O.c(), d = R(), p = E("div"), m = E("span"), h = x(g), _ = R(), P && P.c(), y = R(), D && D.c(), b(t, "class", "skill__proficiency-icon svelte-1posc01"), b(
        t,
        "data-tooltip",
        /*proficiencyTooltip*/
        i[6]
      ), b(t, "data-tooltip-direction", "UP"), Q(
        t,
        "fa-solid",
        /*proficiencyLevel*/
        i[3]
      ), Q(t, "fa-regular", !/*proficiencyLevel*/
      i[3]), Q(
        t,
        "skill__proficiency-icon--expertise",
        /*proficiencyLevel*/
        i[3] === "expertise"
      ), Q(
        t,
        "skill__proficiency-icon--jack",
        /*proficiencyLevel*/
        i[3] === "jack"
      ), Q(
        t,
        "skill__proficiency-icon--proficient",
        /*proficiencyLevel*/
        i[3] === "proficient"
      ), Q(
        t,
        "skill__proficiency-icon--locked",
        /*sheetIsLocked*/
        i[5]
      ), Q(
        t,
        "fa-award",
        /*proficiencyLevel*/
        i[3] === "expertise"
      ), Q(
        t,
        "fa-star-half-stroke",
        /*proficiencyLevel*/
        i[3] === "jack"
      ), Q(t, "fa-star", !/*proficiencyLevel*/
      i[3] || /*proficiencyLevel*/
      i[3] === "proficient"), b(n, "for", l = /*$actor*/
      i[4].id + "-" + /*key*/
      i[1] + "-proficient"), b(n, "class", "fa-solid fa-dice-d20 skill__roll-icon svelte-1posc01"), Q(
        n,
        "skill__roll-icon--shift",
        /*$pressedKeysStore*/
        i[9].Shift
      ), Q(
        n,
        "skill__roll-icon--ctrl",
        /*$pressedKeysStore*/
        i[9].Control
      ), b(o, "class", "skill__name svelte-1posc01"), Q(o, "disable-pointer-events", !/*$actor*/
      i[4].isOwner), b(m, "class", "skill__mod svelte-1posc01"), b(p, "class", "skill__mod-wrapper svelte-1posc01"), b(e, "class", "skill svelte-1posc01"), Q(
        e,
        "skill--column-flow",
        /*columnFlow*/
        i[0]
      );
    },
    m(B, F) {
      T(B, e, F), A(e, t), A(e, s), A(e, n), A(e, r), A(e, o), A(o, c), A(o, u), O && O.m(o, null), A(e, d), A(e, p), A(p, m), A(m, h), A(p, _), P && P.m(p, null), A(e, y), D && D.m(e, null), k || (v = [
        V(
          t,
          "click",
          /*updateSkillProficiency*/
          i[10]
        ),
        V(o, "click", function() {
          $t(
            /*$actor*/
            i[4].rollSkillCheck(
              /*key*/
              i[1],
              Bi(
                /*$pressedKeysStore*/
                i[9]
              )
            )
          ) && i[4].rollSkillCheck(
            /*key*/
            i[1],
            Bi(
              /*$pressedKeysStore*/
              i[9]
            )
          ).apply(this, arguments);
        })
      ], k = !0);
    },
    p(B, [F]) {
      var H;
      i = B, F & /*proficiencyTooltip*/
      64 && b(
        t,
        "data-tooltip",
        /*proficiencyTooltip*/
        i[6]
      ), F & /*proficiencyLevel*/
      8 && Q(
        t,
        "fa-solid",
        /*proficiencyLevel*/
        i[3]
      ), F & /*proficiencyLevel*/
      8 && Q(t, "fa-regular", !/*proficiencyLevel*/
      i[3]), F & /*proficiencyLevel*/
      8 && Q(
        t,
        "skill__proficiency-icon--expertise",
        /*proficiencyLevel*/
        i[3] === "expertise"
      ), F & /*proficiencyLevel*/
      8 && Q(
        t,
        "skill__proficiency-icon--jack",
        /*proficiencyLevel*/
        i[3] === "jack"
      ), F & /*proficiencyLevel*/
      8 && Q(
        t,
        "skill__proficiency-icon--proficient",
        /*proficiencyLevel*/
        i[3] === "proficient"
      ), F & /*sheetIsLocked*/
      32 && Q(
        t,
        "skill__proficiency-icon--locked",
        /*sheetIsLocked*/
        i[5]
      ), F & /*proficiencyLevel*/
      8 && Q(
        t,
        "fa-award",
        /*proficiencyLevel*/
        i[3] === "expertise"
      ), F & /*proficiencyLevel*/
      8 && Q(
        t,
        "fa-star-half-stroke",
        /*proficiencyLevel*/
        i[3] === "jack"
      ), F & /*proficiencyLevel*/
      8 && Q(t, "fa-star", !/*proficiencyLevel*/
      i[3] || /*proficiencyLevel*/
      i[3] === "proficient"), F & /*$actor, key*/
      18 && l !== (l = /*$actor*/
      i[4].id + "-" + /*key*/
      i[1] + "-proficient") && b(n, "for", l), F & /*$pressedKeysStore*/
      512 && Q(
        n,
        "skill__roll-icon--shift",
        /*$pressedKeysStore*/
        i[9].Shift
      ), F & /*$pressedKeysStore*/
      512 && Q(
        n,
        "skill__roll-icon--ctrl",
        /*$pressedKeysStore*/
        i[9].Control
      ), F & /*key*/
      2 && a !== (a = /*skills*/
      i[13][
        /*key*/
        i[1]
      ] + "") && _e(c, a), /*skill*/
      i[2].expertiseDice && !/*hideExpertiseDice*/
      i[12] ? O ? O.p(i, F) : (O = j6(i), O.c(), O.m(o, null)) : O && (O.d(1), O = null), F & /*$actor*/
      16 && Q(o, "disable-pointer-events", !/*$actor*/
      i[4].isOwner), F & /*skillBonus, abilityBonus*/
      384 && g !== (g = Qn(
        /*showDeterministicBonus*/
        i[14] ? (
          /*skillBonus*/
          i[7] + /*abilityBonus*/
          i[8]
        ) : (
          /*skillBonus*/
          i[7]
        )
      ) + "") && _e(h, g), /*$actor*/
      ((H = i[4].flags.a5e) == null ? void 0 : H.showPassiveScores) ?? !0 ? P ? P.p(i, F) : (P = L6(i), P.c(), P.m(p, null)) : P && (P.d(1), P = null), /*sheetIsLocked*/
      i[5] ? D && (D.d(1), D = null) : D ? D.p(i, F) : (D = B6(i), D.c(), D.m(e, null)), F & /*columnFlow*/
      1 && Q(
        e,
        "skill--column-flow",
        /*columnFlow*/
        i[0]
      );
    },
    i: ee,
    o: ee,
    d(B) {
      B && S(e), O && O.d(), P && P.d(), D && D.d(), k = !1, Ne(v);
    }
  };
}
f(pne, "create_fragment$2q");
function mne(i, e) {
  var s;
  const t = (s = i.flags.a5e) == null ? void 0 : s.jackOfAllTrades;
  if (e.proficient === 2)
    return "expertise";
  if (e.proficient)
    return "proficient";
  if (t)
    return "jack";
}
f(mne, "getProficiencyLevel");
function hne(i, e, t) {
  var P, D;
  let s, n, l, r, o, a, c;
  pe(i, Mi, (I) => t(9, c = I));
  let { columnFlow: u } = e, { key: d } = e, { skill: p } = e;
  function m(I) {
    switch (I) {
      case "expertise":
        return "A5E.ProficiencyExpertise";
      case "jack":
        return "A5E.ProficiencyJack";
      case "proficient":
        return "A5E.ProficiencyProficient";
      default:
        return null;
    }
  }
  f(m, "getProficiencyTooltip");
  function g() {
    const I = p.proficient;
    let B;
    game.settings.get("a5e", "5eStyleExpertise") ? I === 2 ? B = 0 : I ? B = 2 : B = 1 : I ? B = 0 : B = 1, a.update({
      [`system.skills.${d}.proficient`]: B
    });
  }
  f(g, "updateSkillProficiency");
  function h() {
    const I = p.deterministicBonus;
    if (v)
      return I;
    {
      const B = at(a.BonusesManager.getAbilityBonusesFormula(p.ability, "check"), a.getRollData());
      return I - B;
    }
  }
  f(h, "getSkillBonus");
  const _ = fe("actor");
  pe(i, _, (I) => t(4, a = I));
  const y = game.settings.get("a5e", "hideExpertiseDice"), { skills: k } = CONFIG.A5E;
  let v = ((D = (P = a.flags) == null ? void 0 : P.a5e) == null ? void 0 : D.includeAbilityModifiersForSkills) ?? !0;
  const O = /* @__PURE__ */ f(() => a.configureSkill({ skillKey: d }), "click_handler");
  return i.$$set = (I) => {
    "columnFlow" in I && t(0, u = I.columnFlow), "key" in I && t(1, d = I.key), "skill" in I && t(2, p = I.skill);
  }, i.$$.update = () => {
    var I, B;
    i.$$.dirty & /*$actor, skill*/
    20 && t(8, s = a.system.abilities[p.ability].check.deterministicBonus), i.$$.dirty & /*$actor*/
    16 && t(7, n = h()), i.$$.dirty & /*$actor, skill*/
    20 && t(3, l = mne(a, p)), i.$$.dirty & /*proficiencyLevel*/
    8 && t(6, r = m(l)), i.$$.dirty & /*$actor*/
    16 && t(5, o = a.isOwner ? ((B = (I = a.flags) == null ? void 0 : I.a5e) == null ? void 0 : B.sheetIsLocked) ?? !0 : !0);
  }, [
    u,
    d,
    p,
    l,
    a,
    o,
    r,
    n,
    s,
    c,
    g,
    _,
    y,
    k,
    v,
    O
  ];
}
f(hne, "instance$2h");
const GS = class GS extends ie {
  constructor(e) {
    super(), le(this, e, hne, pne, ne, { columnFlow: 0, key: 1, skill: 2 });
  }
};
f(GS, "Skill");
let Cv = GS;
function q6(i, e, t) {
  const s = i.slice();
  return s[12] = e[t][0], s[13] = e[t][1], s[15] = t, s;
}
f(q6, "get_each_context$S");
function G6(i, e, t) {
  const s = i.slice();
  s[16] = e[t][0], s[13] = e[t][1];
  const n = (
    /*getSkillSpecialties*/
    s[3](
      /*skillKey*/
      s[16],
      /*skill*/
      s[13]
    )
  );
  s[17] = n;
  const l = K(
    /*A5E*/
    s[6].skills[
      /*skillKey*/
      s[16]
    ]
  );
  return s[18] = l, s;
}
f(G6, "get_each_context_1$9");
function z6(i, e, t) {
  const s = i.slice();
  return s[21] = e[t], s;
}
f(z6, "get_each_context_2$1");
function H6(i) {
  let e, t, s;
  return e = new bt({
    props: {
      $$slots: { default: [gne] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--border", "1px solid #ccc");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, skills*/
      16777217 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(H6, "create_if_block$1j");
function U6(i) {
  let e, t = (
    /*skillName*/
    i[18] + ""
  ), s, n, l, r, o = oe(
    /*specialties*/
    i[17]
  ), a = [];
  for (let c = 0; c < o.length; c += 1)
    a[c] = V6(z6(i, o, c));
  return {
    c() {
      e = E("dt"), s = x(t), n = R(), l = E("dd");
      for (let c = 0; c < a.length; c += 1)
        a[c].c();
      r = R(), b(e, "class", "a5e-skill-specialties__skill"), b(l, "class", "a5e-skill-specialties__list");
    },
    m(c, u) {
      T(c, e, u), A(e, s), A(e, n), T(c, l, u);
      for (let d = 0; d < a.length; d += 1)
        a[d] && a[d].m(l, null);
      A(l, r);
    },
    p(c, u) {
      if (u & /*skills*/
      1 && t !== (t = /*skillName*/
      c[18] + "") && _e(s, t), u & /*A5E, Object, skills, getSkillSpecialties, rollSkillCheckWithSpecialty*/
      89) {
        o = oe(
          /*specialties*/
          c[17]
        );
        let d;
        for (d = 0; d < o.length; d += 1) {
          const p = z6(c, o, d);
          a[d] ? a[d].p(p, u) : (a[d] = V6(p), a[d].c(), a[d].m(l, r));
        }
        for (; d < a.length; d += 1)
          a[d].d(1);
        a.length = o.length;
      }
    },
    d(c) {
      c && (S(e), S(l)), Le(a, c);
    }
  };
}
f(U6, "create_if_block_1$R");
function V6(i) {
  let e, t = (
    /*specialty*/
    i[21] + ""
  ), s, n, l, r;
  function o() {
    return (
      /*click_handler*/
      i[8](
        /*skillKey*/
        i[16]
      )
    );
  }
  return f(o, "click_handler"), {
    c() {
      e = E("button"), s = x(t), b(e, "class", "a5e-skill-specialties__list-item"), b(e, "data-tooltip", n = "Roll " + /*skillName*/
      i[18] + " check with " + /*specialty*/
      i[21] + " specialty"), b(e, "data-tooltip-direction", "UP");
    },
    m(a, c) {
      T(a, e, c), A(e, s), l || (r = V(e, "click", o), l = !0);
    },
    p(a, c) {
      i = a, c & /*skills*/
      1 && t !== (t = /*specialty*/
      i[21] + "") && _e(s, t), c & /*skills*/
      1 && n !== (n = "Roll " + /*skillName*/
      i[18] + " check with " + /*specialty*/
      i[21] + " specialty") && b(e, "data-tooltip", n);
    },
    d(a) {
      a && S(e), l = !1, r();
    }
  };
}
f(V6, "create_each_block_2$1");
function W6(i) {
  let e, t = (
    /*specialties*/
    i[17].length && U6(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*specialties*/
      s[17].length ? t ? t.p(s, n) : (t = U6(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && S(e), t && t.d(s);
    }
  };
}
f(W6, "create_each_block_1$9");
function gne(i) {
  let e, t, s, n = oe(Object.entries(
    /*skills*/
    i[0]
  )), l = [];
  for (let r = 0; r < n.length; r += 1)
    l[r] = W6(G6(i, n, r));
  return {
    c() {
      e = E("h3"), e.textContent = "Skill Specialties", t = R(), s = E("dl");
      for (let r = 0; r < l.length; r += 1)
        l[r].c();
      b(e, "class", "a5e-skill-specialties-heading svelte-19ieu9o"), b(s, "class", "a5e-skill-specialties");
    },
    m(r, o) {
      T(r, e, o), T(r, t, o), T(r, s, o);
      for (let a = 0; a < l.length; a += 1)
        l[a] && l[a].m(s, null);
    },
    p(r, o) {
      if (o & /*getSkillSpecialties, Object, skills, A5E, rollSkillCheckWithSpecialty*/
      89) {
        n = oe(Object.entries(
          /*skills*/
          r[0]
        ));
        let a;
        for (a = 0; a < n.length; a += 1) {
          const c = G6(r, n, a);
          l[a] ? l[a].p(c, o) : (l[a] = W6(c), l[a].c(), l[a].m(s, null));
        }
        for (; a < l.length; a += 1)
          l[a].d(1);
        l.length = n.length;
      }
    },
    d(r) {
      r && (S(e), S(t), S(s)), Le(l, r);
    }
  };
}
f(gne, "create_default_slot$10");
function K6(i) {
  let e, t;
  return e = new Cv({
    props: {
      key: (
        /*key*/
        i[12]
      ),
      skill: (
        /*skill*/
        i[13]
      ),
      columnFlow: (
        /*skillListFlowDirection*/
        i[1] === "column"
      )
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*skills*/
      1 && (l.key = /*key*/
      s[12]), n & /*skills*/
      1 && (l.skill = /*skill*/
      s[13]), n & /*skillListFlowDirection*/
      2 && (l.columnFlow = /*skillListFlowDirection*/
      s[1] === "column"), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(K6, "create_each_block$S");
function bne(i) {
  let e, t, s, n, l = (
    /*showSpecialties*/
    i[2] && H6(i)
  ), r = oe(Object.entries(
    /*skills*/
    i[0]
  )), o = [];
  for (let c = 0; c < r.length; c += 1)
    o[c] = K6(q6(i, r, c));
  const a = /* @__PURE__ */ f((c) => C(o[c], 1, 1, () => {
    o[c] = null;
  }), "out");
  return {
    c() {
      e = E("div"), l && l.c(), t = R(), s = E("ul");
      for (let c = 0; c < o.length; c += 1)
        o[c].c();
      b(s, "class", "skills-container svelte-19ieu9o"), Q(
        s,
        "skills-container--column-flow",
        /*skillListFlowDirection*/
        i[1] === "column"
      ), b(e, "class", "skill-page-wrapper svelte-19ieu9o");
    },
    m(c, u) {
      T(c, e, u), l && l.m(e, null), A(e, t), A(e, s);
      for (let d = 0; d < o.length; d += 1)
        o[d] && o[d].m(s, null);
      n = !0;
    },
    p(c, [u]) {
      if (/*showSpecialties*/
      c[2] ? l ? (l.p(c, u), u & /*showSpecialties*/
      4 && w(l, 1)) : (l = H6(c), l.c(), w(l, 1), l.m(e, t)) : l && (ce(), C(l, 1, 1, () => {
        l = null;
      }), ue()), u & /*Object, skills, skillListFlowDirection*/
      3) {
        r = oe(Object.entries(
          /*skills*/
          c[0]
        ));
        let d;
        for (d = 0; d < r.length; d += 1) {
          const p = q6(c, r, d);
          o[d] ? (o[d].p(p, u), w(o[d], 1)) : (o[d] = K6(p), o[d].c(), w(o[d], 1), o[d].m(s, null));
        }
        for (ce(), d = r.length; d < o.length; d += 1)
          a(d);
        ue();
      }
      (!n || u & /*skillListFlowDirection*/
      2) && Q(
        s,
        "skills-container--column-flow",
        /*skillListFlowDirection*/
        c[1] === "column"
      );
    },
    i(c) {
      if (!n) {
        w(l);
        for (let u = 0; u < r.length; u += 1)
          w(o[u]);
        n = !0;
      }
    },
    o(c) {
      C(l), o = o.filter(Boolean);
      for (let u = 0; u < o.length; u += 1)
        C(o[u]);
      n = !1;
    },
    d(c) {
      c && S(e), l && l.d(), Le(o, c);
    }
  };
}
f(bne, "create_fragment$2p");
function _ne(i, e, t) {
  let s, n, l, r;
  function o(h) {
    return game.settings.get("a5e", "hideSkillSpecialties") ? !1 : Object.values(h).some((_) => _.specialties.length);
  }
  f(o, "determineWhetherToShowSkillSpecialties");
  function a(h) {
    const _ = { ...h };
    return game.settings.get("a5e", "hideA5eSkills") && (delete _.cul, delete _.eng), _;
  }
  f(a, "getSkills");
  function c(h, _) {
    const y = _.specialties;
    return !Array.isArray(y) || !(y != null && y.length) ? [] : y.sort((k, v) => k.toLowerCase().localeCompare(v.toLowerCase())).map((k) => m[h] ? m[h][k] ?? k : k);
  }
  f(c, "getSkillSpecialties");
  function u(h) {
    const _ = r.system.skills[h].expertiseDice;
    r.rollSkillCheck(h, { expertiseDice: _ + 1 });
  }
  f(u, "rollSkillCheckWithSpecialty");
  const d = fe("actor");
  pe(i, d, (h) => t(7, r = h));
  const { A5E: p } = CONFIG, { skillSpecialties: m } = p, g = /* @__PURE__ */ f((h) => u(h), "click_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    128 && t(0, s = a(r.system.skills)), i.$$.dirty & /*skills*/
    1 && t(2, n = o(s));
  }, t(1, l = game.settings.get("a5e", "skillListFlowDirection")), [
    s,
    l,
    n,
    c,
    u,
    d,
    p,
    r,
    g
  ];
}
f(_ne, "instance$2g");
const zS = class zS extends ie {
  constructor(e) {
    super(), le(this, e, _ne, bne, ne, {});
  }
};
f(zS, "ActorSkillsPage");
let ip = zS;
function qi(i) {
  return [...i].some((e) => {
    var t, s, n;
    return (s = (t = e == null ? void 0 : e.system) == null ? void 0 : t.uses) != null && s.max ? !0 : (n = e == null ? void 0 : e.actions) == null ? void 0 : n.values().some((l) => {
      var r;
      return (r = l == null ? void 0 : l.uses) == null ? void 0 : r.max;
    });
  });
}
f(qi, "usesRequired");
function lp(i) {
  return [...i].some((e) => e.type === "object");
}
f(lp, "quantityRequired");
function Y6(i, e, t) {
  const s = i.slice();
  return s[9] = e[t][0], s[10] = e[t][1], s;
}
f(Y6, "get_each_context$R");
function X6(i) {
  let e, t, s = oe(Object.entries(
    /*resources*/
    i[0]
  )), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = J6(Y6(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("ol");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "resources-container svelte-14ay90f");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, o) {
      if (o & /*Object, resources*/
      1) {
        s = oe(Object.entries(
          /*resources*/
          r[0]
        ));
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = Y6(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = J6(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f(X6, "create_if_block_1$Q");
function J6(i) {
  let e, t;
  return e = new Av({
    props: {
      resource: (
        /*resource*/
        i[10]
      ),
      source: (
        /*source*/
        i[9]
      )
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*resources*/
      1 && (l.resource = /*resource*/
      s[10]), n & /*resources*/
      1 && (l.source = /*source*/
      s[9]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(J6, "create_each_block$R");
function yne(i) {
  let e, t;
  return e = new ip({}), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p: ee,
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(yne, "create_else_block$p");
function vne(i) {
  let e, t, s;
  return t = new gl({
    props: {
      label: "A5E.FavoriteItems",
      icon: "fas fa-star a5e-section-header__icon",
      items: [.../*$favorites*/
      i[5]].sort(Z6),
      type: "favorites",
      showQuantity: (
        /*showQuantity*/
        i[2]
      ),
      showUses: (
        /*showUses*/
        i[3]
      )
    }
  }), {
    c() {
      e = E("section"), L(t.$$.fragment), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--item-list");
    },
    m(n, l) {
      T(n, e, l), N(t, e, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$favorites*/
      32 && (r.items = [.../*$favorites*/
      n[5]].sort(Z6)), l & /*showQuantity*/
      4 && (r.showQuantity = /*showQuantity*/
      n[2]), l & /*showUses*/
      8 && (r.showUses = /*showUses*/
      n[3]), t.$set(r);
    },
    i(n) {
      s || (w(t.$$.fragment, n), s = !0);
    },
    o(n) {
      C(t.$$.fragment, n), s = !1;
    },
    d(n) {
      n && S(e), j(t);
    }
  };
}
f(vne, "create_if_block$1i");
function kne(i) {
  var u;
  let e, t, s, n, l, r = !/*flags*/
  (((u = i[4].a5e) == null ? void 0 : u.hideGenericResources) ?? /*$actor*/
  i[1].type === "npc") && X6(i);
  const o = [vne, yne], a = [];
  function c(d, p) {
    var m;
    return (
      /*flags*/
      ((m = d[4].a5e) == null ? void 0 : m.showFavoritesSection) ?? !0 ? 0 : 1
    );
  }
  return f(c, "select_block_type"), t = c(i), s = a[t] = o[t](i), {
    c() {
      r && r.c(), e = R(), s.c(), n = $e();
    },
    m(d, p) {
      r && r.m(d, p), T(d, e, p), a[t].m(d, p), T(d, n, p), l = !0;
    },
    p(d, [p]) {
      var g;
      /*flags*/
      ((g = d[4].a5e) == null ? void 0 : g.hideGenericResources) ?? /*$actor*/
      d[1].type === "npc" ? r && (ce(), C(r, 1, 1, () => {
        r = null;
      }), ue()) : r ? (r.p(d, p), p & /*flags, $actor*/
      18 && w(r, 1)) : (r = X6(d), r.c(), w(r, 1), r.m(e.parentNode, e));
      let m = t;
      t = c(d), t === m ? a[t].p(d, p) : (ce(), C(a[m], 1, 1, () => {
        a[m] = null;
      }), ue(), s = a[t], s ? s.p(d, p) : (s = a[t] = o[t](d), s.c()), w(s, 1), s.m(n.parentNode, n));
    },
    i(d) {
      l || (w(r), w(s), l = !0);
    },
    o(d) {
      C(r), C(s), l = !1;
    },
    d(d) {
      d && (S(e), S(n)), r && r.d(d), a[t].d(d);
    }
  };
}
f(kne, "create_fragment$2o");
const Z6 = /* @__PURE__ */ f((i, e) => i.sort - e.sort, "func$3");
function wne(i, e, t) {
  let s, n, l, { resources: r } = e;
  const o = fe("actor");
  pe(i, o, (p) => t(1, l = p));
  const { favorites: a } = o;
  pe(i, a, (p) => t(5, n = p));
  let c = lp(n), u = qi(n);
  const d = a.subscribe((p) => {
    t(2, c = lp(n)), t(3, u = qi(n));
  });
  return Nt(() => {
    d();
  }), i.$$set = (p) => {
    "resources" in p && t(0, r = p.resources);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    2 && t(0, r = l.system.resources), i.$$.dirty & /*$actor*/
    2 && t(4, s = l.flags);
  }, [r, l, c, u, s, n, o, a];
}
f(wne, "instance$2f");
const HS = class HS extends ie {
  constructor(e) {
    super(), le(this, e, wne, kne, ne, { resources: 0 });
  }
};
f(HS, "ActorCorePage");
let Ov = HS;
function Q6(i, e, t) {
  const s = i.slice();
  return s[7] = e[t][0], s[8] = e[t][1], s;
}
f(Q6, "get_each_context$Q");
function x6(i) {
  let e, t;
  return e = new ji({
    props: {
      $$slots: { default: [$ne] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope*/
      2048 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(x6, "create_if_block_1$P");
function $ne(i) {
  let e, t, s, n, l, r;
  return e = new Fi({ props: { reducerType: Ib } }), s = new Ni({
    props: {
      reducerType: Ib,
      documentName: "ActiveEffect"
    }
  }), l = new Ys({
    props: {
      reducerType: Ib,
      documentName: "ActiveEffect"
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment);
    },
    m(o, a) {
      N(e, o, a), T(o, t, a), N(s, o, a), T(o, n, a), N(l, o, a), r = !0;
    },
    p: ee,
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(s.$$.fragment, o), C(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (S(t), S(n)), j(e, o), j(s, o), j(l, o);
    }
  };
}
f($ne, "create_default_slot$$");
function eR(i) {
  let e, t;
  return e = new Fc({
    props: {
      label: (
        /*subTypes*/
        i[4][
          /*label*/
          i[7]
        ]
      ),
      effects: (
        /*effects*/
        i[8]
      )
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$activeEffects*/
      2 && (l.label = /*subTypes*/
      s[4][
        /*label*/
        s[7]
      ]), n & /*$activeEffects*/
      2 && (l.effects = /*effects*/
      s[8]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(eR, "create_if_block$1h");
function tR(i) {
  let e, t, s = (
    /*effects*/
    i[8].length && eR(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*effects*/
      n[8].length ? s ? (s.p(n, l), l & /*$activeEffects*/
      2 && w(s, 1)) : (s = eR(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ce(), C(s, 1, 1, () => {
        s = null;
      }), ue());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f(tR, "create_each_block$Q");
function Ane(i) {
  let e, t, s, n = (
    /*$actor*/
    i[0].isOwner && x6(i)
  ), l = oe(Object.entries(
    /*$activeEffects*/
    i[1]._types
  )), r = [];
  for (let a = 0; a < l.length; a += 1)
    r[a] = tR(Q6(i, l, a));
  const o = /* @__PURE__ */ f((a) => C(r[a], 1, 1, () => {
    r[a] = null;
  }), "out");
  return {
    c() {
      n && n.c(), e = R(), t = E("section");
      for (let a = 0; a < r.length; a += 1)
        r[a].c();
      b(t, "class", "a5e-page-wrapper a5e-page-wrapper--item-list");
    },
    m(a, c) {
      n && n.m(a, c), T(a, e, c), T(a, t, c);
      for (let u = 0; u < r.length; u += 1)
        r[u] && r[u].m(t, null);
      s = !0;
    },
    p(a, [c]) {
      if (/*$actor*/
      a[0].isOwner ? n ? (n.p(a, c), c & /*$actor*/
      1 && w(n, 1)) : (n = x6(a), n.c(), w(n, 1), n.m(e.parentNode, e)) : n && (ce(), C(n, 1, 1, () => {
        n = null;
      }), ue()), c & /*subTypes, Object, $activeEffects*/
      18) {
        l = oe(Object.entries(
          /*$activeEffects*/
          a[1]._types
        ));
        let u;
        for (u = 0; u < l.length; u += 1) {
          const d = Q6(a, l, u);
          r[u] ? (r[u].p(d, c), w(r[u], 1)) : (r[u] = tR(d), r[u].c(), w(r[u], 1), r[u].m(t, null));
        }
        for (ce(), u = l.length; u < r.length; u += 1)
          o(u);
        ue();
      }
    },
    i(a) {
      if (!s) {
        w(n);
        for (let c = 0; c < l.length; c += 1)
          w(r[c]);
        s = !0;
      }
    },
    o(a) {
      C(n), r = r.filter(Boolean);
      for (let c = 0; c < r.length; c += 1)
        C(r[c]);
      s = !1;
    },
    d(a) {
      a && (S(e), S(t)), n && n.d(a), Le(r, a);
    }
  };
}
f(Ane, "create_fragment$2n");
const Ib = "activeEffects";
function Ene(i, e, t) {
  let s, n;
  const l = fe("actor");
  pe(i, l, (u) => t(0, s = u));
  const { activeEffects: r } = l;
  pe(i, r, (u) => t(1, n = u));
  const { A5E: o, statusEffects: a } = CONFIG, c = o.activeEffectTypes;
  return [s, n, l, r, c];
}
f(Ene, "instance$2e");
const US = class US extends ie {
  constructor(e) {
    super(), le(this, e, Ene, Ane, ne, {});
  }
};
f(US, "ActorEffectsPage");
let Dv = US;
function sR(i, e = "inclusive") {
  return e === "exclusive" ? (t) => !foundry.utils.getProperty(t, i) : (t) => foundry.utils.getProperty(t, i);
}
f(sR, "booleanFilter$1");
function nR(i, e, t = "inclusive") {
  return t === "exclusive" ? (s) => foundry.utils.getProperty(s, i) != e : (s) => foundry.utils.getProperty(s, i) == e;
}
f(nR, "valueBasedFilter");
function iR(i, e, t = "inclusive") {
  return /* @__PURE__ */ f((n) => {
    var r;
    const l = (r = n.actions) == null ? void 0 : r.activationTypes;
    return l ? t === "exclusive" ? l.some((o) => e != o) : l.some((o) => e == o) : !1;
  }, "filter");
}
f(iR, "actionBasedFilter");
function lR(i, e, t) {
  var o, a;
  const s = [...i.filters].reduce((c, u) => {
    var d;
    return (d = u == null ? void 0 : u.id) != null && d.includes(`${e}-`) && c.push(u.id), c;
  }, []);
  i.filters.removeById(...s);
  const n = Object.values(CONFIG.A5E.filters[e]).reduce((c, u) => ({ ...c, ...u.filters }), {}), l = [], r = [];
  (o = t == null ? void 0 : t.inclusive) == null || o.forEach((c) => {
    const { key: u, type: d, truthValue: p } = n[c];
    let m;
    if (d === "boolean")
      m = sR(u);
    else if (d === "value")
      m = nR(u, c);
    else if (d === "action")
      m = iR(u, c);
    else
      return;
    p === "or" ? r.push(m) : l.push({
      id: `${e}-${c}`,
      filter: m
    });
  }), (a = t == null ? void 0 : t.exclusive) == null || a.forEach((c) => {
    const { key: u, type: d } = n[c];
    let p;
    if (d === "boolean")
      p = sR(u, "exclusive");
    else if (d === "value")
      p = nR(u, c, "exclusive");
    else if (d === "action")
      p = iR(u, c, "exclusive");
    else
      return;
    l.push({
      id: `${e}-${c}`,
      filter: p
    });
  }), i.filters.add(...l), r.length && i.filters.add({
    id: `${e}-or`,
    filter: (c) => r.some((u) => u(c))
  });
}
f(lR, "updateFilters");
function rR(i, e, t) {
  const s = i.slice();
  return s[9] = e[t][0], s[10] = e[t][1], s;
}
f(rR, "get_each_context$P");
function oR(i) {
  let e, t, s;
  return e = new Cr({
    props: {
      active: (
        /*selected*/
        i[3][0].includes(
          /*value*/
          i[9]
        )
      ),
      orange: (
        /*selected*/
        i[3][1].includes(
          /*value*/
          i[9]
        ) && /*color*/
        i[0] === "orange"
      ),
      red: (
        /*selected*/
        i[3][1].includes(
          /*value*/
          i[9]
        ) && /*color*/
        i[0] === "red"
      ),
      label: (
        /*label*/
        i[10]
      ),
      value: (
        /*value*/
        i[9]
      )
    }
  }), e.$on(
    "tagToggle",
    /*tagToggle_handler*/
    i[6]
  ), e.$on(
    "tagToggleAux",
    /*tagToggleAux_handler*/
    i[7]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--color-hover", "black");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*selected, options*/
      12 && (r.active = /*selected*/
      n[3][0].includes(
        /*value*/
        n[9]
      )), l & /*selected, options, color*/
      13 && (r.orange = /*selected*/
      n[3][1].includes(
        /*value*/
        n[9]
      ) && /*color*/
      n[0] === "orange"), l & /*selected, options, color*/
      13 && (r.red = /*selected*/
      n[3][1].includes(
        /*value*/
        n[9]
      ) && /*color*/
      n[0] === "red"), l & /*options*/
      4 && (r.label = /*label*/
      n[10]), l & /*options*/
      4 && (r.value = /*value*/
      n[9]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(oR, "create_each_block$P");
function aR(i) {
  let e, t = K(
    /*hint*/
    i[1]
  ) + "", s;
  return {
    c() {
      e = E("p"), s = x(t), b(e, "class", "hint svelte-yo3pbl");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*hint*/
      2 && t !== (t = K(
        /*hint*/
        n[1]
      ) + "") && _e(s, t);
    },
    d(n) {
      n && S(e);
    }
  };
}
f(aR, "create_if_block$1g");
function Sne(i) {
  let e, t, s, n, l = oe(
    /*options*/
    i[2]
  ), r = [];
  for (let c = 0; c < l.length; c += 1)
    r[c] = oR(rR(i, l, c));
  const o = /* @__PURE__ */ f((c) => C(r[c], 1, 1, () => {
    r[c] = null;
  }), "out");
  let a = (
    /*hint*/
    i[1] && aR(i)
  );
  return {
    c() {
      e = E("ul");
      for (let c = 0; c < r.length; c += 1)
        r[c].c();
      t = R(), a && a.c(), s = $e(), b(e, "class", "u-flex u-flex-wrap u-gap-sm u-list-style-none u-m-0 u-p-0 u-text-xs u-w-full ");
    },
    m(c, u) {
      T(c, e, u);
      for (let d = 0; d < r.length; d += 1)
        r[d] && r[d].m(e, null);
      T(c, t, u), a && a.m(c, u), T(c, s, u), n = !0;
    },
    p(c, [u]) {
      if (u & /*selected, options, color, updateSelection*/
      29) {
        l = oe(
          /*options*/
          c[2]
        );
        let d;
        for (d = 0; d < l.length; d += 1) {
          const p = rR(c, l, d);
          r[d] ? (r[d].p(p, u), w(r[d], 1)) : (r[d] = oR(p), r[d].c(), w(r[d], 1), r[d].m(e, null));
        }
        for (ce(), d = l.length; d < r.length; d += 1)
          o(d);
        ue();
      }
      /*hint*/
      c[1] ? a ? a.p(c, u) : (a = aR(c), a.c(), a.m(s.parentNode, s)) : a && (a.d(1), a = null);
    },
    i(c) {
      if (!n) {
        for (let u = 0; u < l.length; u += 1)
          w(r[u]);
        n = !0;
      }
    },
    o(c) {
      r = r.filter(Boolean);
      for (let u = 0; u < r.length; u += 1)
        C(r[u]);
      n = !1;
    },
    d(c) {
      c && (S(e), S(t), S(s)), Le(r, c), a && a.d(c);
    }
  };
}
f(Sne, "create_fragment$2m");
function Tne(i, e, t) {
  let { auxEnabled: s = !0 } = e, { color: n = "orange" } = e, { hint: l = "" } = e, { options: r = [] } = e, { selected: o = [[], []] } = e;
  function a(p, m = !1) {
    let g = o.map((h) => new Set(h));
    g[0].has(p) ? (g[0].delete(p), g[1].add(p)) : g[1].has(p) ? g[1].delete(p) : s && m ? g[1].add(p) : g[0].add(p), g = g.map((h) => [...h]), c("updateSelection", g);
  }
  f(a, "updateSelection");
  const c = it(), u = /* @__PURE__ */ f(({ detail: p }) => a(p), "tagToggle_handler"), d = /* @__PURE__ */ f(({ detail: p }) => a(p, !0), "tagToggleAux_handler");
  return i.$$set = (p) => {
    "auxEnabled" in p && t(5, s = p.auxEnabled), "color" in p && t(0, n = p.color), "hint" in p && t(1, l = p.hint), "options" in p && t(2, r = p.options), "selected" in p && t(3, o = p.selected);
  }, [
    n,
    l,
    r,
    o,
    a,
    s,
    u,
    d
  ];
}
f(Tne, "instance$2d");
const VS = class VS extends ie {
  constructor(e) {
    super(), le(this, e, Tne, Sne, ne, {
      auxEnabled: 5,
      color: 0,
      hint: 1,
      options: 2,
      selected: 3
    });
  }
};
f(VS, "MultiStateCheckBoxGroup");
let rp = VS;
function cR(i, e, t) {
  const s = i.slice();
  return s[16] = e[t].label, s[17] = e[t].filters, s;
}
f(cR, "get_each_context$O");
function uR(i) {
  var m, g;
  let e, t, s, n, l, r, o, a, c, u, d;
  function p() {
    return (
      /*click_handler*/
      i[11](
        /*filters*/
        i[17]
      )
    );
  }
  return f(p, "click_handler"), a = new rp({
    props: {
      options: Object.entries(
        /*filters*/
        i[17]
      ).map(Ine),
      selected: [
        /*activeFilters*/
        ((m = i[0]) == null ? void 0 : m.inclusive) ?? [],
        /*activeFilters*/
        ((g = i[0]) == null ? void 0 : g.exclusive) ?? []
      ]
    }
  }), a.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[12]
  ), {
    c() {
      e = E("section"), t = E("header"), s = E("h3"), s.textContent = `${K(
        /*label*/
        i[16]
      )}`, n = R(), l = E("button"), l.textContent = `${K("A5E.ButtonToggleAll")}`, r = R(), o = E("div"), L(a.$$.fragment), b(s, "class", "u-text-sm u-text-bold"), b(l, "class", "filter-button u-text-xs svelte-c0dakz"), b(t, "class", "u-align-center u-flex u-gap-lg"), b(o, "class", "filters u-text-xs u-w-full svelte-c0dakz"), b(e, "class", "filter-section svelte-c0dakz");
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(t, s), A(t, n), A(t, l), A(e, r), A(e, o), N(a, o, null), c = !0, u || (d = V(l, "click", We(p)), u = !0);
    },
    p(h, _) {
      var k, v;
      i = h;
      const y = {};
      _ & /*activeFilters*/
      1 && (y.selected = [
        /*activeFilters*/
        ((k = i[0]) == null ? void 0 : k.inclusive) ?? [],
        /*activeFilters*/
        ((v = i[0]) == null ? void 0 : v.exclusive) ?? []
      ]), a.$set(y);
    },
    i(h) {
      c || (w(a.$$.fragment, h), c = !0);
    },
    o(h) {
      C(a.$$.fragment, h), c = !1;
    },
    d(h) {
      h && S(e), j(a), u = !1, d();
    }
  };
}
f(uR, "create_each_block$O");
function Cne(i) {
  let e, t, s, n, l = oe(
    /*filterSections*/
    i[7]
  ), r = [];
  for (let a = 0; a < l.length; a += 1)
    r[a] = uR(cR(i, l, a));
  const o = /* @__PURE__ */ f((a) => C(r[a], 1, 1, () => {
    r[a] = null;
  }), "out");
  return {
    c() {
      e = E("article");
      for (let a = 0; a < r.length; a += 1)
        r[a].c();
      t = R(), s = E("div"), s.textContent = `Hint: Right-click a filter to quickly remove it from the
                    selection.`, b(s, "class", "hint svelte-c0dakz"), b(e, "class", "filter-box svelte-c0dakz");
    },
    m(a, c) {
      T(a, e, c);
      for (let u = 0; u < r.length; u += 1)
        r[u] && r[u].m(e, null);
      A(e, t), A(e, s), n = !0;
    },
    p(a, c) {
      if (c & /*Object, filterSections, activeFilters, onUpdateFilters, toggleAll*/
      225) {
        l = oe(
          /*filterSections*/
          a[7]
        );
        let u;
        for (u = 0; u < l.length; u += 1) {
          const d = cR(a, l, u);
          r[u] ? (r[u].p(d, c), w(r[u], 1)) : (r[u] = uR(d), r[u].c(), w(r[u], 1), r[u].m(e, t));
        }
        for (ce(), u = l.length; u < r.length; u += 1)
          o(u);
        ue();
      }
    },
    i(a) {
      if (!n) {
        for (let c = 0; c < l.length; c += 1)
          w(r[c]);
        n = !0;
      }
    },
    o(a) {
      r = r.filter(Boolean);
      for (let c = 0; c < r.length; c += 1)
        C(r[c]);
      n = !1;
    },
    d(a) {
      a && S(e), Le(r, a);
    }
  };
}
f(Cne, "create_default_slot_1$q");
function One(i) {
  let e, t;
  return e = new tp({
    props: {
      $$slots: { default: [Cne] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, activeFilters*/
      1048577 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(One, "create_default_slot$_");
function Dne(i) {
  let e, t, s, n;
  return t = new Qd({
    props: {
      title: "Filters",
      icon: "fas fa-filter",
      $$slots: { default: [One] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("span"), s = E("div"), L(t.$$.fragment), z(s, "display", "contents"), z(s, "--tjs-icon-button-background-hover", "none"), z(s, "--tjs-icon-button-background-focus", "none"), z(s, "--tjs-icon-button-background-focus-visible", "none"), z(s, "--tjs-icon-button-background-selected", "none"), z(s, "--tjs-icon-button-text-shadow-hover", "none"), z(s, "--tjs-icon-button-text-shadow-focus", "none"), z(s, "--tjs-icon-button-transition", "all 0.15s ease-in-out"), z(s, "--tjs-icon-button-diameter", "1.1rem"), z(s, "--tjs-icon-button-border-radius", "0"), b(e, "class", "filter-hints svelte-c0dakz"), b(
        e,
        "data-tooltip",
        /*filterTooltip*/
        i[3]
      ), b(e, "data-tooltip-direction", "UP"), Q(
        e,
        "filter-hints--green",
        /*numInclusiveFilters*/
        i[2]
      ), Q(
        e,
        "filter-hints--red",
        /*numExclusiveFilters*/
        i[1]
      );
    },
    m(l, r) {
      T(l, e, r), A(e, s), N(t, s, null), n = !0;
    },
    p(l, [r]) {
      const o = {};
      r & /*$$scope, activeFilters*/
      1048577 && (o.$$scope = { dirty: r, ctx: l }), t.$set(o), (!n || r & /*filterTooltip*/
      8) && b(
        e,
        "data-tooltip",
        /*filterTooltip*/
        l[3]
      ), (!n || r & /*numInclusiveFilters*/
      4) && Q(
        e,
        "filter-hints--green",
        /*numInclusiveFilters*/
        l[2]
      ), (!n || r & /*numExclusiveFilters*/
      2) && Q(
        e,
        "filter-hints--red",
        /*numExclusiveFilters*/
        l[1]
      );
    },
    i(l) {
      n || (w(t.$$.fragment, l), n = !0);
    },
    o(l) {
      C(t.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(e), j(t);
    }
  };
}
f(Dne, "create_fragment$2l");
const Ine = /* @__PURE__ */ f(([i, { label: e }]) => [i, e], "func$2");
function Pne(i, e, t) {
  let s, n, l, r, { reducerId: o = "" } = e, { reducerType: a } = e, { reducer: c = null } = e;
  const u = fe("actor");
  pe(i, u, (v) => t(13, r = v)), c || (c = u[a]);
  function d(v, O) {
    return v && O ? `Inclusive Filters: ${v} &nbsp;&nbsp;|&nbsp;&nbsp; Exclusive Filers: ${O}` : v ? `Inclusive Filters: ${v}` : O ? `Exclusive Filters: ${O}` : null;
  }
  f(d, "getFilterTooltip");
  function p(v, O) {
    r.setFlag("a5e", h, {
      inclusive: v,
      exclusive: O
    }), t(0, _.inclusive = v, _), t(0, _.exclusive = O, _), lR(c, a, _);
  }
  f(p, "onUpdateFilters");
  function m(v) {
    var D, I;
    v = Object.keys(v);
    const O = (D = _ == null ? void 0 : _.inclusive) == null ? void 0 : D.filter((B) => v.includes(B));
    if (Sc(O, v)) {
      const B = (I = _ == null ? void 0 : _.inclusive) == null ? void 0 : I.filter((F) => !v.includes(F));
      return p(B, []);
    }
    const P = /* @__PURE__ */ new Set([...v, ..._ == null ? void 0 : _.inclusive]);
    return p([...P], []);
  }
  f(m, "toggleAll");
  const g = Object.values(CONFIG.A5E.filters[a] ?? {}), h = o ? `filters.${a}.${o}` : `filters.${a}`;
  let _ = r.getFlag("a5e", h) ?? {};
  lR(c, a, _);
  const y = /* @__PURE__ */ f((v) => m(v), "click_handler"), k = /* @__PURE__ */ f(({ detail: v }) => p(v[0], v[1]), "updateSelection_handler");
  return i.$$set = (v) => {
    "reducerId" in v && t(9, o = v.reducerId), "reducerType" in v && t(10, a = v.reducerType), "reducer" in v && t(8, c = v.reducer);
  }, i.$$.update = () => {
    var v, O;
    i.$$.dirty & /*activeFilters*/
    1 && t(2, s = ((v = _ == null ? void 0 : _.inclusive) == null ? void 0 : v.length) ?? 0), i.$$.dirty & /*activeFilters*/
    1 && t(1, n = ((O = _ == null ? void 0 : _.exclusive) == null ? void 0 : O.length) ?? 0), i.$$.dirty & /*numInclusiveFilters, numExclusiveFilters*/
    6 && t(3, l = d(s, n));
  }, [
    _,
    n,
    s,
    l,
    u,
    p,
    m,
    g,
    c,
    o,
    a,
    y,
    k
  ];
}
f(Pne, "instance$2c");
const WS = class WS extends ie {
  constructor(e) {
    super(), le(this, e, Pne, Dne, ne, {
      reducerId: 9,
      reducerType: 10,
      reducer: 8
    });
  }
};
f(WS, "Filter");
let Ea = WS;
function Mne(i) {
  let e, t, s;
  return e = new ya({
    props: {
      title: "Show Description",
      icon: "fa-solid fa-info-circle",
      onPress: (
        /*func*/
        i[1]
      )
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--tjs-icon-button-background-hover", "none"), z(t, "--tjs-icon-button-background-focus", "none"), z(t, "--tjs-icon-button-background-focus-visible", "none"), z(t, "--tjs-icon-button-background-selected", "none"), z(t, "--tjs-icon-button-text-shadow-hover", "none"), z(t, "--tjs-icon-button-text-shadow-focus", "none"), z(t, "--tjs-icon-button-transition", "all 0.15s ease-in-out"), z(t, "--tjs-icon-button-diameter", "1.1rem"), z(t, "--tjs-icon-button-border-radius", "0");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p: ee,
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(Mne, "create_fragment$2k");
function Rne(i) {
  const e = it();
  return [e, /* @__PURE__ */ f(() => e("updateSelection"), "func")];
}
f(Rne, "instance$2b");
const KS = class KS extends ie {
  constructor(e) {
    super(), le(this, e, Rne, Mne, ne, {});
  }
};
f(KS, "ShowDescription");
let Sa = KS;
function fR(i, e, t) {
  const s = i.slice();
  return s[13] = e[t][0], s[14] = e[t][1], s;
}
f(fR, "get_each_context$N");
function dR(i) {
  let e, t;
  return e = new ji({
    props: {
      $$slots: { default: [Fne] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, menuList, showDescription*/
      131090 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(dR, "create_if_block_2$x");
function Fne(i) {
  let e, t, s, n, l, r, o, a, c, u;
  return e = new Fi({ props: { reducerType: Vf } }), s = new Sa({}), s.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[8]
  ), l = new Ni({ props: { reducerType: Vf } }), o = new Ea({ props: { reducerType: Vf } }), c = new Ys({
    props: {
      reducerType: Vf,
      menuList: (
        /*menuList*/
        i[4]
      )
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment), r = R(), L(o.$$.fragment), a = R(), L(c.$$.fragment);
    },
    m(d, p) {
      N(e, d, p), T(d, t, p), N(s, d, p), T(d, n, p), N(l, d, p), T(d, r, p), N(o, d, p), T(d, a, p), N(c, d, p), u = !0;
    },
    p(d, p) {
      const m = {};
      p & /*menuList*/
      16 && (m.menuList = /*menuList*/
      d[4]), c.$set(m);
    },
    i(d) {
      u || (w(e.$$.fragment, d), w(s.$$.fragment, d), w(l.$$.fragment, d), w(o.$$.fragment, d), w(c.$$.fragment, d), u = !0);
    },
    o(d) {
      C(e.$$.fragment, d), C(s.$$.fragment, d), C(l.$$.fragment, d), C(o.$$.fragment, d), C(c.$$.fragment, d), u = !1;
    },
    d(d) {
      d && (S(t), S(n), S(r), S(a)), j(e, d), j(s, d), j(l, d), j(o, d), j(c, d);
    }
  };
}
f(Fne, "create_default_slot$Z");
function Nne(i) {
  let e, t, s = oe(
    /*sortedFeatures*/
    i[3]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = mR(fR(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, o) {
      if (o & /*sortedFeatures, showDescription, showUses*/
      14) {
        s = oe(
          /*sortedFeatures*/
          r[3]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = fR(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = mR(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f(Nne, "create_else_block$o");
function jne(i) {
  let e, t;
  return e = new gl({
    props: {
      showDescription: (
        /*showDescription*/
        i[1]
      ),
      label: "",
      items: (
        /*$features*/
        i[0]
      ),
      showUses: (
        /*showUses*/
        i[2]
      ),
      type: "featureTypes"
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*showDescription*/
      2 && (l.showDescription = /*showDescription*/
      s[1]), n & /*$features*/
      1 && (l.items = /*$features*/
      s[0]), n & /*showUses*/
      4 && (l.showUses = /*showUses*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(jne, "create_if_block$1f");
function pR(i) {
  let e, t;
  return e = new gl({
    props: {
      label: (
        /*label*/
        i[13]
      ),
      items: (
        /*items*/
        i[14]
      ),
      showDescription: (
        /*showDescription*/
        i[1]
      ),
      showUses: (
        /*showUses*/
        i[2]
      ),
      type: "featureTypes"
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*sortedFeatures*/
      8 && (l.label = /*label*/
      s[13]), n & /*sortedFeatures*/
      8 && (l.items = /*items*/
      s[14]), n & /*showDescription*/
      2 && (l.showDescription = /*showDescription*/
      s[1]), n & /*showUses*/
      4 && (l.showUses = /*showUses*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(pR, "create_if_block_1$O");
function mR(i) {
  let e, t, s = (
    /*items*/
    i[14].length && pR(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*items*/
      n[14].length ? s ? (s.p(n, l), l & /*sortedFeatures*/
      8 && w(s, 1)) : (s = pR(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ce(), C(s, 1, 1, () => {
        s = null;
      }), ue());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f(mR, "create_each_block$N");
function Lne(i) {
  let e, t, s, n, l, r, o, a = (
    /*$actor*/
    i[5].isOwner && dR(i)
  );
  const c = [jne, Nne], u = [];
  function d(p, m) {
    return (
      /*$actor*/
      p[5].type === "npc" ? 0 : 1
    );
  }
  return f(d, "select_block_type"), s = d(i), n = u[s] = c[s](i), {
    c() {
      a && a.c(), e = R(), t = E("section"), n.c(), l = R(), r = E("footer"), b(t, "class", "a5e-page-wrapper a5e-page-wrapper--item-list"), b(r, "class", "features-footer");
    },
    m(p, m) {
      a && a.m(p, m), T(p, e, m), T(p, t, m), u[s].m(t, null), T(p, l, m), T(p, r, m), o = !0;
    },
    p(p, [m]) {
      /*$actor*/
      p[5].isOwner ? a ? (a.p(p, m), m & /*$actor*/
      32 && w(a, 1)) : (a = dR(p), a.c(), w(a, 1), a.m(e.parentNode, e)) : a && (ce(), C(a, 1, 1, () => {
        a = null;
      }), ue());
      let g = s;
      s = d(p), s === g ? u[s].p(p, m) : (ce(), C(u[g], 1, 1, () => {
        u[g] = null;
      }), ue(), n = u[s], n ? n.p(p, m) : (n = u[s] = c[s](p), n.c()), w(n, 1), n.m(t, null));
    },
    i(p) {
      o || (w(a), w(n), o = !0);
    },
    o(p) {
      C(a), C(n), o = !1;
    },
    d(p) {
      p && (S(e), S(t), S(l), S(r)), a && a.d(p), u[s].d();
    }
  };
}
f(Lne, "create_fragment$2j");
const Vf = "features";
function Bne(i, e, t) {
  let s, n, l, r;
  const o = fe("actor");
  pe(i, o, (_) => t(5, r = _));
  const { features: a } = o;
  pe(i, a, (_) => t(0, l = _));
  const { A5E: c } = CONFIG, u = c.featureTypes, d = CONFIG.A5E.reducerSortMap.features;
  let p = !1, m = qi(a);
  const g = a.subscribe((_) => {
    t(2, m = qi(a));
  });
  Nt(() => {
    g();
  });
  const h = /* @__PURE__ */ f(() => t(1, p = !p), "updateSelection_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$features*/
    1 && t(3, n = Object.entries(l._types).sort((_, y) => d[_[0]] - d[y[0]]));
  }, t(4, s = Object.entries(u)), [
    l,
    p,
    m,
    n,
    s,
    r,
    o,
    a,
    h
  ];
}
f(Bne, "instance$2a");
const YS = class YS extends ie {
  constructor(e) {
    super(), le(this, e, Bne, Lne, ne, {});
  }
};
f(YS, "ActorFeaturesPage");
let Iv = YS;
function hR(i, e, t) {
  const s = i.slice();
  return s[14] = e[t][0], s[15] = e[t][1], s;
}
f(hR, "get_each_context$M");
function gR(i) {
  let e, t, s, n, l = (
    /*attunement*/
    i[5].current + ""
  ), r, o, a, c, u, d, p, m = K("A5E.Supply") + "", g, h, _, y, k;
  return {
    c() {
      e = E("div"), t = E("h3"), t.textContent = `${K("A5E.Attunement")}`, s = R(), n = E("span"), r = x(l), o = x(`
            /
            `), a = E("input"), u = R(), d = E("div"), p = E("h3"), g = x(m), h = R(), _ = E("input"), b(t, "class", "footer-shield-header svelte-12j6lc0"), b(n, "class", "a5e-footer-group__value a5e-footer-group__value--attunement"), b(a, "class", "shield-input a5e-footer-group__input svelte-12j6lc0"), b(a, "type", "number"), b(a, "name", "system.attributes.attunement.max"), a.value = c = /*attunement*/
      i[5].max, b(a, "placeholder", "0"), b(a, "min", "0"), b(a, "max", "9"), a.disabled = /*sheetIsLocked*/
      i[6], Q(a, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(e, "class", "shield shield--attunement svelte-12j6lc0"), b(p, "class", "footer-shield-header svelte-12j6lc0"), b(
        p,
        "data-tooltip",
        /*supplyTooltip*/
        i[1]
      ), b(p, "data-tooltip-direction", "UP"), b(_, "class", "shield-input a5e-footer-group__input svelte-12j6lc0"), b(_, "type", "number"), b(_, "name", "system.supply"), _.value = /*supply*/
      i[2], b(_, "placeholder", "0"), b(_, "min", "0"), Q(_, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(d, "class", "shield svelte-12j6lc0");
    },
    m(v, O) {
      T(v, e, O), A(e, t), A(e, s), A(e, n), A(n, r), A(e, o), A(e, a), T(v, u, O), T(v, d, O), A(d, p), A(p, g), A(d, h), A(d, _), y || (k = [
        V(
          a,
          "change",
          /*change_handler*/
          i[9]
        ),
        V(
          _,
          "change",
          /*change_handler_1*/
          i[10]
        )
      ], y = !0);
    },
    p(v, O) {
      O & /*attunement*/
      32 && l !== (l = /*attunement*/
      v[5].current + "") && _e(r, l), O & /*attunement*/
      32 && c !== (c = /*attunement*/
      v[5].max) && a.value !== c && (a.value = c), O & /*sheetIsLocked*/
      64 && (a.disabled = /*sheetIsLocked*/
      v[6]), O & /*$actor*/
      1 && Q(a, "disable-pointer-events", !/*$actor*/
      v[0].isOwner), O & /*supplyTooltip*/
      2 && b(
        p,
        "data-tooltip",
        /*supplyTooltip*/
        v[1]
      ), O & /*supply*/
      4 && _.value !== /*supply*/
      v[2] && (_.value = /*supply*/
      v[2]), O & /*$actor*/
      1 && Q(_, "disable-pointer-events", !/*$actor*/
      v[0].isOwner);
    },
    d(v) {
      v && (S(e), S(u), S(d)), y = !1, Ne(k);
    }
  };
}
f(gR, "create_if_block$1e");
function bR(i) {
  let e, t, s = K(
    /*label*/
    i[14]
  ) + "", n, l, r, o, a, c, u, d, p, m, g;
  return {
    c() {
      e = E("li"), t = E("label"), n = x(s), r = R(), o = E("input"), d = R(), b(t, "class", "currency__label svelte-12j6lc0"), b(t, "for", l = "currency-" + /*label*/
      i[14]), Q(t, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(o, "class", "a5e-footer-group__input a5e-footer-group__input--currency shield-input svelte-12j6lc0"), b(o, "id", a = "currency-" + /*label*/
      i[14]), b(o, "type", "number"), b(o, "name", c = "system.currency." + /*label*/
      i[14]), o.value = u = /*value*/
      i[15], b(o, "min", "0"), Q(o, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(e, "class", "currency__item svelte-12j6lc0"), b(e, "data-type", p = /*label*/
      i[14]);
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(t, n), A(e, r), A(e, o), A(e, d), m || (g = V(
        o,
        "change",
        /*change_handler_2*/
        i[11]
      ), m = !0);
    },
    p(h, _) {
      _ & /*currency*/
      8 && s !== (s = K(
        /*label*/
        h[14]
      ) + "") && _e(n, s), _ & /*currency*/
      8 && l !== (l = "currency-" + /*label*/
      h[14]) && b(t, "for", l), _ & /*$actor*/
      1 && Q(t, "disable-pointer-events", !/*$actor*/
      h[0].isOwner), _ & /*currency*/
      8 && a !== (a = "currency-" + /*label*/
      h[14]) && b(o, "id", a), _ & /*currency*/
      8 && c !== (c = "system.currency." + /*label*/
      h[14]) && b(o, "name", c), _ & /*currency*/
      8 && u !== (u = /*value*/
      h[15]) && o.value !== u && (o.value = u), _ & /*$actor*/
      1 && Q(o, "disable-pointer-events", !/*$actor*/
      h[0].isOwner), _ & /*currency*/
      8 && p !== (p = /*label*/
      h[14]) && b(e, "data-type", p);
    },
    d(h) {
      h && S(e), m = !1, g();
    }
  };
}
f(bR, "create_each_block$M");
function qne(i) {
  let e, t, s, n, l = K("Bulky Items") + "", r, o, a, c, u, d, p, m = (
    /*$actor*/
    i[0].type === "character" && gR(i)
  ), g = oe(Object.entries(
    /*currency*/
    i[3]
  )), h = [];
  for (let _ = 0; _ < g.length; _ += 1)
    h[_] = bR(hR(i, g, _));
  return {
    c() {
      e = E("section"), m && m.c(), t = R(), s = E("div"), n = E("h3"), r = x(l), o = R(), a = E("span"), c = x(
        /*bulkyItems*/
        i[7]
      ), u = R(), d = E("div"), p = E("ol");
      for (let _ = 0; _ < h.length; _ += 1)
        h[_].c();
      b(n, "class", "footer-shield-header svelte-12j6lc0"), b(
        n,
        "data-tooltip",
        /*bulkyTooltip*/
        i[4]
      ), b(n, "data-tooltip-direction", "UP"), b(a, "class", "a5e-footer-group__value"), b(s, "class", "shield svelte-12j6lc0"), b(p, "class", "currency__list svelte-12j6lc0"), b(d, "class", "u-flex u-gap-sm u-text-sm shield shield--currency  svelte-12j6lc0"), Q(
        d,
        "u-ml-auto",
        /*$actor*/
        i[0].type === "npc"
      ), Q(
        d,
        "u-mr-auto",
        /*$actor*/
        i[0].type === "npc"
      ), b(e, "class", "shield-container svelte-12j6lc0");
    },
    m(_, y) {
      T(_, e, y), m && m.m(e, null), A(e, t), A(e, s), A(s, n), A(n, r), A(s, o), A(s, a), A(a, c), A(e, u), A(e, d), A(d, p);
      for (let k = 0; k < h.length; k += 1)
        h[k] && h[k].m(p, null);
    },
    p(_, [y]) {
      if (/*$actor*/
      _[0].type === "character" ? m ? m.p(_, y) : (m = gR(_), m.c(), m.m(e, t)) : m && (m.d(1), m = null), y & /*bulkyTooltip*/
      16 && b(
        n,
        "data-tooltip",
        /*bulkyTooltip*/
        _[4]
      ), y & /*bulkyItems*/
      128 && _e(
        c,
        /*bulkyItems*/
        _[7]
      ), y & /*Object, currency, $actor, Number*/
      9) {
        g = oe(Object.entries(
          /*currency*/
          _[3]
        ));
        let k;
        for (k = 0; k < g.length; k += 1) {
          const v = hR(_, g, k);
          h[k] ? h[k].p(v, y) : (h[k] = bR(v), h[k].c(), h[k].m(p, null));
        }
        for (; k < h.length; k += 1)
          h[k].d(1);
        h.length = g.length;
      }
      y & /*$actor*/
      1 && Q(
        d,
        "u-ml-auto",
        /*$actor*/
        _[0].type === "npc"
      ), y & /*$actor*/
      1 && Q(
        d,
        "u-mr-auto",
        /*$actor*/
        _[0].type === "npc"
      );
    },
    i: ee,
    o: ee,
    d(_) {
      _ && S(e), m && m.d(), Le(h, _);
    }
  };
}
f(qne, "create_fragment$2i");
function Gne(i, e, t) {
  let s, n, l, r, o, a, c, u;
  const d = fe("actor");
  pe(i, d, (y) => t(0, u = y));
  function p(y) {
    let k;
    const { supply: v } = y.system;
    return v ? k = Math.max(1 + y.system.abilities.str.mod, 1) : k = Math.max(2 + y.system.abilities.str.mod, 2), `Bulky Limit: ${k}`;
  }
  f(p, "getBulkyTooltip");
  function m(y) {
    const { supply: k } = y.system, v = y.system.abilities.str.value, O = Math.abs(Math.min(v - k, 0));
    return O ? `Free Supply: ${v} &nbsp;&nbsp;|&nbsp;&nbsp; Additional Supply: ${O}` : `Free Supply: ${k} &nbsp;&nbsp;|&nbsp;&nbsp; Additional Supply: 0`;
  }
  f(m, "getSupplyTooltip");
  const g = /* @__PURE__ */ f(({ target: y }) => se(u, y.name, Number(y.value)), "change_handler"), h = /* @__PURE__ */ f(({ target: y }) => se(u, y.name, Number(y.value)), "change_handler_1"), _ = /* @__PURE__ */ f(({ target: y }) => se(u, y.name, Number(y.value)), "change_handler_2");
  return i.$$.update = () => {
    var y, k;
    i.$$.dirty & /*$actor*/
    1 && t(7, s = u.items.reduce(
      (v, O) => (O.system.bulky && (v += 1), v),
      0
    )), i.$$.dirty & /*$actor*/
    1 && t(6, n = u.isOwner ? ((k = (y = u.flags) == null ? void 0 : y.a5e) == null ? void 0 : k.sheetIsLocked) ?? !0 : !0), i.$$.dirty & /*$actor*/
    1 && t(5, l = u.system.attributes.attunement), i.$$.dirty & /*$actor*/
    1 && t(4, r = p(u)), i.$$.dirty & /*$actor*/
    1 && t(3, o = u.system.currency), i.$$.dirty & /*$actor*/
    1 && t(2, a = u.system.supply), i.$$.dirty & /*$actor*/
    1 && t(1, c = m(u));
  }, [
    u,
    c,
    a,
    o,
    r,
    l,
    n,
    s,
    d,
    g,
    h,
    _
  ];
}
f(Gne, "instance$29");
const XS = class XS extends ie {
  constructor(e) {
    super(), le(this, e, Gne, qne, ne, {});
  }
};
f(XS, "ActorInventoryShields");
let Pv = XS;
function zne(i) {
  var l;
  const e = i.system.abilities.str.value, { size: t } = i.system.traits, s = CONFIG.A5E.carryCapacityMultiplier[t || "med"], n = (l = i.flags.a5e) != null && l.doubleCarryCapacity ? 2 : 1;
  return e * s * n * 15;
}
f(zne, "calculateCarryCapacity");
function Hne(i) {
  var a, c;
  const { EQUIPPED_STATES: e } = CONFIG.A5E, t = i.system, s = i.items.map((u) => u), n = s.reduce((u, d) => {
    let p = null;
    if (d.system.containerId && (p = s.find((_) => _.uuid === d.system.containerId), !p) || ![e.EQUIPPED, e.CARRIED].includes(d.system.equippedState) && !p || p && p.system.equippedState === e.NOT_CARRIED)
      return u;
    const { quantity: g } = d.system, h = parseFloat(d.system.weight || 0, 10) ?? 0;
    return u + (g ? h * g : h);
  }, 0), l = Object.values(t.currency).reduce(
    (u, d) => u + Number(d),
    0
  ), r = 2 * Math.abs(
    Math.min(t.abilities.str.value - (t.supply ?? 0), 0)
  );
  return ((c = (a = i.flags) == null ? void 0 : a.a5e) == null ? void 0 : c.trackCurrencyWeight) ?? game.settings.get("a5e", "currencyWeight") ? n + r + l * 0.02 : n + r;
}
f(Hne, "calculateInventoryWeight");
function _R(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.ConditionEncumbered")}`;
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(_R, "create_if_block$1d");
function Une(i) {
  var k;
  let e, t, s, n, l = (
    /*inventoryWeight*/
    ((k = i[1]) == null ? void 0 : k.toFixed(1)) + ""
  ), r, o, a = K("A5E.MeasurementPoundsAbbr") + "", c, u, d, p, m, g = K("A5E.MeasurementPoundsAbbr") + "", h, _, y = (
    /*encumbrancePercentage*/
    i[2] === 100 && _R()
  );
  return {
    c() {
      e = E("div"), t = E("div"), s = E("div"), n = E("span"), r = x(l), o = R(), c = x(a), u = x(`

            /

            `), d = E("span"), p = x(
        /*carryCapacity*/
        i[0]
      ), m = R(), h = x(g), _ = R(), y && y.c(), b(s, "class", "u-flex u-gap-md u-pos-absolute u-pos-center u-text-light u-text-sm"), b(t, "class", "u-h-full u-rounded"), z(t, "color", "#eee"), z(t, "text-shadow", "0 0 2px #000"), z(
        t,
        "background-color",
        /*encumbrancePercentage*/
        i[2] === 100 ? "$color-secondary" : "#0b5a2f"
      ), z(t, "width", `${Math.min(
        /*encumbrancePercentage*/
        i[2],
        100
      )}%`), b(e, "class", "track-container u-border u-border-thin u-border-light-gray u-h-4 u-pos-relative u-rounded u-w-full  svelte-1qql8j0"), z(e, "background-color", "#a9a594");
    },
    m(v, O) {
      T(v, e, O), A(e, t), A(t, s), A(s, n), A(n, r), A(n, o), A(n, c), A(s, u), A(s, d), A(d, p), A(d, m), A(d, h), A(s, _), y && y.m(s, null);
    },
    p(v, [O]) {
      var P;
      O & /*inventoryWeight*/
      2 && l !== (l = /*inventoryWeight*/
      ((P = v[1]) == null ? void 0 : P.toFixed(1)) + "") && _e(r, l), O & /*carryCapacity*/
      1 && _e(
        p,
        /*carryCapacity*/
        v[0]
      ), /*encumbrancePercentage*/
      v[2] === 100 ? y || (y = _R(), y.c(), y.m(s, null)) : y && (y.d(1), y = null), O & /*encumbrancePercentage*/
      4 && z(
        t,
        "background-color",
        /*encumbrancePercentage*/
        v[2] === 100 ? "$color-secondary" : "#0b5a2f"
      ), O & /*encumbrancePercentage*/
      4 && z(t, "width", `${Math.min(
        /*encumbrancePercentage*/
        v[2],
        100
      )}%`);
    },
    i: ee,
    o: ee,
    d(v) {
      v && S(e), y && y.d();
    }
  };
}
f(Une, "create_fragment$2h");
function Vne(i, e, t) {
  let s, n, l, r;
  const o = fe("actor");
  return pe(i, o, (a) => t(4, r = a)), i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    16 && t(1, s = Hne(r)), i.$$.dirty & /*$actor*/
    16 && t(0, n = zne(r)), i.$$.dirty & /*inventoryWeight, carryCapacity*/
    3 && t(2, l = Math.min(s / n * 100, 100));
  }, [n, s, l, o, r];
}
f(Vne, "instance$28");
const JS = class JS extends ie {
  constructor(e) {
    super(), le(this, e, Vne, Une, ne, {});
  }
};
f(JS, "ItemWeightTrack");
let Mv = JS;
function Wne(i) {
  let e, t;
  const s = (
    /*#slots*/
    i[1].default
  ), n = Pt(
    s,
    i,
    /*$$scope*/
    i[0],
    null
  );
  return {
    c() {
      e = E("footer"), n && n.c(), b(e, "class", "tab-footer svelte-1qk9z9s");
    },
    m(l, r) {
      T(l, e, r), n && n.m(e, null), t = !0;
    },
    p(l, [r]) {
      n && n.p && (!t || r & /*$$scope*/
      1) && Rt(
        n,
        s,
        l,
        /*$$scope*/
        l[0],
        t ? Mt(
          s,
          /*$$scope*/
          l[0],
          r,
          null
        ) : Ft(
          /*$$scope*/
          l[0]
        ),
        null
      );
    },
    i(l) {
      t || (w(n, l), t = !0);
    },
    o(l) {
      C(n, l), t = !1;
    },
    d(l) {
      l && S(e), n && n.d(l);
    }
  };
}
f(Wne, "create_fragment$2g");
function Kne(i, e, t) {
  let { $$slots: s = {}, $$scope: n } = e;
  return i.$$set = (l) => {
    "$$scope" in l && t(0, n = l.$$scope);
  }, [n, s];
}
f(Kne, "instance$27");
const ZS = class ZS extends ie {
  constructor(e) {
    super(), le(this, e, Kne, Wne, ne, {});
  }
};
f(ZS, "TabFooter");
let jc = ZS;
function yR(i, e, t) {
  const s = i.slice();
  return s[16] = e[t][0], s[17] = e[t][1], s;
}
f(yR, "get_each_context$L");
function vR(i) {
  let e, t;
  return e = new ji({
    props: {
      $$slots: { default: [Yne] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $actor, menuList, showDescription*/
      1048625 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(vR, "create_if_block_2$w");
function Yne(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g;
  return e = new Fi({ props: { reducerType: Wf } }), s = new Sa({}), s.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[10]
  ), l = new Ni({ props: { reducerType: Wf } }), o = new Ea({ props: { reducerType: Wf } }), c = new Ys({
    props: {
      reducerType: Wf,
      menuList: (
        /*menuList*/
        i[4]
      )
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment), r = R(), L(o.$$.fragment), a = R(), L(c.$$.fragment), u = R(), d = E("button"), b(d, "class", "a5e-import-from-compendium-button fa-solid fa-download"), b(d, "data-tooltip", "Import Items from Compendium"), b(d, "data-tooltip-direction", "UP");
    },
    m(h, _) {
      N(e, h, _), T(h, t, _), N(s, h, _), T(h, n, _), N(l, h, _), T(h, r, _), N(o, h, _), T(h, a, _), N(c, h, _), T(h, u, _), T(h, d, _), p = !0, m || (g = V(
        d,
        "click",
        /*click_handler*/
        i[11]
      ), m = !0);
    },
    p(h, _) {
      const y = {};
      _ & /*menuList*/
      16 && (y.menuList = /*menuList*/
      h[4]), c.$set(y);
    },
    i(h) {
      p || (w(e.$$.fragment, h), w(s.$$.fragment, h), w(l.$$.fragment, h), w(o.$$.fragment, h), w(c.$$.fragment, h), p = !0);
    },
    o(h) {
      C(e.$$.fragment, h), C(s.$$.fragment, h), C(l.$$.fragment, h), C(o.$$.fragment, h), C(c.$$.fragment, h), p = !1;
    },
    d(h) {
      h && (S(t), S(n), S(r), S(a), S(u), S(d)), j(e, h), j(s, h), j(l, h), j(o, h), j(c, h), m = !1, g();
    }
  };
}
f(Yne, "create_default_slot_1$p");
function kR(i) {
  let e, t;
  return e = new gl({
    props: {
      label: (
        /*label*/
        i[16]
      ),
      items: (
        /*items*/
        i[17]
      ),
      showDescription: (
        /*showDescription*/
        i[0]
      ),
      showQuantity: (
        /*showQuantity*/
        i[2]
      ),
      showUses: (
        /*showUses*/
        i[1]
      ),
      type: "objectTypesPlural"
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*sortedObjects*/
      8 && (l.label = /*label*/
      s[16]), n & /*sortedObjects*/
      8 && (l.items = /*items*/
      s[17]), n & /*showDescription*/
      1 && (l.showDescription = /*showDescription*/
      s[0]), n & /*showQuantity*/
      4 && (l.showQuantity = /*showQuantity*/
      s[2]), n & /*showUses*/
      2 && (l.showUses = /*showUses*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(kR, "create_if_block_1$N");
function wR(i) {
  let e, t, s = (
    /*items*/
    i[17].length && kR(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*items*/
      n[17].length ? s ? (s.p(n, l), l & /*sortedObjects*/
      8 && w(s, 1)) : (s = kR(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ce(), C(s, 1, 1, () => {
        s = null;
      }), ue());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f(wR, "create_each_block$L");
function $R(i) {
  let e, t;
  return e = new Mv({}), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f($R, "create_if_block$1c");
function Xne(i) {
  var l, r;
  let e, t, s, n = (
    /*$actor*/
    (((r = (l = i[5].flags) == null ? void 0 : l.a5e) == null ? void 0 : r.trackInventoryWeight) ?? !0) && $R()
  );
  return t = new Pv({}), {
    c() {
      n && n.c(), e = R(), L(t.$$.fragment);
    },
    m(o, a) {
      n && n.m(o, a), T(o, e, a), N(t, o, a), s = !0;
    },
    p(o, a) {
      var c, u;
      /*$actor*/
      ((u = (c = o[5].flags) == null ? void 0 : c.a5e) == null ? void 0 : u.trackInventoryWeight) ?? !0 ? n ? a & /*$actor*/
      32 && w(n, 1) : (n = $R(), n.c(), w(n, 1), n.m(e.parentNode, e)) : n && (ce(), C(n, 1, 1, () => {
        n = null;
      }), ue());
    },
    i(o) {
      s || (w(n), w(t.$$.fragment, o), s = !0);
    },
    o(o) {
      C(n), C(t.$$.fragment, o), s = !1;
    },
    d(o) {
      o && S(e), n && n.d(o), j(t, o);
    }
  };
}
f(Xne, "create_default_slot$Y");
function Jne(i) {
  let e, t, s, n, l, r = (
    /*$actor*/
    i[5].isOwner && vR(i)
  ), o = oe(
    /*sortedObjects*/
    i[3]
  ), a = [];
  for (let u = 0; u < o.length; u += 1)
    a[u] = wR(yR(i, o, u));
  const c = /* @__PURE__ */ f((u) => C(a[u], 1, 1, () => {
    a[u] = null;
  }), "out");
  return n = new jc({
    props: {
      $$slots: { default: [Xne] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      r && r.c(), e = R(), t = E("section");
      for (let u = 0; u < a.length; u += 1)
        a[u].c();
      s = R(), L(n.$$.fragment), b(t, "class", "a5e-page-wrapper a5e-page-wrapper--item-list");
    },
    m(u, d) {
      r && r.m(u, d), T(u, e, d), T(u, t, d);
      for (let p = 0; p < a.length; p += 1)
        a[p] && a[p].m(t, null);
      T(u, s, d), N(n, u, d), l = !0;
    },
    p(u, [d]) {
      if (/*$actor*/
      u[5].isOwner ? r ? (r.p(u, d), d & /*$actor*/
      32 && w(r, 1)) : (r = vR(u), r.c(), w(r, 1), r.m(e.parentNode, e)) : r && (ce(), C(r, 1, 1, () => {
        r = null;
      }), ue()), d & /*sortedObjects, showDescription, showQuantity, showUses*/
      15) {
        o = oe(
          /*sortedObjects*/
          u[3]
        );
        let m;
        for (m = 0; m < o.length; m += 1) {
          const g = yR(u, o, m);
          a[m] ? (a[m].p(g, d), w(a[m], 1)) : (a[m] = wR(g), a[m].c(), w(a[m], 1), a[m].m(t, null));
        }
        for (ce(), m = o.length; m < a.length; m += 1)
          c(m);
        ue();
      }
      const p = {};
      d & /*$$scope, $actor*/
      1048608 && (p.$$scope = { dirty: d, ctx: u }), n.$set(p);
    },
    i(u) {
      if (!l) {
        w(r);
        for (let d = 0; d < o.length; d += 1)
          w(a[d]);
        w(n.$$.fragment, u), l = !0;
      }
    },
    o(u) {
      C(r), a = a.filter(Boolean);
      for (let d = 0; d < a.length; d += 1)
        C(a[d]);
      C(n.$$.fragment, u), l = !1;
    },
    d(u) {
      u && (S(e), S(t), S(s)), r && r.d(u), Le(a, u), j(n, u);
    }
  };
}
f(Jne, "create_fragment$2f");
const Wf = "objects";
function Zne(i, e, t) {
  let s, n, l, r;
  const o = fe("actor");
  pe(i, o, (v) => t(5, r = v));
  const { objects: a } = o;
  pe(i, a, (v) => t(9, l = v));
  const { A5E: c } = CONFIG, u = c.reducerSortMap.objects, d = c.objectTypes, p = game.a5e.utils.openCompendium;
  let m = !1, g = qi(a), h = lp(a);
  const _ = a.subscribe((v) => {
    t(1, g = qi(a)), t(2, h = lp(a));
  });
  Nt(() => {
    _();
  });
  const y = /* @__PURE__ */ f(() => t(0, m = !m), "updateSelection_handler"), k = /* @__PURE__ */ f(() => p(r, "inventory"), "click_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$objects*/
    512 && t(3, n = Object.entries(l._types).sort((v, O) => u[v[0]] - u[O[0]]));
  }, t(4, s = Object.entries(d)), [
    m,
    g,
    h,
    n,
    s,
    r,
    o,
    a,
    p,
    l,
    y,
    k
  ];
}
f(Zne, "instance$26");
const QS = class QS extends ie {
  constructor(e) {
    super(), le(this, e, Zne, Jne, ne, {});
  }
};
f(QS, "ActorInventoryPage");
let Rv = QS;
function AR(i, e, t) {
  const s = i.slice();
  return s[16] = e[t][0], s[17] = e[t][1], s;
}
f(AR, "get_each_context$K");
function ER(i) {
  let e, t;
  return e = new ji({
    props: {
      $$slots: { default: [Qne] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $actor, menuList, showDescription*/
      1048587 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(ER, "create_if_block_3$l");
function Qne(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g;
  return e = new Fi({ props: { reducerType: Kf } }), s = new Sa({}), s.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[9]
  ), l = new Ni({ props: { reducerType: Kf } }), o = new Ea({ props: { reducerType: Kf } }), c = new Ys({
    props: {
      reducerType: Kf,
      menuList: (
        /*menuList*/
        i[3]
      )
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment), r = R(), L(o.$$.fragment), a = R(), L(c.$$.fragment), u = R(), d = E("button"), b(d, "class", "a5e-import-from-compendium-button fa-solid fa-download"), b(d, "data-tooltip", "Import Maneuvers from Compendium"), b(d, "data-tooltip-direction", "UP");
    },
    m(h, _) {
      N(e, h, _), T(h, t, _), N(s, h, _), T(h, n, _), N(l, h, _), T(h, r, _), N(o, h, _), T(h, a, _), N(c, h, _), T(h, u, _), T(h, d, _), p = !0, m || (g = V(
        d,
        "click",
        /*click_handler*/
        i[10]
      ), m = !0);
    },
    p(h, _) {
      const y = {};
      _ & /*menuList*/
      8 && (y.menuList = /*menuList*/
      h[3]), c.$set(y);
    },
    i(h) {
      p || (w(e.$$.fragment, h), w(s.$$.fragment, h), w(l.$$.fragment, h), w(o.$$.fragment, h), w(c.$$.fragment, h), p = !0);
    },
    o(h) {
      C(e.$$.fragment, h), C(s.$$.fragment, h), C(l.$$.fragment, h), C(o.$$.fragment, h), C(c.$$.fragment, h), p = !1;
    },
    d(h) {
      h && (S(t), S(n), S(r), S(a), S(u), S(d)), j(e, h), j(s, h), j(l, h), j(o, h), j(c, h), m = !1, g();
    }
  };
}
f(Qne, "create_default_slot_1$o");
function SR(i) {
  let e, t;
  return e = new gl({
    props: {
      label: (
        /*label*/
        i[16]
      ),
      items: (
        /*items*/
        i[17]
      ),
      showDescription: (
        /*showDescription*/
        i[1]
      ),
      showUses: (
        /*showUses*/
        i[2]
      ),
      type: "maneuverDegrees"
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$maneuvers*/
      32 && (l.label = /*label*/
      s[16]), n & /*$maneuvers*/
      32 && (l.items = /*items*/
      s[17]), n & /*showDescription*/
      2 && (l.showDescription = /*showDescription*/
      s[1]), n & /*showUses*/
      4 && (l.showUses = /*showUses*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(SR, "create_if_block_2$v");
function TR(i) {
  let e, t, s = (
    /*items*/
    i[17].length && SR(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*items*/
      n[17].length ? s ? (s.p(n, l), l & /*$maneuvers*/
      32 && w(s, 1)) : (s = SR(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ce(), C(s, 1, 1, () => {
        s = null;
      }), ue());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f(TR, "create_each_block$K");
function CR(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m = (
    /*exertion*/
    i[4].current < /*exertion*/
    i[4].max && /*exertion*/
    i[4].max && OR(i)
  );
  return {
    c() {
      e = E("div"), t = E("h3"), t.textContent = `${K("A5E.ExertionPool")}`, s = R(), n = E("input"), r = x(`
            /
            `), o = E("input"), u = R(), m && m.c(), b(t, "class", "u-mb-0 u-text-sm u-text-bold"), b(n, "class", "a5e-footer-group__input svelte-1hbyg6z"), b(n, "type", "number"), b(n, "name", "system.attributes.exertion.current"), n.value = l = /*exertion*/
      i[4].current, b(n, "placeholder", "0"), b(n, "min", "0"), Q(n, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(o, "class", "a5e-footer-group__input"), b(o, "type", "number"), b(o, "name", "system.attributes.exertion.max"), o.value = a = /*exertion*/
      i[4].max, o.disabled = c = /*$actor*/
      i[0].automationAvailable, b(o, "placeholder", "0"), b(o, "min", "0"), b(e, "class", "u-flex u-align-center u-gap-md");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(e, s), A(e, n), A(e, r), A(e, o), A(e, u), m && m.m(e, null), d || (p = [
        V(
          n,
          "change",
          /*change_handler*/
          i[11]
        ),
        V(
          o,
          "change",
          /*change_handler_1*/
          i[12]
        )
      ], d = !0);
    },
    p(g, h) {
      h & /*exertion*/
      16 && l !== (l = /*exertion*/
      g[4].current) && n.value !== l && (n.value = l), h & /*$actor*/
      1 && Q(n, "disable-pointer-events", !/*$actor*/
      g[0].isOwner), h & /*exertion*/
      16 && a !== (a = /*exertion*/
      g[4].max) && o.value !== a && (o.value = a), h & /*$actor*/
      1 && c !== (c = /*$actor*/
      g[0].automationAvailable) && (o.disabled = c), /*exertion*/
      g[4].current < /*exertion*/
      g[4].max && /*exertion*/
      g[4].max ? m ? m.p(g, h) : (m = OR(g), m.c(), m.m(e, null)) : m && (m.d(1), m = null);
    },
    d(g) {
      g && S(e), m && m.d(), d = !1, Ne(p);
    }
  };
}
f(CR, "create_if_block$1b");
function OR(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), e.innerHTML = '<i class="fa-solid fa-bolt"></i>', b(e, "class", "recharge-button svelte-1hbyg6z"), b(e, "data-tooltip", "A5E.ExertionRechargeFromHitDice"), b(e, "data-tooltip-direction", "UP");
    },
    m(n, l) {
      T(n, e, l), t || (s = V(
        e,
        "click",
        /*click_handler_1*/
        i[13]
      ), t = !0);
    },
    p: ee,
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(OR, "create_if_block_1$M");
function xne(i) {
  let e, t = (
    /*$actor*/
    i[0].type === "character" && CR(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*$actor*/
      s[0].type === "character" ? t ? t.p(s, n) : (t = CR(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && S(e), t && t.d(s);
    }
  };
}
f(xne, "create_default_slot$X");
function eie(i) {
  let e, t, s, n, l, r, o = (
    /*$actor*/
    i[0].isOwner && ER(i)
  ), a = oe(Object.entries(
    /*$maneuvers*/
    i[5]._degrees
  )), c = [];
  for (let d = 0; d < a.length; d += 1)
    c[d] = TR(AR(i, a, d));
  const u = /* @__PURE__ */ f((d) => C(c[d], 1, 1, () => {
    c[d] = null;
  }), "out");
  return n = new jc({
    props: {
      $$slots: { default: [xne] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      o && o.c(), e = R(), t = E("section");
      for (let d = 0; d < c.length; d += 1)
        c[d].c();
      s = R(), l = E("div"), L(n.$$.fragment), b(t, "class", "a5e-page-wrapper a5e-page-wrapper--item-list"), z(l, "display", "contents"), z(l, "--padding-right", "1rem");
    },
    m(d, p) {
      o && o.m(d, p), T(d, e, p), T(d, t, p);
      for (let m = 0; m < c.length; m += 1)
        c[m] && c[m].m(t, null);
      T(d, s, p), T(d, l, p), N(n, l, null), r = !0;
    },
    p(d, [p]) {
      if (/*$actor*/
      d[0].isOwner ? o ? (o.p(d, p), p & /*$actor*/
      1 && w(o, 1)) : (o = ER(d), o.c(), w(o, 1), o.m(e.parentNode, e)) : o && (ce(), C(o, 1, 1, () => {
        o = null;
      }), ue()), p & /*Object, $maneuvers, showDescription, showUses*/
      38) {
        a = oe(Object.entries(
          /*$maneuvers*/
          d[5]._degrees
        ));
        let g;
        for (g = 0; g < a.length; g += 1) {
          const h = AR(d, a, g);
          c[g] ? (c[g].p(h, p), w(c[g], 1)) : (c[g] = TR(h), c[g].c(), w(c[g], 1), c[g].m(t, null));
        }
        for (ce(), g = a.length; g < c.length; g += 1)
          u(g);
        ue();
      }
      const m = {};
      p & /*$$scope, $actor, exertion*/
      1048593 && (m.$$scope = { dirty: p, ctx: d }), n.$set(m);
    },
    i(d) {
      if (!r) {
        w(o);
        for (let p = 0; p < a.length; p += 1)
          w(c[p]);
        w(n.$$.fragment, d), r = !0;
      }
    },
    o(d) {
      C(o), c = c.filter(Boolean);
      for (let p = 0; p < c.length; p += 1)
        C(c[p]);
      C(n.$$.fragment, d), r = !1;
    },
    d(d) {
      d && (S(e), S(t), S(s)), o && o.d(d), Le(c, d), d && n && S(l), j(n, d);
    }
  };
}
f(eie, "create_fragment$2e");
const Kf = "maneuvers";
function tie(i, e, t) {
  let s, n, l, r;
  const o = fe("actor");
  pe(i, o, (v) => t(0, l = v));
  const { maneuvers: a } = o;
  pe(i, a, (v) => t(5, r = v));
  const c = CONFIG.A5E.maneuverDegrees, u = game.a5e.utils.openCompendium;
  let d = !1, p = qi(a);
  const m = a.subscribe((v) => {
    t(2, p = qi(a));
  });
  Nt(() => {
    m();
  });
  const g = /* @__PURE__ */ f(() => t(1, d = !d), "updateSelection_handler"), h = /* @__PURE__ */ f(() => u(l, "maneuvers"), "click_handler"), _ = /* @__PURE__ */ f(({ target: v }) => se(l, v.name, Number(v.value)), "change_handler"), y = /* @__PURE__ */ f(({ target: v }) => se(l, v.name, Number(v.value)), "change_handler_1"), k = /* @__PURE__ */ f(() => l.recoverExertionUsingHitDice(), "click_handler_1");
  return i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    1 && t(4, s = l.system.attributes.exertion);
  }, t(3, n = Object.entries(c)), [
    l,
    d,
    p,
    n,
    s,
    r,
    o,
    a,
    u,
    g,
    h,
    _,
    y,
    k
  ];
}
f(tie, "instance$25");
const xS = class xS extends ie {
  constructor(e) {
    super(), le(this, e, tie, eie, ne, {});
  }
};
f(xS, "ActorManueversPage");
let Fv = xS;
function sie(i) {
  let e, t = K(
    /*tab*/
    i[2].label
  ) + "", s, n, l;
  return {
    c() {
      e = E("li"), s = x(t), b(e, "class", "a5e-secondary-nav-list__item"), Q(
        e,
        "a5e-secondary-nav-list__item--active",
        /*name*/
        i[1] === /*currentTab*/
        i[0]
      );
    },
    m(r, o) {
      T(r, e, o), A(e, s), n || (l = V(
        e,
        "click",
        /*click_handler*/
        i[4]
      ), n = !0);
    },
    p(r, [o]) {
      o & /*tab*/
      4 && t !== (t = K(
        /*tab*/
        r[2].label
      ) + "") && _e(s, t), o & /*name, currentTab*/
      3 && Q(
        e,
        "a5e-secondary-nav-list__item--active",
        /*name*/
        r[1] === /*currentTab*/
        r[0]
      );
    },
    i: ee,
    o: ee,
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(sie, "create_fragment$2d");
function nie(i, e, t) {
  let { currentTab: s } = e, { name: n } = e, { tab: l } = e;
  const r = it(), o = /* @__PURE__ */ f(() => r("tab-change", n), "click_handler");
  return i.$$set = (a) => {
    "currentTab" in a && t(0, s = a.currentTab), "name" in a && t(1, n = a.name), "tab" in a && t(2, l = a.tab);
  }, [s, n, l, r, o];
}
f(nie, "instance$24");
const eT = class eT extends ie {
  constructor(e) {
    super(), le(this, e, nie, sie, ne, { currentTab: 0, name: 1, tab: 2 });
  }
};
f(eT, "SecondaryNavigationItem");
let Nv = eT;
function DR(i, e, t) {
  const s = i.slice();
  return s[3] = e[t][0], s[4] = e[t][1], s;
}
f(DR, "get_each_context$J");
function IR(i) {
  let e, t;
  return e = new Nv({
    props: {
      currentTab: (
        /*currentTab*/
        i[0]
      ),
      name: (
        /*name*/
        i[3]
      ),
      tab: (
        /*tab*/
        i[4]
      )
    }
  }), e.$on(
    "tab-change",
    /*tab_change_handler*/
    i[2]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*currentTab*/
      1 && (l.currentTab = /*currentTab*/
      s[0]), n & /*tabs*/
      2 && (l.name = /*name*/
      s[3]), n & /*tabs*/
      2 && (l.tab = /*tab*/
      s[4]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(IR, "create_if_block$1a");
function PR(i) {
  var n;
  let e, t, s = (
    /*tab*/
    (((n = i[4]) == null ? void 0 : n.display) ?? !0) && IR(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(l, r) {
      s && s.m(l, r), T(l, e, r), t = !0;
    },
    p(l, r) {
      var o;
      /*tab*/
      ((o = l[4]) == null ? void 0 : o.display) ?? !0 ? s ? (s.p(l, r), r & /*tabs*/
      2 && w(s, 1)) : (s = IR(l), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ce(), C(s, 1, 1, () => {
        s = null;
      }), ue());
    },
    i(l) {
      t || (w(s), t = !0);
    },
    o(l) {
      C(s), t = !1;
    },
    d(l) {
      l && S(e), s && s.d(l);
    }
  };
}
f(PR, "create_each_block$J");
function iie(i) {
  let e, t, s, n = oe(Object.entries(
    /*tabs*/
    i[1]
  )), l = [];
  for (let o = 0; o < n.length; o += 1)
    l[o] = PR(DR(i, n, o));
  const r = /* @__PURE__ */ f((o) => C(l[o], 1, 1, () => {
    l[o] = null;
  }), "out");
  return {
    c() {
      e = E("nav"), t = E("ul");
      for (let o = 0; o < l.length; o += 1)
        l[o].c();
      b(t, "class", "a5e-secondary-nav-list"), b(e, "class", "a5e-secondary-nav");
    },
    m(o, a) {
      T(o, e, a), A(e, t);
      for (let c = 0; c < l.length; c += 1)
        l[c] && l[c].m(t, null);
      s = !0;
    },
    p(o, [a]) {
      if (a & /*currentTab, Object, tabs*/
      3) {
        n = oe(Object.entries(
          /*tabs*/
          o[1]
        ));
        let c;
        for (c = 0; c < n.length; c += 1) {
          const u = DR(o, n, c);
          l[c] ? (l[c].p(u, a), w(l[c], 1)) : (l[c] = PR(u), l[c].c(), w(l[c], 1), l[c].m(t, null));
        }
        for (ce(), c = n.length; c < l.length; c += 1)
          r(c);
        ue();
      }
    },
    i(o) {
      if (!s) {
        for (let a = 0; a < n.length; a += 1)
          w(l[a]);
        s = !0;
      }
    },
    o(o) {
      l = l.filter(Boolean);
      for (let a = 0; a < l.length; a += 1)
        C(l[a]);
      s = !1;
    },
    d(o) {
      o && S(e), Le(l, o);
    }
  };
}
f(iie, "create_fragment$2c");
function lie(i, e, t) {
  let { currentTab: s } = e, { tabs: n } = e;
  function l(r) {
    gt.call(this, i, r);
  }
  return f(l, "tab_change_handler"), i.$$set = (r) => {
    "currentTab" in r && t(0, s = r.currentTab), "tabs" in r && t(1, n = r.tabs);
  }, [s, n, l];
}
f(lie, "instance$23");
const tT = class tT extends ie {
  constructor(e) {
    super(), le(this, e, lie, iie, ne, { currentTab: 0, tabs: 1 });
  }
};
f(tT, "SecondaryNavigationBar");
let op = tT;
function MR(i, e, t) {
  const s = i.slice();
  return s[11] = e[t][0], s[12] = e[t][1], s;
}
f(MR, "get_each_context$I");
function RR(i, e, t) {
  const s = i.slice();
  return s[11] = e[t][0], s[12] = e[t][1], s;
}
f(RR, "get_each_context_1$8");
function FR(i) {
  let e, t, s, n, l, r, o = oe(Object.entries(
    /*charChoicesLabel*/
    i[5]
  )), a = [];
  for (let m = 0; m < o.length; m += 1)
    a[m] = NR(RR(i, o, m));
  const c = /* @__PURE__ */ f((m) => C(a[m], 1, 1, () => {
    a[m] = null;
  }), "out");
  let u = oe(Object.entries(
    /*traitsLabel*/
    i[6]
  )), d = [];
  for (let m = 0; m < u.length; m += 1)
    d[m] = jR(MR(i, u, m));
  const p = /* @__PURE__ */ f((m) => C(d[m], 1, 1, () => {
    d[m] = null;
  }), "out_1");
  return {
    c() {
      e = E("section");
      for (let m = 0; m < a.length; m += 1)
        a[m].c();
      t = R(), s = E("section");
      for (let m = 0; m < d.length; m += 1)
        d[m].c();
      n = R(), l = E("heading"), l.innerHTML = '<h3 class="a5e-section-header__heading">Appearance</h3>', b(e, "class", "a5e-box u-p-md a5e-form__section--bio-wrapper"), b(s, "class", "a5e-box u-p-md a5e-form__section--bio-wrapper"), b(l, "class", "a5e-section-header");
    },
    m(m, g) {
      T(m, e, g);
      for (let h = 0; h < a.length; h += 1)
        a[h] && a[h].m(e, null);
      T(m, t, g), T(m, s, g);
      for (let h = 0; h < d.length; h += 1)
        d[h] && d[h].m(s, null);
      T(m, n, g), T(m, l, g), r = !0;
    },
    p(m, g) {
      if (g & /*Object, charChoicesLabel, actor, $actor, Number*/
      42) {
        o = oe(Object.entries(
          /*charChoicesLabel*/
          m[5]
        ));
        let h;
        for (h = 0; h < o.length; h += 1) {
          const _ = RR(m, o, h);
          a[h] ? (a[h].p(_, g), w(a[h], 1)) : (a[h] = NR(_), a[h].c(), w(a[h], 1), a[h].m(e, null));
        }
        for (ce(), h = o.length; h < a.length; h += 1)
          c(h);
        ue();
      }
      if (g & /*Object, traitsLabel, actor, $actor*/
      74) {
        u = oe(Object.entries(
          /*traitsLabel*/
          m[6]
        ));
        let h;
        for (h = 0; h < u.length; h += 1) {
          const _ = MR(m, u, h);
          d[h] ? (d[h].p(_, g), w(d[h], 1)) : (d[h] = jR(_), d[h].c(), w(d[h], 1), d[h].m(s, null));
        }
        for (ce(), h = u.length; h < d.length; h += 1)
          p(h);
        ue();
      }
    },
    i(m) {
      if (!r) {
        for (let g = 0; g < o.length; g += 1)
          w(a[g]);
        for (let g = 0; g < u.length; g += 1)
          w(d[g]);
        r = !0;
      }
    },
    o(m) {
      a = a.filter(Boolean);
      for (let g = 0; g < a.length; g += 1)
        C(a[g]);
      d = d.filter(Boolean);
      for (let g = 0; g < d.length; g += 1)
        C(d[g]);
      r = !1;
    },
    d(m) {
      m && (S(e), S(t), S(s), S(n), S(l)), Le(a, m), Le(d, m);
    }
  };
}
f(FR, "create_if_block$19");
function rie(i) {
  let e, t, s, n, l;
  function r(...o) {
    return (
      /*change_handler*/
      i[7](
        /*key*/
        i[11],
        ...o
      )
    );
  }
  return f(r, "change_handler"), {
    c() {
      e = E("input"), s = R(), b(e, "class", "a5e-input a5e-input--slim u-w-full"), b(
        e,
        "id",
        /*actor*/
        i[3].id + "-details-" + /*key*/
        i[11]
      ), b(e, "type", "text"), b(e, "name", "system.details." + /*key*/
      i[11]), e.value = t = /*$actor*/
      i[1].system.details[
        /*key*/
        i[11]
      ] ?? "", Q(e, "disable-pointer-events", !/*$actor*/
      i[1].isOwner);
    },
    m(o, a) {
      T(o, e, a), T(o, s, a), n || (l = V(e, "change", r), n = !0);
    },
    p(o, a) {
      i = o, a & /*$actor*/
      2 && t !== (t = /*$actor*/
      i[1].system.details[
        /*key*/
        i[11]
      ] ?? "") && e.value !== t && (e.value = t), a & /*$actor*/
      2 && Q(e, "disable-pointer-events", !/*$actor*/
      i[1].isOwner);
    },
    d(o) {
      o && (S(e), S(s)), n = !1, l();
    }
  };
}
f(rie, "create_default_slot_1$n");
function NR(i) {
  let e, t, s;
  return e = new bt({
    props: {
      heading: (
        /*label*/
        i[12]
      ),
      $$slots: { default: [rie] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--background", "none"), z(t, "--direction", "column"), z(t, "--gap", "0.25rem"), z(t, "--padding", "0");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, $actor*/
      131074 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(NR, "create_each_block_1$8");
function oie(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("input"), s = R(), b(e, "class", "a5e-input a5e-input--slim"), b(
        e,
        "id",
        /*actor*/
        i[3].id + "-details-" + /*key*/
        i[11]
      ), b(e, "type", "text"), b(e, "name", "system.details." + /*key*/
      i[11]), e.value = t = /*$actor*/
      i[1].system.details[
        /*key*/
        i[11]
      ], Q(e, "disable-pointer-events", !/*$actor*/
      i[1].isOwner);
    },
    m(r, o) {
      T(r, e, o), T(r, s, o), n || (l = V(
        e,
        "change",
        /*change_handler_1*/
        i[8]
      ), n = !0);
    },
    p(r, o) {
      o & /*$actor*/
      2 && t !== (t = /*$actor*/
      r[1].system.details[
        /*key*/
        r[11]
      ]) && e.value !== t && (e.value = t), o & /*$actor*/
      2 && Q(e, "disable-pointer-events", !/*$actor*/
      r[1].isOwner);
    },
    d(r) {
      r && (S(e), S(s)), n = !1, l();
    }
  };
}
f(oie, "create_default_slot$W");
function jR(i) {
  let e, t, s;
  return e = new bt({
    props: {
      heading: (
        /*label*/
        i[12]
      ),
      $$slots: { default: [oie] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--background", "none"), z(t, "--direction", "column"), z(t, "--gap", "0.25rem"), z(t, "--padding", "0");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, $actor*/
      131074 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(jR, "create_each_block$I");
function aie(i) {
  let e, t, s, n, l, r;
  e = new op({
    props: {
      currentTab: (
        /*currentTab*/
        i[0]
      ),
      tabs: (
        /*tabs*/
        i[4]
      )
    }
  }), e.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[2]
  );
  let o = (
    /*currentTab*/
    i[0] === "appearance" && FR(i)
  );
  return l = new hl({
    props: {
      document: (
        /*actor*/
        i[3]
      ),
      content: (
        /*$actor*/
        i[1].system.details[
          /*currentTab*/
          i[0]
        ]
      ),
      updatePath: "system.details." + /*currentTab*/
      i[0]
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), s = E("div"), o && o.c(), n = R(), L(l.$$.fragment), b(s, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable");
    },
    m(a, c) {
      N(e, a, c), T(a, t, c), T(a, s, c), o && o.m(s, null), A(s, n), N(l, s, null), r = !0;
    },
    p(a, [c]) {
      const u = {};
      c & /*currentTab*/
      1 && (u.currentTab = /*currentTab*/
      a[0]), e.$set(u), /*currentTab*/
      a[0] === "appearance" ? o ? (o.p(a, c), c & /*currentTab*/
      1 && w(o, 1)) : (o = FR(a), o.c(), w(o, 1), o.m(s, n)) : o && (ce(), C(o, 1, 1, () => {
        o = null;
      }), ue());
      const d = {};
      c & /*$actor, currentTab*/
      3 && (d.content = /*$actor*/
      a[1].system.details[
        /*currentTab*/
        a[0]
      ]), c & /*currentTab*/
      1 && (d.updatePath = "system.details." + /*currentTab*/
      a[0]), l.$set(d);
    },
    i(a) {
      r || (w(e.$$.fragment, a), w(o), w(l.$$.fragment, a), r = !0);
    },
    o(a) {
      C(e.$$.fragment, a), C(o), C(l.$$.fragment, a), r = !1;
    },
    d(a) {
      a && (S(t), S(s)), j(e, a), o && o.d(), j(l);
    }
  };
}
f(aie, "create_fragment$2b");
function cie(i, e, t) {
  var g;
  let s;
  function n({ detail: h }) {
    const { uuid: _ } = s;
    t(0, d = h), li.update((y) => ({
      ...y,
      [_]: {
        ...y[_] ?? {},
        currentNotesTab: h
      }
    }));
  }
  f(n, "updateCurrentTab");
  const l = fe("actor");
  pe(i, l, (h) => t(1, s = h));
  let r = game.user.isGM;
  const o = {
    appearance: {
      label: "Character Details",
      display: s.type === "character"
    },
    bio: {
      label: s.type === "npc" ? "A5E.TabBiography" : "Backstory",
      display: s.type === "character" || r && s.type === "npc"
    },
    notes: { label: "A5E.TabNotes" },
    privateNotes: {
      label: "A5E.DetailsNotesPrivate",
      display: r && s.type === "npc"
    }
  }, a = {
    classes: "A5E.ClassPlural",
    archetype: "A5E.Archetype",
    // background: "A5E.Background",
    // culture: "A5E.Culture",
    // destiny: "A5E.Destiny",
    // heritage: "A5E.Heritage",
    prestige: "A5E.Prestige"
  }, c = {
    age: "A5E.DetailsAge",
    eyeColor: "A5E.DetailsEyeColor",
    hairColor: "A5E.DetailsHairColor",
    skinColor: "A5E.DetailsSkinColor",
    height: "A5E.DetailsHeight",
    weight: "A5E.DetailsWeight",
    gender: "A5E.DetailsGender"
  };
  let u = {};
  li.subscribe((h) => {
    u = h;
  });
  let d = ((g = u[s == null ? void 0 : s.uuid]) == null ? void 0 : g.currentNotesTab) ?? (s.type === "npc" ? "bio" : "appearance");
  return [
    d,
    s,
    n,
    l,
    o,
    a,
    c,
    /* @__PURE__ */ f((h, { target: _ }) => {
      se(s, _.name, h === "prestige" ? Number(_.value) : _.value);
    }, "change_handler"),
    /* @__PURE__ */ f(({ target: h }) => {
      se(s, h.name, h.value);
    }, "change_handler_1")
  ];
}
f(cie, "instance$22");
const sT = class sT extends ie {
  constructor(e) {
    super(), le(this, e, cie, aie, ne, {});
  }
};
f(sT, "ActorNotesPage");
let jv = sT;
function uie(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.automatePrototypeTokenSize",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.automatePrototypeTokenSize) ?? /*automateTokenSize*/
        i[3] ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[4]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.automatePrototypeTokenSize) ?? /*automateTokenSize*/
      n[3] ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(uie, "create_default_slot_11$3");
function fie(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.HideGenericResources",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.hideGenericResources) ?? /*$actor*/
        i[0].type === "npc"
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[5]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags, $actor*/
      3 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.hideGenericResources) ?? /*$actor*/
      n[0].type === "npc"), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(fie, "create_default_slot_10$3");
function die(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.includeAbilityModifiersForSkills",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.includeAbilityModifiersForSkills) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[6]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.includeAbilityModifiersForSkills) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(die, "create_default_slot_9$3");
function pie(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.showFavoritesSection",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.showFavoritesSection) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[7]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.showFavoritesSection) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(pie, "create_default_slot_8$4");
function mie(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.showManeuverTab",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.showManeuverTab) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[8]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.showManeuverTab) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(mie, "create_default_slot_7$7");
function hie(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.showPassiveScores",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.showPassiveScores) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[9]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.showPassiveScores) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(hie, "create_default_slot_6$8");
function gie(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.showSpellTab",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.showSpellTab) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_6*/
    i[10]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.showSpellTab) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(gie, "create_default_slot_5$b");
function LR(i) {
  let e, t;
  return e = new de({
    props: {
      $$slots: { default: [bie] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, flags, $actor*/
      32771 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(LR, "create_if_block_1$L");
function bie(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.showXP",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.showXP) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_7*/
    i[11]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.showXP) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(bie, "create_default_slot_4$c");
function _ie(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _;
  e = new de({
    props: {
      $$slots: { default: [uie] },
      $$scope: { ctx: i }
    }
  }), s = new de({
    props: {
      $$slots: { default: [fie] },
      $$scope: { ctx: i }
    }
  }), l = new de({
    props: {
      $$slots: { default: [die] },
      $$scope: { ctx: i }
    }
  }), o = new de({
    props: {
      $$slots: { default: [pie] },
      $$scope: { ctx: i }
    }
  }), c = new de({
    props: {
      $$slots: { default: [mie] },
      $$scope: { ctx: i }
    }
  }), d = new de({
    props: {
      $$slots: { default: [hie] },
      $$scope: { ctx: i }
    }
  }), m = new de({
    props: {
      $$slots: { default: [gie] },
      $$scope: { ctx: i }
    }
  });
  let y = (
    /*$actor*/
    i[0].type === "character" && LR(i)
  );
  return {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment), r = R(), L(o.$$.fragment), a = R(), L(c.$$.fragment), u = R(), L(d.$$.fragment), p = R(), L(m.$$.fragment), g = R(), y && y.c(), h = $e();
    },
    m(k, v) {
      N(e, k, v), T(k, t, v), N(s, k, v), T(k, n, v), N(l, k, v), T(k, r, v), N(o, k, v), T(k, a, v), N(c, k, v), T(k, u, v), N(d, k, v), T(k, p, v), N(m, k, v), T(k, g, v), y && y.m(k, v), T(k, h, v), _ = !0;
    },
    p(k, v) {
      const O = {};
      v & /*$$scope, flags, $actor*/
      32771 && (O.$$scope = { dirty: v, ctx: k }), e.$set(O);
      const P = {};
      v & /*$$scope, flags, $actor*/
      32771 && (P.$$scope = { dirty: v, ctx: k }), s.$set(P);
      const D = {};
      v & /*$$scope, flags, $actor*/
      32771 && (D.$$scope = { dirty: v, ctx: k }), l.$set(D);
      const I = {};
      v & /*$$scope, flags, $actor*/
      32771 && (I.$$scope = { dirty: v, ctx: k }), o.$set(I);
      const B = {};
      v & /*$$scope, flags, $actor*/
      32771 && (B.$$scope = { dirty: v, ctx: k }), c.$set(B);
      const F = {};
      v & /*$$scope, flags, $actor*/
      32771 && (F.$$scope = { dirty: v, ctx: k }), d.$set(F);
      const H = {};
      v & /*$$scope, flags, $actor*/
      32771 && (H.$$scope = { dirty: v, ctx: k }), m.$set(H), /*$actor*/
      k[0].type === "character" ? y ? (y.p(k, v), v & /*$actor*/
      1 && w(y, 1)) : (y = LR(k), y.c(), w(y, 1), y.m(h.parentNode, h)) : y && (ce(), C(y, 1, 1, () => {
        y = null;
      }), ue());
    },
    i(k) {
      _ || (w(e.$$.fragment, k), w(s.$$.fragment, k), w(l.$$.fragment, k), w(o.$$.fragment, k), w(c.$$.fragment, k), w(d.$$.fragment, k), w(m.$$.fragment, k), w(y), _ = !0);
    },
    o(k) {
      C(e.$$.fragment, k), C(s.$$.fragment, k), C(l.$$.fragment, k), C(o.$$.fragment, k), C(c.$$.fragment, k), C(d.$$.fragment, k), C(m.$$.fragment, k), C(y), _ = !1;
    },
    d(k) {
      k && (S(t), S(n), S(r), S(a), S(u), S(p), S(g), S(h)), j(e, k), j(s, k), j(l, k), j(o, k), j(c, k), j(d, k), j(m, k), y && y.d(k);
    }
  };
}
f(_ie, "create_default_slot_3$h");
function BR(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Automation Customization",
      $$slots: { default: [kie] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, flags, $actor*/
      32771 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(BR, "create_if_block$18");
function yie(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.automateHitDice",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.automateHitDice) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_8*/
    i[12]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.automateHitDice) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(yie, "create_default_slot_2$i");
function vie(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.automateSpellResources",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.automateSpellResources) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_9*/
    i[13]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.automateSpellResources) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(vie, "create_default_slot_1$m");
function kie(i) {
  let e, t, s, n;
  return e = new de({
    props: {
      $$slots: { default: [yie] },
      $$scope: { ctx: i }
    }
  }), s = new de({
    props: {
      $$slots: { default: [vie] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$$scope, flags, $actor*/
      32771 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$$scope, flags, $actor*/
      32771 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(kie, "create_default_slot$V");
function wie(i) {
  let e, t, s, n, l;
  e = new Me({
    props: {
      heading: "Sheet Customization",
      $$slots: { default: [_ie] },
      $$scope: { ctx: i }
    }
  });
  let r = (
    /*$actor*/
    i[0].type === "character" && BR(i)
  );
  return {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), r && r.c(), n = $e(), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(o, a) {
      T(o, t, a), N(e, t, null), T(o, s, a), r && r.m(o, a), T(o, n, a), l = !0;
    },
    p(o, [a]) {
      const c = {};
      a & /*$$scope, flags, $actor*/
      32771 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c), /*$actor*/
      o[0].type === "character" ? r ? (r.p(o, a), a & /*$actor*/
      1 && w(r, 1)) : (r = BR(o), r.c(), w(r, 1), r.m(n.parentNode, n)) : r && (ce(), C(r, 1, 1, () => {
        r = null;
      }), ue());
    },
    i(o) {
      l || (w(e.$$.fragment, o), w(r), l = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(r), l = !1;
    },
    d(o) {
      o && (S(s), S(n)), o && e && S(t), j(e, o), r && r.d(o);
    }
  };
}
f(wie, "create_fragment$2a");
function $ie(i, e, t) {
  let s, n;
  const l = fe("actor");
  pe(i, l, (k) => t(0, n = k));
  let o = game.a5e.settings.store.getStore("automatePrototypeTokenSize");
  const a = /* @__PURE__ */ f(({ detail: k }) => {
    se(n, "flags.a5e.automatePrototypeTokenSize", k);
  }, "updateSelection_handler"), c = /* @__PURE__ */ f(({ detail: k }) => {
    se(n, "flags.a5e.hideGenericResources", k);
  }, "updateSelection_handler_1"), u = /* @__PURE__ */ f(({ detail: k }) => {
    se(n, "flags.a5e.includeAbilityModifiersForSkills", k);
  }, "updateSelection_handler_2"), d = /* @__PURE__ */ f(({ detail: k }) => {
    se(n, "flags.a5e.showFavoritesSection", k);
  }, "updateSelection_handler_3"), p = /* @__PURE__ */ f(({ detail: k }) => {
    se(n, "flags.a5e.showManeuverTab", k);
  }, "updateSelection_handler_4"), m = /* @__PURE__ */ f(({ detail: k }) => {
    se(n, "flags.a5e.showPassiveScores", k);
  }, "updateSelection_handler_5"), g = /* @__PURE__ */ f(({ detail: k }) => {
    se(n, "flags.a5e.showSpellTab", k);
  }, "updateSelection_handler_6"), h = /* @__PURE__ */ f(({ detail: k }) => {
    se(n, "flags.a5e.showXP", k);
  }, "updateSelection_handler_7"), _ = /* @__PURE__ */ f(({ detail: k }) => {
    se(n, "flags.a5e.automateHitDice", k);
  }, "updateSelection_handler_8"), y = /* @__PURE__ */ f(({ detail: k }) => {
    se(n, "flags.a5e.automateSpellResources", k);
  }, "updateSelection_handler_9");
  return i.$$.update = () => {
    var k;
    i.$$.dirty & /*$actor*/
    1 && t(1, s = ((k = n.flags) == null ? void 0 : k.a5e) ?? {});
  }, [
    n,
    s,
    l,
    o,
    a,
    c,
    u,
    d,
    p,
    m,
    g,
    h,
    _,
    y
  ];
}
f($ie, "instance$21");
const nT = class nT extends ie {
  constructor(e) {
    super(), le(this, e, $ie, wie, ne, {});
  }
};
f(nT, "ActorGeneralSettingsTab");
let Lv = nT;
function Aie(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.trackInventoryWeight",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.trackInventoryWeight) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[4]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.trackInventoryWeight) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(Aie, "create_default_slot_3$g");
function qR(i) {
  let e, t, s, n;
  return e = new de({
    props: {
      $$slots: { default: [Eie] },
      $$scope: { ctx: i }
    }
  }), s = new de({
    props: {
      hint: "A5E.settings.hints.trackCurrencyWeight",
      $$slots: { default: [Sie] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$$scope, flags, $actor*/
      131 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$$scope, flags, $actor*/
      131 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(qR, "create_if_block$17");
function Eie(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.doubleCarryingCapacity",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.doubleCarryCapacity) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[5]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.doubleCarryCapacity) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(Eie, "create_default_slot_2$h");
function Sie(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.trackCurrencyWeight",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.trackCurrencyWeight) ?? /*globalCurrencyWeightTrackingSelection*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[6]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.trackCurrencyWeight) ?? /*globalCurrencyWeightTrackingSelection*/
      n[3]), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(Sie, "create_default_slot_1$l");
function Tie(i) {
  var r;
  let e, t, s, n;
  e = new de({
    props: {
      $$slots: { default: [Aie] },
      $$scope: { ctx: i }
    }
  });
  let l = (
    /*flags*/
    (((r = i[1]) == null ? void 0 : r.trackInventoryWeight) ?? !0) && qR(i)
  );
  return {
    c() {
      L(e.$$.fragment), t = R(), l && l.c(), s = $e();
    },
    m(o, a) {
      N(e, o, a), T(o, t, a), l && l.m(o, a), T(o, s, a), n = !0;
    },
    p(o, a) {
      var u;
      const c = {};
      a & /*$$scope, flags, $actor*/
      131 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c), /*flags*/
      ((u = o[1]) == null ? void 0 : u.trackInventoryWeight) ?? !0 ? l ? (l.p(o, a), a & /*flags*/
      2 && w(l, 1)) : (l = qR(o), l.c(), w(l, 1), l.m(s.parentNode, s)) : l && (ce(), C(l, 1, 1, () => {
        l = null;
      }), ue());
    },
    i(o) {
      n || (w(e.$$.fragment, o), w(l), n = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(l), n = !1;
    },
    d(o) {
      o && (S(t), S(s)), j(e, o), l && l.d(o);
    }
  };
}
f(Tie, "create_default_slot$U");
function Cie(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Weight Tracking Options",
      $$slots: { default: [Tie] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, flags, $actor*/
      131 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(Cie, "create_fragment$29");
function Oie(i, e, t) {
  let s, n;
  const l = fe("actor");
  pe(i, l, (u) => t(0, n = u));
  const r = game.settings.get("a5e", "currencyWeight"), o = /* @__PURE__ */ f(({ detail: u }) => {
    se(n, "flags.a5e.trackInventoryWeight", u);
  }, "updateSelection_handler"), a = /* @__PURE__ */ f(({ detail: u }) => {
    se(n, "flags.a5e.doubleCarryCapacity", u);
  }, "updateSelection_handler_1"), c = /* @__PURE__ */ f(({ detail: u }) => {
    se(n, "flags.a5e.trackCurrencyWeight", u);
  }, "updateSelection_handler_2");
  return i.$$.update = () => {
    var u;
    i.$$.dirty & /*$actor*/
    1 && t(1, s = ((u = n.flags) == null ? void 0 : u.a5e) ?? {});
  }, [
    n,
    s,
    l,
    r,
    o,
    a,
    c
  ];
}
f(Oie, "instance$20");
const iT = class iT extends ie {
  constructor(e) {
    super(), le(this, e, Oie, Cie, ne, {});
  }
};
f(iT, "ActorInventorySettingsTab");
let Bv = iT;
function Iie(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.ExertionRecoveryConfigPrompt",
      checked: (
        /*$actor*/
        i[0].system.attributes.exertion.recoverOnRest
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[2]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$actor*/
      1 && (l.checked = /*$actor*/
      s[0].system.attributes.exertion.recoverOnRest), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Iie, "create_default_slot_1$k");
function Pie(i) {
  let e, t;
  return e = new de({
    props: {
      $$slots: { default: [Iie] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $actor*/
      9 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Pie, "create_default_slot$T");
function Mie(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Maneuver Resource Settings",
      $$slots: { default: [Pie] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, $actor*/
      9 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(Mie, "create_fragment$28");
function Rie(i, e, t) {
  let s;
  const n = fe("actor");
  return pe(i, n, (r) => t(0, s = r)), [s, n, /* @__PURE__ */ f(({ detail: r }) => {
    se(s, "system.attributes.exertion.recoverOnRest", r);
  }, "updateSelection_handler")];
}
f(Rie, "instance$1$");
const lT = class lT extends ie {
  constructor(e) {
    super(), le(this, e, Rie, Mie, ne, {});
  }
};
f(lT, "ActorManeuverSettingsTab");
let qv = lT;
function Fie(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.halflingLuck",
      checked: (
        /*flags*/
        ((s = i[1].a5e) == null ? void 0 : s.halflingLuck) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[3]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1].a5e) == null ? void 0 : o.halflingLuck) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(Fie, "create_default_slot_3$f");
function Nie(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.jackOfAllTrades",
      checked: (
        /*flags*/
        ((s = i[1].a5e) == null ? void 0 : s.jackOfAllTrades) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[4]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1].a5e) == null ? void 0 : o.jackOfAllTrades) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(Nie, "create_default_slot_2$g");
function jie(i) {
  let e, t, s, n, l = K("A5E.settings.deathSaveThreshold") + "", r, o, a;
  return {
    c() {
      var c;
      e = E("input"), s = R(), n = E("label"), r = x(l), b(
        e,
        "id",
        /*actor*/
        i[2].id + "-death-save-threshold"
      ), b(e, "class", "a5e-input a5e-input--small a5e-input--slim"), b(e, "type", "number"), b(e, "min", "0"), b(e, "max", "20"), e.value = t = /*flags*/
      ((c = i[1].a5e) == null ? void 0 : c.deathSaveThreshold) ?? 10, b(
        n,
        "for",
        /*actor*/
        i[2].id + "-death-save-threshold"
      );
    },
    m(c, u) {
      T(c, e, u), T(c, s, u), T(c, n, u), A(n, r), o || (a = V(
        e,
        "change",
        /*change_handler*/
        i[5]
      ), o = !0);
    },
    p(c, u) {
      var d;
      u & /*flags*/
      2 && t !== (t = /*flags*/
      ((d = c[1].a5e) == null ? void 0 : d.deathSaveThreshold) ?? 10) && e.value !== t && (e.value = t);
    },
    d(c) {
      c && (S(e), S(s), S(n)), o = !1, a();
    }
  };
}
f(jie, "create_default_slot_1$j");
function Lie(i) {
  let e, t, s, n, l, r, o;
  return e = new de({
    props: {
      hint: "A5E.settings.hints.halflingLuck",
      $$slots: { default: [Fie] },
      $$scope: { ctx: i }
    }
  }), s = new de({
    props: {
      hint: "A5E.settings.hints.jackOfAllTrades",
      $$slots: { default: [Nie] },
      $$scope: { ctx: i }
    }
  }), l = new de({
    props: {
      hint: "A5E.settings.hints.deathSaveThreshold",
      $$slots: { default: [jie] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), r = E("div"), L(l.$$.fragment), z(r, "display", "contents"), z(r, "--a5e-field-wrapper-direction", "row"), z(r, "--a5e-field-wrapper-item-alignment", "center");
    },
    m(a, c) {
      N(e, a, c), T(a, t, c), N(s, a, c), T(a, n, c), T(a, r, c), N(l, r, null), o = !0;
    },
    p(a, c) {
      const u = {};
      c & /*$$scope, flags, $actor*/
      67 && (u.$$scope = { dirty: c, ctx: a }), e.$set(u);
      const d = {};
      c & /*$$scope, flags, $actor*/
      67 && (d.$$scope = { dirty: c, ctx: a }), s.$set(d);
      const p = {};
      c & /*$$scope, flags, $actor*/
      67 && (p.$$scope = { dirty: c, ctx: a }), l.$set(p);
    },
    i(a) {
      o || (w(e.$$.fragment, a), w(s.$$.fragment, a), w(l.$$.fragment, a), o = !0);
    },
    o(a) {
      C(e.$$.fragment, a), C(s.$$.fragment, a), C(l.$$.fragment, a), o = !1;
    },
    d(a) {
      a && (S(t), S(n)), j(e, a), j(s, a), a && l && S(r), j(l, a);
    }
  };
}
f(Lie, "create_default_slot$S");
function Bie(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Roll Modifiers",
      $$slots: { default: [Lie] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, flags, $actor*/
      67 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(Bie, "create_fragment$27");
function qie(i, e, t) {
  let s, n;
  const l = fe("actor");
  pe(i, l, (c) => t(0, n = c));
  const r = /* @__PURE__ */ f(({ detail: c }) => {
    se(n, "flags.a5e.halflingLuck", c);
  }, "updateSelection_handler"), o = /* @__PURE__ */ f(({ detail: c }) => {
    se(n, "flags.a5e.jackOfAllTrades", c);
  }, "updateSelection_handler_1"), a = /* @__PURE__ */ f(({ target: c }) => {
    se(n, "flags.a5e.deathSaveThreshold", parseInt(c.value, 10));
  }, "change_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    1 && t(1, s = n.flags);
  }, [
    n,
    s,
    l,
    r,
    o,
    a
  ];
}
f(qie, "instance$1_");
const rT = class rT extends ie {
  constructor(e) {
    super(), le(this, e, qie, Bie, ne, {});
  }
};
f(rT, "ActorRollSettingsTab");
let Gv = rT;
function Gie(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.restoreSpellSlotsOnShortRest",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.restoreSpellSlotsOnShortRest) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[4]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.restoreSpellSlotsOnShortRest) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(Gie, "create_default_slot_3$e");
function zie(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.restoreSpellPointsOnShortRest",
      checked: (
        /*flags*/
        ((s = i[1]) == null ? void 0 : s.restoreSpellPointsOnShortRest) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[5]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1]) == null ? void 0 : o.restoreSpellPointsOnShortRest) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(zie, "create_default_slot_2$f");
function Hie(i) {
  let e, t, s, n;
  return e = new de({
    props: {
      $$slots: { default: [Gie] },
      $$scope: { ctx: i }
    }
  }), s = new de({
    props: {
      $$slots: { default: [zie] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$$scope, flags, $actor*/
      131 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$$scope, flags, $actor*/
      131 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(Hie, "create_default_slot_1$i");
function Uie(i) {
  let e, t;
  return e = new Ye({
    props: {
      heading: "A5E.DefaultSpellcastingAbilityScore",
      optionStyles: "min-width:2rem; text-align: center;",
      options: Object.entries(
        /*abilityAbbreviations*/
        i[3]
      ),
      selected: (
        /*$actor*/
        i[0].system.attributes.spellcasting
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[6]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$actor*/
      1 && (l.selected = /*$actor*/
      s[0].system.attributes.spellcasting), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Uie, "create_default_slot$R");
function Vie(i) {
  let e, t, s, n, l, r;
  return e = new Me({
    props: {
      heading: "Spell Resource Settings",
      $$slots: { default: [Hie] },
      $$scope: { ctx: i }
    }
  }), n = new Me({
    props: {
      heading: "Miscellaneous Spell Settings",
      $$slots: { default: [Uie] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), l = E("div"), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem"), z(l, "display", "contents"), z(l, "--a5e-section-body-gap", "0.75rem");
    },
    m(o, a) {
      T(o, t, a), N(e, t, null), T(o, s, a), T(o, l, a), N(n, l, null), r = !0;
    },
    p(o, [a]) {
      const c = {};
      a & /*$$scope, flags, $actor*/
      131 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const u = {};
      a & /*$$scope, $actor*/
      129 && (u.$$scope = { dirty: a, ctx: o }), n.$set(u);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(n.$$.fragment, o), r = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(n.$$.fragment, o), r = !1;
    },
    d(o) {
      o && S(s), o && e && S(t), j(e, o), o && n && S(l), j(n, o);
    }
  };
}
f(Vie, "create_fragment$26");
function Wie(i, e, t) {
  let s, n;
  const l = fe("actor");
  pe(i, l, (u) => t(0, n = u));
  const { abilityAbbreviations: r } = CONFIG.A5E, o = /* @__PURE__ */ f(({ detail: u }) => {
    se(n, "flags.a5e.restoreSpellSlotsOnShortRest", u);
  }, "updateSelection_handler"), a = /* @__PURE__ */ f(({ detail: u }) => {
    se(n, "flags.a5e.restoreSpellPointsOnShortRest", u);
  }, "updateSelection_handler_1"), c = /* @__PURE__ */ f((u) => se(n, "system.attributes.spellcasting", u.detail), "updateSelection_handler_2");
  return i.$$.update = () => {
    var u;
    i.$$.dirty & /*$actor*/
    1 && t(1, s = ((u = n.flags) == null ? void 0 : u.a5e) ?? {});
  }, [
    n,
    s,
    l,
    r,
    o,
    a,
    c
  ];
}
f(Wie, "instance$1Z");
const oT = class oT extends ie {
  constructor(e) {
    super(), le(this, e, Wie, Vie, ne, {});
  }
};
f(oT, "ActorSpellSettingsTab");
let zv = oT;
function Kie(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "Disable Randomized HP Rolls",
      checked: (
        /*flags*/
        ((s = i[1].a5e) == null ? void 0 : s.disableRandomizedHP) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[3]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*flags*/
      2 && (r.checked = /*flags*/
      ((o = n[1].a5e) == null ? void 0 : o.disableRandomizedHP) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(Kie, "create_default_slot_1$h");
function Yie(i) {
  let e, t;
  return e = new de({
    props: {
      $$slots: { default: [Kie] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, flags, $actor*/
      19 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Yie, "create_default_slot$Q");
function Xie(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Token Options",
      $$slots: { default: [Yie] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, flags, $actor*/
      19 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(Xie, "create_fragment$25");
function Jie(i, e, t) {
  let s, n;
  const l = fe("actor");
  pe(i, l, (o) => t(0, n = o));
  const r = /* @__PURE__ */ f(({ detail: o }) => {
    se(n, "flags.a5e.disableRandomizedHP", o);
  }, "updateSelection_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    1 && t(1, s = n.flags);
  }, [n, s, l, r];
}
f(Jie, "instance$1Y");
const aT = class aT extends ie {
  constructor(e) {
    super(), le(this, e, Jie, Xie, ne, {});
  }
};
f(aT, "ActorNPCSettingsTab");
let Hv = aT;
function Zie(i) {
  var a;
  let e, t, s, n, l;
  e = new op({
    props: {
      currentTab: (
        /*currentTab*/
        i[0]
      ),
      tabs: (
        /*tabs*/
        i[3]
      )
    }
  }), e.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[1]
  );
  var r = (
    /*tabs*/
    (a = i[3][
      /*currentTab*/
      i[0]
    ]) == null ? void 0 : a.component
  );
  function o(c, u) {
    return {};
  }
  return f(o, "switch_props"), r && (n = nt(r, o())), {
    c() {
      L(e.$$.fragment), t = R(), s = E("section"), n && L(n.$$.fragment), b(s, "class", "a5e-page-wrapper");
    },
    m(c, u) {
      N(e, c, u), T(c, t, u), T(c, s, u), n && N(n, s, null), l = !0;
    },
    p(c, [u]) {
      var p;
      const d = {};
      if (u & /*currentTab*/
      1 && (d.currentTab = /*currentTab*/
      c[0]), e.$set(d), u & /*currentTab*/
      1 && r !== (r = /*tabs*/
      (p = c[3][
        /*currentTab*/
        c[0]
      ]) == null ? void 0 : p.component)) {
        if (n) {
          ce();
          const m = n;
          C(m.$$.fragment, 1, 0, () => {
            j(m, 1);
          }), ue();
        }
        r ? (n = nt(r, o()), L(n.$$.fragment), w(n.$$.fragment, 1), N(n, s, null)) : n = null;
      }
    },
    i(c) {
      l || (w(e.$$.fragment, c), n && w(n.$$.fragment, c), l = !0);
    },
    o(c) {
      C(e.$$.fragment, c), n && C(n.$$.fragment, c), l = !1;
    },
    d(c) {
      c && (S(t), S(s)), j(e, c), n && j(n);
    }
  };
}
f(Zie, "create_fragment$24");
function Qie(i, e, t) {
  var c;
  let s;
  function n({ detail: u }) {
    const { uuid: d } = s;
    t(0, a = u), li.update((p) => ({
      ...p,
      [d]: {
        ...p[d] ?? {},
        currentSettingsTab: u
      }
    }));
  }
  f(n, "updateCurrentTab");
  let l = {};
  li.subscribe((u) => {
    l = u;
  });
  const r = fe("actor");
  pe(i, r, (u) => t(5, s = u));
  const o = {
    general: {
      component: Lv,
      label: "General"
    },
    inventory: {
      component: Bv,
      label: "Inventory"
    },
    maneuvers: {
      component: qv,
      label: "Maneuvers",
      display: s.type === "character"
    },
    spells: {
      component: zv,
      label: "Spells"
    },
    rolls: {
      component: Gv,
      label: "Rolls",
      display: s.type === "character"
    },
    npc: {
      component: Hv,
      label: "NPC Options",
      display: s.type === "npc" && (game.settings.get("a5e", "randomizeNPCHitPoints") ?? !0)
    }
  };
  let a = ((c = l[s == null ? void 0 : s.uuid]) == null ? void 0 : c.currentSettingsTab) ?? "general";
  return [a, n, r, o];
}
f(Qie, "instance$1X");
const cT = class cT extends ie {
  constructor(e) {
    super(), le(this, e, Qie, Zie, ne, {});
  }
};
f(cT, "ActorSettingsPage");
let Uv = cT;
function GR(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "a5e-ability-score__config-button fas fa-gear");
    },
    m(n, l) {
      T(n, e, l), t || (s = V(
        e,
        "click",
        /*click_handler*/
        i[9]
      ), t = !0);
    },
    p: ee,
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(GR, "create_if_block$16");
function xie(i) {
  var G, U;
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h = Qn(
    /*ability*/
    i[0].check.deterministicBonus
  ) + "", _, y, k, v, O, P = Qn(
    /*ability*/
    i[0].save.deterministicBonus
  ) + "", D, I, B, F, H = !/*$actor*/
  (!i[3].isOwner || /*$actor*/
  (((U = (G = i[3].flags) == null ? void 0 : G.a5e) == null ? void 0 : U.sheetIsLocked) ?? !0)) && GR(i);
  return {
    c() {
      e = E("li"), t = E("header"), s = E("h3"), n = x(
        /*abilityLabel*/
        i[1]
      ), l = R(), H && H.c(), r = R(), o = E("div"), a = E("input"), p = R(), m = E("button"), g = E("div"), _ = x(h), k = R(), v = E("button"), O = E("div"), D = x(P), b(s, "class", "a5e-ability-score__label"), b(t, "class", "a5e-ability-score__header"), b(a, "class", "a5e-ability-score__value"), b(a, "name", c = "system.abilities." + /*abilityLabel*/
      i[1] + ".value"), b(a, "type", "number"), a.value = u = /*sheetIsLocked*/
      i[4] ? (
        /*ability*/
        i[0].value
      ) : (
        /*sourceValue*/
        i[5]
      ), b(a, "tabindex", d = /*idx*/
      i[2] + 1), b(a, "placeholder", "10"), a.disabled = /*sheetIsLocked*/
      i[4], b(g, "class", "a5e-ability-score__roll-button-value"), b(m, "class", "a5e-ability-score__roll-button a5e-ability-score__roll-button--check"), b(m, "data-tooltip", y = /*sheetIsLocked*/
      i[4] ? "A5E.RollAbilityCheck" : null), b(m, "data-tooltip-direction", "DOWN"), Q(m, "a5e-ability-score__roll-button--no-click", !/*sheetIsLocked*/
      i[4]), b(O, "class", "a5e-ability-score__roll-button-value"), b(v, "class", "a5e-ability-score__roll-button a5e-ability-score__roll-button--save"), b(v, "data-tooltip", I = /*sheetIsLocked*/
      i[4] ? "A5E.RollSavingThrow" : "Toggle Saving Throw Proficiency"), b(v, "data-tooltip-direction", "DOWN"), Q(
        v,
        "a5e-ability-score__roll-button--proficient",
        /*ability*/
        i[0].save.proficient
      ), b(o, "class", "a5e-ability-score__body"), b(e, "class", "a5e-ability-score");
    },
    m(q, W) {
      T(q, e, W), A(e, t), A(t, s), A(s, n), A(t, l), H && H.m(t, null), A(e, r), A(e, o), A(o, a), A(o, p), A(o, m), A(m, g), A(g, _), A(o, k), A(o, v), A(v, O), A(O, D), B || (F = [
        V(
          a,
          "change",
          /*change_handler*/
          i[10]
        ),
        V(
          m,
          "click",
          /*click_handler_1*/
          i[11]
        ),
        V(
          v,
          "click",
          /*click_handler_2*/
          i[12]
        )
      ], B = !0);
    },
    p(q, [W]) {
      var X, te;
      W & /*abilityLabel*/
      2 && _e(
        n,
        /*abilityLabel*/
        q[1]
      ), /*$actor*/
      !q[3].isOwner || /*$actor*/
      (((te = (X = q[3].flags) == null ? void 0 : X.a5e) == null ? void 0 : te.sheetIsLocked) ?? !0) ? H && (H.d(1), H = null) : H ? H.p(q, W) : (H = GR(q), H.c(), H.m(t, null)), W & /*abilityLabel*/
      2 && c !== (c = "system.abilities." + /*abilityLabel*/
      q[1] + ".value") && b(a, "name", c), W & /*sheetIsLocked, ability, sourceValue*/
      49 && u !== (u = /*sheetIsLocked*/
      q[4] ? (
        /*ability*/
        q[0].value
      ) : (
        /*sourceValue*/
        q[5]
      )) && a.value !== u && (a.value = u), W & /*idx*/
      4 && d !== (d = /*idx*/
      q[2] + 1) && b(a, "tabindex", d), W & /*sheetIsLocked*/
      16 && (a.disabled = /*sheetIsLocked*/
      q[4]), W & /*ability*/
      1 && h !== (h = Qn(
        /*ability*/
        q[0].check.deterministicBonus
      ) + "") && _e(_, h), W & /*sheetIsLocked*/
      16 && y !== (y = /*sheetIsLocked*/
      q[4] ? "A5E.RollAbilityCheck" : null) && b(m, "data-tooltip", y), W & /*sheetIsLocked*/
      16 && Q(m, "a5e-ability-score__roll-button--no-click", !/*sheetIsLocked*/
      q[4]), W & /*ability*/
      1 && P !== (P = Qn(
        /*ability*/
        q[0].save.deterministicBonus
      ) + "") && _e(D, P), W & /*sheetIsLocked*/
      16 && I !== (I = /*sheetIsLocked*/
      q[4] ? "A5E.RollSavingThrow" : "Toggle Saving Throw Proficiency") && b(v, "data-tooltip", I), W & /*ability*/
      1 && Q(
        v,
        "a5e-ability-score__roll-button--proficient",
        /*ability*/
        q[0].save.proficient
      );
    },
    i: ee,
    o: ee,
    d(q) {
      q && S(e), H && H.d(), B = !1, Ne(F);
    }
  };
}
f(xie, "create_fragment$23");
function ele(i, e, t) {
  let s, n, l, r;
  pe(i, Mi, (y) => t(13, r = y));
  let { ability: o } = e, { abilityLabel: a } = e, { idx: c } = e;
  function u(y) {
    n && l.rollAbilityCheck(y, Bi(r));
  }
  f(u, "handleCheckClick");
  function d(y) {
    var k, v;
    if (n)
      l.rollSavingThrow(y, Bi(r));
    else {
      const O = (v = (k = l.system.abilities[y]) == null ? void 0 : k.save) == null ? void 0 : v.proficient;
      l.update({
        [`system.abilities.${y}.save.proficient`]: !O
      });
    }
  }
  f(d, "handleSaveClick");
  const p = fe("actor");
  pe(i, p, (y) => t(3, l = y));
  const m = /* @__PURE__ */ f(() => l.configureAbilityScore({ abilityKey: a }), "click_handler"), g = /* @__PURE__ */ f(({ target: y }) => se(l, y.name, Number(y.value)), "change_handler"), h = /* @__PURE__ */ f(() => u(a), "click_handler_1"), _ = /* @__PURE__ */ f(() => d(a), "click_handler_2");
  return i.$$set = (y) => {
    "ability" in y && t(0, o = y.ability), "abilityLabel" in y && t(1, a = y.abilityLabel), "idx" in y && t(2, c = y.idx);
  }, i.$$.update = () => {
    var y, k;
    i.$$.dirty & /*$actor, abilityLabel*/
    10 && t(5, s = l._source.system.abilities[a].value), i.$$.dirty & /*$actor*/
    8 && t(4, n = l.isOwner ? ((k = (y = l.flags) == null ? void 0 : y.a5e) == null ? void 0 : k.sheetIsLocked) ?? !0 : !0);
  }, [
    o,
    a,
    c,
    l,
    n,
    s,
    u,
    d,
    p,
    m,
    g,
    h,
    _
  ];
}
f(ele, "instance$1W");
const uT = class uT extends ie {
  constructor(e) {
    super(), le(this, e, ele, xie, ne, { ability: 0, abilityLabel: 1, idx: 2 });
  }
};
f(uT, "AbilityScore");
let Vv = uT;
function zR(i, e, t) {
  const s = i.slice();
  return s[2] = e[t][0], s[3] = e[t][1], s[5] = t, s;
}
f(zR, "get_each_context$H");
function HR(i) {
  let e, t;
  return e = new Vv({
    props: {
      ability: (
        /*ability*/
        i[3]
      ),
      abilityLabel: (
        /*abilityLabel*/
        i[2]
      ),
      idx: (
        /*idx*/
        i[5]
      )
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$actor*/
      1 && (l.ability = /*ability*/
      s[3]), n & /*$actor*/
      1 && (l.abilityLabel = /*abilityLabel*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(HR, "create_each_block$H");
function tle(i) {
  let e, t, s = oe(Object.entries(
    /*$actor*/
    i[0].system.abilities
  )), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = HR(zR(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("ul");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "a5e-ability-scores");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, [o]) {
      if (o & /*Object, $actor*/
      1) {
        s = oe(Object.entries(
          /*$actor*/
          r[0].system.abilities
        ));
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = zR(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = HR(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f(tle, "create_fragment$22");
function sle(i, e, t) {
  let s;
  const n = fe("actor");
  return pe(i, n, (l) => t(0, s = l)), [s, n];
}
f(sle, "instance$1V");
const fT = class fT extends ie {
  constructor(e) {
    super(), le(this, e, sle, tle, ne, {});
  }
};
f(fT, "AbilityScores");
let Wv = fT;
function nle(i) {
  if (i.type === "npc")
    return 0;
  let e = i.levels.character;
  return e < 1 ? e = 1 : e > 19 && (e = 19), CONFIG.A5E.CHARACTER_EXP_LEVELS[e.toString()] ?? 0;
}
f(nle, "getRequiredExperiencePoints");
function UR(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k;
  return {
    c() {
      e = E("div"), t = E("label"), s = x("Current XP"), l = R(), r = E("input"), c = R(), u = E("div"), d = E("label"), p = x("Required XP"), g = R(), h = E("input"), b(t, "class", "xp-label svelte-1biolez"), b(t, "for", n = /*$actor*/
      i[0].id + "-current-xp"), b(r, "id", o = /*$actor*/
      i[0].id + "-current-xp"), b(r, "class", "xp-input svelte-1biolez"), b(r, "type", "number"), b(r, "name", "system.details.xp"), r.value = a = /*$actor*/
      i[0].system.details.xp, b(r, "placeholder", "0"), b(r, "min", "0"), Q(r, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(e, "class", "xp-box svelte-1biolez"), b(d, "class", "xp-label svelte-1biolez"), b(d, "for", m = /*$actor*/
      i[0].id + "-required-xp"), b(h, "id", _ = /*$actor*/
      i[0].id + "-required-xp"), b(h, "class", "xp-input svelte-1biolez"), b(h, "type", "number"), h.value = /*requiredXP*/
      i[2], b(h, "placeholder", "0"), b(h, "min", "0"), h.disabled = !0, b(u, "class", "xp-box svelte-1biolez");
    },
    m(v, O) {
      T(v, e, O), A(e, t), A(t, s), A(e, l), A(e, r), T(v, c, O), T(v, u, O), A(u, d), A(d, p), A(u, g), A(u, h), y || (k = [
        V(
          r,
          "change",
          /*change_handler_1*/
          i[10]
        ),
        V(r, "click", rle)
      ], y = !0);
    },
    p(v, O) {
      O & /*$actor*/
      1 && n !== (n = /*$actor*/
      v[0].id + "-current-xp") && b(t, "for", n), O & /*$actor*/
      1 && o !== (o = /*$actor*/
      v[0].id + "-current-xp") && b(r, "id", o), O & /*$actor*/
      1 && a !== (a = /*$actor*/
      v[0].system.details.xp) && r.value !== a && (r.value = a), O & /*$actor*/
      1 && Q(r, "disable-pointer-events", !/*$actor*/
      v[0].isOwner), O & /*$actor*/
      1 && m !== (m = /*$actor*/
      v[0].id + "-required-xp") && b(d, "for", m), O & /*$actor*/
      1 && _ !== (_ = /*$actor*/
      v[0].id + "-required-xp") && b(h, "id", _), O & /*requiredXP*/
      4 && h.value !== /*requiredXP*/
      v[2] && (h.value = /*requiredXP*/
      v[2]);
    },
    d(v) {
      v && (S(e), S(c), S(u)), y = !1, Ne(k);
    }
  };
}
f(UR, "create_if_block$15");
function ile(i) {
  var W, X;
  let e, t, s, n = K("A5E.Inspiration") + "", l, r, o, a, c, u, d, p, m, g, h, _, y, k, v, O, P, D, I, B, F, H, G, U, q = (
    /*$actor*/
    (((X = (W = i[0].flags) == null ? void 0 : W.a5e) == null ? void 0 : X.showXP) ?? !0) && UR(i)
  );
  return {
    c() {
      e = E("div"), t = E("div"), s = E("label"), l = x(n), o = R(), a = E("i"), c = R(), u = E("div"), d = E("label"), p = x("Level"), g = R(), h = E("input"), y = R(), k = E("div"), v = E("label"), O = x("Prof."), D = R(), I = E("input"), H = R(), q && q.c(), b(s, "class", "xp-label svelte-1biolez"), b(s, "for", r = /*$actor*/
      i[0].id + "-inspiration"), b(a, "class", "fas fa-dice-d20 shield-inspiration svelte-1biolez"), Q(
        a,
        "shield-inspiration--active",
        /*hasInspiration*/
        i[3]
      ), Q(a, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(t, "class", "character-shields__box svelte-1biolez"), b(d, "class", "xp-label svelte-1biolez"), b(d, "for", m = /*$actor*/
      i[0].id + "-level"), b(h, "id", _ = /*$actor*/
      i[0].id + "-level"), b(h, "class", "xp-input svelte-1biolez"), b(
        h,
        "data-tooltip",
        /*levelSource*/
        i[4]
      ), b(h, "data-tooltip-direction", "DOWN"), b(h, "type", "number"), b(h, "name", "system.details.level"), h.value = /*characterLevel*/
      i[5], b(h, "placeholder", "0"), b(h, "min", "0"), h.disabled = /*levelIsLocked*/
      i[1], Q(h, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(u, "class", "character-shields__box svelte-1biolez"), b(v, "class", "xp-label svelte-1biolez"), b(v, "for", P = /*$actor*/
      i[0].id + "-prof"), b(I, "id", B = /*$actor*/
      i[0].id + "-prof"), b(I, "class", "xp-input svelte-1biolez"), b(I, "type", "number"), I.value = F = /*$actor*/
      i[0].system.attributes.prof, b(I, "placeholder", "0"), b(I, "min", "0"), I.disabled = !0, b(k, "class", "character-shields__box svelte-1biolez"), b(e, "class", "character-shields__container svelte-1biolez");
    },
    m(te, J) {
      T(te, e, J), A(e, t), A(t, s), A(s, l), A(t, o), A(t, a), A(e, c), A(e, u), A(u, d), A(d, p), A(u, g), A(u, h), A(e, y), A(e, k), A(k, v), A(v, O), A(k, D), A(k, I), A(e, H), q && q.m(e, null), G || (U = [
        V(
          a,
          "click",
          /*click_handler*/
          i[8]
        ),
        V(
          h,
          "change",
          /*change_handler*/
          i[9]
        ),
        V(h, "click", lle)
      ], G = !0);
    },
    p(te, [J]) {
      var re, ae;
      J & /*$actor*/
      1 && r !== (r = /*$actor*/
      te[0].id + "-inspiration") && b(s, "for", r), J & /*hasInspiration*/
      8 && Q(
        a,
        "shield-inspiration--active",
        /*hasInspiration*/
        te[3]
      ), J & /*$actor*/
      1 && Q(a, "disable-pointer-events", !/*$actor*/
      te[0].isOwner), J & /*$actor*/
      1 && m !== (m = /*$actor*/
      te[0].id + "-level") && b(d, "for", m), J & /*$actor*/
      1 && _ !== (_ = /*$actor*/
      te[0].id + "-level") && b(h, "id", _), J & /*levelSource*/
      16 && b(
        h,
        "data-tooltip",
        /*levelSource*/
        te[4]
      ), J & /*characterLevel*/
      32 && h.value !== /*characterLevel*/
      te[5] && (h.value = /*characterLevel*/
      te[5]), J & /*levelIsLocked*/
      2 && (h.disabled = /*levelIsLocked*/
      te[1]), J & /*$actor*/
      1 && Q(h, "disable-pointer-events", !/*$actor*/
      te[0].isOwner), J & /*$actor*/
      1 && P !== (P = /*$actor*/
      te[0].id + "-prof") && b(v, "for", P), J & /*$actor*/
      1 && B !== (B = /*$actor*/
      te[0].id + "-prof") && b(I, "id", B), J & /*$actor*/
      1 && F !== (F = /*$actor*/
      te[0].system.attributes.prof) && I.value !== F && (I.value = F), /*$actor*/
      ((ae = (re = te[0].flags) == null ? void 0 : re.a5e) == null ? void 0 : ae.showXP) ?? !0 ? q ? q.p(te, J) : (q = UR(te), q.c(), q.m(e, null)) : q && (q.d(1), q = null);
    },
    i: ee,
    o: ee,
    d(te) {
      te && S(e), q && q.d(), G = !1, Ne(U);
    }
  };
}
f(ile, "create_fragment$21");
const lle = /* @__PURE__ */ f(({ target: i }) => i.select(), "click_handler_1"), rle = /* @__PURE__ */ f(({ target: i }) => i.select(), "click_handler_2");
function ole(i, e, t) {
  let s, n, l, r, o, a, c;
  const u = fe("actor");
  pe(i, u, (y) => t(0, c = y));
  function d() {
    return !!(o || Object.keys(c.classes ?? {}).length);
  }
  f(d, "isLevelLocked");
  function p() {
    return Object.keys(c.classes ?? {}).length ? c.levels.character : c.system.details.level;
  }
  f(p, "getCharacterLevel");
  function m() {
    return Object.keys(c.classes ?? {}).length ? Object.values(c.classes ?? {}).map(
      (k) => `${k.name} (${k.classLevels})`,
      []
    ).join(" / ") : "";
  }
  f(m, "getLevelSource");
  const g = /* @__PURE__ */ f(() => c.toggleInspiration(), "click_handler"), h = /* @__PURE__ */ f(({ target: y }) => se(c, y.name, Number(y.value)), "change_handler"), _ = /* @__PURE__ */ f(({ target: y }) => se(c, y.name, Number(y.value)), "change_handler_1");
  return i.$$.update = () => {
    var y;
    i.$$.dirty & /*$actor*/
    1 && t(5, s = p()), i.$$.dirty & /*$actor*/
    1 && t(4, n = m()), i.$$.dirty & /*$actor*/
    1 && t(3, l = c.system.attributes.inspiration), i.$$.dirty & /*$actor*/
    1 && t(2, r = nle(c)), i.$$.dirty & /*$actor*/
    1 && t(7, o = ((y = c.flags.a5e) == null ? void 0 : y.sheetIsLocked) ?? !0), i.$$.dirty & /*$actor, sheetIsLocked*/
    129 && t(1, a = d());
  }, [
    c,
    a,
    r,
    l,
    n,
    s,
    u,
    o,
    g,
    h,
    _
  ];
}
f(ole, "instance$1U");
const dT = class dT extends ie {
  constructor(e) {
    super(), le(this, e, ole, ile, ne, {});
  }
};
f(dT, "CharacterShields");
let Kv = dT;
function YB(i) {
  var n, l, r, o;
  const e = parseFloat(((l = (n = i == null ? void 0 : i.system) == null ? void 0 : n.details) == null ? void 0 : l.cr) || 0);
  let t = 0;
  return e === 0.125 ? t = CONFIG.A5E.CR_EXP_LEVELS["1/8"] : e === 0.25 ? t = CONFIG.A5E.CR_EXP_LEVELS["1/4"] : e === 0.5 ? t = CONFIG.A5E.CR_EXP_LEVELS["1/2"] : t = CONFIG.A5E.CR_EXP_LEVELS[parseInt(e, 10) > 30 ? 30 : e], ((o = (r = i == null ? void 0 : i.system) == null ? void 0 : r.details) != null && o.elite ? t * 2 : t).toLocaleString();
}
f(YB, "prepareXP");
function VR(i) {
  let e, t, s, n, l, r, o, a;
  return {
    c() {
      e = E("div"), t = E("label"), s = x("Elite"), l = R(), r = E("i"), b(t, "class", "xp-label svelte-99uq6p"), b(t, "for", n = /*$actor*/
      i[0].id + "-elite"), b(r, "class", "fas fa-skull shield-elite svelte-99uq6p"), Q(r, "shield-elite--unlocked", !/*sheetIsLocked*/
      i[1]), Q(
        r,
        "shield-elite--active",
        /*isElite*/
        i[2]
      ), b(e, "class", "level-box svelte-99uq6p");
    },
    m(c, u) {
      T(c, e, u), A(e, t), A(t, s), A(e, l), A(e, r), o || (a = V(
        r,
        "click",
        /*click_handler*/
        i[7]
      ), o = !0);
    },
    p(c, u) {
      u & /*$actor*/
      1 && n !== (n = /*$actor*/
      c[0].id + "-elite") && b(t, "for", n), u & /*sheetIsLocked*/
      2 && Q(r, "shield-elite--unlocked", !/*sheetIsLocked*/
      c[1]), u & /*isElite*/
      4 && Q(
        r,
        "shield-elite--active",
        /*isElite*/
        c[2]
      );
    },
    d(c) {
      c && S(e), o = !1, a();
    }
  };
}
f(VR, "create_if_block$14");
function ale(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k, v, O, P, D, I, B, F, H, G, U, q = (
    /*isElite*/
    (i[2] || !/*sheetIsLocked*/
    i[1]) && VR(i)
  );
  return {
    c() {
      e = E("div"), q && q.c(), t = R(), s = E("div"), n = E("label"), l = x("CR"), o = R(), a = E("input"), u = R(), d = E("div"), p = E("label"), m = x("XP"), h = R(), _ = E("span"), y = x(
        /*xp*/
        i[3]
      ), k = R(), v = E("div"), O = E("label"), P = x("Prof."), I = R(), B = E("input"), b(n, "class", "xp-label svelte-99uq6p"), b(n, "for", r = /*$actor*/
      i[0].id + "-cr"), b(a, "id", c = /*$actor*/
      i[0].id + "-cr"), b(a, "class", "xp-input svelte-99uq6p"), b(a, "type", "text"), b(a, "name", "system.details.cr"), a.value = /*cr*/
      i[4], b(a, "placeholder", "0"), b(a, "min", "0"), a.disabled = /*sheetIsLocked*/
      i[1], b(s, "class", "level-box svelte-99uq6p"), b(p, "class", "xp-label svelte-99uq6p"), b(p, "for", g = /*$actor*/
      i[0].id + "-xp"), b(_, "class", "xp-input svelte-99uq6p"), b(
        _,
        "value",
        /*xp*/
        i[3]
      ), b(d, "class", "level-box svelte-99uq6p"), b(O, "class", "xp-label svelte-99uq6p"), b(O, "for", D = /*$actor*/
      i[0].id + "-prof"), b(B, "id", F = /*$actor*/
      i[0].id + "-prof"), b(B, "class", "xp-input svelte-99uq6p"), b(B, "type", "number"), B.value = H = /*$actor*/
      i[0].system.attributes.prof, b(B, "placeholder", "0"), b(B, "min", "0"), B.disabled = !0, b(v, "class", "level-box svelte-99uq6p"), b(e, "class", "level-container svelte-99uq6p");
    },
    m(W, X) {
      T(W, e, X), q && q.m(e, null), A(e, t), A(e, s), A(s, n), A(n, l), A(s, o), A(s, a), A(e, u), A(e, d), A(d, p), A(p, m), A(d, h), A(d, _), A(_, y), A(e, k), A(e, v), A(v, O), A(O, P), A(v, I), A(v, B), G || (U = [
        V(
          a,
          "change",
          /*change_handler*/
          i[8]
        ),
        V(
          a,
          "click",
          /*click_handler_1*/
          i[9]
        )
      ], G = !0);
    },
    p(W, [X]) {
      /*isElite*/
      W[2] || !/*sheetIsLocked*/
      W[1] ? q ? q.p(W, X) : (q = VR(W), q.c(), q.m(e, t)) : q && (q.d(1), q = null), X & /*$actor*/
      1 && r !== (r = /*$actor*/
      W[0].id + "-cr") && b(n, "for", r), X & /*$actor*/
      1 && c !== (c = /*$actor*/
      W[0].id + "-cr") && b(a, "id", c), X & /*cr*/
      16 && a.value !== /*cr*/
      W[4] && (a.value = /*cr*/
      W[4]), X & /*sheetIsLocked*/
      2 && (a.disabled = /*sheetIsLocked*/
      W[1]), X & /*$actor*/
      1 && g !== (g = /*$actor*/
      W[0].id + "-xp") && b(p, "for", g), X & /*xp*/
      8 && _e(
        y,
        /*xp*/
        W[3]
      ), X & /*xp*/
      8 && b(
        _,
        "value",
        /*xp*/
        W[3]
      ), X & /*$actor*/
      1 && D !== (D = /*$actor*/
      W[0].id + "-prof") && b(O, "for", D), X & /*$actor*/
      1 && F !== (F = /*$actor*/
      W[0].id + "-prof") && b(B, "id", F), X & /*$actor*/
      1 && H !== (H = /*$actor*/
      W[0].system.attributes.prof) && B.value !== H && (B.value = H);
    },
    i: ee,
    o: ee,
    d(W) {
      W && S(e), q && q.d(), G = !1, Ne(U);
    }
  };
}
f(ale, "create_fragment$20");
function cle(i, e, t) {
  let s, n, l, r, o;
  const a = fe("actor");
  pe(i, a, (g) => t(0, o = g));
  function c(g) {
    const { value: h } = g;
    let _;
    h === "1/2" ? _ = 0.5 : h === "1/4" ? _ = 0.25 : h === "1/8" ? _ = 0.125 : _ = parseInt(h, 10), isNaN(_) && (_ = o.system.details.cr), se(o, g.name, _);
  }
  f(c, "updateCr");
  function u(g) {
    return g === 0.5 ? "1/2" : g === 0.25 ? "1/4" : g === 0.125 ? "1/8" : g;
  }
  f(u, "displayCr");
  const d = /* @__PURE__ */ f(() => r ? null : o.toggleElite(), "click_handler"), p = /* @__PURE__ */ f(({ target: g }) => c(g), "change_handler"), m = /* @__PURE__ */ f(({ target: g }) => !r && g.select(), "click_handler_1");
  return i.$$.update = () => {
    var g;
    i.$$.dirty & /*$actor*/
    1 && t(4, s = u(o.system.details.cr)), i.$$.dirty & /*$actor*/
    1 && t(3, n = YB(o)), i.$$.dirty & /*$actor*/
    1 && t(2, l = o.system.details.elite), i.$$.dirty & /*$actor*/
    1 && t(1, r = ((g = o.flags.a5e) == null ? void 0 : g.sheetIsLocked) ?? !0);
  }, [
    o,
    r,
    l,
    n,
    s,
    a,
    c,
    d,
    p,
    m
  ];
}
f(cle, "instance$1T");
const pT = class pT extends ie {
  constructor(e) {
    super(), le(this, e, cle, ale, ne, {});
  }
};
f(pT, "NpcShields");
let Yv = pT;
function ule(i) {
  let e, t, s;
  return t = new Yv({}), {
    c() {
      e = E("section"), L(t.$$.fragment);
    },
    m(n, l) {
      T(n, e, l), N(t, e, null), s = !0;
    },
    i(n) {
      s || (w(t.$$.fragment, n), s = !0);
    },
    o(n) {
      C(t.$$.fragment, n), s = !1;
    },
    d(n) {
      n && S(e), j(t);
    }
  };
}
f(ule, "create_else_block$n");
function fle(i) {
  let e, t, s;
  return t = new Kv({}), {
    c() {
      e = E("section"), L(t.$$.fragment);
    },
    m(n, l) {
      T(n, e, l), N(t, e, null), s = !0;
    },
    i(n) {
      s || (w(t.$$.fragment, n), s = !0);
    },
    o(n) {
      C(t.$$.fragment, n), s = !1;
    },
    d(n) {
      n && S(e), j(t);
    }
  };
}
f(fle, "create_if_block$13");
function dle(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m;
  const g = [fle, ule], h = [];
  function _(y, k) {
    return (
      /*$actor*/
      y[0].type === "character" ? 0 : 1
    );
  }
  return f(_, "select_block_type"), o = _(i), a = h[o] = g[o](i), u = new Wv({}), {
    c() {
      e = E("header"), t = E("section"), s = E("section"), n = E("input"), r = R(), a.c(), c = R(), L(u.$$.fragment), b(n, "type", "text"), b(n, "name", "name"), n.value = l = /*$actor*/
      i[0].name, b(n, "class", "a5e-input a5e-input--character-name svelte-b6ggbk"), b(n, "placeholder", "Name"), b(n, "spellcheck", "false"), Q(n, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(s, "class", "sheet-header-top-left svelte-b6ggbk"), b(t, "class", "sheet-header-top svelte-b6ggbk"), b(e, "class", "sheet-header svelte-b6ggbk");
    },
    m(y, k) {
      T(y, e, k), A(e, t), A(t, s), A(s, n), A(t, r), h[o].m(t, null), A(e, c), N(u, e, null), d = !0, p || (m = V(
        n,
        "change",
        /*change_handler*/
        i[2]
      ), p = !0);
    },
    p(y, [k]) {
      (!d || k & /*$actor*/
      1 && l !== (l = /*$actor*/
      y[0].name) && n.value !== l) && (n.value = l), (!d || k & /*$actor*/
      1) && Q(n, "disable-pointer-events", !/*$actor*/
      y[0].isOwner);
      let v = o;
      o = _(y), o !== v && (ce(), C(h[v], 1, 1, () => {
        h[v] = null;
      }), ue(), a = h[o], a || (a = h[o] = g[o](y), a.c()), w(a, 1), a.m(t, null));
    },
    i(y) {
      d || (w(a), w(u.$$.fragment, y), d = !0);
    },
    o(y) {
      C(a), C(u.$$.fragment, y), d = !1;
    },
    d(y) {
      y && S(e), h[o].d(), j(u), p = !1, m();
    }
  };
}
f(dle, "create_fragment$1$");
function ple(i, e, t) {
  let s;
  const n = fe("actor");
  return pe(i, n, (r) => t(0, s = r)), [s, n, /* @__PURE__ */ f(({ target: r }) => se(s, r.name, r.value), "change_handler")];
}
f(ple, "instance$1S");
const mT = class mT extends ie {
  constructor(e) {
    super(), le(this, e, ple, dle, ne, {});
  }
};
f(mT, "ActorSheetHeader");
let Xv = mT;
function WR(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "fas fa-cog ac__config-button svelte-1j9qpb5"), b(e, "data-tooltip", "A5E.ArmorClassConfigurationTitle"), b(e, "data-tooltip-direction", "DOWN");
    },
    m(n, l) {
      T(n, e, l), t || (s = V(
        e,
        "click",
        /*click_handler*/
        i[4]
      ), t = !0);
    },
    p: ee,
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(WR, "create_if_block$12");
function mle(i) {
  let e, t, s, n, l, r, o, a, c, u = !/*sheetIsLocked*/
  i[2] && WR(i);
  return {
    c() {
      e = E("li"), t = E("h4"), t.textContent = "AC", s = R(), n = E("input"), r = R(), o = pn("svg"), a = pn("path"), c = R(), u && u.c(), b(t, "class", "ac-label svelte-1j9qpb5"), b(n, "class", "ac-value svelte-1j9qpb5"), b(n, "name", "system.attributes.ac.value"), b(n, "type", "number"), n.value = l = /*$actor*/
      i[0].system.attributes.ac.value, b(n, "placeholder", "10"), n.disabled = !0, b(
        n,
        "data-tooltip",
        /*acFormula*/
        i[1]
      ), b(n, "data-tooltip-direction", "UP"), b(a, "d", `M45,100C-2.6,79.3,0,12.6,0,12.6c0-2.2,1.8-4,4.4-4.6l39.1-7.9C44,0,44.5,0,45,0c0.5,0,1,0,1.4,0.1L85.5,8
                c2.6,0.5,4.4,2.4,4.4,4.6C90,12.6,92.6,79.3,45,100L45,100z`), b(o, "class", "ac-background svelte-1j9qpb5"), b(o, "version", "1.1"), b(o, "x", "0px"), b(o, "y", "0px"), b(o, "viewBox", "0 0 90 100"), b(o, "xml:space", "preserve"), b(e, "class", "ac-wrapper svelte-1j9qpb5");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(e, s), A(e, n), A(e, r), A(e, o), A(o, a), A(e, c), u && u.m(e, null);
    },
    p(d, [p]) {
      p & /*$actor*/
      1 && l !== (l = /*$actor*/
      d[0].system.attributes.ac.value) && n.value !== l && (n.value = l), p & /*acFormula*/
      2 && b(
        n,
        "data-tooltip",
        /*acFormula*/
        d[1]
      ), /*sheetIsLocked*/
      d[2] ? u && (u.d(1), u = null) : u ? u.p(d, p) : (u = WR(d), u.c(), u.m(e, null));
    },
    i: ee,
    o: ee,
    d(d) {
      d && S(e), u && u.d();
    }
  };
}
f(mle, "create_fragment$1_");
function hle(i, e, t) {
  let s, n, l;
  const r = fe("actor");
  pe(i, r, (a) => t(0, l = a));
  const o = /* @__PURE__ */ f(() => l.configureArmorClass(), "click_handler");
  return i.$$.update = () => {
    var a, c;
    i.$$.dirty & /*$actor*/
    1 && t(2, s = l.isOwner ? ((c = (a = l.flags) == null ? void 0 : a.a5e) == null ? void 0 : c.sheetIsLocked) ?? !0 : !0), i.$$.dirty & /*$actor*/
    1 && t(1, n = K9(l));
  }, [l, n, s, r, o];
}
f(hle, "instance$1R");
const hT = class hT extends ie {
  constructor(e) {
    super(), le(this, e, hle, mle, ne, {});
  }
};
f(hT, "ArmorClass");
let Jv = hT;
function gle(i) {
  return Object.values(i.system.attributes.hitDice).reduce(
    (e, { current: t }) => e + t,
    0
  );
}
f(gle, "computeTotalAvailableHitDice");
function ble(i) {
  let e, t, s, n, l, r, o, a, c;
  return {
    c() {
      e = E("li"), t = E("h4"), t.textContent = "Hit Dice", s = R(), n = E("div"), l = x(
        /*availableHitDice*/
        i[0]
      ), r = R(), o = pn("svg"), a = pn("g"), c = pn("path"), b(t, "class", "hit-die-label svelte-78m369"), b(n, "class", "hit-dice svelte-78m369"), b(n, "data-tooltip", "A5E.HitDiceRemaining"), b(n, "data-tooltip-direction", "DOWN"), b(c, "d", "M3250 11884 c-25 -2 -106 -11 -180 -20 -1485 -172 -2704 -1295 -3001 -2764 -133 -660 -67 -1507 171 -2223 252 -753 675 -1411 1397 -2172 342 -360 634 -630 1588 -1470 231 -203 488 -430 570 -505 1024 -920 1735 -1692 2346 -2547 l130 -183 132 0 132 1 130 192 c557 822 1212 1560 2185 2461 191 178 408 373 1027 923 956 852 1445 1343 1841 1850 643 825 968 1603 1064 2553 19 196 17 665 -5 835 -105 805 -441 1497 -998 2054 -557 557 -1250 894 -2054 998 -193 24 -613 24 -810 0 -733 -93 -1379 -387 -1920 -874 -191 -172 -406 -417 -535 -610 -30 -45 -57 -82 -60 -82 -3 0 -30 37 -60 82 -129 193 -344 438 -535 610 -531 478 -1170 773 -1878 867 -146 20 -562 34 -677 24z"), b(a, "transform", "translate(0.000000,1189.000000) scale(0.100000,-0.100000)"), b(a, "fill", "rgba(0, 0, 0, 0.15)"), b(a, "stroke", "none"), b(o, "class", "hit-dice-background svelte-78m369"), b(o, "xmlns", "http://www.w3.org/2000/svg"), b(o, "version", "1.0"), b(o, "viewBox", "0 0 1280.000000 1189.000000"), b(o, "preserveAspectRatio", "xMidYMid meet"), b(e, "class", "hit-dice-wrapper svelte-78m369");
    },
    m(u, d) {
      T(u, e, d), A(e, t), A(e, s), A(e, n), A(n, l), A(e, r), A(e, o), A(o, a), A(a, c);
    },
    p(u, [d]) {
      d & /*availableHitDice*/
      1 && _e(
        l,
        /*availableHitDice*/
        u[0]
      );
    },
    i: ee,
    o: ee,
    d(u) {
      u && S(e);
    }
  };
}
f(ble, "create_fragment$1Z");
function _le(i, e, t) {
  let s, n;
  const l = fe("actor");
  return pe(i, l, (r) => t(2, n = r)), i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    4 && t(0, s = gle(n));
  }, [s, l, n];
}
f(_le, "instance$1Q");
const gT = class gT extends ie {
  constructor(e) {
    super(), le(this, e, _le, ble, ne, {});
  }
};
f(gT, "HitDice");
let Zv = gT;
function yle(i) {
  let e, t;
  const s = (
    /*#slots*/
    i[4].default
  ), n = Pt(
    s,
    i,
    /*$$scope*/
    i[3],
    null
  );
  return {
    c() {
      e = E("div"), n && n.c(), b(e, "class", "hp-bar svelte-192qrfs"), z(
        e,
        "--primary-hp-percentage",
        /*hpPrimaryPercentage*/
        i[1]
      ), z(
        e,
        "--temp-hp-percentage",
        /*hpTempPercentage*/
        i[0]
      ), z(e, "--secondary-bar-color", "#2FA6B1");
    },
    m(l, r) {
      T(l, e, r), n && n.m(e, null), t = !0;
    },
    p(l, [r]) {
      n && n.p && (!t || r & /*$$scope*/
      8) && Rt(
        n,
        s,
        l,
        /*$$scope*/
        l[3],
        t ? Mt(
          s,
          /*$$scope*/
          l[3],
          r,
          null
        ) : Ft(
          /*$$scope*/
          l[3]
        ),
        null
      ), (!t || r & /*hpPrimaryPercentage*/
      2) && z(
        e,
        "--primary-hp-percentage",
        /*hpPrimaryPercentage*/
        l[1]
      ), (!t || r & /*hpTempPercentage*/
      1) && z(
        e,
        "--temp-hp-percentage",
        /*hpTempPercentage*/
        l[0]
      );
    },
    i(l) {
      t || (w(n, l), t = !0);
    },
    o(l) {
      C(n, l), t = !1;
    },
    d(l) {
      l && S(e), n && n.d(l);
    }
  };
}
f(yle, "create_fragment$1Y");
function vle(i, e, t) {
  let s, n, { $$slots: l = {}, $$scope: r } = e, { hp: o } = e;
  return i.$$set = (a) => {
    "hp" in a && t(2, o = a.hp), "$$scope" in a && t(3, r = a.$$scope);
  }, i.$$.update = () => {
    i.$$.dirty & /*hp*/
    4 && t(1, s = Math.floor(Math.min(o.value / o.max * 100, 100))), i.$$.dirty & /*hp*/
    4 && t(0, n = Math.min((o.temp || 0) / o.max * 100, 100));
  }, [n, s, o, r, l];
}
f(vle, "instance$1P");
const bT = class bT extends ie {
  constructor(e) {
    super(), le(this, e, vle, yle, ne, { hp: 2 });
  }
};
f(bT, "HitPointBar");
let Qv = bT;
function KR(i, e, t) {
  const s = i.slice();
  return s[7] = e[t].key, s[8] = e[t].label, s[9] = e[t].value, s;
}
f(KR, "get_each_context$G");
function kle(i) {
  let e, t, s, n, l = K("A5E.HitPointsConfigurationTooltip") + "", r, o, a;
  return {
    c() {
      e = E("div"), t = E("button"), s = E("i"), n = R(), r = x(l), b(s, "class", "fas fa-gear"), b(t, "class", "a5e-button svelte-pvlm90"), b(e, "class", "hp-config__container svelte-pvlm90");
    },
    m(c, u) {
      T(c, e, u), A(e, t), A(t, s), A(t, n), A(t, r), o || (a = V(
        t,
        "click",
        /*click_handler_1*/
        i[6]
      ), o = !0);
    },
    p: ee,
    d(c) {
      c && S(e), o = !1, a();
    }
  };
}
f(kle, "create_else_block$m");
function wle(i) {
  let e, t = oe(
    /*hpFields*/
    i[0]
  ), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = YR(KR(i, t, n));
  return {
    c() {
      e = E("div");
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      b(e, "class", "hp-container svelte-pvlm90");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l & /*$actor, hpFields, Number*/
      3) {
        t = oe(
          /*hpFields*/
          n[0]
        );
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = KR(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = YR(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && S(e), Le(s, n);
    }
  };
}
f(wle, "create_if_block$11");
function YR(i) {
  let e, t, s = (
    /*label*/
    i[8] + ""
  ), n, l, r, o, a, c, u, d, p, m, g, h;
  return {
    c() {
      e = E("div"), t = E("label"), n = x(s), r = R(), o = E("input"), m = R(), b(t, "class", "hp-label svelte-pvlm90"), b(t, "for", l = /*$actor*/
      i[1].id + "-hp-" + /*key*/
      i[7]), b(o, "id", a = /*$actor*/
      i[1].id + "-hp-" + /*key*/
      i[7]), b(o, "class", "hp-input svelte-pvlm90"), b(o, "type", "number"), b(o, "name", c = "system.attributes.hp." + /*key*/
      i[7]), o.value = u = /*value*/
      i[9], b(o, "placeholder", "0"), b(o, "min", d = /*key*/
      i[7] !== "bonus" ? 0 : ""), o.disabled = p = /*key*/
      i[7] === "max", Q(o, "disable-pointer-events", !/*$actor*/
      i[1].isOwner), b(e, "class", "hp-box svelte-pvlm90");
    },
    m(_, y) {
      T(_, e, y), A(e, t), A(t, n), A(e, r), A(e, o), A(e, m), g || (h = [
        V(
          o,
          "change",
          /*change_handler*/
          i[5]
        ),
        V(o, "click", Ale)
      ], g = !0);
    },
    p(_, y) {
      y & /*hpFields*/
      1 && s !== (s = /*label*/
      _[8] + "") && _e(n, s), y & /*$actor, hpFields*/
      3 && l !== (l = /*$actor*/
      _[1].id + "-hp-" + /*key*/
      _[7]) && b(t, "for", l), y & /*$actor, hpFields*/
      3 && a !== (a = /*$actor*/
      _[1].id + "-hp-" + /*key*/
      _[7]) && b(o, "id", a), y & /*hpFields*/
      1 && c !== (c = "system.attributes.hp." + /*key*/
      _[7]) && b(o, "name", c), y & /*hpFields*/
      1 && u !== (u = /*value*/
      _[9]) && o.value !== u && (o.value = u), y & /*hpFields*/
      1 && d !== (d = /*key*/
      _[7] !== "bonus" ? 0 : "") && b(o, "min", d), y & /*hpFields*/
      1 && p !== (p = /*key*/
      _[7] === "max") && (o.disabled = p), y & /*$actor*/
      2 && Q(o, "disable-pointer-events", !/*$actor*/
      _[1].isOwner);
    },
    d(_) {
      _ && S(e), g = !1, Ne(h);
    }
  };
}
f(YR, "create_each_block$G");
function $le(i) {
  let e;
  function t(l, r) {
    return (
      /*sheetIsLocked*/
      l[2] ? wle : kle
    );
  }
  f(t, "select_block_type");
  let s = t(i), n = s(i);
  return {
    c() {
      n.c(), e = $e();
    },
    m(l, r) {
      n.m(l, r), T(l, e, r);
    },
    p(l, [r]) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e.parentNode, e)));
    },
    i: ee,
    o: ee,
    d(l) {
      l && S(e), n.d(l);
    }
  };
}
f($le, "create_fragment$1X");
const Ale = /* @__PURE__ */ f(({ target: i }) => i.select(), "click_handler");
function Ele(i, e, t) {
  let s, n, { hp: l } = e, { hpFields: r } = e;
  const o = fe("actor");
  pe(i, o, (u) => t(1, n = u));
  const a = /* @__PURE__ */ f(({ target: u }) => se(n, u.name, Number(u.value)), "change_handler"), c = /* @__PURE__ */ f(() => n.configureHealth(), "click_handler_1");
  return i.$$set = (u) => {
    "hp" in u && t(4, l = u.hp), "hpFields" in u && t(0, r = u.hpFields);
  }, i.$$.update = () => {
    var u, d;
    i.$$.dirty & /*hp*/
    16 && t(0, r = [
      {
        key: "temp",
        label: "Temp. HP",
        value: l.temp
      },
      {
        key: "value",
        label: "Curr. HP",
        value: l.value
      },
      {
        key: "max",
        label: "Max HP",
        value: l.max
      },
      {
        key: "bonus",
        label: "Bonus HP",
        value: l.bonus
      }
    ]), i.$$.dirty & /*$actor*/
    2 && t(2, s = n.isOwner ? ((d = (u = n.flags) == null ? void 0 : u.a5e) == null ? void 0 : d.sheetIsLocked) ?? !0 : !0);
  }, [r, n, s, o, l, a, c];
}
f(Ele, "instance$1O");
const _T = class _T extends ie {
  constructor(e) {
    super(), le(this, e, Ele, $le, ne, { hp: 4, hpFields: 0 });
  }
};
f(_T, "HitPointValues");
let xv = _T;
function Sle(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "initiative-roll-button fas fa-cog svelte-1ndmmcr"), b(e, "data-tooltip", "A5E.InitiativeConfigurationTitle"), b(e, "data-tooltip-direction", "DOWN");
    },
    m(n, l) {
      T(n, e, l), t || (s = V(
        e,
        "click",
        /*click_handler_1*/
        i[6]
      ), t = !0);
    },
    p: ee,
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(Sle, "create_else_block$l");
function Tle(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "initiative-roll-button fas fa-dice-d20 svelte-1ndmmcr"), b(e, "data-tooltip", "A5E.RollInitiative"), b(e, "data-tooltip-direction", "DOWN"), Q(
        e,
        "initiative-roll-button--shift",
        /*$pressedKeysStore*/
        i[2].Shift
      ), Q(
        e,
        "initiative-roll-button--ctrl",
        /*$pressedKeysStore*/
        i[2].Control
      ), Q(e, "disable-pointer-events", !/*$actor*/
      i[0].isOwner);
    },
    m(n, l) {
      T(n, e, l), t || (s = V(
        e,
        "click",
        /*click_handler*/
        i[5]
      ), t = !0);
    },
    p(n, l) {
      l & /*$pressedKeysStore*/
      4 && Q(
        e,
        "initiative-roll-button--shift",
        /*$pressedKeysStore*/
        n[2].Shift
      ), l & /*$pressedKeysStore*/
      4 && Q(
        e,
        "initiative-roll-button--ctrl",
        /*$pressedKeysStore*/
        n[2].Control
      ), l & /*$actor*/
      1 && Q(e, "disable-pointer-events", !/*$actor*/
      n[0].isOwner);
    },
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(Tle, "create_if_block$10");
function Cle(i) {
  let e, t, s;
  function n(o, a) {
    return (
      /*sheetIsLocked*/
      o[1] ? Tle : Sle
    );
  }
  f(n, "select_block_type");
  let l = n(i), r = l(i);
  return {
    c() {
      e = E("li"), t = E("h4"), t.textContent = "Initiative", s = R(), r.c(), b(t, "class", "initiative-label svelte-1ndmmcr");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(e, s), r.m(e, null);
    },
    p(o, [a]) {
      l === (l = n(o)) && r ? r.p(o, a) : (r.d(1), r = l(o), r && (r.c(), r.m(e, null)));
    },
    i: ee,
    o: ee,
    d(o) {
      o && S(e), r.d();
    }
  };
}
f(Cle, "create_fragment$1W");
function Ole(i, e, t) {
  let s, n, l;
  pe(i, Mi, (p) => t(2, l = p));
  const r = fe("actor");
  pe(i, r, (p) => t(0, n = p));
  const { settings: o } = game;
  function a() {
    const p = Bi(l, {
      reverseAlt: o.get("a5e", "reverseInitiativeAltBehavior")
    });
    return p.expertiseDie = n.RollOverrideManager.getExpertiseDice("initiative", p.expertiseDie ?? 0, { ability: c }), p.rollMode = n.RollOverrideManager.getRollOverride("initiative", p.rollMode, { ability: c }), p;
  }
  f(a, "getRollOptions");
  let c = n.system.attributes.initiative.ability ?? "dex";
  const u = /* @__PURE__ */ f(() => n.rollInitiative({
    createCombatants: !0,
    initiativeOptions: { rollOptions: a() }
  }), "click_handler"), d = /* @__PURE__ */ f(() => n.configureInitiative(), "click_handler_1");
  return i.$$.update = () => {
    var p, m;
    i.$$.dirty & /*$actor*/
    1 && t(1, s = n.isOwner ? ((m = (p = n.flags) == null ? void 0 : p.a5e) == null ? void 0 : m.sheetIsLocked) ?? !0 : !0);
  }, [
    n,
    s,
    l,
    r,
    a,
    u,
    d
  ];
}
f(Ole, "instance$1N");
const yT = class yT extends ie {
  constructor(e) {
    super(), le(this, e, Ole, Cle, ne, {});
  }
};
f(yT, "Initiative");
let ek = yT;
function XR(i, e, t) {
  const s = i.slice();
  return s[3] = e[t].label, s[4] = e[t].value, s;
}
f(XR, "get_each_context$F");
function JR(i) {
  let e, t, s = K(
    /*label*/
    i[3]
  ) + "", n, l, r, o = (
    /*value*/
    i[4] + ""
  ), a, c;
  return {
    c() {
      e = E("div"), t = E("h4"), n = x(s), l = R(), r = E("div"), a = x(o), c = R(), b(t, "class", "passive-label svelte-19ofer7"), b(r, "class", "passive-value svelte-19ofer7"), b(e, "class", "passive-box svelte-19ofer7");
    },
    m(u, d) {
      T(u, e, d), A(e, t), A(t, n), A(e, l), A(e, r), A(r, a), A(e, c);
    },
    p(u, d) {
      d & /*passiveFields*/
      1 && s !== (s = K(
        /*label*/
        u[3]
      ) + "") && _e(n, s), d & /*passiveFields*/
      1 && o !== (o = /*value*/
      u[4] + "") && _e(a, o);
    },
    d(u) {
      u && S(e);
    }
  };
}
f(JR, "create_each_block$F");
function Dle(i) {
  let e, t = oe(
    /*passiveFields*/
    i[0]
  ), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = JR(XR(i, t, n));
  return {
    c() {
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      e = $e();
    },
    m(n, l) {
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(n, l);
      T(n, e, l);
    },
    p(n, [l]) {
      if (l & /*passiveFields*/
      1) {
        t = oe(
          /*passiveFields*/
          n[0]
        );
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = XR(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = JR(o), s[r].c(), s[r].m(e.parentNode, e));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    i: ee,
    o: ee,
    d(n) {
      n && S(e), Le(s, n);
    }
  };
}
f(Dle, "create_fragment$1V");
function Ile(i, e, t) {
  let s, { passiveFields: n } = e;
  const l = fe("actor");
  return pe(i, l, (r) => t(2, s = r)), i.$$set = (r) => {
    "passiveFields" in r && t(0, n = r.passiveFields);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    4 && t(0, n = [
      {
        label: "A5E.ManeuverDC",
        value: s.system.attributes.maneuverDC
      },
      {
        label: "A5E.SpellDC",
        value: s.system.attributes.spellDC
      },
      {
        label: "Passive Percep.",
        value: s.system.skills.prc.passive
      }
    ]);
  }, [n, l, s];
}
f(Ile, "instance$1M");
const vT = class vT extends ie {
  constructor(e) {
    super(), le(this, e, Ile, Dle, ne, { passiveFields: 0 });
  }
};
f(vT, "Passives");
let tk = vT;
function Ple(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("div"), t = E("i"), b(t, "class", "rest__icon fas fa-campfire svelte-1aczzd1"), Q(t, "disable-pointer-events", !/*$actor*/
      i[0].isOwner), b(e, "class", "rest svelte-1aczzd1"), b(e, "data-tooltip", "A5E.Rest"), b(e, "data-tooltip-direction", "DOWN"), Q(
        e,
        "rest--5e",
        /*replaceFatigueAndStrife*/
        i[2]
      ), Q(e, "disable-pointer-events", !/*$actor*/
      i[0].isOwner);
    },
    m(l, r) {
      T(l, e, r), A(e, t), s || (n = V(
        t,
        "click",
        /*click_handler*/
        i[3]
      ), s = !0);
    },
    p(l, [r]) {
      r & /*$actor*/
      1 && Q(t, "disable-pointer-events", !/*$actor*/
      l[0].isOwner), r & /*$actor*/
      1 && Q(e, "disable-pointer-events", !/*$actor*/
      l[0].isOwner);
    },
    i: ee,
    o: ee,
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Ple, "create_fragment$1U");
function Mle(i, e, t) {
  let s;
  const n = fe("actor");
  pe(i, n, (o) => t(0, s = o));
  let l = game.settings.get("a5e", "replaceFatigueAndStrife");
  return [s, n, l, /* @__PURE__ */ f(() => s.triggerRest(), "click_handler")];
}
f(Mle, "instance$1L");
const kT = class kT extends ie {
  constructor(e) {
    super(), le(this, e, Mle, Ple, ne, {});
  }
};
f(kT, "RestButton");
let sk = kT;
function ZR(i, e, t) {
  const s = i.slice();
  return s[10] = e[t].value, s[11] = e[t].hint, s;
}
f(ZR, "get_each_context$E");
function QR(i) {
  let e, t, s = (
    /*value*/
    i[10] + ""
  ), n, l, r, o, a, c;
  function u() {
    return (
      /*click_handler*/
      i[9](
        /*value*/
        i[10]
      )
    );
  }
  return f(u, "click_handler"), {
    c() {
      e = E("li"), t = E("button"), n = x(s), r = R(), b(t, "class", "track-item svelte-bsulr3"), b(t, "data-degree", l = /*value*/
      i[10]), Q(
        t,
        "track-item-selected",
        /*value*/
        i[10] === /*selectedOption*/
        i[4]
      ), Q(t, "disable-pointer-events", !/*$actor*/
      i[5].isOwner), b(e, "data-tooltip", o = /*hint*/
      i[11] || null), b(e, "data-tooltip-direction", "DOWN");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(t, n), A(e, r), a || (c = V(t, "click", u), a = !0);
    },
    p(d, p) {
      i = d, p & /*options*/
      8 && s !== (s = /*value*/
      i[10] + "") && _e(n, s), p & /*options*/
      8 && l !== (l = /*value*/
      i[10]) && b(t, "data-degree", l), p & /*options, selectedOption*/
      24 && Q(
        t,
        "track-item-selected",
        /*value*/
        i[10] === /*selectedOption*/
        i[4]
      ), p & /*$actor*/
      32 && Q(t, "disable-pointer-events", !/*$actor*/
      i[5].isOwner), p & /*options*/
      8 && o !== (o = /*hint*/
      i[11] || null) && b(e, "data-tooltip", o);
    },
    d(d) {
      d && S(e), a = !1, c();
    }
  };
}
f(QR, "create_each_block$E");
function Rle(i) {
  let e, t, s, n, l, r, o = oe(
    /*options*/
    i[3]
  ), a = [];
  for (let c = 0; c < o.length; c += 1)
    a[c] = QR(ZR(i, o, c));
  return {
    c() {
      e = E("div"), t = E("i"), n = R(), l = E("ul");
      for (let c = 0; c < a.length; c += 1)
        a[c].c();
      b(t, "class", s = "track-icon fas " + /*icon*/
      i[0] + " track-icon-level-" + /*selectedOption*/
      i[4] + " svelte-bsulr3"), b(l, "class", "track-items svelte-bsulr3"), b(e, "class", r = "track track--" + /*trackProperty*/
      i[2] + " svelte-bsulr3"), b(
        e,
        "data-tooltip",
        /*tooltipText*/
        i[1]
      ), b(e, "data-tooltip-direction", "DOWN"), Q(
        e,
        "track--5e",
        /*replaceFatigueAndStrife*/
        i[8]
      );
    },
    m(c, u) {
      T(c, e, u), A(e, t), A(e, n), A(e, l);
      for (let d = 0; d < a.length; d += 1)
        a[d] && a[d].m(l, null);
    },
    p(c, [u]) {
      if (u & /*icon, selectedOption*/
      17 && s !== (s = "track-icon fas " + /*icon*/
      c[0] + " track-icon-level-" + /*selectedOption*/
      c[4] + " svelte-bsulr3") && b(t, "class", s), u & /*options, selectedOption, $actor, handleStatusEffectChange*/
      120) {
        o = oe(
          /*options*/
          c[3]
        );
        let d;
        for (d = 0; d < o.length; d += 1) {
          const p = ZR(c, o, d);
          a[d] ? a[d].p(p, u) : (a[d] = QR(p), a[d].c(), a[d].m(l, null));
        }
        for (; d < a.length; d += 1)
          a[d].d(1);
        a.length = o.length;
      }
      u & /*trackProperty*/
      4 && r !== (r = "track track--" + /*trackProperty*/
      c[2] + " svelte-bsulr3") && b(e, "class", r), u & /*tooltipText*/
      2 && b(
        e,
        "data-tooltip",
        /*tooltipText*/
        c[1]
      ), u & /*trackProperty, replaceFatigueAndStrife*/
      260 && Q(
        e,
        "track--5e",
        /*replaceFatigueAndStrife*/
        c[8]
      );
    },
    i: ee,
    o: ee,
    d(c) {
      c && S(e), Le(a, c);
    }
  };
}
f(Rle, "create_fragment$1T");
function Fle(i, e, t) {
  let s, { icon: n } = e, { tooltipText: l } = e, { trackProperty: r } = e, { options: o } = e, { selectedOption: a } = e;
  function c(m) {
    se(s, `system.attributes.${r}`, m);
  }
  f(c, "handleStatusEffectChange");
  const u = fe("actor");
  pe(i, u, (m) => t(5, s = m));
  let d = game.settings.get("a5e", "replaceFatigueAndStrife");
  const p = /* @__PURE__ */ f((m) => c(m), "click_handler");
  return i.$$set = (m) => {
    "icon" in m && t(0, n = m.icon), "tooltipText" in m && t(1, l = m.tooltipText), "trackProperty" in m && t(2, r = m.trackProperty), "options" in m && t(3, o = m.options), "selectedOption" in m && t(4, a = m.selectedOption);
  }, [
    n,
    l,
    r,
    o,
    a,
    s,
    c,
    u,
    d,
    p
  ];
}
f(Fle, "instance$1K");
const wT = class wT extends ie {
  constructor(e) {
    super(), le(this, e, Fle, Rle, ne, {
      icon: 0,
      tooltipText: 1,
      trackProperty: 2,
      options: 3,
      selectedOption: 4
    });
  }
};
f(wT, "StatusTrack");
let ap = wT;
function Nle(i) {
  var t;
  return ((t = i.system.traits.alignment) == null ? void 0 : t.sort(
    (s, n) => s.toLowerCase().localeCompare(n.toLowerCase())
  )).map(
    (s) => K(CONFIG.A5E.alignments[s] ?? s)
  );
}
f(Nle, "prepareAlignment");
function jle(i) {
  const e = i.system.proficiencies.armor.map((t) => game.i18n.localize(t === "shield" ? "A5E.ArmorShieldPlural" : CONFIG.A5E.armor[t] ?? t));
  return e.sort((t, s) => t.toLowerCase().localeCompare(s.toLowerCase())), e;
}
f(jle, "getArmorProficiencies");
function Lle(i) {
  const e = i.system.traits.conditionImmunities.map((t) => game.i18n.localize(CONFIG.A5E.conditions[t]) ?? t);
  return e.sort((t, s) => t.toLowerCase().localeCompare(s.toLowerCase())), e;
}
f(Lle, "prepareConditionImmunities");
function Ble(i) {
  return i.type !== "npc" ? [] : i.system.details.terrain.sort(
    (t, s) => t.toLowerCase().localeCompare(s.toLowerCase())
  ).map(
    (t) => K(CONFIG.A5E.terrainTypes[t] ?? t)
  );
}
f(Ble, "prepareCreatureTerrains");
function qle(i) {
  const t = i.system.details.creatureTypes.sort(
    (s, n) => s.toLowerCase().localeCompare(n.toLowerCase())
  ).map(
    (s) => K(CONFIG.A5E.creatureTypes[s] ?? s)
  );
  return i.system.details.isSquad && t.push(K("Squad")), i.system.details.isSwarm && t.push(K("A5E.CreatureSwarm")), t;
}
f(qle, "prepareCreatureTypes");
function Gle(i) {
  return [CONFIG.A5E.actorSizes[i.system.traits.size]].map((e) => game.i18n.localize(e));
}
f(Gle, "prepareCreatureSize");
function zle(i) {
  const e = i.system.traits.damageImmunities.map((t) => game.i18n.localize(CONFIG.A5E.damageTypes[t]) ?? t);
  return e.sort((t, s) => t.toLowerCase().localeCompare(s.toLowerCase())), e;
}
f(zle, "prepareDamageImmunities");
function Hle(i) {
  const e = i.system.traits.damageResistances.map((t) => game.i18n.localize(CONFIG.A5E.damageTypes[t]) ?? t);
  return e.sort((t, s) => t.toLowerCase().localeCompare(s.toLowerCase())), e;
}
f(Hle, "prepareDamageResistances");
function Ule(i) {
  const e = i.system.traits.damageVulnerabilities.map((t) => game.i18n.localize(CONFIG.A5E.damageTypes[t]) ?? t);
  return e.sort((t, s) => t.toLowerCase().localeCompare(s.toLowerCase())), e;
}
f(Ule, "prepareDamageVulnerabilities");
function Vle(i) {
  const e = i.system.proficiencies.languages.map((t) => game.i18n.localize(CONFIG.A5E.languages[t]) ?? t);
  return e.sort((t, s) => t.toLowerCase().localeCompare(s.toLowerCase())), e;
}
f(Vle, "getLanguageProficiencies");
function Wle(i) {
  if (i.type !== "character")
    return [];
  const e = (i.system.proficiencies.traditions ?? []).map((t) => game.i18n.localize(CONFIG.A5E.maneuverTraditions[t]) ?? t);
  return e.sort((t, s) => t.toLowerCase().localeCompare(s.toLowerCase())), e;
}
f(Wle, "prepareManeuverTraditions");
function Kle(i) {
  return Object.entries(
    i.system.attributes.senses
  ).filter(
    ([t, s]) => t === "blindsight" && s.otherwiseBlind || s.distance || s.unit === "unlimited"
  ).map(([t, s]) => {
    const n = game.i18n.localize(CONFIG.A5E.senses[t]), l = game.i18n.localize(CONFIG.A5E.distanceAbbreviations[s.unit]);
    if (t === "blindsight" && s.otherwiseBlind)
      return `${n} - ${s.distance} ${l || "ft."} (Blind Beyond)`;
    if (s.unit === "unlimited") {
      const r = game.i18n.localize(CONFIG.A5E.visionUnits.unlimited);
      return `${n} - ${r}`;
    }
    return `${n} - ${s.distance} ${l || "ft."}`;
  });
}
f(Kle, "prepareSenses");
function Yle(i) {
  var n, l;
  const e = (l = (n = i.system.attributes.movement) == null ? void 0 : n.traits) == null ? void 0 : l.hover, t = Object.entries(i.system.attributes.movement).filter(
    ([r, o]) => r === "fly" && e ? !0 : r === "traits" || o.distance === 0 ? !1 : o
  ), s = game.i18n.localize("A5E.MovementHover");
  return t.map(([r, o]) => {
    const a = game.i18n.localize(CONFIG.A5E.movement[r]), c = game.i18n.localize(CONFIG.A5E.distanceAbbreviations[o.unit]);
    return r === "fly" && e ? `${a} - ${o.distance || 0} ${c} (${s.toLocaleLowerCase()})` : `${a} - ${o.distance} ${c || "ft."}`;
  });
}
f(Yle, "getMovementData");
function Xle(i) {
  const e = i.system.proficiencies.tools.reduce((t, s) => {
    let n;
    for (const l of ["artisansTools", "gamingSets", "musicalInstruments", "miscellaneous", "vehicles"])
      if (CONFIG.A5E.toolsPlural[l][s]) {
        n = game.i18n.localize(CONFIG.A5E.toolsPlural[l][s]);
        break;
      }
    return t.push(n || s), t;
  }, []);
  return e.sort((t, s) => t.toLowerCase().localeCompare(s.toLowerCase())), e;
}
f(Xle, "getToolProficiencies");
function Jle(i) {
  const e = i.system.proficiencies.weapons.reduce(
    (s, n) => (Object.keys(CONFIG.A5E.weaponsPlural.martial).includes(n) ? s.martial.push(n) : Object.keys(CONFIG.A5E.weaponsPlural.simple).includes(n) ? s.simple.push(n) : Object.keys(CONFIG.A5E.weaponsPlural.rare).includes(n) ? s.rare.push(n) : s.other.push(n), s),
    {
      simple: [],
      martial: [],
      rare: [],
      other: []
    }
  );
  ["simple", "martial", "rare"].forEach((s) => {
    const n = Object.keys(CONFIG.A5E.weaponsPlural[s]);
    Sc(n, e[s]) ? e[s] = [game.i18n.localize(
      `A5E.Weapons${s[0].toUpperCase() + s.slice(1)}`
    )] : e[s] = e[s].map(
      (l) => game.i18n.localize(CONFIG.A5E.weaponsPlural[s][l])
    );
  });
  const t = Object.values(e).flat();
  return t.sort((s, n) => s.toLowerCase().localeCompare(n.toLowerCase())), t;
}
f(Jle, "getWeaponProficiencies");
function xR(i, e, t) {
  const s = i.slice();
  return s[6] = e[t].dialogMethod, s[7] = e[t].display, s[8] = e[t].heading, s[9] = e[t].propertyKey, s[10] = e[t].tooltip, s[11] = e[t].values, s;
}
f(xR, "get_each_context$D");
function eF(i, e, t) {
  const s = i.slice();
  return s[14] = e[t], s;
}
f(eF, "get_each_context_1$7");
function tF(i) {
  let e, t, s;
  function n() {
    return (
      /*func*/
      i[5](
        /*dialogMethod*/
        i[6],
        /*propertyKey*/
        i[9]
      )
    );
  }
  return f(n, "func"), e = new de({
    props: {
      heading: (
        /*heading*/
        i[8]
      ),
      buttons: [
        {
          classes: "fa-solid fa-gear a5e-field-wrapper__header-button--scale",
          display: !/*sheetIsLocked*/
          i[0],
          handler: n,
          tooltip: (
            /*tooltip*/
            i[10]
          )
        }
      ],
      $$slots: { default: [Zle] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-heading-weight", "400"), z(t, "--a5e-header-button-color", "rgba(0, 0, 0, 0.2)"), z(t, "--a5e-header-button-color-hover", "#555");
    },
    m(l, r) {
      T(l, t, r), N(e, t, null), s = !0;
    },
    p(l, r) {
      i = l;
      const o = {};
      r & /*details*/
      2 && (o.heading = /*heading*/
      i[8]), r & /*sheetIsLocked, details*/
      3 && (o.buttons = [
        {
          classes: "fa-solid fa-gear a5e-field-wrapper__header-button--scale",
          display: !/*sheetIsLocked*/
          i[0],
          handler: n,
          tooltip: (
            /*tooltip*/
            i[10]
          )
        }
      ]), r & /*$$scope, details*/
      131074 && (o.$$scope = { dirty: r, ctx: i }), e.$set(o);
    },
    i(l) {
      s || (w(e.$$.fragment, l), s = !0);
    },
    o(l) {
      C(e.$$.fragment, l), s = !1;
    },
    d(l) {
      l && e && S(t), j(e, l);
    }
  };
}
f(tF, "create_if_block$$");
function sF(i) {
  let e, t;
  return e = new Cr({
    props: {
      label: (
        /*tag*/
        i[14]
      ),
      value: (
        /*tag*/
        i[14]
      ),
      tight: !0,
      optionStyles: `
                            color: black;
                            background-color: rgba(0 0 0 / 0.05);
                            max-width: 98%;
                            border: 1px solid #ccc;
                        `,
      disabled: !0
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*details*/
      2 && (l.label = /*tag*/
      s[14]), n & /*details*/
      2 && (l.value = /*tag*/
      s[14]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(sF, "create_each_block_1$7");
function Zle(i) {
  let e, t, s, n = oe(
    /*values*/
    i[11]
  ), l = [];
  for (let o = 0; o < n.length; o += 1)
    l[o] = sF(eF(i, n, o));
  const r = /* @__PURE__ */ f((o) => C(l[o], 1, 1, () => {
    l[o] = null;
  }), "out");
  return {
    c() {
      e = E("ul");
      for (let o = 0; o < l.length; o += 1)
        l[o].c();
      t = R(), b(e, "class", "details-list svelte-1mz5oo");
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < l.length; c += 1)
        l[c] && l[c].m(e, null);
      T(o, t, a), s = !0;
    },
    p(o, a) {
      if (a & /*details*/
      2) {
        n = oe(
          /*values*/
          o[11]
        );
        let c;
        for (c = 0; c < n.length; c += 1) {
          const u = eF(o, n, c);
          l[c] ? (l[c].p(u, a), w(l[c], 1)) : (l[c] = sF(u), l[c].c(), w(l[c], 1), l[c].m(e, null));
        }
        for (ce(), c = n.length; c < l.length; c += 1)
          r(c);
        ue();
      }
    },
    i(o) {
      if (!s) {
        for (let a = 0; a < n.length; a += 1)
          w(l[a]);
        s = !0;
      }
    },
    o(o) {
      l = l.filter(Boolean);
      for (let a = 0; a < l.length; a += 1)
        C(l[a]);
      s = !1;
    },
    d(o) {
      o && (S(e), S(t)), Le(l, o);
    }
  };
}
f(Zle, "create_default_slot$P");
function nF(i) {
  let e, t, s = (
    /*values*/
    (i[11].length || !/*sheetIsLocked*/
    i[0]) && /*display*/
    (i[7] ?? !0) && tF(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*values*/
      (n[11].length || !/*sheetIsLocked*/
      n[0]) && /*display*/
      (n[7] ?? !0) ? s ? (s.p(n, l), l & /*details, sheetIsLocked*/
      3 && w(s, 1)) : (s = tF(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ce(), C(s, 1, 1, () => {
        s = null;
      }), ue());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f(nF, "create_each_block$D");
function Qle(i) {
  let e, t, s = oe(
    /*details*/
    i[1]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = nF(xR(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, [o]) {
      if (o & /*details, sheetIsLocked, openConfig*/
      11) {
        s = oe(
          /*details*/
          r[1]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = xR(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = nF(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f(Qle, "create_fragment$1S");
function xle(i, e, t) {
  let s, n, l;
  const r = fe("actor");
  pe(i, r, (c) => t(4, l = c));
  function o(c, u) {
    if (!no(l, u))
      return l[c]({ propertyKey: u });
    ui.notifications.warn(K("A5E.validations.warnings.modifiedByEffect"));
  }
  f(o, "openConfig");
  const a = /* @__PURE__ */ f((c, u) => o(c, u), "func");
  return i.$$.update = () => {
    var c, u;
    i.$$.dirty & /*$actor*/
    16 && t(1, s = [
      {
        heading: K("A5E.Movement"),
        values: Yle(l),
        dialogMethod: "configureMovement",
        propertyKey: "system.attributes.movement",
        tooltip: "Configure Movement"
      },
      {
        heading: K("A5E.SensesSpecial"),
        values: Kle(l),
        dialogMethod: "configureSenses",
        propertyKey: "system.attributes.senses",
        tooltip: "Configure Senses"
      },
      {
        heading: K("A5E.Languages"),
        values: Vle(l),
        dialogMethod: "configureLanguages",
        propertyKey: "system.proficiencies.languages",
        tooltip: "Configure Languages"
      },
      {
        heading: K("A5E.ConditionImmunities"),
        values: Lle(l),
        dialogMethod: "configureConditionImmunities",
        propertyKey: "system.traits.conditionImmunities",
        tooltip: "Configure Condition Immunities"
      },
      {
        heading: K("A5E.DamageImmunities"),
        values: zle(l),
        dialogMethod: "configureDamageImmunities",
        propertyKey: "system.traits.damageImmunities",
        tooltip: "Configure Damage Immunities"
      },
      {
        heading: K("A5E.DamageResistances"),
        values: Hle(l),
        dialogMethod: "configureDamageResistances",
        propertyKey: "system.traits.damageResistances",
        tooltip: "Configure Damage Resistances"
      },
      {
        heading: K("A5E.DamageVulnerabilities"),
        values: Ule(l),
        dialogMethod: "configureDamageVulnerabilities",
        propertyKey: "system.traits.damageVulnerabilities",
        tooltip: "Configure Damage Vulnerabilities"
      },
      {
        heading: K("A5E.ManeuverTraditionPlural"),
        values: Wle(l),
        dialogMethod: "configureManeuverTraditions",
        propertyKey: "system.proficiencies.traditions",
        tooltip: "Configure Maneuver Traditions",
        display: l.type === "character"
      },
      {
        heading: K("A5E.WeaponProficiencies"),
        values: Jle(l),
        dialogMethod: "configureWeaponProficiencies",
        propertyKey: "system.proficiencies.weapons",
        tooltip: "Configure Weapon Proficiencies"
      },
      {
        heading: K("A5E.ArmorProficiencies"),
        values: jle(l),
        dialogMethod: "configureArmorProficiencies",
        propertyKey: "system.proficiencies.armor",
        tooltip: "Configure Armor Proficiencies"
      },
      {
        heading: K("A5E.ToolProficiencies"),
        values: Xle(l),
        dialogMethod: "configureToolProficiencies",
        propertyKey: "system.proficiencies.tools",
        tooltip: "Configure Tool Proficiencies"
      },
      {
        heading: K("A5E.Size"),
        values: Gle(l),
        dialogMethod: "configureSizeCategory",
        propertyKey: "system.traits.size",
        tooltip: "Configure Size Category"
      },
      {
        heading: K("A5E.CreatureTypesLabel"),
        values: qle(l),
        dialogMethod: "configureCreatureTypes",
        propertyKey: "system.details.creatureTypes",
        tooltip: "Configure Creature Types"
      },
      {
        heading: K("A5E.CreatureTerrainsLabel"),
        values: Ble(l),
        dialogMethod: "configureCreatureTerrains",
        propertyKey: "system.details.terrain",
        tooltip: "Configure Creature Terrains",
        display: l.type === "npc"
      },
      {
        heading: K("A5E.Alignments"),
        values: Nle(l),
        dialogMethod: "configureAlignment",
        propertyKey: "system.traits.alignment",
        tooltip: "Configure Alignment"
      }
    ]), i.$$.dirty & /*$actor*/
    16 && t(0, n = l.isOwner ? ((u = (c = l.flags) == null ? void 0 : c.a5e) == null ? void 0 : u.sheetIsLocked) ?? !0 : !0);
  }, [n, s, r, o, l, a];
}
f(xle, "instance$1J");
const $T = class $T extends ie {
  constructor(e) {
    super(), le(this, e, xle, Qle, ne, {});
  }
};
f($T, "Details");
let nk = $T;
function ere(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "death-saves__input svelte-10v4r32"), b(e, "type", "number"), b(e, "name", "system.attributes.death.success"), b(e, "placeholder", "?"), b(e, "min", "0"), b(e, "data-tooltip", "A5E.DeathSuccess"), b(e, "data-tooltip-direction", "UP"), e.value = t = /*death*/
      i[1].success;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[6]
      ), s = !0);
    },
    p(l, r) {
      r & /*death*/
      2 && t !== (t = /*death*/
      l[1].success) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(ere, "create_if_block_1$K");
function tre(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "death-saves__input svelte-10v4r32"), b(e, "type", "number"), b(e, "name", "system.attributes.death.failure"), b(e, "data-dtype", "Number"), b(e, "placeholder", "0"), b(e, "min", "0"), b(e, "data-tooltip", "A5E.DeathFailure"), b(e, "data-tooltip-direction", "UP"), e.value = t = /*isBlind*/
      i[4] ? "?" : (
        /*death*/
        i[1].failure
      );
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[7]
      ), s = !0);
    },
    p(l, r) {
      r & /*death*/
      2 && t !== (t = /*isBlind*/
      l[4] ? "?" : (
        /*death*/
        l[1].failure
      )) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(tre, "create_if_block$_");
function sre(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p = !/*isBlind*/
  i[4] && ere(i), m = !/*isBlind*/
  i[4] && tre(i);
  return {
    c() {
      e = E("div"), t = E("button"), t.innerHTML = '<i class="fas fa-check"></i>', s = R(), p && p.c(), n = R(), l = E("div"), r = E("button"), r.innerHTML = '<i class="fas fa-skull a5e-js-roll-death-saving-throw"></i>', o = R(), m && m.c(), a = R(), c = E("button"), c.innerHTML = '<i class="fas fa-times"></i>', b(t, "class", "death-saves__button svelte-10v4r32"), b(r, "class", "death-saves__button svelte-10v4r32"), b(r, "data-tooltip", "A5E.DeathSavingThrowRoll"), b(r, "data-tooltip-direction", "UP"), b(l, "class", "death-saves__icon u-align-center u-flex u-flex-col u-pos-relative svelte-10v4r32"), b(c, "class", "death-saves__button svelte-10v4r32"), b(e, "class", "death-saves svelte-10v4r32");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(e, s), p && p.m(e, null), A(e, n), A(e, l), A(l, r), A(e, o), m && m.m(e, null), A(e, a), A(e, c), u || (d = [
        V(
          t,
          "click",
          /*click_handler*/
          i[5]
        ),
        V(r, "click", function() {
          $t(
            /*$actor*/
            i[0].rollDeathSavingThrow(Bi(
              /*$pressedKeysStore*/
              i[2]
            ))
          ) && i[0].rollDeathSavingThrow(Bi(
            /*$pressedKeysStore*/
            i[2]
          )).apply(this, arguments);
        }),
        V(
          c,
          "click",
          /*click_handler_1*/
          i[8]
        )
      ], u = !0);
    },
    p(g, [h]) {
      i = g, /*isBlind*/
      i[4] || p.p(i, h), /*isBlind*/
      i[4] || m.p(i, h);
    },
    i: ee,
    o: ee,
    d(g) {
      g && S(e), p && p.d(), m && m.d(), u = !1, Ne(d);
    }
  };
}
f(sre, "create_fragment$1R");
function nre(i, e, t) {
  let s, n, l;
  pe(i, Mi, (p) => t(2, l = p));
  const r = fe("actor");
  pe(i, r, (p) => t(0, n = p));
  let o = game.settings.get("a5e", "blindDeathSaves");
  const a = /* @__PURE__ */ f(() => se(n, "system.attributes.death.success", s.success + 1), "click_handler"), c = /* @__PURE__ */ f(({ target: p }) => se(n, p.name, Number(p.value)), "change_handler"), u = /* @__PURE__ */ f(({ target: p }) => se(n, p.name, Number(p.value)), "change_handler_1"), d = /* @__PURE__ */ f(() => se(n, "system.attributes.death.failure", s.failure + 1), "click_handler_1");
  return i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    1 && t(1, s = n.system.attributes.death);
  }, [
    n,
    s,
    l,
    r,
    o,
    a,
    c,
    u,
    d
  ];
}
f(nre, "instance$1I");
const AT = class AT extends ie {
  constructor(e) {
    super(), le(this, e, nre, sre, ne, {});
  }
};
f(AT, "DeathSaveOverlay");
let ik = AT;
function iF(i) {
  let e, t;
  return e = new ik({}), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(iF, "create_if_block_1$J");
function ire(i) {
  let e, t, s, n, l, r, o, a, c, u = (
    /*hp*/
    i[0].value === 0 && iF()
  );
  return {
    c() {
      e = E("img"), l = R(), u && u.c(), r = $e(), b(e, "class", "actor-image svelte-jypnyq"), ze(e.src, t = /*$actor*/
      i[1].img) || b(e, "src", t), b(e, "alt", s = /*$actor*/
      i[1].name), b(e, "title", n = /*$actor*/
      i[1].name);
    },
    m(d, p) {
      T(d, e, p), T(d, l, p), u && u.m(d, p), T(d, r, p), o = !0, a || (c = V(
        e,
        "click",
        /*onEditImage*/
        i[6]
      ), a = !0);
    },
    p(d, p) {
      (!o || p & /*$actor*/
      2 && !ze(e.src, t = /*$actor*/
      d[1].img)) && b(e, "src", t), (!o || p & /*$actor*/
      2 && s !== (s = /*$actor*/
      d[1].name)) && b(e, "alt", s), (!o || p & /*$actor*/
      2 && n !== (n = /*$actor*/
      d[1].name)) && b(e, "title", n), /*hp*/
      d[0].value === 0 ? u ? p & /*hp*/
      1 && w(u, 1) : (u = iF(), u.c(), w(u, 1), u.m(r.parentNode, r)) : u && (ce(), C(u, 1, 1, () => {
        u = null;
      }), ue());
    },
    i(d) {
      o || (w(u), o = !0);
    },
    o(d) {
      C(u), o = !1;
    },
    d(d) {
      d && (S(e), S(l), S(r)), u && u.d(d), a = !1, c();
    }
  };
}
f(ire, "create_default_slot$O");
function lre(i) {
  let e, t;
  return e = new ap({
    props: {
      icon: "fa-brain",
      tooltipText: "A5E.Strife",
      trackProperty: "strife",
      options: (
        /*strifeOptions*/
        i[4]
      ),
      selectedOption: (
        /*$actor*/
        i[1].system.attributes.strife
      )
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$actor*/
      2 && (l.selectedOption = /*$actor*/
      s[1].system.attributes.strife), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(lre, "create_if_block$Z");
function rre(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k, v, O, P, D, I, B, F;
  s = new Qv({
    props: {
      hp: (
        /*hp*/
        i[0]
      ),
      $$slots: { default: [ire] },
      $$scope: { ctx: i }
    }
  }), l = new ap({
    props: {
      icon: "fa-running",
      tooltipText: (
        /*replaceFatigueAndStrife*/
        i[5] ? "A5E.Exhaustion" : "A5E.Fatigue"
      ),
      trackProperty: "fatigue",
      options: (
        /*fatigueOptions*/
        i[2]
      ),
      selectedOption: (
        /*$actor*/
        i[1].system.attributes.fatigue
      )
    }
  });
  let H = !/*replaceFatigueAndStrife*/
  i[5] && lre(i);
  return a = new sk({}), d = new xv({ props: { hp: (
    /*hp*/
    i[0]
  ) } }), g = new Jv({}), _ = new Zv({}), k = new ek({}), P = new nk({}), B = new tk({}), {
    c() {
      e = E("div"), t = E("section"), L(s.$$.fragment), n = R(), L(l.$$.fragment), r = R(), H && H.c(), o = R(), L(a.$$.fragment), c = R(), u = E("section"), L(d.$$.fragment), p = R(), m = E("ul"), L(g.$$.fragment), h = R(), L(_.$$.fragment), y = R(), L(k.$$.fragment), v = R(), O = E("div"), L(P.$$.fragment), D = R(), I = E("footer"), L(B.$$.fragment), b(t, "class", "actor-portrait-wrapper svelte-jypnyq"), b(m, "class", "actor-glance-trackers svelte-jypnyq"), b(O, "class", "actor-details svelte-jypnyq"), b(I, "class", "actor-sidebar-footer svelte-jypnyq"), b(u, "class", "actor-sidebar-lower svelte-jypnyq"), b(e, "class", "actor-sidebar svelte-jypnyq");
    },
    m(G, U) {
      T(G, e, U), A(e, t), N(s, t, null), A(t, n), N(l, t, null), A(t, r), H && H.m(t, null), A(t, o), N(a, t, null), A(e, c), A(e, u), N(d, u, null), A(u, p), A(u, m), N(g, m, null), A(m, h), N(_, m, null), A(m, y), N(k, m, null), A(u, v), A(u, O), N(P, O, null), A(u, D), A(u, I), N(B, I, null), F = !0;
    },
    p(G, [U]) {
      const q = {};
      U & /*hp*/
      1 && (q.hp = /*hp*/
      G[0]), U & /*$$scope, hp, $actor*/
      131 && (q.$$scope = { dirty: U, ctx: G }), s.$set(q);
      const W = {};
      U & /*fatigueOptions*/
      4 && (W.options = /*fatigueOptions*/
      G[2]), U & /*$actor*/
      2 && (W.selectedOption = /*$actor*/
      G[1].system.attributes.fatigue), l.$set(W), /*replaceFatigueAndStrife*/
      G[5] || H.p(G, U);
      const X = {};
      U & /*hp*/
      1 && (X.hp = /*hp*/
      G[0]), d.$set(X);
    },
    i(G) {
      F || (w(s.$$.fragment, G), w(l.$$.fragment, G), w(H), w(a.$$.fragment, G), w(d.$$.fragment, G), w(g.$$.fragment, G), w(_.$$.fragment, G), w(k.$$.fragment, G), w(P.$$.fragment, G), w(B.$$.fragment, G), F = !0);
    },
    o(G) {
      C(s.$$.fragment, G), C(l.$$.fragment, G), C(H), C(a.$$.fragment, G), C(d.$$.fragment, G), C(g.$$.fragment, G), C(_.$$.fragment, G), C(k.$$.fragment, G), C(P.$$.fragment, G), C(B.$$.fragment, G), F = !1;
    },
    d(G) {
      G && S(e), j(s), j(l), H && H.d(), j(a), j(d), j(g), j(_), j(k), j(P), j(B);
    }
  };
}
f(rre, "create_fragment$1Q");
function ore(i, e, t) {
  let s, { hp: n } = e;
  const l = fe("actor");
  pe(i, l, (u) => t(1, s = u));
  let r = [
    { value: 0, hint: null },
    {
      value: 1,
      hint: "A5E.tracks.fatigue.hints.1"
    },
    {
      value: 2,
      hint: "A5E.tracks.fatigue.hints.2"
    },
    {
      value: 3,
      hint: "A5E.tracks.fatigue.hints.3"
    },
    {
      value: 4,
      hint: "A5E.tracks.fatigue.hints.4"
    },
    {
      value: 5,
      hint: "A5E.tracks.fatigue.hints.5"
    },
    {
      value: 6,
      hint: "A5E.tracks.fatigue.hints.6"
    },
    {
      value: 7,
      hint: "A5E.tracks.fatigue.hints.7"
    }
  ];
  const o = [
    { value: 0, hint: null },
    {
      value: 1,
      hint: "A5E.tracks.strife.hints.1"
    },
    {
      value: 2,
      hint: "A5E.tracks.strife.hints.2"
    },
    {
      value: 3,
      hint: "A5E.tracks.strife.hints.3"
    },
    {
      value: 4,
      hint: "A5E.tracks.strife.hints.4"
    },
    {
      value: 5,
      hint: "A5E.tracks.strife.hints.5"
    },
    {
      value: 6,
      hint: "A5E.tracks.strife.hints.6"
    },
    {
      value: 7,
      hint: "A5E.tracks.strife.hints.7"
    }
  ], a = game.settings.get("a5e", "replaceFatigueAndStrife");
  a && (r = [
    { value: 0, hint: null },
    {
      value: 1,
      hint: "A5E.tracks.exhaustion.hints.1"
    },
    {
      value: 2,
      hint: "A5E.tracks.exhaustion.hints.2"
    },
    {
      value: 3,
      hint: "A5E.tracks.exhaustion.hints.3"
    },
    {
      value: 4,
      hint: "A5E.tracks.exhaustion.hints.4"
    },
    {
      value: 5,
      hint: "A5E.tracks.exhaustion.hints.5"
    },
    {
      value: 6,
      hint: "A5E.tracks.exhaustion.hints.6"
    }
  ]);
  async function c() {
    await ab(s);
  }
  return f(c, "onEditImage"), i.$$set = (u) => {
    "hp" in u && t(0, n = u.hp);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    2 && t(0, n = s.system.attributes.hp);
  }, [
    n,
    s,
    r,
    l,
    o,
    a,
    c
  ];
}
f(ore, "instance$1H");
const ET = class ET extends ie {
  constructor(e) {
    super(), le(this, e, ore, rre, ne, { hp: 0 });
  }
};
f(ET, "ActorSidebar");
let lk = ET;
function lF(i, e, t) {
  const s = i.slice();
  return s[17] = e[t][0], s[18] = e[t][1], s;
}
f(lF, "get_each_context$C");
function rF(i) {
  let e, t;
  return e = new ji({
    props: {
      $$slots: { default: [are] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $actor, spellBookId, menuList, reducer, showDescription*/
      2097451 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(rF, "create_if_block_1$I");
function are(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g;
  return e = new Fi({
    props: { reducerType: Yf, reducer: (
      /*reducer*/
      i[1]
    ) }
  }), s = new Sa({}), s.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[14]
  ), l = new Ni({
    props: {
      reducerType: Yf,
      reducer: (
        /*reducer*/
        i[1]
      ),
      reducerId: (
        /*spellBookId*/
        i[0]
      )
    }
  }), o = new Ea({
    props: {
      reducerType: Yf,
      reducerId: (
        /*spellBookId*/
        i[0]
      ),
      reducer: (
        /*reducer*/
        i[1]
      )
    }
  }), c = new Ys({
    props: {
      reducerType: Yf,
      menuList: (
        /*menuList*/
        i[8]
      ),
      reducer: (
        /*reducer*/
        i[1]
      )
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment), r = R(), L(o.$$.fragment), a = R(), L(c.$$.fragment), u = R(), d = E("button"), b(d, "class", "a5e-import-from-compendium-button fa-solid fa-download"), b(d, "data-tooltip", "Import Spells from Compendium"), b(d, "data-tooltip-direction", "UP");
    },
    m(h, _) {
      N(e, h, _), T(h, t, _), N(s, h, _), T(h, n, _), N(l, h, _), T(h, r, _), N(o, h, _), T(h, a, _), N(c, h, _), T(h, u, _), T(h, d, _), p = !0, m || (g = V(
        d,
        "click",
        /*click_handler*/
        i[15]
      ), m = !0);
    },
    p(h, _) {
      const y = {};
      _ & /*reducer*/
      2 && (y.reducer = /*reducer*/
      h[1]), e.$set(y);
      const k = {};
      _ & /*reducer*/
      2 && (k.reducer = /*reducer*/
      h[1]), _ & /*spellBookId*/
      1 && (k.reducerId = /*spellBookId*/
      h[0]), l.$set(k);
      const v = {};
      _ & /*spellBookId*/
      1 && (v.reducerId = /*spellBookId*/
      h[0]), _ & /*reducer*/
      2 && (v.reducer = /*reducer*/
      h[1]), o.$set(v);
      const O = {};
      _ & /*menuList*/
      256 && (O.menuList = /*menuList*/
      h[8]), _ & /*reducer*/
      2 && (O.reducer = /*reducer*/
      h[1]), c.$set(O);
    },
    i(h) {
      p || (w(e.$$.fragment, h), w(s.$$.fragment, h), w(l.$$.fragment, h), w(o.$$.fragment, h), w(c.$$.fragment, h), p = !0);
    },
    o(h) {
      C(e.$$.fragment, h), C(s.$$.fragment, h), C(l.$$.fragment, h), C(o.$$.fragment, h), C(c.$$.fragment, h), p = !1;
    },
    d(h) {
      h && (S(t), S(n), S(r), S(a), S(u), S(d)), j(e, h), j(s, h), j(l, h), j(o, h), j(c, h), m = !1, g();
    }
  };
}
f(are, "create_default_slot$N");
function oF(i) {
  var s, n, l, r;
  let e, t;
  return e = new gl({
    props: {
      level: (
        /*level*/
        i[17]
      ),
      label: (
        /*label*/
        i[18]
      ),
      showDescription: (
        /*showDescription*/
        i[5]
      ),
      showSpellPoints: (
        /*spellBook*/
        ((s = i[7]) == null ? void 0 : s.showSpellPoints) ?? !1
      ),
      showSpellSlots: (
        /*spellBook*/
        ((n = i[7]) == null ? void 0 : n.showSpellSlots) ?? !0
      ),
      showUses: (
        /*showUses*/
        i[4]
      ),
      items: (
        /*$reducer*/
        (r = (l = i[2]) == null ? void 0 : l._levels) == null ? void 0 : r[
          /*level*/
          i[17]
        ]
      ),
      type: "spellLevels"
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(o, a) {
      N(e, o, a), t = !0;
    },
    p(o, a) {
      var u, d, p, m;
      const c = {};
      a & /*showDescription*/
      32 && (c.showDescription = /*showDescription*/
      o[5]), a & /*spellBook*/
      128 && (c.showSpellPoints = /*spellBook*/
      ((u = o[7]) == null ? void 0 : u.showSpellPoints) ?? !1), a & /*spellBook*/
      128 && (c.showSpellSlots = /*spellBook*/
      ((d = o[7]) == null ? void 0 : d.showSpellSlots) ?? !0), a & /*showUses*/
      16 && (c.showUses = /*showUses*/
      o[4]), a & /*$reducer*/
      4 && (c.items = /*$reducer*/
      (m = (p = o[2]) == null ? void 0 : p._levels) == null ? void 0 : m[
        /*level*/
        o[17]
      ]), e.$set(c);
    },
    i(o) {
      t || (w(e.$$.fragment, o), t = !0);
    },
    o(o) {
      C(e.$$.fragment, o), t = !1;
    },
    d(o) {
      j(e, o);
    }
  };
}
f(oF, "create_if_block$Y");
function aF(i) {
  let e = (
    /*isSpellLevelVisible*/
    i[6](
      /*level*/
      i[17]
    )
  ), t, s, n = e && oF(i);
  return {
    c() {
      n && n.c(), t = $e();
    },
    m(l, r) {
      n && n.m(l, r), T(l, t, r), s = !0;
    },
    p(l, r) {
      r & /*isSpellLevelVisible*/
      64 && (e = /*isSpellLevelVisible*/
      l[6](
        /*level*/
        l[17]
      )), e ? n ? (n.p(l, r), r & /*isSpellLevelVisible*/
      64 && w(n, 1)) : (n = oF(l), n.c(), w(n, 1), n.m(t.parentNode, t)) : n && (ce(), C(n, 1, 1, () => {
        n = null;
      }), ue());
    },
    i(l) {
      s || (w(n), s = !0);
    },
    o(l) {
      C(n), s = !1;
    },
    d(l) {
      l && S(t), n && n.d(l);
    }
  };
}
f(aF, "create_each_block$C");
function cre(i) {
  let e, t, s, n, l = (
    /*$actor*/
    i[3].isOwner && rF(i)
  ), r = oe(Object.entries(
    /*spellLevels*/
    i[11]
  )), o = [];
  for (let c = 0; c < r.length; c += 1)
    o[c] = aF(lF(i, r, c));
  const a = /* @__PURE__ */ f((c) => C(o[c], 1, 1, () => {
    o[c] = null;
  }), "out");
  return {
    c() {
      e = E("article"), l && l.c(), t = R(), s = E("section");
      for (let c = 0; c < o.length; c += 1)
        o[c].c();
      b(s, "class", "a5e-page-wrapper a5e-page-wrapper--item-list"), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable"), b(
        e,
        "data-spell-book-id",
        /*spellBookId*/
        i[0]
      );
    },
    m(c, u) {
      T(c, e, u), l && l.m(e, null), A(e, t), A(e, s);
      for (let d = 0; d < o.length; d += 1)
        o[d] && o[d].m(s, null);
      n = !0;
    },
    p(c, [u]) {
      if (/*$actor*/
      c[3].isOwner ? l ? (l.p(c, u), u & /*$actor*/
      8 && w(l, 1)) : (l = rF(c), l.c(), w(l, 1), l.m(e, t)) : l && (ce(), C(l, 1, 1, () => {
        l = null;
      }), ue()), u & /*Object, spellLevels, showDescription, spellBook, showUses, $reducer, isSpellLevelVisible*/
      2292) {
        r = oe(Object.entries(
          /*spellLevels*/
          c[11]
        ));
        let d;
        for (d = 0; d < r.length; d += 1) {
          const p = lF(c, r, d);
          o[d] ? (o[d].p(p, u), w(o[d], 1)) : (o[d] = aF(p), o[d].c(), w(o[d], 1), o[d].m(s, null));
        }
        for (ce(), d = r.length; d < o.length; d += 1)
          a(d);
        ue();
      }
      (!n || u & /*spellBookId*/
      1) && b(
        e,
        "data-spell-book-id",
        /*spellBookId*/
        c[0]
      );
    },
    i(c) {
      if (!n) {
        w(l);
        for (let u = 0; u < r.length; u += 1)
          w(o[u]);
        n = !0;
      }
    },
    o(c) {
      C(l), o = o.filter(Boolean);
      for (let u = 0; u < o.length; u += 1)
        C(o[u]);
      n = !1;
    },
    d(c) {
      c && S(e), l && l.d(), Le(o, c);
    }
  };
}
f(cre, "create_fragment$1P");
const Yf = "spells";
function ure(i, e, t) {
  let s, n, l, r, o, a = ee, c = /* @__PURE__ */ f(() => (a(), a = Et(p, (D) => t(2, o = D)), p), "$$subscribe_reducer"), u;
  i.$$.on_destroy.push(() => a());
  let { spellBookId: d } = e, { reducer: p } = e;
  c();
  function m(D) {
    D.forEach((I) => {
      I.system.spellBook = d;
    }), u.createEmbeddedDocuments("Item", D);
  }
  f(m, "importer");
  const g = fe("actor");
  pe(i, g, (D) => t(3, u = D));
  const { spellLevels: h } = CONFIG.A5E, _ = game.a5e.utils.openCompendium;
  let y = !1;
  const k = p.subscribe((D) => {
    const I = Object.keys(h).reduce(
      (B, F) => (B.push(...o == null ? void 0 : o._levels[F]), B),
      []
    );
    t(4, y = qi(I));
  });
  let v = !1;
  Nt(() => {
    k();
  });
  const O = /* @__PURE__ */ f(() => t(5, v = !v), "updateSelection_handler"), P = /* @__PURE__ */ f(() => _(u, "spells", { importFunction: m, spellBookId: d }), "click_handler");
  return i.$$set = (D) => {
    "spellBookId" in D && t(0, d = D.spellBookId), "reducer" in D && c(t(1, p = D.reducer));
  }, i.$$.update = () => {
    var D, I, B;
    i.$$.dirty & /*$actor, spellBookId*/
    9 && t(7, n = (D = u == null ? void 0 : u.spellBooks) == null ? void 0 : D.get(d)), i.$$.dirty & /*$actor*/
    8 && t(13, l = u.isOwner ? ((B = (I = u.flags) == null ? void 0 : I.a5e) == null ? void 0 : B.sheetIsLocked) ?? !0 : !0), i.$$.dirty & /*sheetIsLocked, $actor, $reducer*/
    8204 && t(6, r = /* @__PURE__ */ f((F) => {
      var q, W, X;
      if (!l)
        return !0;
      const H = (q = u.system.spellResources.slots[F]) == null ? void 0 : q.max, G = ((X = (W = u.flags) == null ? void 0 : W.a5e) == null ? void 0 : X.showSpellSlots) ?? !0;
      return !!([...(o == null ? void 0 : o._levels[F]) ?? []].length || G && H > 0);
    }, "isSpellLevelVisible"));
  }, t(8, s = Object.entries(h)), [
    d,
    p,
    o,
    u,
    y,
    v,
    r,
    n,
    s,
    m,
    g,
    h,
    _,
    l,
    O,
    P
  ];
}
f(ure, "instance$1G");
const ST = class ST extends ie {
  constructor(e) {
    super(), le(this, e, ure, cre, ne, { spellBookId: 0, reducer: 1 });
  }
};
f(ST, "SpellBook");
let rk = ST;
function fre(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "type", "text"), b(e, "spellcheck", "false"), e.value = t = /*book*/
      ((l = i[3]) == null ? void 0 : l.name) || "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[6]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r & /*book*/
      8 && t !== (t = /*book*/
      ((o = l[3]) == null ? void 0 : o.name) || "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(fre, "create_default_slot_5$a");
function dre(i) {
  var s;
  let e, t;
  return e = new Ye({
    props: {
      allowDeselect: !1,
      options: (
        /*abilityOptions*/
        i[4]
      ),
      selected: (
        /*book*/
        ((s = i[3]) == null ? void 0 : s.ability) ?? "default"
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*book*/
      8 && (r.selected = /*book*/
      ((o = n[3]) == null ? void 0 : o.ability) ?? "default"), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(dre, "create_default_slot_4$b");
function pre(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "Show Spell Slots",
      checked: (
        /*book*/
        ((s = i[3]) == null ? void 0 : s.showSpellSlots) ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[8]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*book*/
      8 && (r.checked = /*book*/
      ((o = n[3]) == null ? void 0 : o.showSpellSlots) ?? !0), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(pre, "create_default_slot_3$d");
function mre(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "Show Spell Points",
      checked: (
        /*book*/
        ((s = i[3]) == null ? void 0 : s.showSpellPoints) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[9]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*book*/
      8 && (r.checked = /*book*/
      ((o = n[3]) == null ? void 0 : o.showSpellPoints) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(mre, "create_default_slot_2$e");
function hre(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "Disable Spell Consumers",
      checked: (
        /*book*/
        ((s = i[3]) == null ? void 0 : s.disableSpellConsumers) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[10]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*book*/
      8 && (r.checked = /*book*/
      ((o = n[3]) == null ? void 0 : o.disableSpellConsumers) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(hre, "create_default_slot_1$g");
function gre(i) {
  let e, t, s, n, l, r, o, a, c, u;
  return e = new de({
    props: {
      heading: "Spell Book Name",
      $$slots: { default: [fre] },
      $$scope: { ctx: i }
    }
  }), s = new de({
    props: {
      heading: "Spellcasting Ability",
      hint: "Spells in this spellbook will use this spellcasting ability for the purposes of spell attack roll and spell save DCs in place of the sheet default.",
      $$slots: { default: [dre] },
      $$scope: { ctx: i }
    }
  }), l = new de({
    props: {
      $$slots: { default: [pre] },
      $$scope: { ctx: i }
    }
  }), o = new de({
    props: {
      $$slots: { default: [mre] },
      $$scope: { ctx: i }
    }
  }), c = new de({
    props: {
      hint: "When enabled, resource consumers for spell slots and points will be ignored by default. This is useful for things like ritual books, where you're rarely if ever going to want to consume a spell slot.",
      $$slots: { default: [hre] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment), r = R(), L(o.$$.fragment), a = R(), L(c.$$.fragment);
    },
    m(d, p) {
      N(e, d, p), T(d, t, p), N(s, d, p), T(d, n, p), N(l, d, p), T(d, r, p), N(o, d, p), T(d, a, p), N(c, d, p), u = !0;
    },
    p(d, p) {
      const m = {};
      p & /*$$scope, book, $document, spellBookId*/
      2062 && (m.$$scope = { dirty: p, ctx: d }), e.$set(m);
      const g = {};
      p & /*$$scope, book, $document, spellBookId*/
      2062 && (g.$$scope = { dirty: p, ctx: d }), s.$set(g);
      const h = {};
      p & /*$$scope, book, $document, spellBookId*/
      2062 && (h.$$scope = { dirty: p, ctx: d }), l.$set(h);
      const _ = {};
      p & /*$$scope, book, $document, spellBookId*/
      2062 && (_.$$scope = { dirty: p, ctx: d }), o.$set(_);
      const y = {};
      p & /*$$scope, book, $document, spellBookId*/
      2062 && (y.$$scope = { dirty: p, ctx: d }), c.$set(y);
    },
    i(d) {
      u || (w(e.$$.fragment, d), w(s.$$.fragment, d), w(l.$$.fragment, d), w(o.$$.fragment, d), w(c.$$.fragment, d), u = !0);
    },
    o(d) {
      C(e.$$.fragment, d), C(s.$$.fragment, d), C(l.$$.fragment, d), C(o.$$.fragment, d), C(c.$$.fragment, d), u = !1;
    },
    d(d) {
      d && (S(t), S(n), S(r), S(a)), j(e, d), j(s, d), j(l, d), j(o, d), j(c, d);
    }
  };
}
f(gre, "create_default_slot$M");
function bre(i) {
  let e, t, s, n;
  return t = new Me({
    props: {
      $$slots: { default: [gre] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), s = E("div"), L(t.$$.fragment), z(s, "display", "contents"), z(s, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "svelte-99fflt");
    },
    m(l, r) {
      T(l, e, r), A(e, s), N(t, s, null), n = !0;
    },
    p(l, [r]) {
      const o = {};
      r & /*$$scope, book, $document, spellBookId*/
      2062 && (o.$$scope = { dirty: r, ctx: l }), t.$set(o);
    },
    i(l) {
      n || (w(t.$$.fragment, l), n = !0);
    },
    o(l) {
      C(t.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(e), j(t);
    }
  };
}
f(bre, "create_fragment$1O");
function _re(i, e, t) {
  let s, n, l = ee, r = /* @__PURE__ */ f(() => (l(), l = Et(u, (v) => t(2, n = v)), u), "$$subscribe_document");
  i.$$.on_destroy.push(() => l());
  let { document: o, appId: a, spellBookId: c } = fe("#external").application, { document: u = o, appId: d = a, spellBookId: p = c } = e;
  r();
  const m = [["default", "A5E.abilities.default"], ...ci()], g = /* @__PURE__ */ f(({ target: v }) => {
    se(n, `system.spellBooks.${p}.name`, v.value);
  }, "change_handler"), h = /* @__PURE__ */ f(({ detail: v }) => se(n, `system.spellBooks.${p}.ability`, v), "updateSelection_handler"), _ = /* @__PURE__ */ f(({ detail: v }) => {
    se(n, `system.spellBooks.${p}.showSpellSlots`, v);
  }, "updateSelection_handler_1"), y = /* @__PURE__ */ f(({ detail: v }) => {
    se(n, `system.spellBooks.${p}.showSpellPoints`, v);
  }, "updateSelection_handler_2"), k = /* @__PURE__ */ f(({ detail: v }) => {
    se(n, `system.spellBooks.${p}.disableSpellConsumers`, v);
  }, "updateSelection_handler_3");
  return i.$$set = (v) => {
    "document" in v && r(t(0, u = v.document)), "appId" in v && t(5, d = v.appId), "spellBookId" in v && t(1, p = v.spellBookId);
  }, i.$$.update = () => {
    var v;
    i.$$.dirty & /*$document, spellBookId*/
    6 && t(3, s = (v = n.spellBooks) == null ? void 0 : v.get(p));
  }, [
    u,
    p,
    n,
    s,
    m,
    d,
    g,
    h,
    _,
    y,
    k
  ];
}
f(_re, "instance$1F");
const TT = class TT extends ie {
  constructor(e) {
    super(), le(this, e, _re, bre, ne, { document: 0, appId: 5, spellBookId: 1 });
  }
};
f(TT, "SpellbookConfigDialog");
let ok = TT;
function yre(i) {
  let e, t, s, n, l, r, o, a, c;
  return {
    c() {
      e = E("form"), t = E("p"), t.textContent = `Are you sure you want to delete this spellbook? This will also remove
        all of the spells it contains.`, s = R(), n = E("div"), l = E("button"), l.textContent = "Delete", r = R(), o = E("button"), o.textContent = "Cancel", b(n, "class", "button-container svelte-1ev6ohd"), b(e, "class", "svelte-1ev6ohd");
    },
    m(u, d) {
      T(u, e, d), A(e, t), A(e, s), A(e, n), A(n, l), A(n, r), A(n, o), a || (c = [
        V(l, "click", tt(
          /*click_handler*/
          i[3]
        )),
        V(o, "click", tt(
          /*click_handler_1*/
          i[4]
        ))
      ], a = !0);
    },
    p: ee,
    i: ee,
    o: ee,
    d(u) {
      u && S(e), a = !1, Ne(c);
    }
  };
}
f(yre, "create_fragment$1N");
function vre(i, e, t) {
  let { dialog: s } = fe("#external").application, { dialog: n = s } = e;
  function l() {
    n.submit({ confirmDeletion: !0 });
  }
  f(l, "onSubmit");
  function r() {
    n.submit({ confirmDeletion: !1 });
  }
  f(r, "onCancelDeletion");
  const o = /* @__PURE__ */ f(() => l(), "click_handler"), a = /* @__PURE__ */ f(() => r(), "click_handler_1");
  return i.$$set = (c) => {
    "dialog" in c && t(2, n = c.dialog);
  }, [l, r, n, o, a];
}
f(vre, "instance$1E");
var ff;
let kre = (ff = class extends ie {
  constructor(e) {
    super(), le(this, e, vre, yre, ne, { dialog: 2 });
  }
}, f(ff, "SpellbookDeletionConfirmationDialog"), ff);
var df, ck;
const CT = class CT extends Fs {
  constructor() {
    super({
      title: "Confirm Spellbook Deletion",
      content: {
        class: kre,
        props: {}
      }
    }, {
      classes: ["a5e-sheet"],
      width: 420
    });
    Y(this, df);
    this.data.content.props.dialog = this, this.promise = new Promise((t) => {
      this.resolve = t;
    });
  }
  /** @inheritdoc */
  close(t) {
    return Z(this, df, ck).call(this, null), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    return Z(this, df, ck).call(this, t), super.close();
  }
};
df = new WeakSet(), ck = /* @__PURE__ */ f(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), f(CT, "SpellbookDeletionConfirmationDialog");
let ak = CT;
function cF(i, e, t) {
  const s = i.slice();
  return s[24] = e[t][0], s[25] = e[t][1], s[27] = t, s;
}
f(cF, "get_each_context$B");
function uF(i) {
  let e, t, s = oe([.../*spellBooks*/
  i[5]]), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = dF(cF(i, s, r));
  let l = !/*sheetIsLocked*/
  i[0] && pF(i);
  return {
    c() {
      e = E("nav");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      t = R(), l && l.c(), b(e, "class", "a5e-spellbook-list svelte-wuitj9");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      A(e, t), l && l.m(e, null);
    },
    p(r, o) {
      if (o & /*currentSpellBook, spellBooks, updateCurrentSpellBook, deleteSpellbook, configureSpellbook, sheetIsLocked*/
      14377) {
        s = oe([.../*spellBooks*/
        r[5]]);
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = cF(r, s, a);
          n[a] ? n[a].p(c, o) : (n[a] = dF(c), n[a].c(), n[a].m(e, t));
        }
        for (; a < n.length; a += 1)
          n[a].d(1);
        n.length = s.length;
      }
      /*sheetIsLocked*/
      r[0] ? l && (l.d(1), l = null) : l ? l.p(r, o) : (l = pF(r), l.c(), l.m(e, null));
    },
    d(r) {
      r && S(e), Le(n, r), l && l.d();
    }
  };
}
f(uF, "create_if_block_4$h");
function fF(i) {
  let e, t, s, n, l;
  function r() {
    return (
      /*click_handler*/
      i[15](
        /*spellBookId*/
        i[24]
      )
    );
  }
  f(r, "click_handler");
  function o() {
    return (
      /*click_handler_1*/
      i[16](
        /*spellBookId*/
        i[24]
      )
    );
  }
  return f(o, "click_handler_1"), {
    c() {
      e = E("i"), t = R(), s = E("i"), b(e, "class", "a5e-control-button a5e-control-button--config fa-solid fa-gear svelte-wuitj9"), b(s, "class", "a5e-control-button a5e-control-button--delete fa-solid fa-trash svelte-wuitj9");
    },
    m(a, c) {
      T(a, e, c), T(a, t, c), T(a, s, c), n || (l = [
        V(e, "click", We(r)),
        V(s, "click", We(o))
      ], n = !0);
    },
    p(a, c) {
      i = a;
    },
    d(a) {
      a && (S(e), S(t), S(s)), n = !1, Ne(l);
    }
  };
}
f(fF, "create_if_block_6$9");
function dF(i) {
  let e, t = (
    /*spellBook*/
    i[25].name + ""
  ), s, n, l, r, o = !/*sheetIsLocked*/
  i[0] && fF(i);
  function a() {
    return (
      /*click_handler_2*/
      i[17](
        /*spellBookId*/
        i[24]
      )
    );
  }
  return f(a, "click_handler_2"), {
    c() {
      e = E("button"), s = x(t), n = R(), o && o.c(), b(e, "class", "a5e-spellbook-list__item svelte-wuitj9"), Q(
        e,
        "a5e-spellbook-list__item--active",
        /*currentSpellBook*/
        i[3] ? (
          /*currentSpellBook*/
          i[3] === /*spellBookId*/
          i[24]
        ) : (
          /*index*/
          i[27] === 0
        )
      );
    },
    m(c, u) {
      T(c, e, u), A(e, s), A(e, n), o && o.m(e, null), l || (r = V(e, "click", a), l = !0);
    },
    p(c, u) {
      i = c, u & /*spellBooks*/
      32 && t !== (t = /*spellBook*/
      i[25].name + "") && _e(s, t), /*sheetIsLocked*/
      i[0] ? o && (o.d(1), o = null) : o ? o.p(i, u) : (o = fF(i), o.c(), o.m(e, null)), u & /*currentSpellBook, spellBooks*/
      40 && Q(
        e,
        "a5e-spellbook-list__item--active",
        /*currentSpellBook*/
        i[3] ? (
          /*currentSpellBook*/
          i[3] === /*spellBookId*/
          i[24]
        ) : (
          /*index*/
          i[27] === 0
        )
      );
    },
    d(c) {
      c && S(e), o && o.d(), l = !1, r();
    }
  };
}
f(dF, "create_each_block$B");
function pF(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "a5e-spellbook-list__item a5e-spellbook-list__item--add fa-solid fa-plus svelte-wuitj9"), b(e, "data-tooltip", "Create new spell book");
    },
    m(n, l) {
      T(n, e, l), t || (s = V(
        e,
        "click",
        /*click_handler_3*/
        i[18]
      ), t = !0);
    },
    p: ee,
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(pF, "create_if_block_5$a");
function mF(i) {
  let e = (
    /*currentSpellBook*/
    i[3]
  ), t, s, n = hF(i);
  return {
    c() {
      n.c(), t = $e();
    },
    m(l, r) {
      n.m(l, r), T(l, t, r), s = !0;
    },
    p(l, r) {
      r & /*currentSpellBook*/
      8 && ne(e, e = /*currentSpellBook*/
      l[3]) ? (ce(), C(n, 1, 1, ee), ue(), n = hF(l), n.c(), w(n, 1), n.m(t.parentNode, t)) : n.p(l, r);
    },
    i(l) {
      s || (w(n), s = !0);
    },
    o(l) {
      C(n), s = !1;
    },
    d(l) {
      l && S(t), n.d(l);
    }
  };
}
f(mF, "create_if_block_3$k");
function hF(i) {
  let e, t;
  return e = new rk({
    props: {
      spellBookId: (
        /*currentSpellBook*/
        i[3]
      ),
      reducer: (
        /*$spells*/
        i[7]._books[
          /*currentSpellBook*/
          i[3]
        ]
      )
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*currentSpellBook*/
      8 && (l.spellBookId = /*currentSpellBook*/
      s[3]), n & /*$spells, currentSpellBook*/
      136 && (l.reducer = /*$spells*/
      s[7]._books[
        /*currentSpellBook*/
        s[3]
      ]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(hF, "create_key_block");
function gF(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("div"), t = E("h3"), t.textContent = "Spells Prepared:", s = R(), n = E("span"), l = x(
        /*preparedSpellCount*/
        i[6]
      ), b(t, "class", "u-mb-0 u-text-bold u-text-sm u-flex-grow-1"), b(n, "class", "a5e-footer-group__input"), b(e, "class", "u-flex u-flex-wrap u-align-center u-gap-md"), b(e, "data-tooltip", "This number does not include spells which are marked as always prepared."), b(e, "data-tooltip-direction", "UP");
    },
    m(r, o) {
      T(r, e, o), A(e, t), A(e, s), A(e, n), A(n, l);
    },
    p(r, o) {
      o & /*preparedSpellCount*/
      64 && _e(
        l,
        /*preparedSpellCount*/
        r[6]
      );
    },
    d(r) {
      r && S(e);
    }
  };
}
f(gF, "create_if_block_2$u");
function bF(i) {
  let e, t, s, n, l, r, o, a, c, u;
  return {
    c() {
      e = E("div"), t = E("h3"), t.textContent = `${K("A5E.SpellPoints")}`, s = R(), n = E("input"), r = x(`
            /
            `), o = E("input"), b(t, "class", "u-mb-0 u-text-bold u-text-sm u-flex-grow-1"), b(n, "class", "a5e-footer-group__input svelte-wuitj9"), b(n, "type", "number"), b(n, "name", "system.spellResources.points.current"), n.value = l = /*spellResources*/
      i[1].points.current, b(n, "placeholder", "0"), b(n, "min", "0"), Q(n, "disable-pointer-events", !/*$actor*/
      i[2].isOwner), b(o, "class", "a5e-footer-group__input"), b(o, "type", "number"), b(o, "name", "system.spellResources.points.max"), o.value = a = /*spellPointMax*/
      i[4] ?? 0, o.disabled = /*sheetIsLocked*/
      i[0], b(o, "placeholder", "0"), b(o, "min", "0"), b(e, "class", "u-flex u-flex-wrap u-align-center u-gap-md");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(e, s), A(e, n), A(e, r), A(e, o), c || (u = [
        V(
          n,
          "change",
          /*change_handler*/
          i[19]
        ),
        V(
          o,
          "change",
          /*change_handler_1*/
          i[20]
        )
      ], c = !0);
    },
    p(d, p) {
      p & /*spellResources*/
      2 && l !== (l = /*spellResources*/
      d[1].points.current) && n.value !== l && (n.value = l), p & /*$actor*/
      4 && Q(n, "disable-pointer-events", !/*$actor*/
      d[2].isOwner), p & /*spellPointMax*/
      16 && a !== (a = /*spellPointMax*/
      d[4] ?? 0) && o.value !== a && (o.value = a), p & /*sheetIsLocked*/
      1 && (o.disabled = /*sheetIsLocked*/
      d[0]);
    },
    d(d) {
      d && S(e), c = !1, Ne(u);
    }
  };
}
f(bF, "create_if_block_1$H");
function _F(i) {
  let e, t, s, n, l, r, o;
  return {
    c() {
      e = E("div"), t = E("h3"), t.textContent = `${K("A5E.CasterLevel")}`, s = R(), n = E("input"), b(t, "class", "u-mb-0 u-text-bold u-text-sm u-flex-grow-1"), b(n, "class", "a5e-footer-group__input svelte-wuitj9"), b(n, "type", "number"), b(n, "name", "system.attributes.casterLevel"), n.value = l = /*$actor*/
      i[2].system.attributes.casterLevel, b(n, "placeholder", "0"), b(n, "min", "0"), Q(n, "disable-pointer-events", !/*$actor*/
      i[2].isOwner || /*sheetIsLocked*/
      i[0]), b(e, "class", "u-flex u-flex-wrap u-align-center u-gap-md");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(e, s), A(e, n), r || (o = V(
        n,
        "change",
        /*change_handler_2*/
        i[21]
      ), r = !0);
    },
    p(a, c) {
      c & /*$actor*/
      4 && l !== (l = /*$actor*/
      a[2].system.attributes.casterLevel) && n.value !== l && (n.value = l), c & /*$actor, sheetIsLocked*/
      5 && Q(n, "disable-pointer-events", !/*$actor*/
      a[2].isOwner || /*sheetIsLocked*/
      a[0]);
    },
    d(a) {
      a && S(e), r = !1, o();
    }
  };
}
f(_F, "create_if_block$X");
function wre(i) {
  var a, c;
  let e, t = (
    /*$actor*/
    ((c = (a = i[2].spellBooks) == null ? void 0 : a.get(
      /*currentSpellBook*/
      i[3]
    )) == null ? void 0 : c.showSpellPoints) ?? !1
  ), s, n, l = (
    /*preparedSpellCount*/
    i[6] && gF(i)
  ), r = t && bF(i), o = (
    /*$actor*/
    i[2].type === "npc" && _F(i)
  );
  return {
    c() {
      l && l.c(), e = R(), r && r.c(), s = R(), o && o.c(), n = $e();
    },
    m(u, d) {
      l && l.m(u, d), T(u, e, d), r && r.m(u, d), T(u, s, d), o && o.m(u, d), T(u, n, d);
    },
    p(u, d) {
      var p, m;
      /*preparedSpellCount*/
      u[6] ? l ? l.p(u, d) : (l = gF(u), l.c(), l.m(e.parentNode, e)) : l && (l.d(1), l = null), d & /*$actor, currentSpellBook*/
      12 && (t = /*$actor*/
      ((m = (p = u[2].spellBooks) == null ? void 0 : p.get(
        /*currentSpellBook*/
        u[3]
      )) == null ? void 0 : m.showSpellPoints) ?? !1), t ? r ? r.p(u, d) : (r = bF(u), r.c(), r.m(s.parentNode, s)) : r && (r.d(1), r = null), /*$actor*/
      u[2].type === "npc" ? o ? o.p(u, d) : (o = _F(u), o.c(), o.m(n.parentNode, n)) : o && (o.d(1), o = null);
    },
    d(u) {
      u && (S(e), S(s), S(n)), l && l.d(u), r && r.d(u), o && o.d(u);
    }
  };
}
f(wre, "create_default_slot$L");
function $re(i) {
  let e, t, s, n, l, r = (!/*sheetIsLocked*/
  i[0] || [.../*spellBooks*/
  i[5]].length > 1) && uF(i), o = (
    /*currentSpellBook*/
    i[3] && /*$spells*/
    i[7]._books[
      /*currentSpellBook*/
      i[3]
    ] && mF(i)
  );
  return s = new jc({
    props: {
      $$slots: { default: [wre] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      r && r.c(), e = R(), o && o.c(), t = R(), n = E("div"), L(s.$$.fragment), z(n, "display", "contents"), z(n, "--padding-right", "1rem");
    },
    m(a, c) {
      r && r.m(a, c), T(a, e, c), o && o.m(a, c), T(a, t, c), T(a, n, c), N(s, n, null), l = !0;
    },
    p(a, [c]) {
      !/*sheetIsLocked*/
      a[0] || [.../*spellBooks*/
      a[5]].length > 1 ? r ? r.p(a, c) : (r = uF(a), r.c(), r.m(e.parentNode, e)) : r && (r.d(1), r = null), /*currentSpellBook*/
      a[3] && /*$spells*/
      a[7]._books[
        /*currentSpellBook*/
        a[3]
      ] ? o ? (o.p(a, c), c & /*currentSpellBook, $spells*/
      136 && w(o, 1)) : (o = mF(a), o.c(), w(o, 1), o.m(t.parentNode, t)) : o && (ce(), C(o, 1, 1, () => {
        o = null;
      }), ue());
      const u = {};
      c & /*$$scope, $actor, sheetIsLocked, spellPointMax, spellResources, currentSpellBook, preparedSpellCount*/
      268435551 && (u.$$scope = { dirty: c, ctx: a }), s.$set(u);
    },
    i(a) {
      l || (w(o), w(s.$$.fragment, a), l = !0);
    },
    o(a) {
      C(o), C(s.$$.fragment, a), l = !1;
    },
    d(a) {
      a && (S(e), S(t)), r && r.d(a), o && o.d(a), a && s && S(n), j(s, a);
    }
  };
}
f($re, "create_fragment$1M");
function Are(i, e, t) {
  var G, U;
  let s, n, l, r, o, a, c;
  const u = fe("actor");
  pe(i, u, (q) => t(2, c = q));
  let { spells: d } = u;
  pe(i, d, (q) => t(7, a = q));
  async function p() {
    const q = Object.keys(c.system.spellBooks ?? {}).length, W = await c.spellBooks.add({});
    d.initialize(), q === 0 ? _(W) : t(3, v), m(W);
  }
  f(p, "addSpellBook");
  async function m(q) {
    await new gn(c, "Configure Spell Book", ok, { spellBookId: q }).render(!0);
  }
  f(m, "configureSpellbook");
  async function g(q) {
    var J;
    const W = Object.keys(c.system.spellBooks ?? {}).length, X = new ak();
    await X.render(!0);
    const { confirmDeletion: te } = await X.promise;
    if (te && (c.spellBooks.remove(q), W === 1 && _(null), v === q)) {
      const re = (J = Object.keys(c.system.spellBooks ?? {})) == null ? void 0 : J[0];
      _(re);
    }
  }
  f(g, "deleteSpellbook");
  function h() {
    return c.type !== "character" || l ? s.points.max : s.points.override;
  }
  f(h, "getMaxSpellPoints");
  function _(q) {
    const { uuid: W } = c;
    t(3, v = q), li.update((X) => ({
      ...X,
      [W]: {
        ...X[W] ?? {},
        currentSpellBook: q
      }
    }));
  }
  f(_, "updateCurrentSpellBook");
  function y(q) {
    const W = c.type === "character" ? "system.spellResources.points.override" : "system.spellResources.points.max";
    se(c, W, q);
  }
  f(y, "updateSpellPointMax");
  let k = {};
  li.subscribe((q) => {
    k = q;
  });
  let v = ((G = k[c == null ? void 0 : c.uuid]) == null ? void 0 : G.currentSpellBook) ?? ((U = Object.keys(c.system.spellBooks ?? {})) == null ? void 0 : U[0]);
  a._books[v] || d.initialize();
  const O = /* @__PURE__ */ f((q) => m(q), "click_handler"), P = /* @__PURE__ */ f((q) => g(q), "click_handler_1"), D = /* @__PURE__ */ f((q) => _(q), "click_handler_2"), I = /* @__PURE__ */ f(() => p(), "click_handler_3"), B = /* @__PURE__ */ f(({ target: q }) => se(c, q.name, Number(q.value)), "change_handler"), F = /* @__PURE__ */ f(({ target: q }) => y(Number(q.value)), "change_handler_1"), H = /* @__PURE__ */ f(({ target: q }) => se(c, q.name, Number(q.value)), "change_handler_2");
  return i.$$.update = () => {
    var q, W;
    i.$$.dirty & /*$actor*/
    4 && t(1, s = c.system.spellResources), i.$$.dirty & /*$actor*/
    4 && t(6, n = c.items.filter((X) => !(X.type !== "spell" || !X.system.prepared || X.system.prepared === CONFIG.A5E.PREPARED_STATES.ALWAYS_PREPARED)).length), i.$$.dirty & /*$actor*/
    4 && t(0, l = c.isOwner ? ((W = (q = c.flags) == null ? void 0 : q.a5e) == null ? void 0 : W.sheetIsLocked) ?? !0 : !0), i.$$.dirty & /*$actor*/
    4 && t(5, r = c.spellBooks), i.$$.dirty & /*spellResources, sheetIsLocked*/
    3 && t(4, o = h());
  }, [
    l,
    s,
    c,
    v,
    o,
    r,
    n,
    a,
    u,
    d,
    p,
    m,
    g,
    _,
    y,
    O,
    P,
    D,
    I,
    B,
    F,
    H
  ];
}
f(Are, "instance$1D");
const OT = class OT extends ie {
  constructor(e) {
    super(), le(this, e, Are, $re, ne, {});
  }
};
f(OT, "ActorSpellsPage");
let uk = OT;
function Ere(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("li"), b(e, "class", t = "a5e-nav-item " + /*icon*/
      i[2]), b(e, "data-tooltip", s = K(
        /*label*/
        i[3]
      )), b(e, "data-tooltip-direction", "UP"), Q(
        e,
        "a5e-nav-item--active",
        /*name*/
        i[1] === /*currentTab*/
        i[0].name
      );
    },
    m(r, o) {
      T(r, e, o), n || (l = V(
        e,
        "click",
        /*click_handler*/
        i[5]
      ), n = !0);
    },
    p(r, [o]) {
      o & /*icon*/
      4 && t !== (t = "a5e-nav-item " + /*icon*/
      r[2]) && b(e, "class", t), o & /*label*/
      8 && s !== (s = K(
        /*label*/
        r[3]
      )) && b(e, "data-tooltip", s), o & /*icon, name, currentTab*/
      7 && Q(
        e,
        "a5e-nav-item--active",
        /*name*/
        r[1] === /*currentTab*/
        r[0].name
      );
    },
    i: ee,
    o: ee,
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(Ere, "create_fragment$1L");
function Sre(i, e, t) {
  let { currentTab: s } = e, { name: n } = e, { icon: l } = e, { label: r } = e;
  const o = it(), a = /* @__PURE__ */ f(() => o("tab-change", n), "click_handler");
  return i.$$set = (c) => {
    "currentTab" in c && t(0, s = c.currentTab), "name" in c && t(1, n = c.name), "icon" in c && t(2, l = c.icon), "label" in c && t(3, r = c.label);
  }, [s, n, l, r, o, a];
}
f(Sre, "instance$1C");
const DT = class DT extends ie {
  constructor(e) {
    super(), le(this, e, Sre, Ere, ne, {
      currentTab: 0,
      name: 1,
      icon: 2,
      label: 3
    });
  }
};
f(DT, "NewNavigationItem");
let fk = DT;
function yF(i, e, t) {
  const s = i.slice();
  return s[9] = e[t].name, s[10] = e[t].display, s[11] = e[t].icon, s[12] = e[t].label, s;
}
f(yF, "get_each_context$A");
function vF(i, e, t) {
  const s = i.slice();
  return s[9] = e[t].name, s[12] = e[t].label, s;
}
f(vF, "get_each_context_1$6");
function kF(i) {
  let e, t = K(
    /*label*/
    i[12]
  ) + "", s;
  return {
    c() {
      e = E("span"), s = x(t), b(e, "class", "a5e-nav__current-tab-label"), Q(
        e,
        "a5e-nav__current-tab-label--active",
        /*name*/
        i[9] === /*currentTab*/
        i[0].name
      );
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*tabs*/
      2 && t !== (t = K(
        /*label*/
        n[12]
      ) + "") && _e(s, t), l & /*tabs, currentTab*/
      3 && Q(
        e,
        "a5e-nav__current-tab-label--active",
        /*name*/
        n[9] === /*currentTab*/
        n[0].name
      );
    },
    d(n) {
      n && S(e);
    }
  };
}
f(kF, "create_each_block_1$6");
function wF(i) {
  let e, t;
  return e = new fk({
    props: {
      icon: (
        /*icon*/
        i[11]
      ),
      label: (
        /*label*/
        i[12]
      ),
      name: (
        /*name*/
        i[9]
      ),
      currentTab: (
        /*currentTab*/
        i[0]
      )
    }
  }), e.$on(
    "tab-change",
    /*tab_change_handler*/
    i[7]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*tabs*/
      2 && (l.icon = /*icon*/
      s[11]), n & /*tabs*/
      2 && (l.label = /*label*/
      s[12]), n & /*tabs*/
      2 && (l.name = /*name*/
      s[9]), n & /*currentTab*/
      1 && (l.currentTab = /*currentTab*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(wF, "create_if_block_1$G");
function $F(i) {
  let e, t, s = (
    /*display*/
    (i[10] ?? !0) && wF(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*display*/
      n[10] ?? !0 ? s ? (s.p(n, l), l & /*tabs*/
      2 && w(s, 1)) : (s = wF(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ce(), C(s, 1, 1, () => {
        s = null;
      }), ue());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f($F, "create_each_block$A");
function AF(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("li"), b(e, "class", t = "a5e-nav-item a5e-nav-item--lock fa-solid " + /*sheetIsLocked*/
      (i[4] ? "fa-lock" : "fa-unlock")), b(e, "data-tooltip", "Toggle Sheet Lock"), b(e, "data-tooltip-direction", "UP"), Q(
        e,
        "a5e-nav-item--active",
        /*sheetIsLocked*/
        i[4]
      );
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "click",
        /*click_handler*/
        i[8]
      ), s = !0);
    },
    p(l, r) {
      r & /*sheetIsLocked*/
      16 && t !== (t = "a5e-nav-item a5e-nav-item--lock fa-solid " + /*sheetIsLocked*/
      (l[4] ? "fa-lock" : "fa-unlock")) && b(e, "class", t), r & /*sheetIsLocked, sheetIsLocked*/
      16 && Q(
        e,
        "a5e-nav-item--active",
        /*sheetIsLocked*/
        l[4]
      );
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(AF, "create_if_block$W");
function Tre(i) {
  let e, t, s, n, l, r = oe(
    /*tabs*/
    i[1]
  ), o = [];
  for (let p = 0; p < r.length; p += 1)
    o[p] = kF(vF(i, r, p));
  let a = oe(
    /*tabs*/
    i[1]
  ), c = [];
  for (let p = 0; p < a.length; p += 1)
    c[p] = $F(yF(i, a, p));
  const u = /* @__PURE__ */ f((p) => C(c[p], 1, 1, () => {
    c[p] = null;
  }), "out");
  let d = (
    /*showLock*/
    i[2] && /*$actor*/
    i[3].permission !== /*observerPermissionsLevel*/
    i[6] && AF(i)
  );
  return {
    c() {
      e = E("nav");
      for (let p = 0; p < o.length; p += 1)
        o[p].c();
      t = R(), s = E("ul");
      for (let p = 0; p < c.length; p += 1)
        c[p].c();
      n = R(), d && d.c(), b(s, "class", "a5e-nav-list"), b(e, "class", "a5e-nav"), Q(
        e,
        "a5e-nav--flat-bottom",
        /*currentTab*/
        i[0].hasSubNavigation
      );
    },
    m(p, m) {
      T(p, e, m);
      for (let g = 0; g < o.length; g += 1)
        o[g] && o[g].m(e, null);
      A(e, t), A(e, s);
      for (let g = 0; g < c.length; g += 1)
        c[g] && c[g].m(s, null);
      A(s, n), d && d.m(s, null), l = !0;
    },
    p(p, [m]) {
      if (m & /*tabs, currentTab*/
      3) {
        r = oe(
          /*tabs*/
          p[1]
        );
        let g;
        for (g = 0; g < r.length; g += 1) {
          const h = vF(p, r, g);
          o[g] ? o[g].p(h, m) : (o[g] = kF(h), o[g].c(), o[g].m(e, t));
        }
        for (; g < o.length; g += 1)
          o[g].d(1);
        o.length = r.length;
      }
      if (m & /*tabs, currentTab*/
      3) {
        a = oe(
          /*tabs*/
          p[1]
        );
        let g;
        for (g = 0; g < a.length; g += 1) {
          const h = yF(p, a, g);
          c[g] ? (c[g].p(h, m), w(c[g], 1)) : (c[g] = $F(h), c[g].c(), w(c[g], 1), c[g].m(s, n));
        }
        for (ce(), g = a.length; g < c.length; g += 1)
          u(g);
        ue();
      }
      /*showLock*/
      p[2] && /*$actor*/
      p[3].permission !== /*observerPermissionsLevel*/
      p[6] ? d ? d.p(p, m) : (d = AF(p), d.c(), d.m(s, null)) : d && (d.d(1), d = null), (!l || m & /*currentTab*/
      1) && Q(
        e,
        "a5e-nav--flat-bottom",
        /*currentTab*/
        p[0].hasSubNavigation
      );
    },
    i(p) {
      if (!l) {
        for (let m = 0; m < a.length; m += 1)
          w(c[m]);
        l = !0;
      }
    },
    o(p) {
      c = c.filter(Boolean);
      for (let m = 0; m < c.length; m += 1)
        C(c[m]);
      l = !1;
    },
    d(p) {
      p && S(e), Le(o, p), Le(c, p), d && d.d();
    }
  };
}
f(Tre, "create_fragment$1K");
function Cre(i, e, t) {
  let s, n, { currentTab: l } = e, { tabs: r } = e, { showLock: o = !1 } = e;
  const a = fe("actor");
  pe(i, a, (p) => t(3, n = p));
  const c = CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER;
  function u(p) {
    gt.call(this, i, p);
  }
  f(u, "tab_change_handler");
  const d = /* @__PURE__ */ f(({ target: p }) => {
    RB(n), p.blur();
  }, "click_handler");
  return i.$$set = (p) => {
    "currentTab" in p && t(0, l = p.currentTab), "tabs" in p && t(1, r = p.tabs), "showLock" in p && t(2, o = p.showLock);
  }, i.$$.update = () => {
    var p, m;
    i.$$.dirty & /*$actor*/
    8 && t(4, s = n.isOwner ? ((m = (p = n.flags) == null ? void 0 : p.a5e) == null ? void 0 : m.sheetIsLocked) ?? !0 : !0);
  }, [
    l,
    r,
    o,
    n,
    s,
    a,
    c,
    u,
    d
  ];
}
f(Cre, "instance$1B");
const IT = class IT extends ie {
  constructor(e) {
    super(), le(this, e, Cre, Tre, ne, { currentTab: 0, tabs: 1, showLock: 2 });
  }
};
f(IT, "NewNavigationBar");
let dk = IT;
function Ore(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p;
  t = new lk({}), l = new Xv({}), o = new dk({
    props: {
      currentTab: (
        /*currentTab*/
        i[3]
      ),
      tabs: (
        /*tabs*/
        i[2]
      ),
      showLock: !0
    }
  }), o.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[4]
  );
  var m = (
    /*currentTab*/
    i[3].component
  );
  function g(h, _) {
    return {};
  }
  return f(g, "switch_props"), m && (c = nt(m, g())), {
    c() {
      e = E("main"), L(t.$$.fragment), s = R(), n = E("section"), L(l.$$.fragment), r = R(), L(o.$$.fragment), a = R(), c && L(c.$$.fragment), b(n, "class", "main-container svelte-150xh4e"), b(e, "class", "svelte-150xh4e");
    },
    m(h, _) {
      T(h, e, _), N(t, e, null), A(e, s), A(e, n), N(l, n, null), A(n, r), N(o, n, null), A(n, a), c && N(c, n, null), u = !0, d || (p = V(e, "drop", We(tt(
        /*drop_handler*/
        i[9]
      ))), d = !0);
    },
    p(h, _) {
      const y = {};
      if (_ & /*currentTab*/
      8 && (y.currentTab = /*currentTab*/
      h[3]), _ & /*tabs*/
      4 && (y.tabs = /*tabs*/
      h[2]), o.$set(y), _ & /*currentTab*/
      8 && m !== (m = /*currentTab*/
      h[3].component)) {
        if (c) {
          ce();
          const k = c;
          C(k.$$.fragment, 1, 0, () => {
            j(k, 1);
          }), ue();
        }
        m ? (c = nt(m, g()), L(c.$$.fragment), w(c.$$.fragment, 1), N(c, n, null)) : c = null;
      }
    },
    i(h) {
      u || (w(t.$$.fragment, h), w(l.$$.fragment, h), w(o.$$.fragment, h), c && w(c.$$.fragment, h), u = !0);
    },
    o(h) {
      C(t.$$.fragment, h), C(l.$$.fragment, h), C(o.$$.fragment, h), c && C(c.$$.fragment, h), u = !1;
    },
    d(h) {
      h && S(e), j(t), j(l), j(o), c && j(c), d = !1, p();
    }
  };
}
f(Ore, "create_default_slot$K");
function Dre(i) {
  let e, t, s;
  function n(r) {
    i[10](r);
  }
  f(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [Ore] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Ss({ props: l }), st.push(() => mt(e, "elementRoot", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, sheet, currentTab, tabs*/
        16398 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(Dre, "create_fragment$1J");
function Ire(i, e, t) {
  let s;
  const n = fe("#external");
  let { document: l, sheet: r } = n, { document: o = l, sheet: a = r } = e, { elementRoot: c } = e;
  function u(v) {
    const { uuid: O } = s, P = (v == null ? void 0 : v.detail) ?? "core";
    t(3, _ = h.find((D) => D.name === P) ?? h[0]), li.update((D) => ({
      ...D,
      [O]: { currentTab: (v == null ? void 0 : v.detail) ?? "core" }
    }));
  }
  f(u, "updateCurrentTab");
  function d(v) {
    var O, P, D, I, B, F;
    return [
      {
        name: "core",
        label: "A5E.TabCore",
        icon: "fa-solid fa-home",
        component: Ov
      },
      {
        name: "skills",
        label: "A5E.TabSkills",
        icon: "fa-solid fa-graduation-cap",
        component: ip,
        display: ((P = (O = v.flags) == null ? void 0 : O.a5e) == null ? void 0 : P.showFavoritesSection) ?? !0
      },
      {
        name: "inventory",
        label: "A5E.TabInventory",
        icon: "fa-solid fa-box-open",
        component: Rv
      },
      {
        name: "features",
        label: "A5E.TabFeatures",
        icon: "fa-solid fa-table-list",
        component: Iv
      },
      {
        name: "maneuvers",
        label: "A5E.TabManeuvers",
        icon: "fa-solid fa-hand-fist",
        component: Fv,
        display: (I = (D = v.flags) == null ? void 0 : D.a5e) == null ? void 0 : I.showManeuverTab
      },
      {
        name: "spells",
        label: "A5E.TabSpells",
        icon: "fa-solid fa-wand-sparkles",
        component: uk,
        display: (F = (B = v.flags) == null ? void 0 : B.a5e) == null ? void 0 : F.showSpellTab
      },
      // {
      //     name: "biography",
      //     label: "A5E.TabBiography",
      //     component: ActorBioPage,
      //     display: actor.type === "character",
      // },
      {
        name: "notes",
        label: "A5E.TabNotes",
        icon: "fa-solid fa-file-lines",
        component: jv,
        hasSubNavigation: !0
      },
      {
        name: "bonuses",
        label: "Bonuses",
        icon: "fa-solid fa-angles-up",
        component: wv
      },
      {
        name: "effects",
        label: "A5E.TabEffects",
        icon: "fa-solid fa-person-rays",
        component: Dv
      },
      {
        name: "settings",
        label: "A5E.TabSettings",
        icon: "fas fa-gear",
        component: Uv,
        hasSubNavigation: !0,
        display: !v.pack && v.permission !== CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER.OBSERVER
      }
    ];
  }
  f(d, "getTabs");
  let p = {};
  const m = li.subscribe((v) => {
    p = v;
  }), g = o;
  pe(i, g, (v) => t(8, s = v));
  let h = d(s), _ = h.find((v) => {
    var O;
    return v.name === ((O = p[s == null ? void 0 : s.uuid]) == null ? void 0 : O.currentTab);
  }) ?? h[0];
  et("actor", g), et("sheet", a), Nt(() => {
    m();
  });
  const y = /* @__PURE__ */ f((v) => a._onDrop(v), "drop_handler");
  function k(v) {
    c = v, t(0, c);
  }
  return f(k, "applicationshell_elementRoot_binding"), i.$$set = (v) => {
    "document" in v && t(7, o = v.document), "sheet" in v && t(1, a = v.sheet), "elementRoot" in v && t(0, c = v.elementRoot);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    256 && t(2, h = d(s));
  }, [
    c,
    a,
    h,
    _,
    u,
    g,
    n,
    o,
    s,
    y,
    k
  ];
}
f(Ire, "instance$1A");
var pf;
let Pre = (pf = class extends ie {
  constructor(e) {
    super(), le(this, e, Ire, Dre, ne, {
      application: 6,
      document: 7,
      sheet: 1,
      elementRoot: 0
    });
  }
  get application() {
    return this.$$.ctx[6];
  }
  get document() {
    return this.$$.ctx[7];
  }
  set document(e) {
    this.$$set({ document: e }), Ke();
  }
  get sheet() {
    return this.$$.ctx[1];
  }
  set sheet(e) {
    this.$$set({ sheet: e }), Ke();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Ke();
  }
}, f(pf, "ActorSheet"), pf);
function Mre(i) {
  let e, t, s;
  return {
    c() {
      e = E("hr"), t = R(), s = E("div"), b(e, "class", "a5e-rule u-ml-xl u-mr-xl"), b(s, "class", "description-wrapper svelte-167cm64");
    },
    m(n, l) {
      T(n, e, l), T(n, t, l), T(n, s, l), s.innerHTML = /*description*/
      i[3];
    },
    p: ee,
    d(n) {
      n && (S(e), S(t), S(s));
    }
  };
}
f(Mre, "create_if_block$V");
function Rre(i) {
  let e, t, s, n, l, r, o, a, c = (
    /*$document*/
    i[2].name + ""
  ), u, d, p = (
    /*showDescription*/
    i[4] && Mre(i)
  );
  return {
    c() {
      e = E("main"), t = E("div"), s = E("img"), o = R(), a = E("h1"), u = x(c), d = R(), p && p.c(), b(s, "class", "document-image svelte-167cm64"), ze(s.src, n = /*$document*/
      i[2].img) || b(s, "src", n), b(s, "alt", l = /*$document*/
      i[2].name), b(s, "title", r = /*$document*/
      i[2].name), b(t, "class", "image-wrapper svelte-167cm64"), b(a, "class", "document-name svelte-167cm64"), b(e, "class", "svelte-167cm64");
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(t, s), A(e, o), A(e, a), A(a, u), A(e, d), p && p.m(e, null);
    },
    p(m, g) {
      g & /*$document*/
      4 && !ze(s.src, n = /*$document*/
      m[2].img) && b(s, "src", n), g & /*$document*/
      4 && l !== (l = /*$document*/
      m[2].name) && b(s, "alt", l), g & /*$document*/
      4 && r !== (r = /*$document*/
      m[2].name) && b(s, "title", r), g & /*$document*/
      4 && c !== (c = /*$document*/
      m[2].name + "") && _e(u, c), /*showDescription*/
      m[4] && p.p(m, g);
    },
    d(m) {
      m && S(e), p && p.d();
    }
  };
}
f(Rre, "create_default_slot$J");
function Fre(i) {
  let e, t, s;
  function n(r) {
    i[6](r);
  }
  f(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [Rre] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Ss({ props: l }), st.push(() => mt(e, "elementRoot", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, $document*/
        132 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(Fre, "create_fragment$1I");
function Nre(i, e, t) {
  let s, n = ee, l = /* @__PURE__ */ f(() => (n(), n = Et(a, (g) => t(2, s = g)), a), "$$subscribe_document");
  i.$$.on_destroy.push(() => n());
  let { document: r, sheet: o } = fe("#external").application, { document: a = r, sheet: c = o } = e;
  l();
  let { elementRoot: u } = e;
  const d = s.system.unidentified ? s.system.unidentifiedDescription : s.system.description, p = d != null && d.length ? game.settings.get("a5e", "showDescriptionOnLimitedPerms") ?? !1 : !1;
  function m(g) {
    u = g, t(0, u);
  }
  return f(m, "applicationshell_elementRoot_binding"), i.$$set = (g) => {
    "document" in g && l(t(1, a = g.document)), "sheet" in g && t(5, c = g.sheet), "elementRoot" in g && t(0, u = g.elementRoot);
  }, [
    u,
    a,
    s,
    d,
    p,
    c,
    m
  ];
}
f(Nre, "instance$1z");
const PT = class PT extends ie {
  constructor(e) {
    super(), le(this, e, Nre, Fre, ne, { document: 1, sheet: 5, elementRoot: 0 });
  }
  get document() {
    return this.$$.ctx[1];
  }
  set document(e) {
    this.$$set({ document: e }), Ke();
  }
  get sheet() {
    return this.$$.ctx[5];
  }
  set sheet(e) {
    this.$$set({ sheet: e }), Ke();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Ke();
  }
};
f(PT, "LimitedSheet");
let cp = PT;
function _n(i) {
  if (!i)
    return null;
  let e = `<header class="a5e-tooltip__heading a5e-tooltip__heading--source">${i.title}</header>`;
  return i.affiliate && (e += ' <small class="a5e-tooltip__note">Note: This is an affiliate link.</small>'), e;
}
f(_n, "getDocumentSourceTooltip");
var Jg, XB, Zg, JB, Qg, ZB, xg, QB, e1, xB, t1, eq, mf;
let Pb = (mf = class extends _s {
  /**
   * @inheritDoc
   */
  constructor(t, s = {}) {
    var n;
    s.svelte ?? (s.svelte = {}), [
      CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE,
      CONST.DOCUMENT_OWNERSHIP_LEVELS.LIMITED
    ].includes(t.permission) ? (s.classes = ["a5e-sheet", "a5e-actor-sheet", "a5e-actor-sheet--limited"], s.svelte.class = cp, s.width = 512, s.resizable = !1) : (s.svelte.class = Pre, s.width = 755, s.height = 706, s.resizable = !0);
    super(foundry.utils.mergeObject(
      s,
      {
        baseApplication: "ActorSheet",
        id: `actor-sheet-${t.isToken ? (n = t.parent) == null ? void 0 : n.id : t.id}`,
        title: t.name,
        token: null,
        svelte: {
          props: {
            document: null
          }
        }
      }
    ));
    // eslint-disable-next-line no-unused-vars, no-empty-function, @typescript-eslint/no-unused-vars
    Y(this, Jg);
    Y(this, Zg);
    Y(this, Qg);
    Y(this, xg);
    Y(this, e1);
    Y(this, t1);
    Ge(this, "actor");
    Ge(this, "tempSettings");
    this.actor = t.isToken ? t.parent.actor : t, this.options.svelte.props.document = new kv(
      this.actor,
      { delete: this.close.bind(this) }
    ), this.options.svelte.props.sheet = this, this.tempSettings = {}, li.subscribe((l) => {
      this.tempSettings = l;
    }), this.position.subscribe((l) => this.setPosition(l, !1));
  }
  /**
   * Default Application options
   *
   * @returns {object} options - Application options.
   * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      baseApplication: "ActorSheet",
      classes: ["a5e-sheet", "a5e-actor-sheet"],
      minimizable: !0,
      svelte: {
        target: document.body
      },
      token: null
    });
  }
  get object() {
    return this.actor;
  }
  get token() {
    var t;
    return ((t = this.options) == null ? void 0 : t.token) || this.actor.token || null;
  }
  setPosition(t, s = !0) {
    return s ? super.setPosition(t) : this.position.get();
  }
  _getHeaderButtons() {
    var o;
    const t = super._getHeaderButtons(), s = {
      isGM: game.user.isGM,
      isOwner: this.actor.isOwner,
      canConfigure: game.user.can("TOKEN_CONFIGURE"),
      isPack: this.actor.pack
    };
    (s.isGM || s.isOwner && s.canConfigure) && t.unshift({
      label: this.options.token ? "Token" : "Prototype Token",
      class: "configure-token",
      icon: "fas fa-user-circle",
      onclick: (a) => this._onConfigureToken(a)
    }), s.isPack || t.unshift({
      label: "Sheet Configuration",
      class: "configure-sheet",
      icon: "fas fa-cog fa-fw",
      title: "Configure Sheet",
      onclick: (a) => this._onConfigureSheet(a)
    }), ((o = game.modules.get("warpgate")) == null ? void 0 : o.active) && !s.isPack && (s.isGM || s.isOwner && s.canConfigure) && (/* @__PURE__ */ f((c) => !(!(c instanceof TokenDocument) || warpgate.mutationStack(c).stack.length === 0), "shouldAddRevert"))(this.token) && t.unshift({
      label: "Revert",
      class: "revert-wrapgate",
      icon: "fas fa-undo-alt",
      title: "Revert",
      onclick: async (c) => {
        var g, h;
        const u = /* @__PURE__ */ f((_) => game.settings.get("warpgate", "revertButtonBehavior") === "menu" ? !_ : _, "shouldShow"), d = (h = (g = this.token) == null ? void 0 : g.actor) == null ? void 0 : h.getFlag("warpgate", "mutate");
        let p;
        if (u(c.shiftKey)) {
          const _ = d.map((y) => ({ label: y.name, value: y.name }));
          if (p = await warpgate.buttonDialog(
            { warpButtons: _, title: K("warpgate.display.revertDialogTitle") },
            "column"
          ), p === !1)
            return;
        }
        warpgate.revert(this.token), this == null || this.render(!1);
      }
    }), s.isPack && t.unshift({
      label: "Import",
      class: "import",
      icon: "fas fa-download",
      onclick: (a) => this._onImport(a)
    });
    const l = /* @__PURE__ */ new Set(), r = [];
    return t.forEach(({ label: a }, c) => {
      l.has(a) || (l.add(a), r.push(t[c]));
    }), r;
  }
  _onImport(t) {
    return t && t.preventDefault(), this.actor.collection.importFromCompendium(this.actor.compendium, this.actor.id);
  }
  _onConfigureToken(t) {
    return t && t.preventDefault(), this.token ? this.token.sheet.render(!0) : new CONFIG.Token.prototypeSheetClass(this.actor.prototypeToken).render(!0);
  }
  _onConfigureSheet(t) {
    t && t.preventDefault(), new DocumentSheetConfig(this.actor, { top: this.position.top + 40 }).render(!0);
  }
  async _onDrop(t, s = {}) {
    var d, p, m, g, h, _, y, k;
    const n = t.dataTransfer.getData("text/plain");
    if (!n)
      return;
    const l = JSON.parse(n);
    Hooks.callAll("dropActorSheetData", this.actor, this, l);
    const r = (d = this.tempSettings[this.actor.uuid]) == null ? void 0 : d.currentTab, o = ((p = this.tempSettings[this.actor.uuid]) == null ? void 0 : p.currentSpellBook) ?? ((h = Object.keys((g = (m = this.actor) == null ? void 0 : m.system) == null ? void 0 : g.spellBooks)) == null ? void 0 : h[0]);
    if (r !== "inventory" && ((l == null ? void 0 : l.actorId) === ((_ = this.actor) == null ? void 0 : _.id) || (l == null ? void 0 : l.parentId) === ((y = this.actor) == null ? void 0 : y.id)))
      return;
    o && (s.spellBookId = o);
    const { uuid: a, type: c } = l;
    let u = null;
    if (c)
      try {
        u = await ((k = CONFIG[c]) == null ? void 0 : k.documentClass).fromDropData(l);
      } catch {
        u = await fromUuid(a);
      }
    else
      u = await fromUuid(a);
    this._onDropDocument(u, s);
  }
  async _onDropDocument(t, s = {}) {
    t.documentName === "Actor" ? Z(this, Jg, XB).call(this, t) : t.documentName === "Item" ? Z(this, Qg, ZB).call(this, t, s) : t.documentName === "ActiveEffect" && Z(this, Zg, JB).call(this, t);
  }
  /** @inheritdoc */
  async close(t) {
    return this.options.token = null, super.close(t);
  }
  async _render(t = !1, s = {}) {
    var d, p, m, g, h, _;
    await super._render(t, s);
    const l = this.element[0].querySelector(".window-header .window-title");
    if (l.querySelector(".document-id-link"))
      return;
    const o = ((d = this.token) == null ? void 0 : d.id) ?? ((p = this.actor) == null ? void 0 : p.id), a = ((m = this.token) == null ? void 0 : m.uuid) ?? ((g = this.actor) == null ? void 0 : g.uuid), c = CONFIG.A5E.products[(_ = (h = this.actor) == null ? void 0 : h.system) == null ? void 0 : _.source];
    if (c != null && c.abbreviation) {
      const y = document.createElement("a");
      y.classList.add("a5e-document-source-link"), y.setAttribute("alt", c == null ? void 0 : c.title), y.dataset.tooltip = _n(c), y.dataset.tooltipClass = "a5e-tooltip a5e-tooltip--dark a5e-tooltip--document-source", y.dataset.tooltipDirection = "DOWN", y.innerHTML = `<i class="fa-solid fa-book-open"></i> ${c == null ? void 0 : c.abbreviation}`, y.href = c == null ? void 0 : c.url, y.target = "_blank", l.append(y);
    }
    const u = document.createElement("a");
    u.classList.add("document-id-link"), u.setAttribute("alt", "Copy Document ID"), u.dataset.tooltip = "Copy Document ID", u.dataset.tooltipDirection = "DOWN", u.innerHTML = '<i class="fa-solid fa-passport"></i>', u.addEventListener("click", (y) => {
      y.preventDefault(), game.clipboard.copyPlainText(o), ui.notifications.info(game.i18n.format(
        "DOCUMENT.IdCopiedClipboard",
        { label: "Actor", type: "id", id: o }
      ));
    }), u.addEventListener("contextmenu", (y) => {
      y.preventDefault(), game.clipboard.copyPlainText(a), ui.notifications.info(game.i18n.format(
        "DOCUMENT.IdCopiedClipboard",
        { label: "Actor", type: "uuid", id: a }
      ));
    }), l.append(u);
  }
}, Jg = new WeakSet(), XB = /* @__PURE__ */ f(async function(t) {
}, "#onDropActor"), Zg = new WeakSet(), JB = /* @__PURE__ */ f(async function(t) {
  this.actor.createEmbeddedDocuments("ActiveEffect", [t]);
}, "#onDropActiveEffect"), Qg = new WeakSet(), ZB = /* @__PURE__ */ f(async function(t, s = {}) {
  t.type === "destiny" ? Z(this, xg, QB).call(this, t) : t.type === "object" ? Z(this, e1, xB).call(this, t, s) : t.type === "spell" ? Z(this, t1, eq).call(this, t, s) : this.actor.createEmbeddedDocuments("Item", [t]);
}, "#onDropItem"), xg = new WeakSet(), QB = /* @__PURE__ */ f(async function(t) {
  if (this.actor.type !== "character") {
    ui.notifications.warn("Destiny documents cannot be added to NPCs.");
    return;
  }
  await this.actor.setFlag("a5e", "destinyFulfilled", !1);
  const s = [
    t.system.sourceOfInspiration,
    t.system.inspirationFeature
  ], n = (await Promise.all(s.map((l) => fromUuid(l)))).filter((l) => l);
  await this.actor.createEmbeddedDocuments("Item", [
    t,
    ...n
  ]);
}, "#onDropDestiny"), e1 = new WeakSet(), xB = /* @__PURE__ */ f(async function(t, s) {
  var l, r, o, a;
  if (t.system.objectType === "container" && ((l = t.parent) == null ? void 0 : l.id) !== this.actor.id) {
    const c = await Dr.createContainerOnActor(this.actor, t);
    c && s.containerUuid && c.updateContainer(s.containerUuid ?? "");
    return;
  }
  if (((r = t == null ? void 0 : t.parent) == null ? void 0 : r.id) === this.actor.id) {
    t.updateContainer(s.containerUuid ?? "");
    return;
  }
  const n = t.toObject();
  n.system.containerId = s.containerUuid ?? "", (a = (o = await this.actor.createEmbeddedDocuments("Item", [n])) == null ? void 0 : o[0]) == null || a.updateContainer(s.containerUuid ?? "");
}, "#onDropObject"), t1 = new WeakSet(), eq = /* @__PURE__ */ f(async function(t, s) {
  var g, h;
  if (((g = this.tempSettings[this.actor.uuid]) == null ? void 0 : g.currentTab) !== "inventory") {
    const { spellBookId: _ } = s;
    if (_) {
      const y = this.actor.spellBooks.get(_);
      y == null || y.addSpell(t);
    } else
      ui.notifications.error("No spell book detected.");
    return;
  }
  const l = t.system.level, {
    attackBonus: r,
    cost: o,
    craftingComponent: a,
    saveDC: c,
    rarity: u
  } = CONFIG.A5E.scrollData[l], d = {
    name: `Spell Scroll (${t.name})`,
    img: "icons/sundries/scrolls/scroll-writing-brown-gold.webp",
    type: "object",
    system: {
      actions: {},
      craftingComponents: a,
      description: t.system.description,
      price: o,
      objectType: "consumable",
      rarity: u
    }
  };
  d.system.actions = t.actions.values().reduce((_, y) => {
    const k = { ...y };
    return k.prompts = Object.entries(
      (k == null ? void 0 : k.prompts) ?? {}
    ).reduce((v, [O, P]) => {
      const D = { ...P };
      return D.type === "savingThrow" && (D.saveDC.type = "custom", D.saveDC.bonus = c), v[O] = D, v;
    }, {}), k.rolls = Object.entries(
      (k == null ? void 0 : k.rolls) ?? {}
    ).reduce((v, [O, P]) => {
      const D = { ...P };
      return D.type === "attack" && (D.ability = "none", D.bonus = r.toString(10)), D.scaling && delete D.scaling, v[O] = D, v;
    }, {}), k.consumers = {
      [foundry.utils.randomID()]: {
        itemId: "",
        quantity: 1,
        type: "quantity"
      }
    }, _[foundry.utils.randomID()] = k, _;
  }, {});
  const p = (h = await this.actor.createEmbeddedDocuments("Item", [d])) == null ? void 0 : h[0];
  if (!p)
    return;
  const m = {};
  Object.entries(p.system.actions).forEach(([_, y]) => {
    Object.entries(y.consumers ?? {}).forEach(([k]) => {
      m[`system.actions.${_}.consumers.${k}.itemId`] = p.id;
    });
  }), p.update(m);
}, "#onDropSpell"), f(mf, "ActorSheet"), mf);
function jre(i) {
  let e, t;
  return e = new hl({
    props: {
      document: (
        /*effect*/
        i[1]
      ),
      content: (
        /*content*/
        i[0]
      ),
      updatePath: "description"
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*content*/
      1 && (l.content = /*content*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(jre, "create_fragment$1H");
function Lre(i, e, t) {
  let s, n;
  const l = fe("effect");
  return pe(i, l, (r) => t(2, n = r)), i.$$.update = () => {
    i.$$.dirty & /*$effect*/
    4 && t(0, s = n.description ?? "");
  }, [s, l, n];
}
f(Lre, "instance$1y");
const MT = class MT extends ie {
  constructor(e) {
    super(), le(this, e, Lre, jre, ne, {});
  }
};
f(MT, "EffectsDescriptionTab");
let pk = MT;
function Bre(i) {
  const e = Object.values(i), t = Object.entries(CONFIG.A5E.effectKeyGroups).reduce(
    (n, [l, { items: r }]) => (r.forEach((o) => {
      n[o] = l;
    }), n),
    {}
  ), s = e.map((n) => {
    var l;
    return {
      label: n.label,
      key: n.effectKey,
      group: K(
        ((l = CONFIG.A5E.effectKeyGroups[t[n.effectKey] ?? "other"]) == null ? void 0 : l.label) ?? "Other"
      )
    };
  });
  return s.sort((n, l) => n.group.localeCompare(l.group)), s;
}
f(Bre, "getEffectOptionGroups");
const up = Math.min, Ar = Math.max, fp = Math.round, Xf = Math.floor, bl = /* @__PURE__ */ f((i) => ({
  x: i,
  y: i
}), "createCoords"), qre = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Gre = {
  start: "end",
  end: "start"
};
function EF(i, e, t) {
  return Ar(i, up(e, t));
}
f(EF, "clamp");
function cb(i, e) {
  return typeof i == "function" ? i(e) : i;
}
f(cb, "evaluate");
function Ir(i) {
  return i.split("-")[0];
}
f(Ir, "getSide");
function ub(i) {
  return i.split("-")[1];
}
f(ub, "getAlignment");
function tq(i) {
  return i === "x" ? "y" : "x";
}
f(tq, "getOppositeAxis");
function sq(i) {
  return i === "y" ? "height" : "width";
}
f(sq, "getAxisLength");
function fb(i) {
  return ["top", "bottom"].includes(Ir(i)) ? "y" : "x";
}
f(fb, "getSideAxis");
function nq(i) {
  return tq(fb(i));
}
f(nq, "getAlignmentAxis");
function zre(i, e, t) {
  t === void 0 && (t = !1);
  const s = ub(i), n = nq(i), l = sq(n);
  let r = n === "x" ? s === (t ? "end" : "start") ? "right" : "left" : s === "start" ? "bottom" : "top";
  return e.reference[l] > e.floating[l] && (r = dp(r)), [r, dp(r)];
}
f(zre, "getAlignmentSides");
function Hre(i) {
  const e = dp(i);
  return [mk(i), e, mk(e)];
}
f(Hre, "getExpandedPlacements");
function mk(i) {
  return i.replace(/start|end/g, (e) => Gre[e]);
}
f(mk, "getOppositeAlignmentPlacement");
function Ure(i, e, t) {
  const s = ["left", "right"], n = ["right", "left"], l = ["top", "bottom"], r = ["bottom", "top"];
  switch (i) {
    case "top":
    case "bottom":
      return t ? e ? n : s : e ? s : n;
    case "left":
    case "right":
      return e ? l : r;
    default:
      return [];
  }
}
f(Ure, "getSideList");
function Vre(i, e, t, s) {
  const n = ub(i);
  let l = Ure(Ir(i), t === "start", s);
  return n && (l = l.map((r) => r + "-" + n), e && (l = l.concat(l.map(mk)))), l;
}
f(Vre, "getOppositeAxisPlacements");
function dp(i) {
  return i.replace(/left|right|bottom|top/g, (e) => qre[e]);
}
f(dp, "getOppositePlacement");
function Wre(i) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...i
  };
}
f(Wre, "expandPaddingObject");
function Kre(i) {
  return typeof i != "number" ? Wre(i) : {
    top: i,
    right: i,
    bottom: i,
    left: i
  };
}
f(Kre, "getPaddingObject");
function pp(i) {
  const {
    x: e,
    y: t,
    width: s,
    height: n
  } = i;
  return {
    width: s,
    height: n,
    top: t,
    left: e,
    right: e + s,
    bottom: t + n,
    x: e,
    y: t
  };
}
f(pp, "rectToClientRect");
function SF(i, e, t) {
  let {
    reference: s,
    floating: n
  } = i;
  const l = fb(e), r = nq(e), o = sq(r), a = Ir(e), c = l === "y", u = s.x + s.width / 2 - n.width / 2, d = s.y + s.height / 2 - n.height / 2, p = s[o] / 2 - n[o] / 2;
  let m;
  switch (a) {
    case "top":
      m = {
        x: u,
        y: s.y - n.height
      };
      break;
    case "bottom":
      m = {
        x: u,
        y: s.y + s.height
      };
      break;
    case "right":
      m = {
        x: s.x + s.width,
        y: d
      };
      break;
    case "left":
      m = {
        x: s.x - n.width,
        y: d
      };
      break;
    default:
      m = {
        x: s.x,
        y: s.y
      };
  }
  switch (ub(e)) {
    case "start":
      m[r] -= p * (t && c ? -1 : 1);
      break;
    case "end":
      m[r] += p * (t && c ? -1 : 1);
      break;
  }
  return m;
}
f(SF, "computeCoordsFromPlacement");
const Yre = /* @__PURE__ */ f(async (i, e, t) => {
  const {
    placement: s = "bottom",
    strategy: n = "absolute",
    middleware: l = [],
    platform: r
  } = t, o = l.filter(Boolean), a = await (r.isRTL == null ? void 0 : r.isRTL(e));
  let c = await r.getElementRects({
    reference: i,
    floating: e,
    strategy: n
  }), {
    x: u,
    y: d
  } = SF(c, s, a), p = s, m = {}, g = 0;
  for (let h = 0; h < o.length; h++) {
    const {
      name: _,
      fn: y
    } = o[h], {
      x: k,
      y: v,
      data: O,
      reset: P
    } = await y({
      x: u,
      y: d,
      initialPlacement: s,
      placement: p,
      strategy: n,
      middlewareData: m,
      rects: c,
      platform: r,
      elements: {
        reference: i,
        floating: e
      }
    });
    u = k ?? u, d = v ?? d, m = {
      ...m,
      [_]: {
        ...m[_],
        ...O
      }
    }, P && g <= 50 && (g++, typeof P == "object" && (P.placement && (p = P.placement), P.rects && (c = P.rects === !0 ? await r.getElementRects({
      reference: i,
      floating: e,
      strategy: n
    }) : P.rects), {
      x: u,
      y: d
    } = SF(c, p, a)), h = -1);
  }
  return {
    x: u,
    y: d,
    placement: p,
    strategy: n,
    middlewareData: m
  };
}, "computePosition$1");
async function iq(i, e) {
  var t;
  e === void 0 && (e = {});
  const {
    x: s,
    y: n,
    platform: l,
    rects: r,
    elements: o,
    strategy: a
  } = i, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: d = "floating",
    altBoundary: p = !1,
    padding: m = 0
  } = cb(e, i), g = Kre(m), _ = o[p ? d === "floating" ? "reference" : "floating" : d], y = pp(await l.getClippingRect({
    element: (t = await (l.isElement == null ? void 0 : l.isElement(_))) == null || t ? _ : _.contextElement || await (l.getDocumentElement == null ? void 0 : l.getDocumentElement(o.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: a
  })), k = d === "floating" ? {
    x: s,
    y: n,
    width: r.floating.width,
    height: r.floating.height
  } : r.reference, v = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(o.floating)), O = await (l.isElement == null ? void 0 : l.isElement(v)) ? await (l.getScale == null ? void 0 : l.getScale(v)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, P = pp(l.convertOffsetParentRelativeRectToViewportRelativeRect ? await l.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: o,
    rect: k,
    offsetParent: v,
    strategy: a
  }) : k);
  return {
    top: (y.top - P.top + g.top) / O.y,
    bottom: (P.bottom - y.bottom + g.bottom) / O.y,
    left: (y.left - P.left + g.left) / O.x,
    right: (P.right - y.right + g.right) / O.x
  };
}
f(iq, "detectOverflow");
const Xre = /* @__PURE__ */ f(function(i) {
  return i === void 0 && (i = {}), {
    name: "flip",
    options: i,
    async fn(e) {
      var t, s;
      const {
        placement: n,
        middlewareData: l,
        rects: r,
        initialPlacement: o,
        platform: a,
        elements: c
      } = e, {
        mainAxis: u = !0,
        crossAxis: d = !0,
        fallbackPlacements: p,
        fallbackStrategy: m = "bestFit",
        fallbackAxisSideDirection: g = "none",
        flipAlignment: h = !0,
        ..._
      } = cb(i, e);
      if ((t = l.arrow) != null && t.alignmentOffset)
        return {};
      const y = Ir(n), k = Ir(o) === o, v = await (a.isRTL == null ? void 0 : a.isRTL(c.floating)), O = p || (k || !h ? [dp(o)] : Hre(o));
      !p && g !== "none" && O.push(...Vre(o, h, g, v));
      const P = [o, ...O], D = await iq(e, _), I = [];
      let B = ((s = l.flip) == null ? void 0 : s.overflows) || [];
      if (u && I.push(D[y]), d) {
        const U = zre(n, r, v);
        I.push(D[U[0]], D[U[1]]);
      }
      if (B = [...B, {
        placement: n,
        overflows: I
      }], !I.every((U) => U <= 0)) {
        var F, H;
        const U = (((F = l.flip) == null ? void 0 : F.index) || 0) + 1, q = P[U];
        if (q)
          return {
            data: {
              index: U,
              overflows: B
            },
            reset: {
              placement: q
            }
          };
        let W = (H = B.filter((X) => X.overflows[0] <= 0).sort((X, te) => X.overflows[1] - te.overflows[1])[0]) == null ? void 0 : H.placement;
        if (!W)
          switch (m) {
            case "bestFit": {
              var G;
              const X = (G = B.map((te) => [te.placement, te.overflows.filter((J) => J > 0).reduce((J, re) => J + re, 0)]).sort((te, J) => te[1] - J[1])[0]) == null ? void 0 : G[0];
              X && (W = X);
              break;
            }
            case "initialPlacement":
              W = o;
              break;
          }
        if (n !== W)
          return {
            reset: {
              placement: W
            }
          };
      }
      return {};
    }
  };
}, "flip$1");
async function Jre(i, e) {
  const {
    placement: t,
    platform: s,
    elements: n
  } = i, l = await (s.isRTL == null ? void 0 : s.isRTL(n.floating)), r = Ir(t), o = ub(t), a = fb(t) === "y", c = ["left", "top"].includes(r) ? -1 : 1, u = l && a ? -1 : 1, d = cb(e, i);
  let {
    mainAxis: p,
    crossAxis: m,
    alignmentAxis: g
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...d
  };
  return o && typeof g == "number" && (m = o === "end" ? g * -1 : g), a ? {
    x: m * u,
    y: p * c
  } : {
    x: p * c,
    y: m * u
  };
}
f(Jre, "convertValueToCoords");
const Zre = /* @__PURE__ */ f(function(i) {
  return i === void 0 && (i = 0), {
    name: "offset",
    options: i,
    async fn(e) {
      var t, s;
      const {
        x: n,
        y: l,
        placement: r,
        middlewareData: o
      } = e, a = await Jre(e, i);
      return r === ((t = o.offset) == null ? void 0 : t.placement) && (s = o.arrow) != null && s.alignmentOffset ? {} : {
        x: n + a.x,
        y: l + a.y,
        data: {
          ...a,
          placement: r
        }
      };
    }
  };
}, "offset$1"), Qre = /* @__PURE__ */ f(function(i) {
  return i === void 0 && (i = {}), {
    name: "shift",
    options: i,
    async fn(e) {
      const {
        x: t,
        y: s,
        placement: n
      } = e, {
        mainAxis: l = !0,
        crossAxis: r = !1,
        limiter: o = {
          fn: (_) => {
            let {
              x: y,
              y: k
            } = _;
            return {
              x: y,
              y: k
            };
          }
        },
        ...a
      } = cb(i, e), c = {
        x: t,
        y: s
      }, u = await iq(e, a), d = fb(Ir(n)), p = tq(d);
      let m = c[p], g = c[d];
      if (l) {
        const _ = p === "y" ? "top" : "left", y = p === "y" ? "bottom" : "right", k = m + u[_], v = m - u[y];
        m = EF(k, m, v);
      }
      if (r) {
        const _ = d === "y" ? "top" : "left", y = d === "y" ? "bottom" : "right", k = g + u[_], v = g - u[y];
        g = EF(k, g, v);
      }
      const h = o.fn({
        ...e,
        [p]: m,
        [d]: g
      });
      return {
        ...h,
        data: {
          x: h.x - t,
          y: h.y - s
        }
      };
    }
  };
}, "shift$1");
function Ra(i) {
  return lq(i) ? (i.nodeName || "").toLowerCase() : "#document";
}
f(Ra, "getNodeName");
function Ks(i) {
  var e;
  return (i == null || (e = i.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
f(Ks, "getWindow");
function zi(i) {
  var e;
  return (e = (lq(i) ? i.ownerDocument : i.document) || window.document) == null ? void 0 : e.documentElement;
}
f(zi, "getDocumentElement");
function lq(i) {
  return i instanceof Node || i instanceof Ks(i).Node;
}
f(lq, "isNode");
function oi(i) {
  return i instanceof Element || i instanceof Ks(i).Element;
}
f(oi, "isElement");
function ai(i) {
  return i instanceof HTMLElement || i instanceof Ks(i).HTMLElement;
}
f(ai, "isHTMLElement");
function TF(i) {
  return typeof ShadowRoot > "u" ? !1 : i instanceof ShadowRoot || i instanceof Ks(i).ShadowRoot;
}
f(TF, "isShadowRoot");
function Df(i) {
  const {
    overflow: e,
    overflowX: t,
    overflowY: s,
    display: n
  } = Mn(i);
  return /auto|scroll|overlay|hidden|clip/.test(e + s + t) && !["inline", "contents"].includes(n);
}
f(Df, "isOverflowElement");
function xre(i) {
  return ["table", "td", "th"].includes(Ra(i));
}
f(xre, "isTableElement");
function Y5(i) {
  const e = X5(), t = Mn(i);
  return t.transform !== "none" || t.perspective !== "none" || (t.containerType ? t.containerType !== "normal" : !1) || !e && (t.backdropFilter ? t.backdropFilter !== "none" : !1) || !e && (t.filter ? t.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((s) => (t.willChange || "").includes(s)) || ["paint", "layout", "strict", "content"].some((s) => (t.contain || "").includes(s));
}
f(Y5, "isContainingBlock");
function eoe(i) {
  let e = _l(i);
  for (; ai(e) && !Ta(e); ) {
    if (Y5(e))
      return e;
    e = _l(e);
  }
  return null;
}
f(eoe, "getContainingBlock");
function X5() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
f(X5, "isWebKit");
function Ta(i) {
  return ["html", "body", "#document"].includes(Ra(i));
}
f(Ta, "isLastTraversableNode");
function Mn(i) {
  return Ks(i).getComputedStyle(i);
}
f(Mn, "getComputedStyle$1");
function db(i) {
  return oi(i) ? {
    scrollLeft: i.scrollLeft,
    scrollTop: i.scrollTop
  } : {
    scrollLeft: i.pageXOffset,
    scrollTop: i.pageYOffset
  };
}
f(db, "getNodeScroll");
function _l(i) {
  if (Ra(i) === "html")
    return i;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    i.assignedSlot || // DOM Element detected.
    i.parentNode || // ShadowRoot detected.
    TF(i) && i.host || // Fallback.
    zi(i)
  );
  return TF(e) ? e.host : e;
}
f(_l, "getParentNode");
function rq(i) {
  const e = _l(i);
  return Ta(e) ? i.ownerDocument ? i.ownerDocument.body : i.body : ai(e) && Df(e) ? e : rq(e);
}
f(rq, "getNearestOverflowAncestor");
function Lc(i, e, t) {
  var s;
  e === void 0 && (e = []), t === void 0 && (t = !0);
  const n = rq(i), l = n === ((s = i.ownerDocument) == null ? void 0 : s.body), r = Ks(n);
  return l ? e.concat(r, r.visualViewport || [], Df(n) ? n : [], r.frameElement && t ? Lc(r.frameElement) : []) : e.concat(n, Lc(n, [], t));
}
f(Lc, "getOverflowAncestors");
function oq(i) {
  const e = Mn(i);
  let t = parseFloat(e.width) || 0, s = parseFloat(e.height) || 0;
  const n = ai(i), l = n ? i.offsetWidth : t, r = n ? i.offsetHeight : s, o = fp(t) !== l || fp(s) !== r;
  return o && (t = l, s = r), {
    width: t,
    height: s,
    $: o
  };
}
f(oq, "getCssDimensions");
function J5(i) {
  return oi(i) ? i : i.contextElement;
}
f(J5, "unwrapElement");
function io(i) {
  const e = J5(i);
  if (!ai(e))
    return bl(1);
  const t = e.getBoundingClientRect(), {
    width: s,
    height: n,
    $: l
  } = oq(e);
  let r = (l ? fp(t.width) : t.width) / s, o = (l ? fp(t.height) : t.height) / n;
  return (!r || !Number.isFinite(r)) && (r = 1), (!o || !Number.isFinite(o)) && (o = 1), {
    x: r,
    y: o
  };
}
f(io, "getScale");
const toe = /* @__PURE__ */ bl(0);
function aq(i) {
  const e = Ks(i);
  return !X5() || !e.visualViewport ? toe : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
f(aq, "getVisualOffsets");
function soe(i, e, t) {
  return e === void 0 && (e = !1), !t || e && t !== Ks(i) ? !1 : e;
}
f(soe, "shouldAddVisualOffsets");
function Pr(i, e, t, s) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  const n = i.getBoundingClientRect(), l = J5(i);
  let r = bl(1);
  e && (s ? oi(s) && (r = io(s)) : r = io(i));
  const o = soe(l, t, s) ? aq(l) : bl(0);
  let a = (n.left + o.x) / r.x, c = (n.top + o.y) / r.y, u = n.width / r.x, d = n.height / r.y;
  if (l) {
    const p = Ks(l), m = s && oi(s) ? Ks(s) : s;
    let g = p, h = g.frameElement;
    for (; h && s && m !== g; ) {
      const _ = io(h), y = h.getBoundingClientRect(), k = Mn(h), v = y.left + (h.clientLeft + parseFloat(k.paddingLeft)) * _.x, O = y.top + (h.clientTop + parseFloat(k.paddingTop)) * _.y;
      a *= _.x, c *= _.y, u *= _.x, d *= _.y, a += v, c += O, g = Ks(h), h = g.frameElement;
    }
  }
  return pp({
    width: u,
    height: d,
    x: a,
    y: c
  });
}
f(Pr, "getBoundingClientRect");
const noe = [":popover-open", ":modal"];
function Z5(i) {
  return noe.some((e) => {
    try {
      return i.matches(e);
    } catch {
      return !1;
    }
  });
}
f(Z5, "isTopLayer");
function ioe(i) {
  let {
    elements: e,
    rect: t,
    offsetParent: s,
    strategy: n
  } = i;
  const l = n === "fixed", r = zi(s), o = e ? Z5(e.floating) : !1;
  if (s === r || o && l)
    return t;
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = bl(1);
  const u = bl(0), d = ai(s);
  if ((d || !d && !l) && ((Ra(s) !== "body" || Df(r)) && (a = db(s)), ai(s))) {
    const p = Pr(s);
    c = io(s), u.x = p.x + s.clientLeft, u.y = p.y + s.clientTop;
  }
  return {
    width: t.width * c.x,
    height: t.height * c.y,
    x: t.x * c.x - a.scrollLeft * c.x + u.x,
    y: t.y * c.y - a.scrollTop * c.y + u.y
  };
}
f(ioe, "convertOffsetParentRelativeRectToViewportRelativeRect");
function loe(i) {
  return Array.from(i.getClientRects());
}
f(loe, "getClientRects");
function cq(i) {
  return Pr(zi(i)).left + db(i).scrollLeft;
}
f(cq, "getWindowScrollBarX");
function roe(i) {
  const e = zi(i), t = db(i), s = i.ownerDocument.body, n = Ar(e.scrollWidth, e.clientWidth, s.scrollWidth, s.clientWidth), l = Ar(e.scrollHeight, e.clientHeight, s.scrollHeight, s.clientHeight);
  let r = -t.scrollLeft + cq(i);
  const o = -t.scrollTop;
  return Mn(s).direction === "rtl" && (r += Ar(e.clientWidth, s.clientWidth) - n), {
    width: n,
    height: l,
    x: r,
    y: o
  };
}
f(roe, "getDocumentRect");
function ooe(i, e) {
  const t = Ks(i), s = zi(i), n = t.visualViewport;
  let l = s.clientWidth, r = s.clientHeight, o = 0, a = 0;
  if (n) {
    l = n.width, r = n.height;
    const c = X5();
    (!c || c && e === "fixed") && (o = n.offsetLeft, a = n.offsetTop);
  }
  return {
    width: l,
    height: r,
    x: o,
    y: a
  };
}
f(ooe, "getViewportRect");
function aoe(i, e) {
  const t = Pr(i, !0, e === "fixed"), s = t.top + i.clientTop, n = t.left + i.clientLeft, l = ai(i) ? io(i) : bl(1), r = i.clientWidth * l.x, o = i.clientHeight * l.y, a = n * l.x, c = s * l.y;
  return {
    width: r,
    height: o,
    x: a,
    y: c
  };
}
f(aoe, "getInnerBoundingClientRect");
function CF(i, e, t) {
  let s;
  if (e === "viewport")
    s = ooe(i, t);
  else if (e === "document")
    s = roe(zi(i));
  else if (oi(e))
    s = aoe(e, t);
  else {
    const n = aq(i);
    s = {
      ...e,
      x: e.x - n.x,
      y: e.y - n.y
    };
  }
  return pp(s);
}
f(CF, "getClientRectFromClippingAncestor");
function uq(i, e) {
  const t = _l(i);
  return t === e || !oi(t) || Ta(t) ? !1 : Mn(t).position === "fixed" || uq(t, e);
}
f(uq, "hasFixedPositionAncestor");
function coe(i, e) {
  const t = e.get(i);
  if (t)
    return t;
  let s = Lc(i, [], !1).filter((o) => oi(o) && Ra(o) !== "body"), n = null;
  const l = Mn(i).position === "fixed";
  let r = l ? _l(i) : i;
  for (; oi(r) && !Ta(r); ) {
    const o = Mn(r), a = Y5(r);
    !a && o.position === "fixed" && (n = null), (l ? !a && !n : !a && o.position === "static" && !!n && ["absolute", "fixed"].includes(n.position) || Df(r) && !a && uq(i, r)) ? s = s.filter((u) => u !== r) : n = o, r = _l(r);
  }
  return e.set(i, s), s;
}
f(coe, "getClippingElementAncestors");
function uoe(i) {
  let {
    element: e,
    boundary: t,
    rootBoundary: s,
    strategy: n
  } = i;
  const r = [...t === "clippingAncestors" ? Z5(e) ? [] : coe(e, this._c) : [].concat(t), s], o = r[0], a = r.reduce((c, u) => {
    const d = CF(e, u, n);
    return c.top = Ar(d.top, c.top), c.right = up(d.right, c.right), c.bottom = up(d.bottom, c.bottom), c.left = Ar(d.left, c.left), c;
  }, CF(e, o, n));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
f(uoe, "getClippingRect");
function foe(i) {
  const {
    width: e,
    height: t
  } = oq(i);
  return {
    width: e,
    height: t
  };
}
f(foe, "getDimensions");
function doe(i, e, t) {
  const s = ai(e), n = zi(e), l = t === "fixed", r = Pr(i, !0, l, e);
  let o = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const a = bl(0);
  if (s || !s && !l)
    if ((Ra(e) !== "body" || Df(n)) && (o = db(e)), s) {
      const d = Pr(e, !0, l, e);
      a.x = d.x + e.clientLeft, a.y = d.y + e.clientTop;
    } else
      n && (a.x = cq(n));
  const c = r.left + o.scrollLeft - a.x, u = r.top + o.scrollTop - a.y;
  return {
    x: c,
    y: u,
    width: r.width,
    height: r.height
  };
}
f(doe, "getRectRelativeToOffsetParent");
function Mb(i) {
  return Mn(i).position === "static";
}
f(Mb, "isStaticPositioned");
function OF(i, e) {
  return !ai(i) || Mn(i).position === "fixed" ? null : e ? e(i) : i.offsetParent;
}
f(OF, "getTrueOffsetParent");
function fq(i, e) {
  const t = Ks(i);
  if (Z5(i))
    return t;
  if (!ai(i)) {
    let n = _l(i);
    for (; n && !Ta(n); ) {
      if (oi(n) && !Mb(n))
        return n;
      n = _l(n);
    }
    return t;
  }
  let s = OF(i, e);
  for (; s && xre(s) && Mb(s); )
    s = OF(s, e);
  return s && Ta(s) && Mb(s) && !Y5(s) ? t : s || eoe(i) || t;
}
f(fq, "getOffsetParent");
const poe = /* @__PURE__ */ f(async function(i) {
  const e = this.getOffsetParent || fq, t = this.getDimensions, s = await t(i.floating);
  return {
    reference: doe(i.reference, await e(i.floating), i.strategy),
    floating: {
      x: 0,
      y: 0,
      width: s.width,
      height: s.height
    }
  };
}, "getElementRects");
function moe(i) {
  return Mn(i).direction === "rtl";
}
f(moe, "isRTL");
const hoe = {
  convertOffsetParentRelativeRectToViewportRelativeRect: ioe,
  getDocumentElement: zi,
  getClippingRect: uoe,
  getOffsetParent: fq,
  getElementRects: poe,
  getClientRects: loe,
  getDimensions: foe,
  getScale: io,
  isElement: oi,
  isRTL: moe
};
function goe(i, e) {
  let t = null, s;
  const n = zi(i);
  function l() {
    var o;
    clearTimeout(s), (o = t) == null || o.disconnect(), t = null;
  }
  f(l, "cleanup");
  function r(o, a) {
    o === void 0 && (o = !1), a === void 0 && (a = 1), l();
    const {
      left: c,
      top: u,
      width: d,
      height: p
    } = i.getBoundingClientRect();
    if (o || e(), !d || !p)
      return;
    const m = Xf(u), g = Xf(n.clientWidth - (c + d)), h = Xf(n.clientHeight - (u + p)), _ = Xf(c), k = {
      rootMargin: -m + "px " + -g + "px " + -h + "px " + -_ + "px",
      threshold: Ar(0, up(1, a)) || 1
    };
    let v = !0;
    function O(P) {
      const D = P[0].intersectionRatio;
      if (D !== a) {
        if (!v)
          return r();
        D ? r(!1, D) : s = setTimeout(() => {
          r(!1, 1e-7);
        }, 1e3);
      }
      v = !1;
    }
    f(O, "handleObserve");
    try {
      t = new IntersectionObserver(O, {
        ...k,
        // Handle <iframe>s
        root: n.ownerDocument
      });
    } catch {
      t = new IntersectionObserver(O, k);
    }
    t.observe(i);
  }
  return f(r, "refresh"), r(!0), l;
}
f(goe, "observeMove");
function boe(i, e, t, s) {
  s === void 0 && (s = {});
  const {
    ancestorScroll: n = !0,
    ancestorResize: l = !0,
    elementResize: r = typeof ResizeObserver == "function",
    layoutShift: o = typeof IntersectionObserver == "function",
    animationFrame: a = !1
  } = s, c = J5(i), u = n || l ? [...c ? Lc(c) : [], ...Lc(e)] : [];
  u.forEach((y) => {
    n && y.addEventListener("scroll", t, {
      passive: !0
    }), l && y.addEventListener("resize", t);
  });
  const d = c && o ? goe(c, t) : null;
  let p = -1, m = null;
  r && (m = new ResizeObserver((y) => {
    let [k] = y;
    k && k.target === c && m && (m.unobserve(e), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var v;
      (v = m) == null || v.observe(e);
    })), t();
  }), c && !a && m.observe(c), m.observe(e));
  let g, h = a ? Pr(i) : null;
  a && _();
  function _() {
    const y = Pr(i);
    h && (y.x !== h.x || y.y !== h.y || y.width !== h.width || y.height !== h.height) && t(), h = y, g = requestAnimationFrame(_);
  }
  return f(_, "frameLoop"), t(), () => {
    var y;
    u.forEach((k) => {
      n && k.removeEventListener("scroll", t), l && k.removeEventListener("resize", t);
    }), d == null || d(), (y = m) == null || y.disconnect(), m = null, a && cancelAnimationFrame(g);
  };
}
f(boe, "autoUpdate");
const _oe = Zre, yoe = Qre, voe = Xre, koe = /* @__PURE__ */ f((i, e, t) => {
  const s = /* @__PURE__ */ new Map(), n = {
    platform: hoe,
    ...t
  }, l = {
    ...n.platform,
    _c: s
  };
  return Yre(i, e, {
    ...n,
    platform: l
  });
}, "computePosition");
function woe(i) {
  let e, t;
  const s = {
    autoUpdate: !0
  };
  let n = i;
  const l = /* @__PURE__ */ f((u) => ({ ...s, ...i || {}, ...u || {} }), "getOptions"), r = /* @__PURE__ */ f((u) => {
    e && t && (n = l(u), koe(e, t, n).then((d) => {
      Object.assign(t.style, {
        position: d.strategy,
        left: `${d.x}px`,
        top: `${d.y}px`
      }), n != null && n.onComputed && n.onComputed(d);
    }));
  }, "updatePosition"), o = /* @__PURE__ */ f((u) => {
    if ("subscribe" in u)
      return c(u), {};
    e = u, r();
  }, "referenceAction"), a = /* @__PURE__ */ f((u, d) => {
    let p;
    t = u, n = l(d), setTimeout(() => r(d), 0), r(d);
    const m = /* @__PURE__ */ f(() => {
      p && (p(), p = void 0);
    }, "destroyAutoUpdate"), g = /* @__PURE__ */ f(({ autoUpdate: h } = n || {}) => {
      m(), h !== !1 && A7().then(() => boe(e, t, () => r(n), h === !0 ? {} : h));
    }, "initAutoUpdate");
    return p = g(), {
      update(h) {
        r(h), p = g(h);
      },
      destroy() {
        m();
      }
    };
  }, "contentAction"), c = /* @__PURE__ */ f((u) => {
    const d = u.subscribe((p) => {
      e === void 0 ? (e = p, r()) : (Object.assign(e, p), r());
    });
    Nt(d);
  }, "setupVirtualElementObserver");
  return [
    o,
    a,
    r
  ];
}
f(woe, "createFloatingActions");
function $oe({
  loadOptions: i,
  filterText: e,
  items: t,
  multiple: s,
  value: n,
  itemId: l,
  groupBy: r,
  filterSelectedItems: o,
  itemFilter: a,
  convertStringItemsToObjects: c,
  filterGroupedItems: u,
  label: d
}) {
  if (t && i)
    return t;
  if (!t)
    return [];
  t && t.length > 0 && typeof t[0] != "object" && (t = c(t));
  let p = t.filter((m) => {
    let g = a(m[d], e, m);
    return g && s && (n != null && n.length) && (g = !n.some((h) => o ? h[l] === m[l] : !1)), g;
  });
  return r && (p = u(p)), p;
}
f($oe, "filter");
async function Aoe({ dispatch: i, loadOptions: e, convertStringItemsToObjects: t, filterText: s }) {
  let n = await e(s).catch((l) => {
    console.warn("svelte-select loadOptions error :>> ", l), i("error", { type: "loadOptions", details: l });
  });
  if (n && !n.cancelled)
    return n ? (n && n.length > 0 && typeof n[0] != "object" && (n = t(n)), i("loaded", { items: n })) : n = [], {
      filteredItems: n,
      loading: !1,
      focused: !0,
      listOpen: !0
    };
}
f(Aoe, "getItems");
function Eoe(i) {
  let e, t;
  return {
    c() {
      e = pn("svg"), t = pn("path"), b(t, "fill", "currentColor"), b(t, "d", `M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747
          3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0
          1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502
          0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0
          0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z`), b(e, "width", "100%"), b(e, "height", "100%"), b(e, "viewBox", "0 0 20 20"), b(e, "focusable", "false"), b(e, "aria-hidden", "true"), b(e, "class", "svelte-qbd276");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p: ee,
    i: ee,
    o: ee,
    d(s) {
      s && S(e);
    }
  };
}
f(Eoe, "create_fragment$1G");
const RT = class RT extends ie {
  constructor(e) {
    super(), le(this, e, null, Eoe, ne, {});
  }
};
f(RT, "ChevronIcon");
let hk = RT;
function Soe(i) {
  let e, t;
  return {
    c() {
      e = pn("svg"), t = pn("path"), b(t, "fill", "currentColor"), b(t, "d", `M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124
    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z`), b(e, "width", "100%"), b(e, "height", "100%"), b(e, "viewBox", "-2 -2 50 50"), b(e, "focusable", "false"), b(e, "aria-hidden", "true"), b(e, "role", "presentation"), b(e, "class", "svelte-whdbu1");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p: ee,
    i: ee,
    o: ee,
    d(s) {
      s && S(e);
    }
  };
}
f(Soe, "create_fragment$1F");
const FT = class FT extends ie {
  constructor(e) {
    super(), le(this, e, null, Soe, ne, {});
  }
};
f(FT, "ClearIcon");
let Ca = FT;
function Toe(i) {
  let e, t;
  return {
    c() {
      e = pn("svg"), t = pn("circle"), b(t, "class", "circle_path svelte-1p3nqvd"), b(t, "cx", "50"), b(t, "cy", "50"), b(t, "r", "20"), b(t, "fill", "none"), b(t, "stroke", "currentColor"), b(t, "stroke-width", "5"), b(t, "stroke-miterlimit", "10"), b(e, "class", "loading svelte-1p3nqvd"), b(e, "viewBox", "25 25 50 50");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p: ee,
    i: ee,
    o: ee,
    d(s) {
      s && S(e);
    }
  };
}
f(Toe, "create_fragment$1E");
const NT = class NT extends ie {
  constructor(e) {
    super(), le(this, e, null, Toe, ne, {});
  }
};
f(NT, "LoadingIcon");
let gk = NT;
const Coe = /* @__PURE__ */ f((i) => ({ value: i[0] & /*value*/
8 }), "get_required_slot_changes"), DF = /* @__PURE__ */ f((i) => ({ value: (
  /*value*/
  i[3]
) }), "get_required_slot_context"), Ooe = /* @__PURE__ */ f((i) => ({ value: i[0] & /*value*/
8 }), "get_input_hidden_slot_changes"), IF = /* @__PURE__ */ f((i) => ({ value: (
  /*value*/
  i[3]
) }), "get_input_hidden_slot_context"), Doe = /* @__PURE__ */ f((i) => ({ listOpen: i[0] & /*listOpen*/
64 }), "get_chevron_icon_slot_changes"), PF = /* @__PURE__ */ f((i) => ({ listOpen: (
  /*listOpen*/
  i[6]
) }), "get_chevron_icon_slot_context"), Ioe = /* @__PURE__ */ f((i) => ({}), "get_clear_icon_slot_changes"), MF = /* @__PURE__ */ f((i) => ({}), "get_clear_icon_slot_context"), Poe = /* @__PURE__ */ f((i) => ({}), "get_loading_icon_slot_changes"), RF = /* @__PURE__ */ f((i) => ({}), "get_loading_icon_slot_context"), Moe = /* @__PURE__ */ f((i) => ({ selection: i[0] & /*value*/
8 }), "get_selection_slot_changes_1"), FF = /* @__PURE__ */ f((i) => ({ selection: (
  /*value*/
  i[3]
) }), "get_selection_slot_context_1");
function NF(i, e, t) {
  const s = i.slice();
  return s[126] = e[t], s[128] = t, s;
}
f(NF, "get_each_context$z");
const Roe = /* @__PURE__ */ f((i) => ({}), "get_multi_clear_icon_slot_changes"), jF = /* @__PURE__ */ f((i) => ({}), "get_multi_clear_icon_slot_context"), Foe = /* @__PURE__ */ f((i) => ({ selection: i[0] & /*value*/
8 }), "get_selection_slot_changes"), LF = /* @__PURE__ */ f((i) => ({
  selection: (
    /*item*/
    i[126]
  ),
  index: (
    /*i*/
    i[128]
  )
}), "get_selection_slot_context"), Noe = /* @__PURE__ */ f((i) => ({}), "get_prepend_slot_changes"), BF = /* @__PURE__ */ f((i) => ({}), "get_prepend_slot_context"), joe = /* @__PURE__ */ f((i) => ({}), "get_list_append_slot_changes"), qF = /* @__PURE__ */ f((i) => ({}), "get_list_append_slot_context"), Loe = /* @__PURE__ */ f((i) => ({}), "get_empty_slot_changes"), GF = /* @__PURE__ */ f((i) => ({}), "get_empty_slot_context");
function zF(i, e, t) {
  const s = i.slice();
  return s[126] = e[t], s[128] = t, s;
}
f(zF, "get_each_context_1$5");
const Boe = /* @__PURE__ */ f((i) => ({
  item: i[0] & /*filteredItems*/
  16777216
}), "get_item_slot_changes"), HF = /* @__PURE__ */ f((i) => ({
  item: (
    /*item*/
    i[126]
  ),
  index: (
    /*i*/
    i[128]
  )
}), "get_item_slot_context"), qoe = /* @__PURE__ */ f((i) => ({
  filteredItems: i[0] & /*filteredItems*/
  16777216
}), "get_list_slot_changes"), UF = /* @__PURE__ */ f((i) => ({ filteredItems: (
  /*filteredItems*/
  i[24]
) }), "get_list_slot_context"), Goe = /* @__PURE__ */ f((i) => ({}), "get_list_prepend_slot_changes"), VF = /* @__PURE__ */ f((i) => ({}), "get_list_prepend_slot_context");
function WF(i) {
  let e, t, s, n, l, r, o, a, c = (
    /*$$slots*/
    i[50]["list-prepend"] && KF(i)
  );
  const u = [Uoe, Hoe, zoe], d = [];
  function p(g, h) {
    return (
      /*$$slots*/
      g[50].list ? 0 : (
        /*filteredItems*/
        g[24].length > 0 ? 1 : (
          /*hideEmptyState*/
          g[19] ? -1 : 2
        )
      )
    );
  }
  f(p, "select_block_type"), ~(s = p(i)) && (n = d[s] = u[s](i));
  let m = (
    /*$$slots*/
    i[50]["list-append"] && XF(i)
  );
  return {
    c() {
      e = E("div"), c && c.c(), t = R(), n && n.c(), l = R(), m && m.c(), b(e, "class", "svelte-select-list svelte-82qwg8"), b(e, "role", "none"), Q(
        e,
        "prefloat",
        /*prefloat*/
        i[28]
      );
    },
    m(g, h) {
      T(g, e, h), c && c.m(e, null), A(e, t), ~s && d[s].m(e, null), A(e, l), m && m.m(e, null), i[91](e), r = !0, o || (a = [
        At(
          /*floatingContent*/
          i[49].call(null, e)
        ),
        V(
          e,
          "scroll",
          /*handleListScroll*/
          i[41]
        ),
        V(e, "pointerup", We(tt(
          /*pointerup_handler*/
          i[85]
        ))),
        V(e, "mousedown", We(tt(
          /*mousedown_handler*/
          i[86]
        )))
      ], o = !0);
    },
    p(g, h) {
      /*$$slots*/
      g[50]["list-prepend"] ? c ? (c.p(g, h), h[1] & /*$$slots*/
      524288 && w(c, 1)) : (c = KF(g), c.c(), w(c, 1), c.m(e, t)) : c && (ce(), C(c, 1, 1, () => {
        c = null;
      }), ue());
      let _ = s;
      s = p(g), s === _ ? ~s && d[s].p(g, h) : (n && (ce(), C(d[_], 1, 1, () => {
        d[_] = null;
      }), ue()), ~s ? (n = d[s], n ? n.p(g, h) : (n = d[s] = u[s](g), n.c()), w(n, 1), n.m(e, l)) : n = null), /*$$slots*/
      g[50]["list-append"] ? m ? (m.p(g, h), h[1] & /*$$slots*/
      524288 && w(m, 1)) : (m = XF(g), m.c(), w(m, 1), m.m(e, null)) : m && (ce(), C(m, 1, 1, () => {
        m = null;
      }), ue()), (!r || h[0] & /*prefloat*/
      268435456) && Q(
        e,
        "prefloat",
        /*prefloat*/
        g[28]
      );
    },
    i(g) {
      r || (w(c), w(n), w(m), r = !0);
    },
    o(g) {
      C(c), C(n), C(m), r = !1;
    },
    d(g) {
      g && S(e), c && c.d(), ~s && d[s].d(), m && m.d(), i[91](null), o = !1, Ne(a);
    }
  };
}
f(WF, "create_if_block_8$5");
function KF(i) {
  let e;
  const t = (
    /*#slots*/
    i[83]["list-prepend"]
  ), s = Pt(
    t,
    i,
    /*$$scope*/
    i[82],
    VF
  );
  return {
    c() {
      s && s.c();
    },
    m(n, l) {
      s && s.m(n, l), e = !0;
    },
    p(n, l) {
      s && s.p && (!e || l[2] & /*$$scope*/
      1048576) && Rt(
        s,
        t,
        n,
        /*$$scope*/
        n[82],
        e ? Mt(
          t,
          /*$$scope*/
          n[82],
          l,
          Goe
        ) : Ft(
          /*$$scope*/
          n[82]
        ),
        VF
      );
    },
    i(n) {
      e || (w(s, n), e = !0);
    },
    o(n) {
      C(s, n), e = !1;
    },
    d(n) {
      s && s.d(n);
    }
  };
}
f(KF, "create_if_block_13");
function zoe(i) {
  let e;
  const t = (
    /*#slots*/
    i[83].empty
  ), s = Pt(
    t,
    i,
    /*$$scope*/
    i[82],
    GF
  ), n = s || Voe();
  return {
    c() {
      n && n.c();
    },
    m(l, r) {
      n && n.m(l, r), e = !0;
    },
    p(l, r) {
      s && s.p && (!e || r[2] & /*$$scope*/
      1048576) && Rt(
        s,
        t,
        l,
        /*$$scope*/
        l[82],
        e ? Mt(
          t,
          /*$$scope*/
          l[82],
          r,
          Loe
        ) : Ft(
          /*$$scope*/
          l[82]
        ),
        GF
      );
    },
    i(l) {
      e || (w(n, l), e = !0);
    },
    o(l) {
      C(n, l), e = !1;
    },
    d(l) {
      n && n.d(l);
    }
  };
}
f(zoe, "create_if_block_12$1");
function Hoe(i) {
  let e, t, s = oe(
    /*filteredItems*/
    i[24]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = YF(zF(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, o) {
      if (o[0] & /*filteredItems, value, itemId, listDom, scrollToHoverItem, hoverItemIndex, label*/
      1627402376 | o[1] & /*handleHover, handleItemClick, isItemActive*/
      28672 | o[2] & /*$$scope*/
      1048576) {
        s = oe(
          /*filteredItems*/
          r[24]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = zF(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = YF(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f(Hoe, "create_if_block_11$1");
function Uoe(i) {
  let e;
  const t = (
    /*#slots*/
    i[83].list
  ), s = Pt(
    t,
    i,
    /*$$scope*/
    i[82],
    UF
  );
  return {
    c() {
      s && s.c();
    },
    m(n, l) {
      s && s.m(n, l), e = !0;
    },
    p(n, l) {
      s && s.p && (!e || l[0] & /*filteredItems*/
      16777216 | l[2] & /*$$scope*/
      1048576) && Rt(
        s,
        t,
        n,
        /*$$scope*/
        n[82],
        e ? Mt(
          t,
          /*$$scope*/
          n[82],
          l,
          qoe
        ) : Ft(
          /*$$scope*/
          n[82]
        ),
        UF
      );
    },
    i(n) {
      e || (w(s, n), e = !0);
    },
    o(n) {
      C(s, n), e = !1;
    },
    d(n) {
      s && s.d(n);
    }
  };
}
f(Uoe, "create_if_block_10$2");
function Voe(i) {
  let e;
  return {
    c() {
      e = E("div"), e.textContent = "No options", b(e, "class", "empty svelte-82qwg8");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: ee,
    d(t) {
      t && S(e);
    }
  };
}
f(Voe, "fallback_block_9");
function Woe(i) {
  var s;
  let e = (
    /*item*/
    ((s = i[126]) == null ? void 0 : s[
      /*label*/
      i[12]
    ]) + ""
  ), t;
  return {
    c() {
      t = x(e);
    },
    m(n, l) {
      T(n, t, l);
    },
    p(n, l) {
      var r;
      l[0] & /*filteredItems, label*/
      16781312 && e !== (e = /*item*/
      ((r = n[126]) == null ? void 0 : r[
        /*label*/
        n[12]
      ]) + "") && _e(t, e);
    },
    d(n) {
      n && S(t);
    }
  };
}
f(Woe, "fallback_block_8");
function YF(i) {
  let e, t, s, n, l, r, o, a;
  const c = (
    /*#slots*/
    i[83].item
  ), u = Pt(
    c,
    i,
    /*$$scope*/
    i[82],
    HF
  ), d = u || Woe(i);
  function p() {
    return (
      /*mouseover_handler*/
      i[88](
        /*i*/
        i[128]
      )
    );
  }
  f(p, "mouseover_handler");
  function m() {
    return (
      /*focus_handler*/
      i[89](
        /*i*/
        i[128]
      )
    );
  }
  f(m, "focus_handler");
  function g() {
    return (
      /*click_handler*/
      i[90](
        /*item*/
        i[126],
        /*i*/
        i[128]
      )
    );
  }
  return f(g, "click_handler"), {
    c() {
      var h;
      e = E("div"), t = E("div"), d && d.c(), l = R(), b(t, "class", "item svelte-82qwg8"), Q(
        t,
        "list-group-title",
        /*item*/
        i[126].groupHeader
      ), Q(
        t,
        "active",
        /*isItemActive*/
        i[45](
          /*item*/
          i[126],
          /*value*/
          i[3],
          /*itemId*/
          i[13]
        )
      ), Q(t, "first", iae(
        /*i*/
        i[128]
      )), Q(
        t,
        "hover",
        /*hoverItemIndex*/
        i[7] === /*i*/
        i[128]
      ), Q(
        t,
        "group-item",
        /*item*/
        i[126].groupItem
      ), Q(
        t,
        "not-selectable",
        /*item*/
        ((h = i[126]) == null ? void 0 : h.selectable) === !1
      ), b(e, "class", "list-item svelte-82qwg8"), b(e, "tabindex", "-1"), b(e, "role", "none");
    },
    m(h, _) {
      T(h, e, _), A(e, t), d && d.m(t, null), A(e, l), r = !0, o || (a = [
        At(s = /*activeScroll*/
        i[46].call(null, t, {
          scroll: (
            /*isItemActive*/
            i[45](
              /*item*/
              i[126],
              /*value*/
              i[3],
              /*itemId*/
              i[13]
            )
          ),
          listDom: (
            /*listDom*/
            i[30]
          )
        })),
        At(n = /*hoverScroll*/
        i[47].call(null, t, {
          scroll: (
            /*scrollToHoverItem*/
            i[29] === /*i*/
            i[128]
          ),
          listDom: (
            /*listDom*/
            i[30]
          )
        })),
        V(e, "mouseover", p),
        V(e, "focus", m),
        V(e, "click", We(g)),
        V(e, "keydown", We(tt(
          /*keydown_handler*/
          i[87]
        )))
      ], o = !0);
    },
    p(h, _) {
      var y;
      i = h, u ? u.p && (!r || _[0] & /*filteredItems*/
      16777216 | _[2] & /*$$scope*/
      1048576) && Rt(
        u,
        c,
        i,
        /*$$scope*/
        i[82],
        r ? Mt(
          c,
          /*$$scope*/
          i[82],
          _,
          Boe
        ) : Ft(
          /*$$scope*/
          i[82]
        ),
        HF
      ) : d && d.p && (!r || _[0] & /*filteredItems, label*/
      16781312) && d.p(i, r ? _ : [-1, -1, -1, -1, -1]), s && $t(s.update) && _[0] & /*filteredItems, value, itemId, listDom*/
      1090527240 && s.update.call(null, {
        scroll: (
          /*isItemActive*/
          i[45](
            /*item*/
            i[126],
            /*value*/
            i[3],
            /*itemId*/
            i[13]
          )
        ),
        listDom: (
          /*listDom*/
          i[30]
        )
      }), n && $t(n.update) && _[0] & /*scrollToHoverItem, listDom*/
      1610612736 && n.update.call(null, {
        scroll: (
          /*scrollToHoverItem*/
          i[29] === /*i*/
          i[128]
        ),
        listDom: (
          /*listDom*/
          i[30]
        )
      }), (!r || _[0] & /*filteredItems*/
      16777216) && Q(
        t,
        "list-group-title",
        /*item*/
        i[126].groupHeader
      ), (!r || _[0] & /*filteredItems, value, itemId*/
      16785416 | _[1] & /*isItemActive*/
      16384) && Q(
        t,
        "active",
        /*isItemActive*/
        i[45](
          /*item*/
          i[126],
          /*value*/
          i[3],
          /*itemId*/
          i[13]
        )
      ), (!r || _[0] & /*hoverItemIndex*/
      128) && Q(
        t,
        "hover",
        /*hoverItemIndex*/
        i[7] === /*i*/
        i[128]
      ), (!r || _[0] & /*filteredItems*/
      16777216) && Q(
        t,
        "group-item",
        /*item*/
        i[126].groupItem
      ), (!r || _[0] & /*filteredItems*/
      16777216) && Q(
        t,
        "not-selectable",
        /*item*/
        ((y = i[126]) == null ? void 0 : y.selectable) === !1
      );
    },
    i(h) {
      r || (w(d, h), r = !0);
    },
    o(h) {
      C(d, h), r = !1;
    },
    d(h) {
      h && S(e), d && d.d(h), o = !1, Ne(a);
    }
  };
}
f(YF, "create_each_block_1$5");
function XF(i) {
  let e;
  const t = (
    /*#slots*/
    i[83]["list-append"]
  ), s = Pt(
    t,
    i,
    /*$$scope*/
    i[82],
    qF
  );
  return {
    c() {
      s && s.c();
    },
    m(n, l) {
      s && s.m(n, l), e = !0;
    },
    p(n, l) {
      s && s.p && (!e || l[2] & /*$$scope*/
      1048576) && Rt(
        s,
        t,
        n,
        /*$$scope*/
        n[82],
        e ? Mt(
          t,
          /*$$scope*/
          n[82],
          l,
          joe
        ) : Ft(
          /*$$scope*/
          n[82]
        ),
        qF
      );
    },
    i(n) {
      e || (w(s, n), e = !0);
    },
    o(n) {
      C(s, n), e = !1;
    },
    d(n) {
      s && s.d(n);
    }
  };
}
f(XF, "create_if_block_9$5");
function JF(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("span"), t = x(
        /*ariaSelection*/
        i[32]
      ), s = R(), n = E("span"), l = x(
        /*ariaContext*/
        i[31]
      ), b(e, "id", "aria-selection"), b(e, "class", "svelte-82qwg8"), b(n, "id", "aria-context"), b(n, "class", "svelte-82qwg8");
    },
    m(r, o) {
      T(r, e, o), A(e, t), T(r, s, o), T(r, n, o), A(n, l);
    },
    p(r, o) {
      o[1] & /*ariaSelection*/
      2 && _e(
        t,
        /*ariaSelection*/
        r[32]
      ), o[1] & /*ariaContext*/
      1 && _e(
        l,
        /*ariaContext*/
        r[31]
      );
    },
    d(r) {
      r && (S(e), S(s), S(n));
    }
  };
}
f(JF, "create_if_block_7$7");
function ZF(i) {
  let e, t, s, n;
  const l = [Yoe, Koe], r = [];
  function o(a, c) {
    return (
      /*multiple*/
      a[9] ? 0 : 1
    );
  }
  return f(o, "select_block_type_1"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let u = e;
      e = o(a), e === u ? r[e].p(a, c) : (ce(), C(r[u], 1, 1, () => {
        r[u] = null;
      }), ue(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), r[e].d(a);
    }
  };
}
f(ZF, "create_if_block_4$g");
function Koe(i) {
  let e, t;
  const s = (
    /*#slots*/
    i[83].selection
  ), n = Pt(
    s,
    i,
    /*$$scope*/
    i[82],
    FF
  ), l = n || Xoe(i);
  return {
    c() {
      e = E("div"), l && l.c(), b(e, "class", "selected-item svelte-82qwg8"), Q(
        e,
        "hide-selected-item",
        /*hideSelectedItem*/
        i[35]
      );
    },
    m(r, o) {
      T(r, e, o), l && l.m(e, null), t = !0;
    },
    p(r, o) {
      n ? n.p && (!t || o[0] & /*value*/
      8 | o[2] & /*$$scope*/
      1048576) && Rt(
        n,
        s,
        r,
        /*$$scope*/
        r[82],
        t ? Mt(
          s,
          /*$$scope*/
          r[82],
          o,
          Moe
        ) : Ft(
          /*$$scope*/
          r[82]
        ),
        FF
      ) : l && l.p && (!t || o[0] & /*value, label*/
      4104) && l.p(r, t ? o : [-1, -1, -1, -1, -1]), (!t || o[1] & /*hideSelectedItem*/
      16) && Q(
        e,
        "hide-selected-item",
        /*hideSelectedItem*/
        r[35]
      );
    },
    i(r) {
      t || (w(l, r), t = !0);
    },
    o(r) {
      C(l, r), t = !1;
    },
    d(r) {
      r && S(e), l && l.d(r);
    }
  };
}
f(Koe, "create_else_block$k");
function Yoe(i) {
  let e, t, s = oe(
    /*value*/
    i[3]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = xF(NF(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, o) {
      if (o[0] & /*activeValue, disabled, multiFullItemClearable, value, label*/
      67116040 | o[1] & /*handleMultiItemClear*/
      32 | o[2] & /*$$scope*/
      1048576) {
        s = oe(
          /*value*/
          r[3]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = NF(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = xF(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f(Yoe, "create_if_block_5$9");
function Xoe(i) {
  let e = (
    /*value*/
    i[3][
      /*label*/
      i[12]
    ] + ""
  ), t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n[0] & /*value, label*/
      4104 && e !== (e = /*value*/
      s[3][
        /*label*/
        s[12]
      ] + "") && _e(t, e);
    },
    d(s) {
      s && S(t);
    }
  };
}
f(Xoe, "fallback_block_7");
function Joe(i) {
  let e = (
    /*item*/
    i[126][
      /*label*/
      i[12]
    ] + ""
  ), t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n[0] & /*value, label*/
      4104 && e !== (e = /*item*/
      s[126][
        /*label*/
        s[12]
      ] + "") && _e(t, e);
    },
    d(s) {
      s && S(t);
    }
  };
}
f(Joe, "fallback_block_6");
function QF(i) {
  let e, t, s, n;
  const l = (
    /*#slots*/
    i[83]["multi-clear-icon"]
  ), r = Pt(
    l,
    i,
    /*$$scope*/
    i[82],
    jF
  ), o = r || Zoe();
  function a() {
    return (
      /*pointerup_handler_1*/
      i[92](
        /*i*/
        i[128]
      )
    );
  }
  return f(a, "pointerup_handler_1"), {
    c() {
      e = E("div"), o && o.c(), b(e, "class", "multi-item-clear svelte-82qwg8");
    },
    m(c, u) {
      T(c, e, u), o && o.m(e, null), t = !0, s || (n = V(e, "pointerup", We(tt(a))), s = !0);
    },
    p(c, u) {
      i = c, r && r.p && (!t || u[2] & /*$$scope*/
      1048576) && Rt(
        r,
        l,
        i,
        /*$$scope*/
        i[82],
        t ? Mt(
          l,
          /*$$scope*/
          i[82],
          u,
          Roe
        ) : Ft(
          /*$$scope*/
          i[82]
        ),
        jF
      );
    },
    i(c) {
      t || (w(o, c), t = !0);
    },
    o(c) {
      C(o, c), t = !1;
    },
    d(c) {
      c && S(e), o && o.d(c), s = !1, n();
    }
  };
}
f(QF, "create_if_block_6$8");
function Zoe(i) {
  let e, t;
  return e = new Ca({}), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Zoe, "fallback_block_5");
function xF(i) {
  let e, t, s, n, l, r, o;
  const a = (
    /*#slots*/
    i[83].selection
  ), c = Pt(
    a,
    i,
    /*$$scope*/
    i[82],
    LF
  ), u = c || Joe(i);
  let d = !/*disabled*/
  i[11] && !/*multiFullItemClearable*/
  i[10] && Ca && QF(i);
  function p() {
    return (
      /*click_handler_1*/
      i[93](
        /*i*/
        i[128]
      )
    );
  }
  return f(p, "click_handler_1"), {
    c() {
      e = E("div"), t = E("span"), u && u.c(), s = R(), d && d.c(), n = R(), b(t, "class", "multi-item-text svelte-82qwg8"), b(e, "class", "multi-item svelte-82qwg8"), b(e, "role", "none"), Q(
        e,
        "active",
        /*activeValue*/
        i[26] === /*i*/
        i[128]
      ), Q(
        e,
        "disabled",
        /*disabled*/
        i[11]
      );
    },
    m(m, g) {
      T(m, e, g), A(e, t), u && u.m(t, null), A(e, s), d && d.m(e, null), A(e, n), l = !0, r || (o = [
        V(e, "click", tt(p)),
        V(e, "keydown", We(tt(
          /*keydown_handler_1*/
          i[84]
        )))
      ], r = !0);
    },
    p(m, g) {
      i = m, c ? c.p && (!l || g[0] & /*value*/
      8 | g[2] & /*$$scope*/
      1048576) && Rt(
        c,
        a,
        i,
        /*$$scope*/
        i[82],
        l ? Mt(
          a,
          /*$$scope*/
          i[82],
          g,
          Foe
        ) : Ft(
          /*$$scope*/
          i[82]
        ),
        LF
      ) : u && u.p && (!l || g[0] & /*value, label*/
      4104) && u.p(i, l ? g : [-1, -1, -1, -1, -1]), !/*disabled*/
      i[11] && !/*multiFullItemClearable*/
      i[10] && Ca ? d ? (d.p(i, g), g[0] & /*disabled, multiFullItemClearable*/
      3072 && w(d, 1)) : (d = QF(i), d.c(), w(d, 1), d.m(e, n)) : d && (ce(), C(d, 1, 1, () => {
        d = null;
      }), ue()), (!l || g[0] & /*activeValue*/
      67108864) && Q(
        e,
        "active",
        /*activeValue*/
        i[26] === /*i*/
        i[128]
      ), (!l || g[0] & /*disabled*/
      2048) && Q(
        e,
        "disabled",
        /*disabled*/
        i[11]
      );
    },
    i(m) {
      l || (w(u, m), w(d), l = !0);
    },
    o(m) {
      C(u, m), C(d), l = !1;
    },
    d(m) {
      m && S(e), u && u.d(m), d && d.d(), r = !1, Ne(o);
    }
  };
}
f(xF, "create_each_block$z");
function eN(i) {
  let e, t;
  const s = (
    /*#slots*/
    i[83]["loading-icon"]
  ), n = Pt(
    s,
    i,
    /*$$scope*/
    i[82],
    RF
  ), l = n || Qoe();
  return {
    c() {
      e = E("div"), l && l.c(), b(e, "class", "icon loading svelte-82qwg8"), b(e, "aria-hidden", "true");
    },
    m(r, o) {
      T(r, e, o), l && l.m(e, null), t = !0;
    },
    p(r, o) {
      n && n.p && (!t || o[2] & /*$$scope*/
      1048576) && Rt(
        n,
        s,
        r,
        /*$$scope*/
        r[82],
        t ? Mt(
          s,
          /*$$scope*/
          r[82],
          o,
          Poe
        ) : Ft(
          /*$$scope*/
          r[82]
        ),
        RF
      );
    },
    i(r) {
      t || (w(l, r), t = !0);
    },
    o(r) {
      C(l, r), t = !1;
    },
    d(r) {
      r && S(e), l && l.d(r);
    }
  };
}
f(eN, "create_if_block_3$j");
function Qoe(i) {
  let e, t;
  return e = new gk({}), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Qoe, "fallback_block_4");
function tN(i) {
  let e, t, s, n;
  const l = (
    /*#slots*/
    i[83]["clear-icon"]
  ), r = Pt(
    l,
    i,
    /*$$scope*/
    i[82],
    MF
  ), o = r || xoe();
  return {
    c() {
      e = E("button"), o && o.c(), b(e, "type", "button"), b(e, "class", "icon clear-select svelte-82qwg8");
    },
    m(a, c) {
      T(a, e, c), o && o.m(e, null), t = !0, s || (n = V(
        e,
        "click",
        /*handleClear*/
        i[22]
      ), s = !0);
    },
    p(a, c) {
      r && r.p && (!t || c[2] & /*$$scope*/
      1048576) && Rt(
        r,
        l,
        a,
        /*$$scope*/
        a[82],
        t ? Mt(
          l,
          /*$$scope*/
          a[82],
          c,
          Ioe
        ) : Ft(
          /*$$scope*/
          a[82]
        ),
        MF
      );
    },
    i(a) {
      t || (w(o, a), t = !0);
    },
    o(a) {
      C(o, a), t = !1;
    },
    d(a) {
      a && S(e), o && o.d(a), s = !1, n();
    }
  };
}
f(tN, "create_if_block_2$t");
function xoe(i) {
  let e, t;
  return e = new Ca({}), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(xoe, "fallback_block_3");
function sN(i) {
  let e, t;
  const s = (
    /*#slots*/
    i[83]["chevron-icon"]
  ), n = Pt(
    s,
    i,
    /*$$scope*/
    i[82],
    PF
  ), l = n || eae();
  return {
    c() {
      e = E("div"), l && l.c(), b(e, "class", "icon chevron svelte-82qwg8"), b(e, "aria-hidden", "true");
    },
    m(r, o) {
      T(r, e, o), l && l.m(e, null), t = !0;
    },
    p(r, o) {
      n && n.p && (!t || o[0] & /*listOpen*/
      64 | o[2] & /*$$scope*/
      1048576) && Rt(
        n,
        s,
        r,
        /*$$scope*/
        r[82],
        t ? Mt(
          s,
          /*$$scope*/
          r[82],
          o,
          Doe
        ) : Ft(
          /*$$scope*/
          r[82]
        ),
        PF
      );
    },
    i(r) {
      t || (w(l, r), t = !0);
    },
    o(r) {
      C(l, r), t = !1;
    },
    d(r) {
      r && S(e), l && l.d(r);
    }
  };
}
f(sN, "create_if_block_1$F");
function eae(i) {
  let e, t;
  return e = new hk({}), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(eae, "fallback_block_2");
function tae(i) {
  let e, t;
  return {
    c() {
      e = E("input"), b(
        e,
        "name",
        /*name*/
        i[8]
      ), b(e, "type", "hidden"), e.value = t = /*value*/
      i[3] ? JSON.stringify(
        /*value*/
        i[3]
      ) : null, b(e, "class", "svelte-82qwg8");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n[0] & /*name*/
      256 && b(
        e,
        "name",
        /*name*/
        s[8]
      ), n[0] & /*value*/
      8 && t !== (t = /*value*/
      s[3] ? JSON.stringify(
        /*value*/
        s[3]
      ) : null) && (e.value = t);
    },
    d(s) {
      s && S(e);
    }
  };
}
f(tae, "fallback_block_1");
function nN(i) {
  let e;
  const t = (
    /*#slots*/
    i[83].required
  ), s = Pt(
    t,
    i,
    /*$$scope*/
    i[82],
    DF
  ), n = s || sae();
  return {
    c() {
      n && n.c();
    },
    m(l, r) {
      n && n.m(l, r), e = !0;
    },
    p(l, r) {
      s && s.p && (!e || r[0] & /*value*/
      8 | r[2] & /*$$scope*/
      1048576) && Rt(
        s,
        t,
        l,
        /*$$scope*/
        l[82],
        e ? Mt(
          t,
          /*$$scope*/
          l[82],
          r,
          Coe
        ) : Ft(
          /*$$scope*/
          l[82]
        ),
        DF
      );
    },
    i(l) {
      e || (w(n, l), e = !0);
    },
    o(l) {
      C(n, l), e = !1;
    },
    d(l) {
      n && n.d(l);
    }
  };
}
f(nN, "create_if_block$U");
function sae(i) {
  let e;
  return {
    c() {
      e = E("select"), b(e, "class", "required svelte-82qwg8"), e.required = !0, b(e, "tabindex", "-1"), b(e, "aria-hidden", "true");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: ee,
    d(t) {
      t && S(e);
    }
  };
}
f(sae, "fallback_block");
function nae(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k, v, O, P = (
    /*listOpen*/
    i[6] && WF(i)
  ), D = (
    /*focused*/
    i[2] && JF(i)
  );
  const I = (
    /*#slots*/
    i[83].prepend
  ), B = Pt(
    I,
    i,
    /*$$scope*/
    i[82],
    BF
  );
  let F = (
    /*hasValue*/
    i[25] && ZF(i)
  ), H = [
    {
      readOnly: u = !/*searchable*/
      i[17]
    },
    /*_inputAttributes*/
    i[27],
    { placeholder: (
      /*placeholderText*/
      i[33]
    ) },
    { style: (
      /*inputStyles*/
      i[18]
    ) },
    { disabled: (
      /*disabled*/
      i[11]
    ) }
  ], G = {};
  for (let ae = 0; ae < H.length; ae += 1)
    G = fs(G, H[ae]);
  let U = (
    /*loading*/
    i[5] && eN(i)
  ), q = (
    /*showClear*/
    i[34] && tN(i)
  ), W = (
    /*showChevron*/
    i[20] && sN(i)
  );
  const X = (
    /*#slots*/
    i[83]["input-hidden"]
  ), te = Pt(
    X,
    i,
    /*$$scope*/
    i[82],
    IF
  ), J = te || tae(i);
  let re = (
    /*required*/
    i[16] && (!/*value*/
    i[3] || /*value*/
    i[3].length === 0) && nN(i)
  );
  return {
    c() {
      e = E("div"), P && P.c(), t = R(), s = E("span"), D && D.c(), n = R(), l = E("div"), B && B.c(), r = R(), o = E("div"), F && F.c(), a = R(), c = E("input"), d = R(), p = E("div"), U && U.c(), m = R(), q && q.c(), g = R(), W && W.c(), h = R(), J && J.c(), _ = R(), re && re.c(), b(s, "aria-live", "polite"), b(s, "aria-atomic", "false"), b(s, "aria-relevant", "additions text"), b(s, "class", "a11y-text svelte-82qwg8"), b(l, "class", "prepend svelte-82qwg8"), yd(c, G), Q(c, "svelte-82qwg8", !0), b(o, "class", "value-container svelte-82qwg8"), b(p, "class", "indicators svelte-82qwg8"), b(e, "class", y = "svelte-select " + /*containerClasses*/
      i[21] + " svelte-82qwg8"), b(
        e,
        "style",
        /*containerStyles*/
        i[14]
      ), b(e, "role", "none"), Q(
        e,
        "multi",
        /*multiple*/
        i[9]
      ), Q(
        e,
        "disabled",
        /*disabled*/
        i[11]
      ), Q(
        e,
        "focused",
        /*focused*/
        i[2]
      ), Q(
        e,
        "list-open",
        /*listOpen*/
        i[6]
      ), Q(
        e,
        "show-chevron",
        /*showChevron*/
        i[20]
      ), Q(
        e,
        "error",
        /*hasError*/
        i[15]
      );
    },
    m(ae, be) {
      T(ae, e, be), P && P.m(e, null), A(e, t), A(e, s), D && D.m(s, null), A(e, n), A(e, l), B && B.m(l, null), A(e, r), A(e, o), F && F.m(o, null), A(o, a), A(o, c), c.autofocus && c.focus(), i[94](c), qe(
        c,
        /*filterText*/
        i[4]
      ), A(e, d), A(e, p), U && U.m(p, null), A(p, m), q && q.m(p, null), A(p, g), W && W.m(p, null), A(e, h), J && J.m(e, null), A(e, _), re && re.m(e, null), i[96](e), k = !0, v || (O = [
        V(
          window,
          "click",
          /*handleClickOutside*/
          i[42]
        ),
        V(
          window,
          "keydown",
          /*handleKeyDown*/
          i[37]
        ),
        V(
          c,
          "keydown",
          /*handleKeyDown*/
          i[37]
        ),
        V(
          c,
          "blur",
          /*handleBlur*/
          i[39]
        ),
        V(
          c,
          "focus",
          /*handleFocus*/
          i[38]
        ),
        V(
          c,
          "input",
          /*input_1_input_handler*/
          i[95]
        ),
        V(e, "pointerup", tt(
          /*handleClick*/
          i[40]
        )),
        At(
          /*floatingRef*/
          i[48].call(null, e)
        )
      ], v = !0);
    },
    p(ae, be) {
      /*listOpen*/
      ae[6] ? P ? (P.p(ae, be), be[0] & /*listOpen*/
      64 && w(P, 1)) : (P = WF(ae), P.c(), w(P, 1), P.m(e, t)) : P && (ce(), C(P, 1, 1, () => {
        P = null;
      }), ue()), /*focused*/
      ae[2] ? D ? D.p(ae, be) : (D = JF(ae), D.c(), D.m(s, null)) : D && (D.d(1), D = null), B && B.p && (!k || be[2] & /*$$scope*/
      1048576) && Rt(
        B,
        I,
        ae,
        /*$$scope*/
        ae[82],
        k ? Mt(
          I,
          /*$$scope*/
          ae[82],
          be,
          Noe
        ) : Ft(
          /*$$scope*/
          ae[82]
        ),
        BF
      ), /*hasValue*/
      ae[25] ? F ? (F.p(ae, be), be[0] & /*hasValue*/
      33554432 && w(F, 1)) : (F = ZF(ae), F.c(), w(F, 1), F.m(o, a)) : F && (ce(), C(F, 1, 1, () => {
        F = null;
      }), ue()), yd(c, G = hs(H, [
        (!k || be[0] & /*searchable*/
        131072 && u !== (u = !/*searchable*/
        ae[17])) && { readOnly: u },
        be[0] & /*_inputAttributes*/
        134217728 && /*_inputAttributes*/
        ae[27],
        (!k || be[1] & /*placeholderText*/
        4) && { placeholder: (
          /*placeholderText*/
          ae[33]
        ) },
        (!k || be[0] & /*inputStyles*/
        262144) && { style: (
          /*inputStyles*/
          ae[18]
        ) },
        (!k || be[0] & /*disabled*/
        2048) && { disabled: (
          /*disabled*/
          ae[11]
        ) }
      ])), be[0] & /*filterText*/
      16 && c.value !== /*filterText*/
      ae[4] && qe(
        c,
        /*filterText*/
        ae[4]
      ), Q(c, "svelte-82qwg8", !0), /*loading*/
      ae[5] ? U ? (U.p(ae, be), be[0] & /*loading*/
      32 && w(U, 1)) : (U = eN(ae), U.c(), w(U, 1), U.m(p, m)) : U && (ce(), C(U, 1, 1, () => {
        U = null;
      }), ue()), /*showClear*/
      ae[34] ? q ? (q.p(ae, be), be[1] & /*showClear*/
      8 && w(q, 1)) : (q = tN(ae), q.c(), w(q, 1), q.m(p, g)) : q && (ce(), C(q, 1, 1, () => {
        q = null;
      }), ue()), /*showChevron*/
      ae[20] ? W ? (W.p(ae, be), be[0] & /*showChevron*/
      1048576 && w(W, 1)) : (W = sN(ae), W.c(), w(W, 1), W.m(p, null)) : W && (ce(), C(W, 1, 1, () => {
        W = null;
      }), ue()), te ? te.p && (!k || be[0] & /*value*/
      8 | be[2] & /*$$scope*/
      1048576) && Rt(
        te,
        X,
        ae,
        /*$$scope*/
        ae[82],
        k ? Mt(
          X,
          /*$$scope*/
          ae[82],
          be,
          Ooe
        ) : Ft(
          /*$$scope*/
          ae[82]
        ),
        IF
      ) : J && J.p && (!k || be[0] & /*name, value*/
      264) && J.p(ae, k ? be : [-1, -1, -1, -1, -1]), /*required*/
      ae[16] && (!/*value*/
      ae[3] || /*value*/
      ae[3].length === 0) ? re ? (re.p(ae, be), be[0] & /*required, value*/
      65544 && w(re, 1)) : (re = nN(ae), re.c(), w(re, 1), re.m(e, null)) : re && (ce(), C(re, 1, 1, () => {
        re = null;
      }), ue()), (!k || be[0] & /*containerClasses*/
      2097152 && y !== (y = "svelte-select " + /*containerClasses*/
      ae[21] + " svelte-82qwg8")) && b(e, "class", y), (!k || be[0] & /*containerStyles*/
      16384) && b(
        e,
        "style",
        /*containerStyles*/
        ae[14]
      ), (!k || be[0] & /*containerClasses, multiple*/
      2097664) && Q(
        e,
        "multi",
        /*multiple*/
        ae[9]
      ), (!k || be[0] & /*containerClasses, disabled*/
      2099200) && Q(
        e,
        "disabled",
        /*disabled*/
        ae[11]
      ), (!k || be[0] & /*containerClasses, focused*/
      2097156) && Q(
        e,
        "focused",
        /*focused*/
        ae[2]
      ), (!k || be[0] & /*containerClasses, listOpen*/
      2097216) && Q(
        e,
        "list-open",
        /*listOpen*/
        ae[6]
      ), (!k || be[0] & /*containerClasses, showChevron*/
      3145728) && Q(
        e,
        "show-chevron",
        /*showChevron*/
        ae[20]
      ), (!k || be[0] & /*containerClasses, hasError*/
      2129920) && Q(
        e,
        "error",
        /*hasError*/
        ae[15]
      );
    },
    i(ae) {
      k || (w(P), w(B, ae), w(F), w(U), w(q), w(W), w(J, ae), w(re), k = !0);
    },
    o(ae) {
      C(P), C(B, ae), C(F), C(U), C(q), C(W), C(J, ae), C(re), k = !1;
    },
    d(ae) {
      ae && S(e), P && P.d(), D && D.d(), B && B.d(ae), F && F.d(), i[94](null), U && U.d(), q && q.d(), W && W.d(), J && J.d(ae), re && re.d(), i[96](null), v = !1, Ne(O);
    }
  };
}
f(nae, "create_fragment$1D");
function iN(i) {
  return i.map((e, t) => ({ index: t, value: e, label: `${e}` }));
}
f(iN, "convertStringItemsToObjects");
function iae(i) {
  return i === 0;
}
f(iae, "isItemFirst");
function lae(i) {
  return i.groupHeader && i.selectable || i.selectable || !i.hasOwnProperty("selectable");
}
f(lae, "isItemSelectable");
function rae(i, e, t) {
  let s, n, l, r, o, a, c, u, d, { $$slots: p = {}, $$scope: m } = e;
  const g = b7(p), h = it();
  let { justValue: _ = null } = e, { filter: y = $oe } = e, { getItems: k = Aoe } = e, { id: v = null } = e, { name: O = null } = e, { container: P = void 0 } = e, { input: D = void 0 } = e, { multiple: I = !1 } = e, { multiFullItemClearable: B = !1 } = e, { disabled: F = !1 } = e, { focused: H = !1 } = e, { value: G = null } = e, { filterText: U = "" } = e, { placeholder: q = "Please select" } = e, { placeholderAlwaysShow: W = !1 } = e, { items: X = null } = e, { label: te = "label" } = e, { itemFilter: J = /* @__PURE__ */ f((ge, Qe, Jt) => `${ge}`.toLowerCase().includes(Qe.toLowerCase()), "itemFilter") } = e, { groupBy: re = void 0 } = e, { groupFilter: ae = /* @__PURE__ */ f((ge) => ge, "groupFilter") } = e, { groupHeaderSelectable: be = !1 } = e, { itemId: we = "value" } = e, { loadOptions: ve = void 0 } = e, { containerStyles: me = "" } = e, { hasError: he = !1 } = e, { filterSelectedItems: Ae = !0 } = e, { required: Fe = !1 } = e, { closeListOnChange: Ve = !0 } = e, { clearFilterTextOnBlur: je = !0 } = e, { createGroupHeaderItem: Pe = /* @__PURE__ */ f((ge, Qe) => ({ value: ge, [te]: ge }), "createGroupHeaderItem") } = e;
  const rt = /* @__PURE__ */ f(() => c, "getFilteredItems");
  let { searchable: Te = !0 } = e, { inputStyles: Ee = "" } = e, { clearable: Be = !0 } = e, { loading: Ce = !1 } = e, { listOpen: Re = !1 } = e, Oe, { debounce: Je = /* @__PURE__ */ f((ge, Qe = 1) => {
    clearTimeout(Oe), Oe = setTimeout(ge, Qe);
  }, "debounce") } = e, { debounceWait: Xe = 300 } = e, { hideEmptyState: Gt = !1 } = e, { inputAttributes: zt = {} } = e, { listAutoWidth: Hi = !0 } = e, { showChevron: wl = !1 } = e, { listOffset: Ui = 5 } = e, { hoverItemIndex: St = 0 } = e, { floatingConfig: Xs = {} } = e, { class: $l = "" } = e, Ht, fi, Fa, Na;
  function If() {
    if (typeof G == "string") {
      let ge = (X || []).find((Qe) => Qe[we] === G);
      t(3, G = ge || { [we]: G, label: G });
    } else
      I && Array.isArray(G) && G.length > 0 && t(3, G = G.map((ge) => typeof ge == "string" ? { value: ge, label: ge } : ge));
  }
  f(If, "setValue");
  let Vi;
  function pb() {
    t(27, Vi = Object.assign(
      {
        autocapitalize: "none",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: !1,
        tabindex: 0,
        type: "text",
        "aria-autocomplete": "list"
      },
      zt
    )), v && t(27, Vi.id = v, Vi), Te || t(27, Vi.readonly = !0, Vi);
  }
  f(pb, "assignInputAttributes");
  function Se(ge) {
    const Qe = [], Jt = {};
    ge.forEach((jr) => {
      const mi = re(jr);
      Qe.includes(mi) || (Qe.push(mi), Jt[mi] = [], mi && Jt[mi].push(Object.assign(Pe(mi, jr), {
        id: mi,
        groupHeader: !0,
        selectable: be
      }))), Jt[mi].push(Object.assign({ groupItem: !!mi }, jr));
    });
    const pi = [];
    return ae(Qe).forEach((jr) => {
      Jt[jr] && pi.push(...Jt[jr]);
    }), pi;
  }
  f(Se, "filterGroupedItems");
  function xe() {
    if (I) {
      JSON.stringify(G) !== JSON.stringify(fi) && cO() && h("input", G);
      return;
    }
    (!fi || JSON.stringify(G[we]) !== JSON.stringify(fi[we])) && h("input", G);
  }
  f(xe, "dispatchSelectedItem");
  function Tt() {
    G && (Array.isArray(G) ? t(3, G = [...G]) : t(3, G = [G]));
  }
  f(Tt, "setupMulti");
  function Ct() {
    G && t(3, G = null);
  }
  f(Ct, "setupSingle");
  function yn() {
    const ge = c.findIndex((Qe) => Qe[we] === G[we]);
    Mf(ge, !0);
  }
  f(yn, "setValueIndexAsHoverIndex");
  function Pf(ge) {
    h("hoverItem", ge);
  }
  f(Pf, "dispatchHover");
  function Mf(ge = 0, Qe) {
    t(7, St = ge < 0 ? 0 : ge), !Qe && re && c[St] && !c[St].selectable && Ff(1);
  }
  f(Mf, "checkHoverSelectable");
  function mb() {
    !ve && U.length === 0 || (ve ? Je(
      async function() {
        t(5, Ce = !0);
        let ge = await k({
          dispatch: h,
          loadOptions: ve,
          convertStringItemsToObjects: iN,
          filterText: U
        });
        ge ? (t(5, Ce = ge.loading), t(6, Re = Re ? ge.listOpen : U.length > 0), t(2, H = Re && ge.focused), t(51, X = re ? Se(ge.filteredItems) : ge.filteredItems)) : (t(5, Ce = !1), t(2, H = !0), t(6, Re = !0));
      },
      Xe
    ) : (t(6, Re = !0), I && t(26, Ht = void 0)));
  }
  f(mb, "setupFilterText");
  function Wq(ge) {
    Re && h("filter", ge);
  }
  f(Wq, "handleFilterEvent"), $z(async () => {
    t(78, fi = G), t(79, Fa = U), t(80, Na = I);
  });
  function Kq() {
    return I ? G ? G.map((ge) => ge[we]) : null : G && G[we];
  }
  f(Kq, "computeJustValue");
  function cO() {
    let ge = !0;
    if (G) {
      const Qe = [], Jt = [];
      G.forEach((pi) => {
        Qe.includes(pi[we]) ? ge = !1 : (Qe.push(pi[we]), Jt.push(pi));
      }), ge || t(3, G = Jt);
    }
    return ge;
  }
  f(cO, "checkValueForDuplicates");
  function uO(ge) {
    let Qe = ge ? ge[we] : G[we];
    return X.find((Jt) => Jt[we] === Qe);
  }
  f(uO, "findItem");
  function Yq(ge) {
    !ge || ge.length === 0 || ge.some((Qe) => typeof Qe != "object") || !G || (I ? G.some((Qe) => !Qe || !Qe[we]) : !G[we]) || (Array.isArray(G) ? t(3, G = G.map((Qe) => uO(Qe) || Qe)) : t(3, G = uO() || G));
  }
  f(Yq, "updateValueDisplay");
  async function Rf(ge) {
    const Qe = G[ge];
    G.length === 1 ? t(3, G = void 0) : t(3, G = G.filter((Jt) => Jt !== Qe)), h("clear", Qe);
  }
  f(Rf, "handleMultiItemClear");
  function Xq(ge) {
    if (H)
      switch (ge.stopPropagation(), ge.key) {
        case "Escape":
          ge.preventDefault(), di();
          break;
        case "Enter":
          if (ge.preventDefault(), Re) {
            if (c.length === 0)
              break;
            const Qe = c[St];
            if (G && !I && G[we] === Qe[we]) {
              di();
              break;
            } else
              vb(c[St]);
          }
          break;
        case "ArrowDown":
          ge.preventDefault(), Re ? Ff(1) : (t(6, Re = !0), t(26, Ht = void 0));
          break;
        case "ArrowUp":
          ge.preventDefault(), Re ? Ff(-1) : (t(6, Re = !0), t(26, Ht = void 0));
          break;
        case "Tab":
          if (Re && H) {
            if (c.length === 0 || G && G[we] === c[St][we])
              return di();
            ge.preventDefault(), vb(c[St]), di();
          }
          break;
        case "Backspace":
          if (!I || U.length > 0)
            return;
          if (I && G && G.length > 0) {
            if (Rf(Ht !== void 0 ? Ht : G.length - 1), Ht === 0 || Ht === void 0)
              break;
            t(26, Ht = G.length > Ht ? Ht - 1 : void 0);
          }
          break;
        case "ArrowLeft":
          if (!G || !I || U.length > 0)
            return;
          Ht === void 0 ? t(26, Ht = G.length - 1) : G.length > Ht && Ht !== 0 && t(26, Ht -= 1);
          break;
        case "ArrowRight":
          if (!G || !I || U.length > 0 || Ht === void 0)
            return;
          Ht === G.length - 1 ? t(26, Ht = void 0) : Ht < G.length - 1 && t(26, Ht += 1);
          break;
      }
  }
  f(Xq, "handleKeyDown");
  function hb(ge) {
    H && D === (document == null ? void 0 : document.activeElement) || (ge && h("focus", ge), D == null || D.focus(), t(2, H = !0));
  }
  f(hb, "handleFocus");
  async function fO(ge) {
    yb || (Re || H) && (h("blur", ge), di(), t(2, H = !1), t(26, Ht = void 0), D == null || D.blur());
  }
  f(fO, "handleBlur");
  function Jq() {
    if (!F) {
      if (U.length > 0)
        return t(6, Re = !0);
      t(6, Re = !Re);
    }
  }
  f(Jq, "handleClick");
  function Zq() {
    h("clear", G), t(3, G = void 0), di(), hb();
  }
  f(Zq, "handleClear"), Sr(() => {
    Re && t(2, H = !0), H && D && D.focus();
  });
  function Qq(ge) {
    if (ge) {
      t(4, U = "");
      const Qe = Object.assign({}, ge);
      if (Qe.groupHeader && !Qe.selectable)
        return;
      t(3, G = I ? G ? G.concat([Qe]) : [Qe] : t(3, G = Qe)), setTimeout(() => {
        Ve && di(), t(26, Ht = void 0), h("change", G), h("select", ge);
      });
    }
  }
  f(Qq, "itemSelected");
  function di() {
    je && t(4, U = ""), t(6, Re = !1);
  }
  f(di, "closeList");
  let { ariaValues: gb = /* @__PURE__ */ f((ge) => `Option ${ge}, selected.`, "ariaValues") } = e, { ariaListOpen: bb = /* @__PURE__ */ f((ge, Qe) => `You are currently focused on option ${ge}. There are ${Qe} results available.`, "ariaListOpen") } = e, { ariaFocused: _b = /* @__PURE__ */ f(() => "Select is focused, type to refine list, press down to open the menu.", "ariaFocused") } = e;
  function xq(ge) {
    let Qe;
    return ge && G.length > 0 ? Qe = G.map((Jt) => Jt[te]).join(", ") : Qe = G[te], gb(Qe);
  }
  f(xq, "handleAriaSelection");
  function eG() {
    if (!c || c.length === 0)
      return "";
    let ge = c[St];
    if (Re && ge) {
      let Qe = c ? c.length : 0;
      return bb(ge[te], Qe);
    } else
      return _b();
  }
  f(eG, "handleAriaContent");
  let Ts = null, dO;
  function pO() {
    clearTimeout(dO), dO = setTimeout(
      () => {
        yb = !1;
      },
      100
    );
  }
  f(pO, "handleListScroll");
  function tG(ge) {
    !Re && !H && P && !P.contains(ge.target) && !(Ts != null && Ts.contains(ge.target)) && fO();
  }
  f(tG, "handleClickOutside"), Nt(() => {
    Ts == null || Ts.remove();
  });
  let yb = !1;
  function vb(ge) {
    !ge || ge.selectable === !1 || Qq(ge);
  }
  f(vb, "handleSelect");
  function kb(ge) {
    yb || t(7, St = ge);
  }
  f(kb, "handleHover");
  function mO(ge) {
    const { item: Qe, i: Jt } = ge;
    if ((Qe == null ? void 0 : Qe.selectable) !== !1) {
      if (G && !I && G[we] === Qe[we])
        return di();
      lae(Qe) && (t(7, St = Jt), vb(Qe));
    }
  }
  f(mO, "handleItemClick");
  function Ff(ge) {
    if (c.filter((pi) => !Object.hasOwn(pi, "selectable") || pi.selectable === !0).length === 0)
      return t(7, St = 0);
    ge > 0 && St === c.length - 1 ? t(7, St = 0) : ge < 0 && St === 0 ? t(7, St = c.length - 1) : t(7, St = St + ge);
    const Jt = c[St];
    if (Jt && Jt.selectable === !1) {
      (ge === 1 || ge === -1) && Ff(ge);
      return;
    }
  }
  f(Ff, "setHoverIndex");
  function sG(ge, Qe, Jt) {
    if (!I)
      return Qe && Qe[Jt] === ge[Jt];
  }
  f(sG, "isItemActive");
  const nG = hO, iG = hO;
  function hO(ge) {
    return {
      update(Qe) {
        Qe.scroll && (pO(), ge.scrollIntoView({ behavior: "auto", block: "nearest" }));
      }
    };
  }
  f(hO, "scrollAction");
  function lG() {
    const { width: ge } = P.getBoundingClientRect();
    t(23, Ts.style.width = Hi ? ge + "px" : "auto", Ts);
  }
  f(lG, "setListWidth");
  let ja = {
    strategy: "absolute",
    placement: "bottom-start",
    middleware: [_oe(Ui), voe(), yoe()],
    autoUpdate: !1
  };
  const [rG, oG, aG] = woe(ja);
  let wb = !0;
  function cG(ge, Qe) {
    if (!ge || !Qe)
      return t(28, wb = !0);
    setTimeout(
      () => {
        t(28, wb = !1);
      },
      0
    );
  }
  f(cG, "listMounted");
  function uG(ge) {
    gt.call(this, i, ge);
  }
  f(uG, "keydown_handler_1");
  function fG(ge) {
    gt.call(this, i, ge);
  }
  f(fG, "pointerup_handler");
  function dG(ge) {
    gt.call(this, i, ge);
  }
  f(dG, "mousedown_handler");
  function pG(ge) {
    gt.call(this, i, ge);
  }
  f(pG, "keydown_handler");
  const mG = /* @__PURE__ */ f((ge) => kb(ge), "mouseover_handler"), hG = /* @__PURE__ */ f((ge) => kb(ge), "focus_handler"), gG = /* @__PURE__ */ f((ge, Qe) => mO({ item: ge, i: Qe }), "click_handler");
  function bG(ge) {
    st[ge ? "unshift" : "push"](() => {
      Ts = ge, t(23, Ts);
    });
  }
  f(bG, "div_binding");
  const _G = /* @__PURE__ */ f((ge) => Rf(ge), "pointerup_handler_1"), yG = /* @__PURE__ */ f((ge) => B ? Rf(ge) : {}, "click_handler_1");
  function vG(ge) {
    st[ge ? "unshift" : "push"](() => {
      D = ge, t(1, D);
    });
  }
  f(vG, "input_1_binding");
  function kG() {
    U = this.value, t(4, U);
  }
  f(kG, "input_1_input_handler");
  function wG(ge) {
    st[ge ? "unshift" : "push"](() => {
      P = ge, t(0, P);
    });
  }
  return f(wG, "div3_binding"), i.$$set = (ge) => {
    "justValue" in ge && t(52, _ = ge.justValue), "filter" in ge && t(53, y = ge.filter), "getItems" in ge && t(54, k = ge.getItems), "id" in ge && t(55, v = ge.id), "name" in ge && t(8, O = ge.name), "container" in ge && t(0, P = ge.container), "input" in ge && t(1, D = ge.input), "multiple" in ge && t(9, I = ge.multiple), "multiFullItemClearable" in ge && t(10, B = ge.multiFullItemClearable), "disabled" in ge && t(11, F = ge.disabled), "focused" in ge && t(2, H = ge.focused), "value" in ge && t(3, G = ge.value), "filterText" in ge && t(4, U = ge.filterText), "placeholder" in ge && t(56, q = ge.placeholder), "placeholderAlwaysShow" in ge && t(57, W = ge.placeholderAlwaysShow), "items" in ge && t(51, X = ge.items), "label" in ge && t(12, te = ge.label), "itemFilter" in ge && t(58, J = ge.itemFilter), "groupBy" in ge && t(59, re = ge.groupBy), "groupFilter" in ge && t(60, ae = ge.groupFilter), "groupHeaderSelectable" in ge && t(61, be = ge.groupHeaderSelectable), "itemId" in ge && t(13, we = ge.itemId), "loadOptions" in ge && t(62, ve = ge.loadOptions), "containerStyles" in ge && t(14, me = ge.containerStyles), "hasError" in ge && t(15, he = ge.hasError), "filterSelectedItems" in ge && t(63, Ae = ge.filterSelectedItems), "required" in ge && t(16, Fe = ge.required), "closeListOnChange" in ge && t(64, Ve = ge.closeListOnChange), "clearFilterTextOnBlur" in ge && t(65, je = ge.clearFilterTextOnBlur), "createGroupHeaderItem" in ge && t(66, Pe = ge.createGroupHeaderItem), "searchable" in ge && t(17, Te = ge.searchable), "inputStyles" in ge && t(18, Ee = ge.inputStyles), "clearable" in ge && t(68, Be = ge.clearable), "loading" in ge && t(5, Ce = ge.loading), "listOpen" in ge && t(6, Re = ge.listOpen), "debounce" in ge && t(69, Je = ge.debounce), "debounceWait" in ge && t(70, Xe = ge.debounceWait), "hideEmptyState" in ge && t(19, Gt = ge.hideEmptyState), "inputAttributes" in ge && t(71, zt = ge.inputAttributes), "listAutoWidth" in ge && t(72, Hi = ge.listAutoWidth), "showChevron" in ge && t(20, wl = ge.showChevron), "listOffset" in ge && t(73, Ui = ge.listOffset), "hoverItemIndex" in ge && t(7, St = ge.hoverItemIndex), "floatingConfig" in ge && t(74, Xs = ge.floatingConfig), "class" in ge && t(21, $l = ge.class), "ariaValues" in ge && t(75, gb = ge.ariaValues), "ariaListOpen" in ge && t(76, bb = ge.ariaListOpen), "ariaFocused" in ge && t(77, _b = ge.ariaFocused), "$$scope" in ge && t(82, m = ge.$$scope);
  }, i.$$.update = () => {
    i.$$.dirty[0] & /*value*/
    8 | i.$$.dirty[1] & /*items*/
    1048576 && G && If(), i.$$.dirty[0] & /*searchable*/
    131072 | i.$$.dirty[2] & /*inputAttributes*/
    512 && (zt || !Te) && pb(), i.$$.dirty[0] & /*multiple*/
    512 && I && Tt(), i.$$.dirty[0] & /*multiple*/
    512 | i.$$.dirty[2] & /*prev_multiple*/
    262144 && Na && !I && Ct(), i.$$.dirty[0] & /*multiple, value*/
    520 && I && G && G.length > 1 && cO(), i.$$.dirty[0] & /*value*/
    8 && G && xe(), i.$$.dirty[0] & /*value, multiple*/
    520 | i.$$.dirty[2] & /*prev_value*/
    65536 && !G && I && fi && h("input", G), i.$$.dirty[0] & /*focused, input*/
    6 && !H && D && di(), i.$$.dirty[0] & /*filterText*/
    16 | i.$$.dirty[2] & /*prev_filterText*/
    131072 && U !== Fa && mb(), i.$$.dirty[0] & /*filterText, multiple, value, itemId, label*/
    12824 | i.$$.dirty[1] & /*filter, items, groupBy, itemFilter*/
    407896064 | i.$$.dirty[2] & /*loadOptions, filterSelectedItems*/
    3 && t(24, c = y({
      loadOptions: ve,
      filterText: U,
      items: X,
      multiple: I,
      value: G,
      itemId: we,
      groupBy: re,
      label: te,
      filterSelectedItems: Ae,
      itemFilter: J,
      convertStringItemsToObjects: iN,
      filterGroupedItems: Se
    })), i.$$.dirty[0] & /*multiple, listOpen, value, filteredItems*/
    16777800 && !I && Re && G && c && yn(), i.$$.dirty[0] & /*listOpen, multiple*/
    576 && Re && I && t(7, St = 0), i.$$.dirty[0] & /*filterText*/
    16 && U && t(7, St = 0), i.$$.dirty[0] & /*hoverItemIndex*/
    128 && Pf(St), i.$$.dirty[0] & /*multiple, value*/
    520 && t(25, s = I ? G && G.length > 0 : G), i.$$.dirty[0] & /*hasValue, filterText*/
    33554448 && t(35, n = s && U.length > 0), i.$$.dirty[0] & /*hasValue, disabled, loading*/
    33556512 | i.$$.dirty[2] & /*clearable*/
    64 && t(34, l = s && Be && !F && !Ce), i.$$.dirty[0] & /*multiple, value*/
    520 | i.$$.dirty[1] & /*placeholderAlwaysShow, placeholder*/
    100663296 && t(33, r = W && I || I && (G == null ? void 0 : G.length) === 0 ? q : G ? "" : q), i.$$.dirty[0] & /*value, multiple*/
    520 && t(32, o = G ? xq(I) : ""), i.$$.dirty[0] & /*filteredItems, hoverItemIndex, focused, listOpen*/
    16777412 && t(31, a = eG()), i.$$.dirty[1] & /*items*/
    1048576 && Yq(X), i.$$.dirty[0] & /*multiple, value, itemId*/
    8712 && t(52, _ = Kq()), i.$$.dirty[0] & /*multiple, value*/
    520 | i.$$.dirty[2] & /*prev_value*/
    65536 && !I && fi && !G && h("input", G), i.$$.dirty[0] & /*listOpen, filteredItems, multiple, value*/
    16777800 && Re && c && !I && !G && Mf(), i.$$.dirty[0] & /*filteredItems*/
    16777216 && Wq(c), i.$$.dirty[0] & /*container*/
    1 | i.$$.dirty[2] & /*floatingConfig*/
    4096 && P && (Xs == null ? void 0 : Xs.autoUpdate) === void 0 && t(81, ja.autoUpdate = !0, ja), i.$$.dirty[0] & /*container*/
    1 | i.$$.dirty[2] & /*floatingConfig, _floatingConfig*/
    528384 && P && Xs && aG(Object.assign(ja, Xs)), i.$$.dirty[0] & /*list*/
    8388608 && t(30, u = !!Ts), i.$$.dirty[0] & /*list, listOpen*/
    8388672 && cG(Ts, Re), i.$$.dirty[0] & /*listOpen, container, list*/
    8388673 && Re && P && Ts && lG(), i.$$.dirty[0] & /*hoverItemIndex*/
    128 && t(29, d = St), i.$$.dirty[0] & /*input, listOpen, focused*/
    70 && D && Re && !H && hb();
  }, [
    P,
    D,
    H,
    G,
    U,
    Ce,
    Re,
    St,
    O,
    I,
    B,
    F,
    te,
    we,
    me,
    he,
    Fe,
    Te,
    Ee,
    Gt,
    wl,
    $l,
    Zq,
    Ts,
    c,
    s,
    Ht,
    Vi,
    wb,
    d,
    u,
    a,
    o,
    r,
    l,
    n,
    Rf,
    Xq,
    hb,
    fO,
    Jq,
    pO,
    tG,
    kb,
    mO,
    sG,
    nG,
    iG,
    rG,
    oG,
    g,
    X,
    _,
    y,
    k,
    v,
    q,
    W,
    J,
    re,
    ae,
    be,
    ve,
    Ae,
    Ve,
    je,
    Pe,
    rt,
    Be,
    Je,
    Xe,
    zt,
    Hi,
    Ui,
    Xs,
    gb,
    bb,
    _b,
    fi,
    Fa,
    Na,
    ja,
    m,
    p,
    uG,
    fG,
    dG,
    pG,
    mG,
    hG,
    gG,
    bG,
    _G,
    yG,
    vG,
    kG,
    wG
  ];
}
f(rae, "instance$1x");
const jT = class jT extends ie {
  constructor(e) {
    super(), le(
      this,
      e,
      rae,
      nae,
      ne,
      {
        justValue: 52,
        filter: 53,
        getItems: 54,
        id: 55,
        name: 8,
        container: 0,
        input: 1,
        multiple: 9,
        multiFullItemClearable: 10,
        disabled: 11,
        focused: 2,
        value: 3,
        filterText: 4,
        placeholder: 56,
        placeholderAlwaysShow: 57,
        items: 51,
        label: 12,
        itemFilter: 58,
        groupBy: 59,
        groupFilter: 60,
        groupHeaderSelectable: 61,
        itemId: 13,
        loadOptions: 62,
        containerStyles: 14,
        hasError: 15,
        filterSelectedItems: 63,
        required: 16,
        closeListOnChange: 64,
        clearFilterTextOnBlur: 65,
        createGroupHeaderItem: 66,
        getFilteredItems: 67,
        searchable: 17,
        inputStyles: 18,
        clearable: 68,
        loading: 5,
        listOpen: 6,
        debounce: 69,
        debounceWait: 70,
        hideEmptyState: 19,
        inputAttributes: 71,
        listAutoWidth: 72,
        showChevron: 20,
        listOffset: 73,
        hoverItemIndex: 7,
        floatingConfig: 74,
        class: 21,
        handleClear: 22,
        ariaValues: 75,
        ariaListOpen: 76,
        ariaFocused: 77
      },
      null,
      [-1, -1, -1, -1, -1]
    );
  }
  get getFilteredItems() {
    return this.$$.ctx[67];
  }
  get handleClear() {
    return this.$$.ctx[22];
  }
};
f(jT, "Select");
let bk = jT;
function lN(i, e, t) {
  const s = i.slice();
  return s[15] = e[t], s;
}
f(lN, "get_each_context$y");
function rN(i) {
  var u;
  let e, t, s, n, l, r, o, a = oe(
    /*optionsList*/
    ((u = i[2][
      /*key*/
      i[1]
    ]) == null ? void 0 : u.modes) ?? []
  ), c = [];
  for (let d = 0; d < a.length; d += 1)
    c[d] = oN(lN(i, a, d));
  return {
    c() {
      e = E("div"), t = E("h3"), t.textContent = `${K("A5E.effects.mode")}`, s = R(), n = E("select");
      for (let d = 0; d < c.length; d += 1)
        c[d].c();
      b(t, "class", "u-text-sm u-text-bold"), b(n, "id", ""), b(e, "class", "change-section svelte-bebz9c");
    },
    m(d, p) {
      var m;
      T(d, e, p), A(e, t), A(e, s), A(e, n);
      for (let g = 0; g < c.length; g += 1)
        c[g] && c[g].m(n, null);
      ds(
        n,
        /*$effect*/
        (m = i[4].changes[
          /*idx*/
          i[0]
        ]) == null ? void 0 : m.mode
      ), r || (o = V(
        n,
        "change",
        /*change_handler_2*/
        i[14]
      ), r = !0);
    },
    p(d, p) {
      var m, g, h;
      if (p & /*MODES, optionsList, key*/
      262) {
        a = oe(
          /*optionsList*/
          ((m = d[2][
            /*key*/
            d[1]
          ]) == null ? void 0 : m.modes) ?? []
        );
        let _;
        for (_ = 0; _ < a.length; _ += 1) {
          const y = lN(d, a, _);
          c[_] ? c[_].p(y, p) : (c[_] = oN(y), c[_].c(), c[_].m(n, null));
        }
        for (; _ < c.length; _ += 1)
          c[_].d(1);
        c.length = a.length;
      }
      p & /*$effect, idx, MODES, optionsList, key*/
      279 && l !== (l = /*$effect*/
      (g = d[4].changes[
        /*idx*/
        d[0]
      ]) == null ? void 0 : g.mode) && ds(
        n,
        /*$effect*/
        (h = d[4].changes[
          /*idx*/
          d[0]
        ]) == null ? void 0 : h.mode
      );
    },
    d(d) {
      d && S(e), Le(c, d), r = !1, o();
    }
  };
}
f(rN, "create_if_block$T");
function oN(i) {
  let e, t = (
    /*label*/
    i[15].toLowerCase().capitalize() + ""
  ), s, n, l;
  return {
    c() {
      e = E("option"), s = x(t), n = R(), e.__value = l = /*MODES*/
      i[8][
        /*label*/
        i[15]
      ], qe(e, e.__value);
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      o & /*optionsList, key*/
      6 && t !== (t = /*label*/
      r[15].toLowerCase().capitalize() + "") && _e(s, t), o & /*optionsList, key*/
      6 && l !== (l = /*MODES*/
      r[8][
        /*label*/
        r[15]
      ]) && (e.__value = l, qe(e, e.__value));
    },
    d(r) {
      r && S(e);
    }
  };
}
f(oN, "create_each_block$y");
function oae(i) {
  var k, v;
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _;
  n = new bk({
    props: {
      clearable: (
        /*clearable*/
        i[3]
      ),
      items: (
        /*items*/
        i[9]
      ),
      value: (
        /*effectKeyLocalizations*/
        i[7][
          /*key*/
          i[1]
        ]
      ),
      groupBy: (
        /*groupBy*/
        i[10]
      )
    }
  }), n.$on(
    "change",
    /*change_handler*/
    i[11]
  ), n.$on(
    "clear",
    /*clear_handler*/
    i[12]
  );
  let y = (
    /*optionsList*/
    ((v = (k = i[2][
      /*key*/
      i[1]
    ]) == null ? void 0 : k.modes) == null ? void 0 : v.length) > 1 && rN(i)
  );
  return {
    c() {
      var O;
      e = E("div"), t = E("h3"), t.textContent = `${K("A5E.effects.key")}`, s = R(), l = E("div"), L(n.$$.fragment), r = R(), o = E("div"), a = E("h3"), a.textContent = `${K("A5E.effects.priority")}`, c = R(), u = E("input"), p = R(), y && y.c(), m = $e(), b(t, "class", "u-text-sm u-text-bold"), z(l, "display", "contents"), z(l, "--background", "rgba(0, 0, 0, 0.05)"), z(l, "--height", "calc(var(--form-field-height) + 1px)"), z(l, "--padding", "0 3px"), z(l, "--item-padding", "0.25rem"), z(l, "--group-item-padding-left", "1rem"), z(l, "--border-radius", "3px"), z(l, "--font-size", "0.833rem"), z(l, "--font-family", "inherit"), z(l, "--input-color", "black"), z(l, "--group-title-font-size", "0.833rem"), z(l, "--group-title-font-weight", "bold"), z(l, "--text-overflow", "ellipsis"), b(e, "class", "change-section u-flex-grow svelte-bebz9c"), b(a, "class", "u-text-sm u-text-bold"), b(u, "class", "small-input"), b(u, "type", "number"), b(u, "name", ""), u.value = d = /*$effect*/
      ((O = i[4].changes[
        /*idx*/
        i[0]
      ]) == null ? void 0 : O.priority) ?? 0, b(o, "class", "change-section svelte-bebz9c");
    },
    m(O, P) {
      T(O, e, P), A(e, t), A(e, s), A(e, l), N(n, l, null), T(O, r, P), T(O, o, P), A(o, a), A(o, c), A(o, u), T(O, p, P), y && y.m(O, P), T(O, m, P), g = !0, h || (_ = V(
        u,
        "change",
        /*change_handler_1*/
        i[13]
      ), h = !0);
    },
    p(O, [P]) {
      var I, B, F;
      const D = {};
      P & /*clearable*/
      8 && (D.clearable = /*clearable*/
      O[3]), P & /*key*/
      2 && (D.value = /*effectKeyLocalizations*/
      O[7][
        /*key*/
        O[1]
      ]), n.$set(D), (!g || P & /*$effect, idx, MODES, optionsList, key*/
      279 && d !== (d = /*$effect*/
      ((I = O[4].changes[
        /*idx*/
        O[0]
      ]) == null ? void 0 : I.priority) ?? 0) && u.value !== d) && (u.value = d), /*optionsList*/
      ((F = (B = O[2][
        /*key*/
        O[1]
      ]) == null ? void 0 : B.modes) == null ? void 0 : F.length) > 1 ? y ? y.p(O, P) : (y = rN(O), y.c(), y.m(m.parentNode, m)) : y && (y.d(1), y = null);
    },
    i(O) {
      g || (w(n.$$.fragment, O), g = !0);
    },
    o(O) {
      C(n.$$.fragment, O), g = !1;
    },
    d(O) {
      O && (S(e), S(r), S(o), S(p), S(m)), j(n), y && y.d(O), h = !1, _();
    }
  };
}
f(oae, "create_fragment$1C");
function aae(i, e, t) {
  let s, { idx: n } = e, { key: l } = e, { optionsList: r } = e, { clearable: o = !0 } = e;
  const a = it(), c = fe("effect");
  pe(i, c, (k) => t(4, s = k));
  const u = CONFIG.A5E.effectsKeyLocalizations, d = CONFIG.A5E.ACTIVE_EFFECT_MODES, p = Bre(r), m = /* @__PURE__ */ f((k) => k.group, "groupBy"), g = /* @__PURE__ */ f(({ detail: k }) => a("changeKey", k.key), "change_handler"), h = /* @__PURE__ */ f(() => a("changeKey", ""), "clear_handler"), _ = /* @__PURE__ */ f(({ target: k }) => a("changePriority", Number(k.value)), "change_handler_1"), y = /* @__PURE__ */ f(({ target: k }) => a("changeMode", k.value), "change_handler_2");
  return i.$$set = (k) => {
    "idx" in k && t(0, n = k.idx), "key" in k && t(1, l = k.key), "optionsList" in k && t(2, r = k.optionsList), "clearable" in k && t(3, o = k.clearable);
  }, [
    n,
    l,
    r,
    o,
    s,
    a,
    c,
    u,
    d,
    p,
    m,
    g,
    h,
    _,
    y
  ];
}
f(aae, "instance$1w");
const LT = class LT extends ie {
  constructor(e) {
    super(), le(this, e, aae, oae, ne, {
      idx: 0,
      key: 1,
      optionsList: 2,
      clearable: 3
    });
  }
};
f(LT, "ChangeConfiguration");
let _k = LT;
function cae(i) {
  let e, t, s, n, l, r, o;
  return {
    c() {
      e = E("div"), t = E("div"), s = E("h3"), s.textContent = `${K("A5E.effects.value")}`, n = R(), l = E("input"), b(s, "class", "u-text-sm u-text-bold"), b(t, "class", "change-section u-w-full svelte-amkke6"), b(l, "type", "text"), l.value = /*value*/
      i[3], b(e, "class", "row");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(t, s), A(e, n), A(e, l), r || (o = V(
        l,
        "change",
        /*change_handler_10*/
        i[26]
      ), r = !0);
    },
    p(a, c) {
      c & /*value*/
      8 && l.value !== /*value*/
      a[3] && (l.value = /*value*/
      a[3]);
    },
    i: ee,
    o: ee,
    d(a) {
      a && S(e), r = !1, o();
    }
  };
}
f(cae, "create_else_block$j");
function uae(i) {
  return {
    c: ee,
    m: ee,
    p: ee,
    i: ee,
    o: ee,
    d: ee
  };
}
f(uae, "create_if_block_10$1");
function fae(i) {
  let e, t, s;
  return e = new Wd({ props: { jsonValue: (
    /*value*/
    i[3]
  ) } }), e.$on(
    "change",
    /*change_handler_9*/
    i[25]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--padding", "0"), z(t, "--background", "none");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*value*/
      8 && (r.jsonValue = /*value*/
      n[3]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(fae, "create_if_block_9$4");
function dae(i) {
  let e, t, s;
  return e = new Ud({ props: { jsonValue: (
    /*value*/
    i[3]
  ) } }), e.$on(
    "change",
    /*change_handler_8*/
    i[24]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--padding", "0"), z(t, "--background", "none");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*value*/
      8 && (r.jsonValue = /*value*/
      n[3]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(dae, "create_if_block_8$4");
function pae(i) {
  let e, t, s;
  return e = new Vd({ props: { jsonValue: (
    /*value*/
    i[3]
  ) } }), e.$on(
    "change",
    /*change_handler_7*/
    i[23]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--padding", "0"), z(t, "--background", "none");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*value*/
      8 && (r.jsonValue = /*value*/
      n[3]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(pae, "create_if_block_7$6");
function mae(i) {
  let e, t, s;
  return e = new Hd({ props: { jsonValue: (
    /*value*/
    i[3]
  ) } }), e.$on(
    "change",
    /*change_handler_6*/
    i[22]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--padding", "0"), z(t, "--background", "none");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*value*/
      8 && (r.jsonValue = /*value*/
      n[3]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(mae, "create_if_block_6$7");
function hae(i) {
  let e, t, s;
  return e = new zd({ props: { jsonValue: (
    /*value*/
    i[3]
  ) } }), e.$on(
    "change",
    /*change_handler_5*/
    i[21]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--padding", "0"), z(t, "--background", "none");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*value*/
      8 && (r.jsonValue = /*value*/
      n[3]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(hae, "create_if_block_5$8");
function gae(i) {
  let e, t, s;
  return e = new Gd({ props: { jsonValue: (
    /*value*/
    i[3]
  ) } }), e.$on(
    "change",
    /*change_handler_4*/
    i[20]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--padding", "0"), z(t, "--background", "none");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*value*/
      8 && (r.jsonValue = /*value*/
      n[3]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(gae, "create_if_block_4$f");
function bae(i) {
  var s;
  let e, t;
  return e = new Dc({
    props: {
      heading: "A5E.effects.options",
      options: (
        /*optionsList*/
        ((s = i[2][
          /*key*/
          i[0]
        ]) == null ? void 0 : s.options) ?? [[null, null]]
      ),
      selected: mp(
        /*value*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[19]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*optionsList, key*/
      5 && (r.options = /*optionsList*/
      ((o = n[2][
        /*key*/
        n[0]
      ]) == null ? void 0 : o.options) ?? [[null, null]]), l & /*value*/
      8 && (r.selected = mp(
        /*value*/
        n[3]
      )), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(bae, "create_if_block_3$i");
function _ae(i) {
  var s;
  let e, t;
  return e = new Ze({
    props: {
      heading: "A5E.effects.options",
      options: (
        /*optionsList*/
        ((s = i[2][
          /*key*/
          i[0]
        ]) == null ? void 0 : s.options) ?? [[null, null]]
      ),
      selected: mp(
        /*value*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[18]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*optionsList, key*/
      5 && (r.options = /*optionsList*/
      ((o = n[2][
        /*key*/
        n[0]
      ]) == null ? void 0 : o.options) ?? [[null, null]]), l & /*value*/
      8 && (r.selected = mp(
        /*value*/
        n[3]
      )), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(_ae, "create_if_block_2$s");
function yae(i) {
  var s;
  let e, t;
  return e = new Ye({
    props: {
      heading: "A5E.effects.options",
      allowDeselect: !1,
      options: (
        /*optionsList*/
        ((s = i[2][
          /*key*/
          i[0]
        ]) == null ? void 0 : s.options) ?? [[null, null]]
      ),
      selected: (
        /*value*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[17]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*optionsList, key*/
      5 && (r.options = /*optionsList*/
      ((o = n[2][
        /*key*/
        n[0]
      ]) == null ? void 0 : o.options) ?? [[null, null]]), l & /*value*/
      8 && (r.selected = /*value*/
      n[3]), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(yae, "create_if_block_1$E");
function vae(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y;
  return {
    c() {
      e = E("div"), t = x(`If original value is
        `), s = E("select"), n = E("option"), n.textContent = "equal to", l = E("option"), l.textContent = "not equal", r = E("option"), r.textContent = "greater than", o = E("option"), o.textContent = "greater than or equal to", a = E("option"), a.textContent = "less than", c = E("option"), c.textContent = "less than or equal to", u = R(), d = E("input"), p = x(`

        then change to

        `), m = E("input"), g = x(`

        else change to

        `), h = E("input"), n.__value = "==", qe(n, n.__value), l.__value = "!==", qe(l, l.__value), r.__value = ">", qe(r, r.__value), o.__value = ">=", qe(o, o.__value), a.__value = "<", qe(a, a.__value), c.__value = "<=", qe(c, c.__value), /*conditionalObj*/
      i[4].comparisonOperator === void 0 && is(() => (
        /*select_change_handler*/
        i[9].call(s)
      )), b(d, "class", "conditional-input svelte-amkke6"), b(d, "type", "text"), b(m, "class", "conditional-input svelte-amkke6"), b(m, "type", "text"), b(h, "class", "conditional-input svelte-amkke6"), b(h, "type", "text"), b(e, "class", "conditional-container u-pt-sm svelte-amkke6");
    },
    m(k, v) {
      T(k, e, v), A(e, t), A(e, s), A(s, n), A(s, l), A(s, r), A(s, o), A(s, a), A(s, c), ds(
        s,
        /*conditionalObj*/
        i[4].comparisonOperator,
        !0
      ), A(e, u), A(e, d), qe(
        d,
        /*conditionalObj*/
        i[4].comparisonValue
      ), A(e, p), A(e, m), qe(
        m,
        /*conditionalObj*/
        i[4].positiveValue
      ), A(e, g), A(e, h), qe(
        h,
        /*conditionalObj*/
        i[4].negativeValue
      ), _ || (y = [
        V(
          s,
          "change",
          /*select_change_handler*/
          i[9]
        ),
        V(
          s,
          "change",
          /*change_handler*/
          i[10]
        ),
        V(
          d,
          "input",
          /*input0_input_handler*/
          i[11]
        ),
        V(
          d,
          "change",
          /*change_handler_1*/
          i[12]
        ),
        V(
          m,
          "input",
          /*input1_input_handler*/
          i[13]
        ),
        V(
          m,
          "change",
          /*change_handler_2*/
          i[14]
        ),
        V(
          h,
          "input",
          /*input2_input_handler*/
          i[15]
        ),
        V(
          h,
          "change",
          /*change_handler_3*/
          i[16]
        )
      ], _ = !0);
    },
    p(k, v) {
      v & /*conditionalObj*/
      16 && ds(
        s,
        /*conditionalObj*/
        k[4].comparisonOperator
      ), v & /*conditionalObj*/
      16 && d.value !== /*conditionalObj*/
      k[4].comparisonValue && qe(
        d,
        /*conditionalObj*/
        k[4].comparisonValue
      ), v & /*conditionalObj*/
      16 && m.value !== /*conditionalObj*/
      k[4].positiveValue && qe(
        m,
        /*conditionalObj*/
        k[4].positiveValue
      ), v & /*conditionalObj*/
      16 && h.value !== /*conditionalObj*/
      k[4].negativeValue && qe(
        h,
        /*conditionalObj*/
        k[4].negativeValue
      );
    },
    i: ee,
    o: ee,
    d(k) {
      k && S(e), _ = !1, Ne(y);
    }
  };
}
f(vae, "create_if_block$S");
function kae(i) {
  let e, t, s, n;
  const l = [
    vae,
    yae,
    _ae,
    bae,
    gae,
    hae,
    mae,
    pae,
    dae,
    fae,
    uae,
    cae
  ], r = [];
  function o(a, c) {
    return (
      /*mode*/
      a[1] === /*MODES*/
      a[8].CONDITIONAL ? 0 : (
        /*componentType*/
        a[5] === "RADIO" ? 1 : (
          /*componentType*/
          a[5] === "CHECKBOX" ? 2 : (
            /*componentType*/
            a[5] === "TAG_GROUP" ? 3 : (
              /*componentType*/
              a[5] === "ABILITY_BONUS" ? 4 : (
                /*componentType*/
                a[5] === "ATTACK_BONUS" ? 5 : (
                  /*componentType*/
                  a[5] === "DAMAGE_BONUS" ? 6 : (
                    /*componentType*/
                    a[5] === "HEALING_BONUS" ? 7 : (
                      /*componentType*/
                      a[5] === "INITIATIVE_BONUS" ? 8 : (
                        /*componentType*/
                        a[5] === "SKILL_BONUS" ? 9 : (
                          /*componentType*/
                          a[5] === "NONE" ? 10 : 11
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    );
  }
  return f(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, [c]) {
      let u = e;
      e = o(a), e === u ? r[e].p(a, c) : (ce(), C(r[u], 1, 1, () => {
        r[u] = null;
      }), ue(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), r[e].d(a);
    }
  };
}
f(kae, "create_fragment$1B");
function mp(i) {
  try {
    const e = JSON.parse((i ?? "").trim());
    return Array.isArray(e) ? e : [e];
  } catch {
    return [];
  }
}
f(mp, "convertToArray");
function wae(i) {
  try {
    const e = JSON.parse((i ?? "").trim());
    if (typeof e != "object")
      throw new Error();
    return e.comparisonOperator = e.comparisonOperator ?? "==", e.comparisonValue = e.comparisonValue ?? "", e.positiveValue = e.positiveValue ?? "", e.negativeValue = e.negativeValue ?? "", e;
  } catch {
    return {
      comparisonOperator: "==",
      comparisonValue: "",
      positiveValue: "",
      negativeValue: ""
    };
  }
}
f(wae, "convertToObject");
function $ae(i, e, t) {
  let s, { key: n } = e, { mode: l } = e, { optionsList: r } = e, { value: o } = e;
  const a = it();
  function c(W) {
    const X = JSON.stringify(W);
    a("change", X);
  }
  f(c, "updateObjectValue");
  let u = wae(o);
  const d = CONFIG.A5E.ACTIVE_EFFECT_MODES;
  function p() {
    u.comparisonOperator = ca(this), t(4, u);
  }
  f(p, "select_change_handler");
  const m = /* @__PURE__ */ f(() => c(u), "change_handler");
  function g() {
    u.comparisonValue = this.value, t(4, u);
  }
  f(g, "input0_input_handler");
  const h = /* @__PURE__ */ f(() => c(u), "change_handler_1");
  function _() {
    u.positiveValue = this.value, t(4, u);
  }
  f(_, "input1_input_handler");
  const y = /* @__PURE__ */ f(() => c(u), "change_handler_2");
  function k() {
    u.negativeValue = this.value, t(4, u);
  }
  f(k, "input2_input_handler");
  const v = /* @__PURE__ */ f(() => c(u), "change_handler_3"), O = /* @__PURE__ */ f(({ detail: W }) => a("change", W), "updateSelection_handler"), P = /* @__PURE__ */ f(({ detail: W }) => a("change", JSON.stringify(W)), "updateSelection_handler_1"), D = /* @__PURE__ */ f(({ detail: W }) => {
    a("change", JSON.stringify(W));
  }, "updateSelection_handler_2"), I = /* @__PURE__ */ f(({ detail: W }) => a("change", W), "change_handler_4"), B = /* @__PURE__ */ f(({ detail: W }) => a("change", W), "change_handler_5"), F = /* @__PURE__ */ f(({ detail: W }) => a("change", W), "change_handler_6"), H = /* @__PURE__ */ f(({ detail: W }) => a("change", W), "change_handler_7"), G = /* @__PURE__ */ f(({ detail: W }) => a("change", W), "change_handler_8"), U = /* @__PURE__ */ f(({ detail: W }) => a("change", W), "change_handler_9"), q = /* @__PURE__ */ f(({ target: W }) => a("change", W.value), "change_handler_10");
  return i.$$set = (W) => {
    "key" in W && t(0, n = W.key), "mode" in W && t(1, l = W.mode), "optionsList" in W && t(2, r = W.optionsList), "value" in W && t(3, o = W.value);
  }, i.$$.update = () => {
    var W;
    i.$$.dirty & /*optionsList, key*/
    5 && t(5, s = ((W = r[n]) == null ? void 0 : W.type) ?? "DEFAULT");
  }, [
    n,
    l,
    r,
    o,
    u,
    s,
    a,
    c,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    k,
    v,
    O,
    P,
    D,
    I,
    B,
    F,
    H,
    G,
    U,
    q
  ];
}
f($ae, "instance$1v");
const BT = class BT extends ie {
  constructor(e) {
    super(), le(this, e, $ae, kae, ne, {
      key: 0,
      mode: 1,
      optionsList: 2,
      value: 3
    });
  }
};
f(BT, "ChangeValue");
let yk = BT;
function aN(i, e, t) {
  const s = i.slice();
  return s[15] = e[t].key, s[16] = e[t].value, s[17] = e[t].mode, s[19] = t, s;
}
f(aN, "get_each_context$x");
function cN(i, e) {
  let t, s, n, l, r, o, a, c, u, d, p, m;
  function g() {
    return (
      /*click_handler*/
      e[7](
        /*idx*/
        e[19]
      )
    );
  }
  f(g, "click_handler");
  function h(...v) {
    return (
      /*changeKey_handler*/
      e[8](
        /*idx*/
        e[19],
        ...v
      )
    );
  }
  f(h, "changeKey_handler");
  function _(...v) {
    return (
      /*changePriority_handler*/
      e[9](
        /*idx*/
        e[19],
        ...v
      )
    );
  }
  f(_, "changePriority_handler");
  function y(...v) {
    return (
      /*changeMode_handler*/
      e[10](
        /*idx*/
        e[19],
        ...v
      )
    );
  }
  f(y, "changeMode_handler"), o = new _k({
    props: {
      idx: (
        /*idx*/
        e[19]
      ),
      key: (
        /*key*/
        e[15]
      ),
      optionsList: (
        /*optionsList*/
        e[5]
      )
    }
  }), o.$on("changeKey", h), o.$on("changePriority", _), o.$on("changeMode", y);
  function k(...v) {
    return (
      /*change_handler*/
      e[11](
        /*idx*/
        e[19],
        ...v
      )
    );
  }
  return f(k, "change_handler"), c = new yk({
    props: {
      key: (
        /*key*/
        e[15]
      ),
      value: (
        /*value*/
        e[16]
      ),
      mode: (
        /*mode*/
        e[17]
      ),
      optionsList: (
        /*optionsList*/
        e[5]
      )
    }
  }), c.$on("change", k), {
    key: i,
    first: null,
    c() {
      t = E("li"), s = E("div"), n = E("button"), l = R(), r = E("div"), L(o.$$.fragment), a = R(), L(c.$$.fragment), u = R(), b(n, "class", "a5e-button a5e-button--delete fas fa-trash"), z(n, "font-size", "$font-size-md"), b(s, "class", "button-wrapper svelte-gav87l"), b(r, "class", "row svelte-gav87l"), z(r, "padding-right", "2rem"), b(t, "class", "a5e-item a5e-item--effect-config"), this.first = t;
    },
    m(v, O) {
      T(v, t, O), A(t, s), A(s, n), A(t, l), A(t, r), N(o, r, null), A(t, a), N(c, t, null), A(t, u), d = !0, p || (m = V(n, "click", g), p = !0);
    },
    p(v, O) {
      e = v;
      const P = {};
      O & /*changes*/
      1 && (P.idx = /*idx*/
      e[19]), O & /*changes*/
      1 && (P.key = /*key*/
      e[15]), o.$set(P);
      const D = {};
      O & /*changes*/
      1 && (D.key = /*key*/
      e[15]), O & /*changes*/
      1 && (D.value = /*value*/
      e[16]), O & /*changes*/
      1 && (D.mode = /*mode*/
      e[17]), c.$set(D);
    },
    i(v) {
      d || (w(o.$$.fragment, v), w(c.$$.fragment, v), d = !0);
    },
    o(v) {
      C(o.$$.fragment, v), C(c.$$.fragment, v), d = !1;
    },
    d(v) {
      v && S(t), j(o), j(c), p = !1, m();
    }
  };
}
f(cN, "create_each_block$x");
function Aae(i) {
  let e, t, s = [], n = /* @__PURE__ */ new Map(), l, r, o, a, c, u = oe(
    /*changes*/
    i[0]
  );
  const d = /* @__PURE__ */ f((p) => (
    /*idx*/
    p[19]
  ), "get_key");
  for (let p = 0; p < u.length; p += 1) {
    let m = aN(i, u, p), g = d(m);
    n.set(g, s[p] = cN(g, m));
  }
  return o = new ya({
    props: {
      title: "Add Change",
      icon: "fas fa-plus",
      onPress: (
        /*func*/
        i[12]
      )
    }
  }), {
    c() {
      e = E("section"), t = E("ul");
      for (let p = 0; p < s.length; p += 1)
        s[p].c();
      l = R(), r = E("div"), a = E("div"), L(o.$$.fragment), b(t, "class", "a5e-item-list"), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable"), z(a, "display", "contents"), z(a, "--tjs-icon-button-background-hover", "none"), z(a, "--tjs-icon-button-background-focus", "none"), z(a, "--tjs-icon-button-background-focus-visible", "none"), z(a, "--tjs-icon-button-background-selected", "none"), z(a, "--tjs-icon-button-text-shadow-hover", "none"), z(a, "--tjs-icon-button-text-shadow-focus", "none"), z(a, "--tjs-icon-button-transition", "$standard-transition"), z(a, "--tjs-icon-button-diameter", "1rem"), z(a, "--tjs-icon-button-border-radius", "0"), b(r, "class", "sticky-add-button svelte-gav87l");
    },
    m(p, m) {
      T(p, e, m), A(e, t);
      for (let g = 0; g < s.length; g += 1)
        s[g] && s[g].m(t, null);
      T(p, l, m), T(p, r, m), A(r, a), N(o, a, null), c = !0;
    },
    p(p, [m]) {
      m & /*changes, optionsList, updateChange, deleteChange*/
      57 && (u = oe(
        /*changes*/
        p[0]
      ), ce(), s = kt(s, m, d, 1, p, u, n, t, ks, cN, null, aN), ue());
    },
    i(p) {
      if (!c) {
        for (let m = 0; m < u.length; m += 1)
          w(s[m]);
        w(o.$$.fragment, p), c = !0;
      }
    },
    o(p) {
      for (let m = 0; m < s.length; m += 1)
        C(s[m]);
      C(o.$$.fragment, p), c = !1;
    },
    d(p) {
      p && (S(e), S(l), S(r));
      for (let m = 0; m < s.length; m += 1)
        s[m].d();
      j(o);
    }
  };
}
f(Aae, "create_fragment$1A");
function Eae(i, e, t) {
  let s, n;
  const l = fe("effect");
  pe(i, l, (k) => t(6, n = k));
  const r = fe("sheet");
  function o() {
    const k = {
      key: "",
      mode: null,
      value: "",
      priority: null
    };
    t(0, s = [...s, k]), n.update({ changes: s });
  }
  f(o, "addChange");
  function a(k) {
    t(0, s = s.filter((v, O) => O !== k)), n.update({ changes: s });
  }
  f(a, "deleteChange");
  function c(k, v, O) {
    var P, D, I;
    t(0, s[k] ?? (s[k] = {}), s), t(0, s[k][v] = O, s), v === "key" && (t(0, s[k].value = "", s), t(0, s[k].mode = u[(I = (D = d[(P = s[k]) == null ? void 0 : P.key]) == null ? void 0 : D.modes) == null ? void 0 : I[0]] ?? null, s)), n.update({ changes: s });
  }
  f(c, "updateChange");
  const u = CONFIG.A5E.ACTIVE_EFFECT_MODES, d = r.optionsList, p = /* @__PURE__ */ f((k) => a(k), "click_handler"), m = /* @__PURE__ */ f((k, { detail: v }) => c(k, "key", v), "changeKey_handler"), g = /* @__PURE__ */ f((k, { detail: v }) => c(k, "priority", v), "changePriority_handler"), h = /* @__PURE__ */ f((k, { detail: v }) => c(k, "mode", v), "changeMode_handler"), _ = /* @__PURE__ */ f((k, { detail: v }) => c(k, "value", v), "change_handler"), y = /* @__PURE__ */ f(() => o(), "func");
  return i.$$.update = () => {
    i.$$.dirty & /*$effect*/
    64 && t(0, s = n.changes);
  }, [
    s,
    l,
    o,
    a,
    c,
    d,
    n,
    p,
    m,
    g,
    h,
    _,
    y
  ];
}
f(Eae, "instance$1u");
const qT = class qT extends ie {
  constructor(e) {
    super(), le(this, e, Eae, Aae, ne, {});
  }
};
f(qT, "EffectsEffectTab");
let vk = qT;
function uN(i, e, t) {
  const s = i.slice();
  return s[14] = e[t][0], s[15] = e[t][1], s;
}
f(uN, "get_each_context$w");
function fN(i) {
  let e, t, s, n, l;
  return e = new bt({
    props: {
      $$slots: { default: [Sae] },
      $$scope: { ctx: i }
    }
  }), s = new bt({
    props: {
      heading: "Effect Duration",
      $$slots: { default: [Oae] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), n = E("div"), L(s.$$.fragment), z(n, "display", "contents"), z(n, "--gap", "0.75rem"), z(n, "--direction", "column");
    },
    m(r, o) {
      N(e, r, o), T(r, t, o), T(r, n, o), N(s, n, null), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*$$scope, $effect*/
      262146 && (a.$$scope = { dirty: o, ctx: r }), e.$set(a);
      const c = {};
      o & /*$$scope, parsedSecondsValue, unit, durationType, $effect*/
      262159 && (c.$$scope = { dirty: o, ctx: r }), s.$set(c);
    },
    i(r) {
      l || (w(e.$$.fragment, r), w(s.$$.fragment, r), l = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(s.$$.fragment, r), l = !1;
    },
    d(r) {
      r && S(t), j(e, r), r && s && S(n), j(s, r);
    }
  };
}
f(fN, "create_if_block$R");
function Sae(i) {
  var s, n;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.effects.applyToSelf",
      checked: (
        /*$effect*/
        ((n = (s = i[1].flags) == null ? void 0 : s.a5e) == null ? void 0 : n.applyToSelf) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), t = !0;
    },
    p(l, r) {
      var a, c;
      const o = {};
      r & /*$effect*/
      2 && (o.checked = /*$effect*/
      ((c = (a = l[1].flags) == null ? void 0 : a.a5e) == null ? void 0 : c.applyToSelf) ?? !1), e.$set(o);
    },
    i(l) {
      t || (w(e.$$.fragment, l), t = !0);
    },
    o(l) {
      C(e.$$.fragment, l), t = !1;
    },
    d(l) {
      j(e, l);
    }
  };
}
f(Sae, "create_default_slot_1$f");
function Tae(i) {
  let e, t, s, n = K("A5E.effects.durationTypes.plural.rounds") + "", l, r, o, a, c, u, d, p, m, g = K("A5E.effects.durationTypes.plural.turns") + "", h, _, y, k, v, O, P, D;
  return {
    c() {
      e = E("div"), t = E("div"), s = E("label"), l = x(n), o = R(), a = E("input"), d = R(), p = E("div"), m = E("label"), h = x(g), y = R(), k = E("input"), b(s, "for", r = /*$effect*/
      i[1].id + "-rounds"), b(s, "class", "u-pointer u-text-bold"), b(a, "type", "number"), b(a, "class", "a5e-input a5e-input--small a5e-input--slim"), b(a, "id", c = /*$effect*/
      i[1].id + "-rounds"), a.value = u = /*$effect*/
      i[1].duration.rounds ?? 0, b(t, "class", "u-flex u-flex-col u-gap-md"), b(m, "for", _ = /*$effect*/
      i[1].id + "-turns"), b(m, "class", "u-pointer u-text-bold"), b(k, "type", "number"), b(k, "class", "a5e-input a5e-input--small a5e-input--slim"), b(k, "name", ""), b(k, "id", v = /*$effect*/
      i[1].id + "-turns"), k.value = O = /*$effect*/
      i[1].duration.turns ?? 0, b(p, "class", "u-flex u-flex-col u-gap-md"), b(e, "class", "u-flex u-gap-xl");
    },
    m(I, B) {
      T(I, e, B), A(e, t), A(t, s), A(s, l), A(t, o), A(t, a), A(e, d), A(e, p), A(p, m), A(m, h), A(p, y), A(p, k), P || (D = [
        V(
          a,
          "change",
          /*change_handler_2*/
          i[11]
        ),
        V(
          k,
          "change",
          /*change_handler_3*/
          i[12]
        )
      ], P = !0);
    },
    p(I, B) {
      B & /*$effect*/
      2 && r !== (r = /*$effect*/
      I[1].id + "-rounds") && b(s, "for", r), B & /*$effect*/
      2 && c !== (c = /*$effect*/
      I[1].id + "-rounds") && b(a, "id", c), B & /*$effect*/
      2 && u !== (u = /*$effect*/
      I[1].duration.rounds ?? 0) && a.value !== u && (a.value = u), B & /*$effect*/
      2 && _ !== (_ = /*$effect*/
      I[1].id + "-turns") && b(m, "for", _), B & /*$effect*/
      2 && v !== (v = /*$effect*/
      I[1].id + "-turns") && b(k, "id", v), B & /*$effect*/
      2 && O !== (O = /*$effect*/
      I[1].duration.turns ?? 0) && k.value !== O && (k.value = O);
    },
    d(I) {
      I && S(e), P = !1, Ne(D);
    }
  };
}
f(Tae, "create_if_block_2$r");
function Cae(i) {
  let e, t, s, n, l, r, o = oe(Object.entries(
    /*A5E*/
    i[5].effectDurationUnits
  )), a = [];
  for (let c = 0; c < o.length; c += 1)
    a[c] = dN(uN(i, o, c));
  return {
    c() {
      e = E("div"), t = E("input"), s = R(), n = E("select");
      for (let c = 0; c < a.length; c += 1)
        a[c].c();
      b(t, "class", "a5e-input a5e-input--small a5e-input--slim"), b(t, "type", "number"), t.value = /*parsedSecondsValue*/
      i[3], b(n, "class", "u-w-fit"), b(e, "class", "u-flex u-gap-md");
    },
    m(c, u) {
      T(c, e, u), A(e, t), A(e, s), A(e, n);
      for (let d = 0; d < a.length; d += 1)
        a[d] && a[d].m(n, null);
      l || (r = [
        V(
          t,
          "change",
          /*change_handler*/
          i[9]
        ),
        V(
          n,
          "change",
          /*change_handler_1*/
          i[10]
        )
      ], l = !0);
    },
    p(c, u) {
      if (u & /*parsedSecondsValue*/
      8 && t.value !== /*parsedSecondsValue*/
      c[3] && (t.value = /*parsedSecondsValue*/
      c[3]), u & /*Object, A5E, unit*/
      33) {
        o = oe(Object.entries(
          /*A5E*/
          c[5].effectDurationUnits
        ));
        let d;
        for (d = 0; d < o.length; d += 1) {
          const p = uN(c, o, d);
          a[d] ? a[d].p(p, u) : (a[d] = dN(p), a[d].c(), a[d].m(n, null));
        }
        for (; d < a.length; d += 1)
          a[d].d(1);
        a.length = o.length;
      }
    },
    d(c) {
      c && S(e), Le(a, c), l = !1, Ne(r);
    }
  };
}
f(Cae, "create_if_block_1$D");
function dN(i) {
  let e, t = K(
    /*label*/
    i[15]
  ) + "", s, n, l;
  return {
    c() {
      e = E("option"), s = x(t), n = R(), e.__value = /*durationUnit*/
      i[14], qe(e, e.__value), e.selected = l = /*durationUnit*/
      i[14] === /*unit*/
      i[0];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      o & /*unit*/
      1 && l !== (l = /*durationUnit*/
      r[14] === /*unit*/
      r[0]) && (e.selected = l);
    },
    d(r) {
      r && S(e);
    }
  };
}
f(dN, "create_each_block$w");
function Oae(i) {
  let e, t, s, n;
  e = new Ye({
    props: {
      options: Object.entries(
        /*A5E*/
        i[5].effectDurationTypes
      ),
      selected: (
        /*durationType*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[8]
  );
  function l(a, c) {
    if (
      /*durationType*/
      a[2] === "seconds"
    )
      return Cae;
    if (
      /*durationType*/
      a[2] === "rounds"
    )
      return Tae;
  }
  f(l, "select_block_type");
  let r = l(i), o = r && r(i);
  return {
    c() {
      L(e.$$.fragment), t = R(), o && o.c(), s = $e();
    },
    m(a, c) {
      N(e, a, c), T(a, t, c), o && o.m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      const u = {};
      c & /*durationType*/
      4 && (u.selected = /*durationType*/
      a[2]), e.$set(u), r === (r = l(a)) && o ? o.p(a, c) : (o && o.d(1), o = r && r(a), o && (o.c(), o.m(s.parentNode, s)));
    },
    i(a) {
      n || (w(e.$$.fragment, a), n = !0);
    },
    o(a) {
      C(e.$$.fragment, a), n = !1;
    },
    d(a) {
      a && (S(t), S(s)), j(e, a), o && o.d(a);
    }
  };
}
f(Oae, "create_default_slot$I");
function Dae(i) {
  var n, l;
  let e, t, s = (
    /*$effect*/
    ((l = (n = i[1].flags) == null ? void 0 : n.a5e) == null ? void 0 : l.transferType) === "onUse" && fN(i)
  );
  return {
    c() {
      e = E("article"), s && s.c(), b(e, "class", "svelte-1u79v09");
    },
    m(r, o) {
      T(r, e, o), s && s.m(e, null), t = !0;
    },
    p(r, [o]) {
      var a, c;
      /*$effect*/
      ((c = (a = r[1].flags) == null ? void 0 : a.a5e) == null ? void 0 : c.transferType) === "onUse" ? s ? (s.p(r, o), o & /*$effect*/
      2 && w(s, 1)) : (s = fN(r), s.c(), w(s, 1), s.m(e, null)) : s && (ce(), C(s, 1, 1, () => {
        s = null;
      }), ue());
    },
    i(r) {
      t || (w(s), t = !0);
    },
    o(r) {
      C(s), t = !1;
    },
    d(r) {
      r && S(e), s && s.d();
    }
  };
}
f(Dae, "create_fragment$1z");
function Iae(i, e, t) {
  let s, n, l, r;
  const o = fe("effect");
  pe(i, o, (y) => t(1, r = y));
  const { A5E: a } = CONFIG, c = { seconds: 1, minutes: 60, hours: 3600 };
  function u(y, k, v = null) {
    const O = {
      "flags.a5e.duration.unit": v ?? l,
      "duration.seconds": null,
      "duration.rounds": y === "seconds" ? null : r.duration.rounds,
      "duration.turns": y === "seconds" ? null : r.duration.turns
    };
    if (y === "seconds") {
      let P;
      v && l !== v ? (O["flags.a5e.duration.unit"] = v, P = Math.max(0, s * c[v])) : P = Math.max(0, k * c[l]), O["duration.seconds"] = P;
    } else
      ["rounds", "turns"].includes(y) && (O[`duration.${y}`] = Math.max(0, k));
    r.update(O);
  }
  f(u, "updateEffectDuration");
  const d = /* @__PURE__ */ f(({ detail: y }) => r.update({ "flags.a5e.applyToSelf": y }), "updateSelection_handler"), p = /* @__PURE__ */ f(({ detail: y }) => r.update({ "flags.a5e.duration.type": y }), "updateSelection_handler_1"), m = /* @__PURE__ */ f(({ target: y }) => u(n, Number(y.value)), "change_handler"), g = /* @__PURE__ */ f(({ target: y }) => u("seconds", s, y.value), "change_handler_1"), h = /* @__PURE__ */ f(({ target: y }) => u("rounds", Number(y.value)), "change_handler_2"), _ = /* @__PURE__ */ f(({ target: y }) => u("turns", Number(y.value)), "change_handler_3");
  return i.$$.update = () => {
    var y, k, v, O, P, D;
    i.$$.dirty & /*$effect*/
    2 && t(0, l = ((v = (k = (y = r.flags) == null ? void 0 : y.a5e) == null ? void 0 : k.duration) == null ? void 0 : v.unit) ?? "minutes"), i.$$.dirty & /*$effect, unit*/
    3 && t(3, s = Math.floor((r.duration.seconds ?? 0) / c[l])), i.$$.dirty & /*$effect*/
    2 && t(2, n = ((D = (P = (O = r.flags) == null ? void 0 : O.a5e) == null ? void 0 : P.duration) == null ? void 0 : D.type) ?? "seconds");
  }, [
    l,
    r,
    n,
    s,
    o,
    a,
    u,
    d,
    p,
    m,
    g,
    h,
    _
  ];
}
f(Iae, "instance$1t");
const GT = class GT extends ie {
  constructor(e) {
    super(), le(this, e, Iae, Dae, ne, {});
  }
};
f(GT, "EffectsPropertiesTab");
let kk = GT;
function Pae(i) {
  let e, t, s, n, l, r, o, a, c, u;
  return {
    c() {
      e = E("header"), t = E("img"), l = R(), r = E("div"), o = E("input"), b(t, "class", "effect-image svelte-1oqz0g8"), ze(t.src, s = /*$effect*/
      i[0].img ?? /*$effect*/
      i[0].icon) || b(t, "src", s), b(t, "alt", n = /*$effect*/
      i[0].name), b(o, "type", "text"), b(o, "class", "effect-name svelte-1oqz0g8"), b(o, "name", "name"), o.value = a = /*$effect*/
      i[0].name, b(o, "placeholder", "A5E.Name"), b(r, "class", "name__wrapper svelte-1oqz0g8"), b(e, "class", "sheet-header svelte-1oqz0g8");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(e, l), A(e, r), A(r, o), c || (u = [
        V(
          t,
          "click",
          /*click_handler*/
          i[2]
        ),
        V(
          o,
          "change",
          /*change_handler*/
          i[3]
        )
      ], c = !0);
    },
    p(d, [p]) {
      p & /*$effect*/
      1 && !ze(t.src, s = /*$effect*/
      d[0].img ?? /*$effect*/
      d[0].icon) && b(t, "src", s), p & /*$effect*/
      1 && n !== (n = /*$effect*/
      d[0].name) && b(t, "alt", n), p & /*$effect*/
      1 && a !== (a = /*$effect*/
      d[0].name) && o.value !== a && (o.value = a);
    },
    i: ee,
    o: ee,
    d(d) {
      d && S(e), c = !1, Ne(u);
    }
  };
}
f(Pae, "create_fragment$1y");
function Mae(i, e, t) {
  let s;
  const n = fe("effect");
  return pe(i, n, (o) => t(0, s = o)), fe("appId"), [s, n, /* @__PURE__ */ f(() => ab(s, { type: "effect" }), "click_handler"), /* @__PURE__ */ f(({ target: o }) => se(s, o.name, o.value), "change_handler")];
}
f(Mae, "instance$1s");
const zT = class zT extends ie {
  constructor(e) {
    super(), le(this, e, Mae, Pae, ne, {});
  }
};
f(zT, "EffectSheetHeader");
let wk = zT;
function Rae(i) {
  let e, t, s, n, l, r, o;
  t = new wk({}), n = new bn({
    props: {
      currentTab: (
        /*currentTab*/
        i[1]
      ),
      tabs: (
        /*tabs*/
        i[4]
      )
    }
  }), n.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[3]
  );
  var a = (
    /*currentTab*/
    i[1].component
  );
  function c(u, d) {
    return {};
  }
  return f(c, "switch_props"), a && (r = nt(a, c())), {
    c() {
      e = E("main"), L(t.$$.fragment), s = R(), L(n.$$.fragment), l = R(), r && L(r.$$.fragment), b(e, "class", "svelte-1bx1z8o");
    },
    m(u, d) {
      T(u, e, d), N(t, e, null), A(e, s), N(n, e, null), A(e, l), r && N(r, e, null), o = !0;
    },
    p(u, d) {
      const p = {};
      if (d & /*currentTab*/
      2 && (p.currentTab = /*currentTab*/
      u[1]), n.$set(p), d & /*currentTab*/
      2 && a !== (a = /*currentTab*/
      u[1].component)) {
        if (r) {
          ce();
          const m = r;
          C(m.$$.fragment, 1, 0, () => {
            j(m, 1);
          }), ue();
        }
        a ? (r = nt(a, c()), L(r.$$.fragment), w(r.$$.fragment, 1), N(r, e, null)) : r = null;
      }
    },
    i(u) {
      o || (w(t.$$.fragment, u), w(n.$$.fragment, u), r && w(r.$$.fragment, u), o = !0);
    },
    o(u) {
      C(t.$$.fragment, u), C(n.$$.fragment, u), r && C(r.$$.fragment, u), o = !1;
    },
    d(u) {
      u && S(e), j(t), j(n), r && j(r);
    }
  };
}
f(Rae, "create_default_slot$H");
function Fae(i) {
  let e, t, s;
  function n(r) {
    i[8](r);
  }
  f(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [Rae] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Ss({ props: l }), st.push(() => mt(e, "elementRoot", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, currentTab*/
        2050 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(Fae, "create_fragment$1x");
function Nae(i, e, t) {
  let s, { appId: n, document: l, sheet: r } = fe("#external").application, { appId: o = n, document: a = l, sheet: c = r } = e, { elementRoot: u } = e;
  const d = a;
  pe(i, d, (y) => t(9, s = y));
  function p(y) {
    t(1, h = g[y.detail]);
  }
  f(p, "updateCurrentTab");
  let m = foundry.utils.getProperty(s, "flags.a5e.transferType");
  const g = [
    {
      name: "description",
      label: "A5E.ItemSheetLabelDescriptionTab",
      component: pk
    },
    {
      name: "properties",
      label: "A5E.ItemSheetLabelPropertiesTab",
      component: kk,
      display: m === "onUse"
    },
    {
      name: "effects",
      label: "A5E.TabEffects",
      component: vk
    }
  ];
  let h = g[0];
  et("appId", o), et("effect", d), et("sheet", c);
  function _(y) {
    u = y, t(0, u);
  }
  return f(_, "applicationshell_elementRoot_binding"), i.$$set = (y) => {
    "appId" in y && t(5, o = y.appId), "document" in y && t(6, a = y.document), "sheet" in y && t(7, c = y.sheet), "elementRoot" in y && t(0, u = y.elementRoot);
  }, [
    u,
    h,
    d,
    p,
    g,
    o,
    a,
    c,
    _
  ];
}
f(Nae, "instance$1r");
var hf;
let jae = (hf = class extends ie {
  constructor(e) {
    super(), le(this, e, Nae, Fae, ne, {
      appId: 5,
      document: 6,
      sheet: 7,
      elementRoot: 0
    });
  }
  get appId() {
    return this.$$.ctx[5];
  }
  set appId(e) {
    this.$$set({ appId: e }), Ke();
  }
  get document() {
    return this.$$.ctx[6];
  }
  set document(e) {
    this.$$set({ document: e }), Ke();
  }
  get sheet() {
    return this.$$.ctx[7];
  }
  set sheet(e) {
    this.$$set({ sheet: e }), Ke();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Ke();
  }
}, f(hf, "ActiveEffectConfig"), hf);
const HT = class HT extends _s {
  /**
   * @inheritDoc
   */
  constructor(e, t = {}) {
    var l;
    t.svelte ?? (t.svelte = {}), super(foundry.utils.mergeObject(
      t,
      {
        baseApplication: "ActiveEffectConfig",
        id: e.parent ? `effect-${e.parent.id}-${e.id}` : `effect-${e.id}`,
        title: `Configure Active Effect: ${e.name}`,
        svelte: {
          class: jae,
          props: {
            document: null
          }
        },
        resizable: !0,
        focusAuto: !1,
        width: 555,
        height: 500
      }
    )), this.activeEffect = e, this.options.svelte.props.document = new Bt(
      e,
      { delete: this.close.bind(this) }
    ), this.options.svelte.props.sheet = this, this.statusEffectList = {}, CONFIG.statusEffects.filter((r) => r.id).map((r) => ({ id: r.id, label: K(r.label) })).sort((r, o) => r.label < o.label ? -1 : 1).forEach((r) => {
      this.statusEffectList[r.id] = r.label;
    });
    const n = ((l = e.parent) == null ? void 0 : l.documentName) === "Actor" ? game.a5e.activeEffects.options[this.activeEffect.parent.type] : game.a5e.activeEffects.options.all;
    this.optionsList = n.allOptions;
  }
  /**
   * Default Application options
   *
   * @returns {object} options - Application options.
   * @see https://foundryvtt.com/api/Application.html#options
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      baseApplication: "ActiveEffectConfig",
      classes: ["a5e-sheet", "a5e-sheet--active-effect"],
      minimizable: !0,
      resizable: !0,
      svelte: {
        target: document.body
      }
    });
  }
  get object() {
    return this.activeEffect;
  }
  get title() {
    return `${game.i18n.localize("EFFECT.ConfigTitle")}: ${this.activeEffect.name}`;
  }
  get isActorEffect() {
    var e;
    return ((e = this.activeEffect) == null ? void 0 : e.parent.documentName) === "Actor";
  }
  get isActionEffect() {
    var e;
    return ((e = this.activeEffect) == null ? void 0 : e.parent.documentName) === "Action";
  }
  get isItemEffect() {
    var e;
    return ((e = this.activeEffect) == null ? void 0 : e.parent.documentName) === "Item";
  }
  _getHeaderButtons() {
    const e = super._getHeaderButtons();
    return this.activeEffect.pack || e.unshift({
      label: "Sheet Configuration",
      class: "configure-sheet",
      icon: "fas fa-cog fa-fw",
      title: "Configure Sheet",
      onclick: (t) => this._onConfigureSheet(t)
    }), e;
  }
  _onConfigureSheet(e) {
    e && e.preventDefault(), new DocumentSheetConfig(
      this.activeEffect,
      { top: this.position.top + 40 }
    ).render(!0);
  }
};
f(HT, "ActiveEffectConfigA5e");
let $k = HT;
function pN(i) {
  let e, t, s, n, l;
  return e = new va({
    props: { summaryData: (
      /*summaryData*/
      i[0]
    ) }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), n = E("hr"), z(t, "display", "contents"), z(t, "--inline-padding", "0.25rem"), b(n, "class", "a5e-rule a5e-rule--card");
    },
    m(r, o) {
      T(r, t, o), N(e, t, null), T(r, s, o), T(r, n, o), l = !0;
    },
    p(r, o) {
      const a = {};
      o & /*summaryData*/
      1 && (a.summaryData = /*summaryData*/
      r[0]), e.$set(a);
    },
    i(r) {
      l || (w(e.$$.fragment, r), l = !0);
    },
    o(r) {
      C(e.$$.fragment, r), l = !1;
    },
    d(r) {
      r && (S(s), S(n)), r && e && S(t), j(e, r);
    }
  };
}
f(pN, "create_if_block$Q");
function Lae(i) {
  let e = Object.values(
    /*summaryData*/
    i[0] ?? {}
  ).some(Boolean), t, s, n, l = e && pN(i);
  return s = new hl({
    props: {
      document: (
        /*item*/
        i[2]
      ),
      content: (
        /*content*/
        i[1]
      ),
      updatePath: "system.description"
    }
  }), {
    c() {
      l && l.c(), t = R(), L(s.$$.fragment);
    },
    m(r, o) {
      l && l.m(r, o), T(r, t, o), N(s, r, o), n = !0;
    },
    p(r, [o]) {
      o & /*summaryData*/
      1 && (e = Object.values(
        /*summaryData*/
        r[0] ?? {}
      ).some(Boolean)), e ? l ? (l.p(r, o), o & /*summaryData*/
      1 && w(l, 1)) : (l = pN(r), l.c(), w(l, 1), l.m(t.parentNode, t)) : l && (ce(), C(l, 1, 1, () => {
        l = null;
      }), ue());
      const a = {};
      o & /*content*/
      2 && (a.content = /*content*/
      r[1]), s.$set(a);
    },
    i(r) {
      n || (w(l), w(s.$$.fragment, r), n = !0);
    },
    o(r) {
      C(l), C(s.$$.fragment, r), n = !1;
    },
    d(r) {
      r && S(t), l && l.d(r), j(s, r);
    }
  };
}
f(Lae, "create_fragment$1w");
function Bae(i, e, t) {
  let s, n, { summaryData: l = {} } = e;
  const r = fe("item");
  return pe(i, r, (o) => t(3, n = o)), i.$$set = (o) => {
    "summaryData" in o && t(0, l = o.summaryData);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item*/
    8 && t(1, s = n.system.description);
  }, [l, s, r, n];
}
f(Bae, "instance$1q");
const UT = class UT extends ie {
  constructor(e) {
    super(), le(this, e, Bae, Lae, ne, { summaryData: 0 });
  }
};
f(UT, "ItemDescriptionTab");
let yl = UT;
function mN(i) {
  let e, t, s = K("A5E.Prerequisite") + "", n, l, r, o, a, c, u;
  return {
    c() {
      e = E("div"), t = E("label"), n = x(s), l = x(":"), r = R(), o = E("input"), b(t, "class", "prerequisite-label svelte-18o8wfq"), b(
        t,
        "for",
        /*appId*/
        i[4] + "-prerequisites"
      ), b(
        o,
        "id",
        /*appId*/
        i[4] + "-prerequisites"
      ), b(o, "type", "text"), b(o, "name", "system.prerequisite"), o.value = a = /*$item*/
      i[1].system.prerequisite, b(o, "class", "prerequisite-input svelte-18o8wfq"), b(o, "placeholder", K("A5E.None")), b(e, "class", "prerequisites svelte-18o8wfq");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(t, n), A(t, l), A(e, r), A(e, o), c || (u = V(
        o,
        "change",
        /*change_handler_1*/
        i[12]
      ), c = !0);
    },
    p(d, p) {
      p & /*$item*/
      2 && a !== (a = /*$item*/
      d[1].system.prerequisite) && o.value !== a && (o.value = a);
    },
    d(d) {
      d && S(e), c = !1, u();
    }
  };
}
f(mN, "create_if_block_4$e");
function hN(i) {
  let e, t, s, n, l, r, o, a, c, u = (
    /*$item*/
    i[1].actor && /*$item*/
    i[1].system.requiresAttunement && gN(i)
  );
  return {
    c() {
      e = E("div"), t = E("button"), n = R(), u && u.c(), l = R(), r = E("button"), b(t, "class", "header-button fa-solid fa-circle-question svelte-18o8wfq"), t.disabled = !/*isGM*/
      i[7], b(t, "data-tooltip", s = /*$item*/
      i[1].system.unidentified ? "A5E.ButtonToolTipUnidentified" : "A5E.ButtonToolTipIdentified"), b(t, "data-tooltip-direction", "UP"), Q(
        t,
        "active",
        /*$item*/
        i[1].system.unidentified
      ), Q(t, "locked", !/*isGM*/
      i[7]), b(r, "class", "header-button fas svelte-18o8wfq"), b(r, "data-tooltip", o = /*damagedStates*/
      i[6][
        /*$item*/
        i[1].system.damagedState ?? 0
      ]), b(r, "data-tooltip-direction", "UP"), Q(
        r,
        "fa-heart",
        /*$item*/
        i[1].system.damagedState === /*DAMAGED_STATES*/
        i[5].INTACT
      ), Q(
        r,
        "fa-heart-crack",
        /*$item*/
        i[1].system.damagedState === /*DAMAGED_STATES*/
        i[5].DAMAGED
      ), Q(
        r,
        "fa-heart-pulse",
        /*$item*/
        i[1].system.damagedState === /*DAMAGED_STATES*/
        i[5].BROKEN
      ), Q(r, "active", [
        /*DAMAGED_STATES*/
        i[5].DAMAGED,
        /*DAMAGED_STATES*/
        i[5].BROKEN
      ].includes(
        /*$item*/
        i[1].system.damagedState
      )), b(e, "class", "button-container svelte-18o8wfq");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(e, n), u && u.m(e, null), A(e, l), A(e, r), a || (c = [
        V(t, "click", We(
          /*click_handler_1*/
          i[13]
        )),
        V(r, "click", We(
          /*click_handler_3*/
          i[15]
        ))
      ], a = !0);
    },
    p(d, p) {
      p & /*$item*/
      2 && s !== (s = /*$item*/
      d[1].system.unidentified ? "A5E.ButtonToolTipUnidentified" : "A5E.ButtonToolTipIdentified") && b(t, "data-tooltip", s), p & /*$item*/
      2 && Q(
        t,
        "active",
        /*$item*/
        d[1].system.unidentified
      ), /*$item*/
      d[1].actor && /*$item*/
      d[1].system.requiresAttunement ? u ? u.p(d, p) : (u = gN(d), u.c(), u.m(e, l)) : u && (u.d(1), u = null), p & /*$item*/
      2 && o !== (o = /*damagedStates*/
      d[6][
        /*$item*/
        d[1].system.damagedState ?? 0
      ]) && b(r, "data-tooltip", o), p & /*$item, DAMAGED_STATES*/
      34 && Q(
        r,
        "fa-heart",
        /*$item*/
        d[1].system.damagedState === /*DAMAGED_STATES*/
        d[5].INTACT
      ), p & /*$item, DAMAGED_STATES*/
      34 && Q(
        r,
        "fa-heart-crack",
        /*$item*/
        d[1].system.damagedState === /*DAMAGED_STATES*/
        d[5].DAMAGED
      ), p & /*$item, DAMAGED_STATES*/
      34 && Q(
        r,
        "fa-heart-pulse",
        /*$item*/
        d[1].system.damagedState === /*DAMAGED_STATES*/
        d[5].BROKEN
      ), p & /*DAMAGED_STATES, $item*/
      34 && Q(r, "active", [
        /*DAMAGED_STATES*/
        d[5].DAMAGED,
        /*DAMAGED_STATES*/
        d[5].BROKEN
      ].includes(
        /*$item*/
        d[1].system.damagedState
      ));
    },
    d(d) {
      d && S(e), u && u.d(), a = !1, Ne(c);
    }
  };
}
f(hN, "create_if_block_2$q");
function gN(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "header-button fa-solid fa-link svelte-18o8wfq"), b(e, "data-tooltip", t = /*$item*/
      i[1].system.attuned ? K("A5E.ButtonToolTipBreakAttunement", { item: (
        /*$item*/
        i[1].name
      ) }) : K("A5E.ButtonToolTipAttune", { item: (
        /*$item*/
        i[1].name
      ) })), b(e, "data-tooltip-direction", "UP"), Q(
        e,
        "active",
        /*$item*/
        i[1].system.attuned
      );
    },
    m(l, r) {
      T(l, e, r), s || (n = V(e, "click", We(
        /*click_handler_2*/
        i[14]
      )), s = !0);
    },
    p(l, r) {
      r & /*$item*/
      2 && t !== (t = /*$item*/
      l[1].system.attuned ? K("A5E.ButtonToolTipBreakAttunement", { item: (
        /*$item*/
        l[1].name
      ) }) : K("A5E.ButtonToolTipAttune", { item: (
        /*$item*/
        l[1].name
      ) })) && b(e, "data-tooltip", t), r & /*$item*/
      2 && Q(
        e,
        "active",
        /*$item*/
        l[1].system.attuned
      );
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(gN, "create_if_block_3$h");
function bN(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "class-level-input svelte-18o8wfq"), b(e, "type", "number"), b(e, "min", "1"), b(e, "max", "20"), e.value = t = /*$item*/
      i[1].system.classLevels;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_2*/
        i[16]
      ), s = !0);
    },
    p(l, r) {
      r & /*$item*/
      2 && t !== (t = /*$item*/
      l[1].system.classLevels) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(bN, "create_if_block_1$C");
function _N(i) {
  let e, t = K("A5E.FulfilDestiny") + "", s, n, l;
  return {
    c() {
      e = E("button"), s = x(t), b(e, "class", "fulfil-button svelte-18o8wfq"), e.disabled = /*disableFulfil*/
      i[0];
    },
    m(r, o) {
      T(r, e, o), A(e, s), n || (l = V(
        e,
        "click",
        /*click_handler_4*/
        i[17]
      ), n = !0);
    },
    p(r, o) {
      o & /*disableFulfil*/
      1 && (e.disabled = /*disableFulfil*/
      r[0]);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(_N, "create_if_block$P");
function qae(i) {
  let e, t, s, n, l, r, o, a, c, u, d = (
    /*prerequisiteTypes*/
    i[9].includes(
      /*$item*/
      i[1].type
    )
  ), p, m, g, h, _, y, k = d && mN(i), v = (
    /*$item*/
    i[1].type === "object" && hN(i)
  ), O = (
    /*$item*/
    i[1].type === "class" && /*$item*/
    i[1].actor && bN(i)
  ), P = (
    /*$item*/
    i[1].type === "destiny" && _N(i)
  );
  return {
    c() {
      e = E("header"), t = E("img"), r = R(), o = E("div"), a = E("input"), u = R(), k && k.c(), p = R(), v && v.c(), m = R(), O && O.c(), g = R(), h = E("div"), P && P.c(), b(t, "class", "item-image svelte-18o8wfq"), ze(t.src, s = /*$item*/
      i[1].img) || b(t, "src", s), b(t, "alt", n = /*$item*/
      i[1].name), b(t, "title", l = /*$item*/
      i[1].name), b(a, "class", "item-name svelte-18o8wfq"), b(a, "type", "text"), b(a, "name", "name"), a.value = c = /*$item*/
      i[1].name, b(a, "placeholder", "A5E.Name"), b(o, "class", "name-wrapper svelte-18o8wfq"), b(h, "class", "u-flex u-flex-shrink-0 u-align-center u-gap-xl"), b(e, "class", "sheet-header svelte-18o8wfq");
    },
    m(D, I) {
      T(D, e, I), A(e, t), A(e, r), A(e, o), A(o, a), A(o, u), k && k.m(o, null), A(e, p), v && v.m(e, null), A(e, m), O && O.m(e, null), A(e, g), A(e, h), P && P.m(h, null), _ || (y = [
        V(
          t,
          "click",
          /*click_handler*/
          i[10]
        ),
        V(
          a,
          "change",
          /*change_handler*/
          i[11]
        )
      ], _ = !0);
    },
    p(D, [I]) {
      I & /*$item*/
      2 && !ze(t.src, s = /*$item*/
      D[1].img) && b(t, "src", s), I & /*$item*/
      2 && n !== (n = /*$item*/
      D[1].name) && b(t, "alt", n), I & /*$item*/
      2 && l !== (l = /*$item*/
      D[1].name) && b(t, "title", l), I & /*$item*/
      2 && c !== (c = /*$item*/
      D[1].name) && a.value !== c && (a.value = c), I & /*$item*/
      2 && (d = /*prerequisiteTypes*/
      D[9].includes(
        /*$item*/
        D[1].type
      )), d ? k ? k.p(D, I) : (k = mN(D), k.c(), k.m(o, null)) : k && (k.d(1), k = null), /*$item*/
      D[1].type === "object" ? v ? v.p(D, I) : (v = hN(D), v.c(), v.m(e, m)) : v && (v.d(1), v = null), /*$item*/
      D[1].type === "class" && /*$item*/
      D[1].actor ? O ? O.p(D, I) : (O = bN(D), O.c(), O.m(e, g)) : O && (O.d(1), O = null), /*$item*/
      D[1].type === "destiny" ? P ? P.p(D, I) : (P = _N(D), P.c(), P.m(h, null)) : P && (P.d(1), P = null);
    },
    i: ee,
    o: ee,
    d(D) {
      D && S(e), k && k.d(), v && v.d(), O && O.d(), P && P.d(), _ = !1, Ne(y);
    }
  };
}
f(qae, "create_fragment$1v");
function Gae(i, e, t) {
  var P;
  let s;
  async function n() {
    const D = await fromUuid(s.system.fulfillmentFeature);
    !D || !s.actor || (s.actor.getFlag("a5e", "destinyFulfilled") ?? !1) || (await s.actor.createEmbeddedDocuments("Item", [D]), await s.actor.setFlag("a5e", "destinyFulfilled", !0), t(0, p = !0));
  }
  f(n, "fulfilDestiny");
  async function l(D) {
    D = parseInt(D, 10);
    const I = s.system.classLevels, B = Math.abs(I - D), F = Math.sign(D - I);
    for (let H = 0; H < B; H++)
      F === 1 ? await s.update({
        "system.classLevels": s.system.classLevels + 1
      }) : await s.update({
        "system.classLevels": s.system.classLevels - 1
      });
  }
  f(l, "updateClassLevel");
  const r = fe("appId"), { DAMAGED_STATES: o, damagedStates: a } = CONFIG.A5E, { isGM: c } = game.user, u = fe("item");
  pe(i, u, (D) => t(1, s = D));
  const d = ["maneuver", "feature", "spell"];
  let p = ((P = s.actor) == null ? void 0 : P.getFlag("a5e", "destinyFulfilled")) ?? !0;
  return [
    p,
    s,
    n,
    l,
    r,
    o,
    a,
    c,
    u,
    d,
    /* @__PURE__ */ f(() => ab(s), "click_handler"),
    /* @__PURE__ */ f(({ target: D }) => se(s, D.name, D.value), "change_handler"),
    /* @__PURE__ */ f(({ target: D }) => se(s, D.name, D.value), "change_handler_1"),
    /* @__PURE__ */ f(() => s.toggleUnidentified(), "click_handler_1"),
    /* @__PURE__ */ f(() => s.toggleAttunement(), "click_handler_2"),
    /* @__PURE__ */ f(() => s.toggleDamagedState(), "click_handler_3"),
    /* @__PURE__ */ f(({ target: D }) => l(D.value), "change_handler_2"),
    /* @__PURE__ */ f(() => n(), "click_handler_4")
  ];
}
f(Gae, "instance$1p");
const VT = class VT extends ie {
  constructor(e) {
    super(), le(this, e, Gae, qae, ne, {});
  }
};
f(VT, "ItemSheetHeader");
let vl = VT;
function yN(i) {
  let e, t = !/*sheetIsLocked*/
  i[2] && vN(i);
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*sheetIsLocked*/
      s[2] ? t && (t.d(1), t = null) : t ? t.p(s, n) : (t = vN(s), t.c(), t.m(e.parentNode, e));
    },
    d(s) {
      s && S(e), t && t.d(s);
    }
  };
}
f(yN, "create_if_block$O");
function vN(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g;
  return {
    c() {
      e = E("div"), t = E("i"), s = R(), n = E("ul"), l = E("li"), r = E("button"), o = R(), a = E("li"), c = E("button"), u = R(), d = E("li"), p = E("button"), b(t, "class", "track-icon fa-solid fa-ellipsis-vertical svelte-1f6zu81"), b(r, "class", "action-button fas fa-cog svelte-1f6zu81"), b(r, "data-tooltip", "A5E.ButtonToolTipConfigure"), b(r, "data-tooltip-direction", "UP"), b(c, "class", "action-button fa-solid fa-clone svelte-1f6zu81"), b(c, "data-tooltip", "A5E.ButtonToolTipDuplicate"), b(c, "data-tooltip-direction", "UP"), b(p, "class", "action-button delete-button fas fa-trash svelte-1f6zu81"), b(p, "data-tooltip", "A5E.ButtonToolTipDelete"), b(p, "data-tooltip-direction", "UP"), b(n, "class", "track-items svelte-1f6zu81"), b(e, "class", "track svelte-1f6zu81");
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(e, s), A(e, n), A(n, l), A(l, r), A(n, o), A(n, a), A(a, c), A(n, u), A(n, d), A(d, p), m || (g = [
        V(r, "click", We(
          /*click_handler_2*/
          i[8]
        )),
        V(c, "click", We(
          /*click_handler_3*/
          i[9]
        )),
        V(p, "click", We(
          /*click_handler_4*/
          i[10]
        )),
        V(e, "click", We(
          /*click_handler*/
          i[6]
        ))
      ], m = !0);
    },
    p: ee,
    d(h) {
      h && S(e), m = !1, Ne(g);
    }
  };
}
f(vN, "create_if_block_1$B");
function zae(i) {
  let e, t, s, n, l, r, o, a, c = (
    /*grant*/
    (i[0].label || "New Grant") + ""
  ), u, d, p, m, g, h, _ = (
    /*$item*/
    i[1].isOwner && yN(i)
  );
  return {
    c() {
      var y, k;
      e = E("li"), t = E("button"), s = E("img"), r = R(), o = E("div"), a = E("div"), u = x(c), d = R(), p = E("div"), p.innerHTML = "", m = R(), _ && _.c(), b(s, "class", "grant-image svelte-1f6zu81"), ze(s.src, n = /*grant*/
      ((y = i[0]) == null ? void 0 : y.img) || /*$item*/
      ((k = i[1]) == null ? void 0 : k.img) || "icons/svg/upgrade.svg") || b(s, "src", n), b(s, "alt", l = /*grant*/
      i[0].label || "New Grant"), b(t, "class", "grant-activate-button svelte-1f6zu81"), t.disabled = !0, Q(t, "disable-pointer-events", !/*$item*/
      i[1].isOwner), b(a, "class", "name svelte-1f6zu81"), b(o, "class", "name-wrapper svelte-1f6zu81"), b(p, "class", "indicator-wrapper svelte-1f6zu81"), b(e, "class", "a5e-item a5e-item--grant"), b(e, "draggable", "true");
    },
    m(y, k) {
      T(y, e, k), A(e, t), A(t, s), A(e, r), A(e, o), A(o, a), A(a, u), A(e, d), A(e, p), A(e, m), _ && _.m(e, null), g || (h = [
        V(t, "click", We(
          /*click_handler_1*/
          i[7]
        )),
        V(
          e,
          "dragstart",
          /*_onDragStart*/
          i[4]
        ),
        V(e, "auxclick", tt(
          /*onAuxClick*/
          i[5]
        ))
      ], g = !0);
    },
    p(y, [k]) {
      var v, O;
      k & /*grant, $item*/
      3 && !ze(s.src, n = /*grant*/
      ((v = y[0]) == null ? void 0 : v.img) || /*$item*/
      ((O = y[1]) == null ? void 0 : O.img) || "icons/svg/upgrade.svg") && b(s, "src", n), k & /*grant*/
      1 && l !== (l = /*grant*/
      y[0].label || "New Grant") && b(s, "alt", l), k & /*$item*/
      2 && Q(t, "disable-pointer-events", !/*$item*/
      y[1].isOwner), k & /*grant*/
      1 && c !== (c = /*grant*/
      (y[0].label || "New Grant") + "") && _e(u, c), /*$item*/
      y[1].isOwner ? _ ? _.p(y, k) : (_ = yN(y), _.c(), _.m(e, null)) : _ && (_.d(1), _ = null);
    },
    i: ee,
    o: ee,
    d(y) {
      y && S(e), _ && _.d(), g = !1, Ne(h);
    }
  };
}
f(zae, "create_fragment$1u");
function Hae(i, e, t) {
  let s, n, { grant: l } = e;
  const r = fe("item");
  pe(i, r, (h) => t(1, n = h));
  function o(h) {
    var y;
    const _ = {
      grantId: l._id,
      itemUuid: n.uuid,
      type: "Grant"
    };
    return (y = h.dataTransfer) == null ? void 0 : y.setData("text/plain", JSON.stringify(_));
  }
  f(o, "_onDragStart");
  async function a() {
    c && l.configureGrant();
  }
  f(a, "onAuxClick");
  let c = game.settings.get("a5e", "itemRightClickConfigure") ?? !1;
  function u(h) {
    gt.call(this, i, h);
  }
  f(u, "click_handler");
  const d = /* @__PURE__ */ f(({ target: h }) => {
  }, "click_handler_1"), p = /* @__PURE__ */ f(() => l.configureGrant(), "click_handler_2"), m = /* @__PURE__ */ f(() => n.grants.duplicate(l._id), "click_handler_3"), g = /* @__PURE__ */ f(() => l.deleteGrant(), "click_handler_4");
  return i.$$set = (h) => {
    "grant" in h && t(0, l = h.grant);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item*/
    2 && t(2, s = !n.isOwner);
  }, [
    l,
    n,
    s,
    r,
    o,
    a,
    u,
    d,
    p,
    m,
    g
  ];
}
f(Hae, "instance$1o");
const WT = class WT extends ie {
  constructor(e) {
    super(), le(this, e, Hae, zae, ne, { grant: 0 });
  }
};
f(WT, "ItemGrantListComponent");
let Ak = WT;
function kN(i, e, t) {
  const s = i.slice();
  return s[11] = e[t], s;
}
f(kN, "get_each_context$v");
function wN(i, e, t) {
  const s = i.slice();
  return s[14] = e[t], s;
}
f(wN, "get_each_context_1$4");
function $N(i) {
  let e, t, s, n, l = [], r = /* @__PURE__ */ new Map(), o, a;
  function c() {
    return (
      /*func*/
      i[7](
        /*grantType*/
        i[11]
      )
    );
  }
  f(c, "func"), t = new Me({
    props: {
      heading: `A5E.grants.headingsPlural.${/*grantType*/
      i[11]}`,
      headerButtons: [
        {
          classes: "add-button",
          handler: c,
          label: K("A5E.ButtonAddGrant", {
            type: K(`A5E.grants.headings.${/*grantType*/
            i[11]}`)
          })
        }
      ]
    }
  });
  let u = oe(
    /*grants*/
    i[2].byType(
      /*grantType*/
      i[11]
    )
  );
  const d = /* @__PURE__ */ f((p) => (
    /*grant*/
    p[14]._id
  ), "get_key");
  for (let p = 0; p < u.length; p += 1) {
    let m = wN(i, u, p), g = d(m);
    r.set(g, l[p] = AN(g, m));
  }
  return {
    c() {
      e = E("li"), L(t.$$.fragment), s = R(), n = E("ul");
      for (let p = 0; p < l.length; p += 1)
        l[p].c();
      o = R(), b(n, "class", "a5e-item-list"), b(e, "class", "grant-config-list__item svelte-1v2gb29");
    },
    m(p, m) {
      T(p, e, m), N(t, e, null), A(e, s), A(e, n);
      for (let g = 0; g < l.length; g += 1)
        l[g] && l[g].m(n, null);
      A(e, o), a = !0;
    },
    p(p, m) {
      i = p, m & /*grants, Object, itemGrantTypes, grantTemplateConfiguration*/
      21 && (u = oe(
        /*grants*/
        i[2].byType(
          /*grantType*/
          i[11]
        )
      ), ce(), l = kt(l, m, d, 1, i, u, r, n, ks, AN, null, wN), ue());
    },
    i(p) {
      if (!a) {
        w(t.$$.fragment, p);
        for (let m = 0; m < u.length; m += 1)
          w(l[m]);
        a = !0;
      }
    },
    o(p) {
      C(t.$$.fragment, p);
      for (let m = 0; m < l.length; m += 1)
        C(l[m]);
      a = !1;
    },
    d(p) {
      p && S(e), j(t);
      for (let m = 0; m < l.length; m += 1)
        l[m].d();
    }
  };
}
f($N, "create_if_block$N");
function AN(i, e) {
  let t, s, n, l, r, o;
  return s = new Ak({ props: { grant: (
    /*grant*/
    e[14]
  ) } }), {
    key: i,
    first: null,
    c() {
      t = $e(), n = E("div"), L(s.$$.fragment), z(n, "display", "contents"), z(n, "--grantTemplateAreas", l = /*grantTemplateConfiguration*/
      e[0].areas), z(n, "--grantTemplateColumns", r = /*grantTemplateConfiguration*/
      e[0].columns), this.first = t;
    },
    m(a, c) {
      T(a, t, c), T(a, n, c), N(s, n, null), o = !0;
    },
    p(a, c) {
      e = a, c & /*grantTemplateConfiguration*/
      1 && l !== (l = /*grantTemplateConfiguration*/
      e[0].areas) && z(n, "--grantTemplateAreas", l), c & /*grantTemplateConfiguration*/
      1 && r !== (r = /*grantTemplateConfiguration*/
      e[0].columns) && z(n, "--grantTemplateColumns", r);
      const u = {};
      c & /*grants*/
      4 && (u.grant = /*grant*/
      e[14]), s.$set(u);
    },
    i(a) {
      o || (w(s.$$.fragment, a), o = !0);
    },
    o(a) {
      C(s.$$.fragment, a), o = !1;
    },
    d(a) {
      a && S(t), a && s && S(n), j(s, a);
    }
  };
}
f(AN, "create_each_block_1$4");
function EN(i, e) {
  let t, s = (
    /*grants*/
    e[2].byType(
      /*grantType*/
      e[11]
    ).length
  ), n, l, r = s && $N(e);
  return {
    key: i,
    first: null,
    c() {
      t = $e(), r && r.c(), n = $e(), this.first = t;
    },
    m(o, a) {
      T(o, t, a), r && r.m(o, a), T(o, n, a), l = !0;
    },
    p(o, a) {
      e = o, a & /*grants*/
      4 && (s = /*grants*/
      e[2].byType(
        /*grantType*/
        e[11]
      ).length), s ? r ? (r.p(e, a), a & /*grants*/
      4 && w(r, 1)) : (r = $N(e), r.c(), w(r, 1), r.m(n.parentNode, n)) : r && (ce(), C(r, 1, 1, () => {
        r = null;
      }), ue());
    },
    i(o) {
      l || (w(r), l = !0);
    },
    o(o) {
      C(r), l = !1;
    },
    d(o) {
      o && (S(t), S(n)), r && r.d(o);
    }
  };
}
f(EN, "create_each_block$v");
function Uae(i) {
  let e, t, s = [], n = /* @__PURE__ */ new Map(), l, r, o, a, c = oe(Object.keys(
    /*itemGrantTypes*/
    i[4]
  ));
  const u = /* @__PURE__ */ f((d) => (
    /*grantType*/
    d[11]
  ), "get_key");
  for (let d = 0; d < c.length; d += 1) {
    let p = kN(i, c, d), m = u(p);
    n.set(m, s[d] = EN(m, p));
  }
  return o = new Ys({
    props: {
      menuList: (
        /*menuList*/
        i[1]
      ),
      offset: { x: -165, y: -230 },
      documentName: "Grant"
    }
  }), o.$on(
    "press",
    /*press_handler*/
    i[8]
  ), {
    c() {
      e = E("div"), t = E("ul");
      for (let d = 0; d < s.length; d += 1)
        s[d].c();
      l = R(), r = E("div"), L(o.$$.fragment), b(t, "class", "grant-config-list svelte-1v2gb29"), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable"), b(r, "class", "sticky-add-button svelte-1v2gb29");
    },
    m(d, p) {
      T(d, e, p), A(e, t);
      for (let m = 0; m < s.length; m += 1)
        s[m] && s[m].m(t, null);
      T(d, l, p), T(d, r, p), N(o, r, null), a = !0;
    },
    p(d, [p]) {
      p & /*grants, Object, itemGrantTypes, grantTemplateConfiguration, addGrant*/
      53 && (c = oe(Object.keys(
        /*itemGrantTypes*/
        d[4]
      )), ce(), s = kt(s, p, u, 1, d, c, n, t, ks, EN, null, kN), ue());
      const m = {};
      p & /*menuList*/
      2 && (m.menuList = /*menuList*/
      d[1]), o.$set(m);
    },
    i(d) {
      if (!a) {
        for (let p = 0; p < c.length; p += 1)
          w(s[p]);
        w(o.$$.fragment, d), a = !0;
      }
    },
    o(d) {
      for (let p = 0; p < s.length; p += 1)
        C(s[p]);
      C(o.$$.fragment, d), a = !1;
    },
    d(d) {
      d && (S(e), S(l), S(r));
      for (let p = 0; p < s.length; p += 1)
        s[p].d();
      j(o);
    }
  };
}
f(Uae, "create_fragment$1t");
function Vae(i, e, t) {
  let s, n, l, r, o;
  const a = fe("item");
  pe(i, a, (g) => t(6, o = g));
  const c = CONFIG.A5E.itemGrants;
  function u() {
    let g = "icon name indicators", h = "min-content 1fr min-content";
    return (o.documentName === "Item" || !l) && (g += " menu", h += " 2rem"), { areas: `"${g}"`, columns: h };
  }
  f(u, "getGrantTemplateConfiguration");
  function d(g) {
    const h = { grantType: g, optional: !1 };
    _a.addGrant(o, h);
  }
  f(d, "addGrant");
  const p = /* @__PURE__ */ f((g) => d(g), "func"), m = /* @__PURE__ */ f(({ detail: g }) => d(g), "press_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    64 && t(2, s = o.grants), i.$$.dirty & /*$item*/
    64 && (l = !o.isOwner);
  }, t(1, n = Object.entries(c).reduce(
    (g, [h, _]) => (g.push([h, _]), g),
    []
  )), t(0, r = u()), [
    r,
    n,
    s,
    a,
    c,
    d,
    o,
    p,
    m
  ];
}
f(Vae, "instance$1n");
const KT = class KT extends ie {
  constructor(e) {
    super(), le(this, e, Vae, Uae, ne, {});
  }
};
f(KT, "ItemGrantsTab");
let Mr = KT;
function Wae(i) {
  let e, t, s, n, l, r, o;
  t = new vl({}), n = new bn({
    props: {
      currentTab: (
        /*currentTab*/
        i[1]
      ),
      tabs: (
        /*tabs*/
        i[3]
      )
    }
  }), n.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[2]
  );
  var a = (
    /*currentTab*/
    i[1].component
  );
  function c(u, d) {
    return {};
  }
  return f(c, "switch_props"), a && (r = nt(a, c())), {
    c() {
      e = E("main"), L(t.$$.fragment), s = R(), L(n.$$.fragment), l = R(), r && L(r.$$.fragment), b(e, "class", "svelte-d53nbt");
    },
    m(u, d) {
      T(u, e, d), N(t, e, null), A(e, s), N(n, e, null), A(e, l), r && N(r, e, null), o = !0;
    },
    p(u, d) {
      const p = {};
      if (d & /*currentTab*/
      2 && (p.currentTab = /*currentTab*/
      u[1]), n.$set(p), d & /*currentTab*/
      2 && a !== (a = /*currentTab*/
      u[1].component)) {
        if (r) {
          ce();
          const m = r;
          C(m.$$.fragment, 1, 0, () => {
            j(m, 1);
          }), ue();
        }
        a ? (r = nt(a, c()), L(r.$$.fragment), w(r.$$.fragment, 1), N(r, e, null)) : r = null;
      }
    },
    i(u) {
      o || (w(t.$$.fragment, u), w(n.$$.fragment, u), r && w(r.$$.fragment, u), o = !0);
    },
    o(u) {
      C(t.$$.fragment, u), C(n.$$.fragment, u), r && C(r.$$.fragment, u), o = !1;
    },
    d(u) {
      u && S(e), j(t), j(n), r && j(r);
    }
  };
}
f(Wae, "create_default_slot$G");
function Kae(i) {
  let e, t, s;
  function n(r) {
    i[5](r);
  }
  f(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [Wae] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Ss({ props: l }), st.push(() => mt(e, "elementRoot", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, currentTab*/
        130 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(Kae, "create_fragment$1s");
function Yae(i, e, t) {
  let { document: s } = fe("#external").application, { document: n = s } = e, { elementRoot: l } = e;
  const r = n;
  function o(d) {
    t(1, c = a[d.detail]);
  }
  f(o, "updateCurrentTab");
  const a = [
    {
      name: "description",
      label: "A5E.Description",
      component: yl
    },
    {
      name: "grants",
      label: "A5E.TabGrants",
      component: Mr
    }
  ];
  let c = a[0];
  et("item", r);
  function u(d) {
    l = d, t(0, l);
  }
  return f(u, "applicationshell_elementRoot_binding"), i.$$set = (d) => {
    "document" in d && t(4, n = d.document), "elementRoot" in d && t(0, l = d.elementRoot);
  }, [
    l,
    c,
    o,
    a,
    n,
    u
  ];
}
f(Yae, "instance$1m");
const YT = class YT extends ie {
  constructor(e) {
    super(), le(this, e, Yae, Kae, ne, { document: 4, elementRoot: 0 });
  }
  get document() {
    return this.$$.ctx[4];
  }
  set document(e) {
    this.$$set({ document: e }), Ke();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Ke();
  }
};
f(YT, "BackgroundSheet");
let Ek = YT;
function Xae(i) {
  var a, c, u, d, p, m, g;
  if (!i)
    return 0;
  const e = Object.values(i.classes ?? {}).reduce(
    (h, _) => {
      const y = _.maxHP ?? 0;
      return y && h.push([y, _.name]), h;
    },
    []
  ), t = e.map(([h]) => h).join(" + "), s = (((d = (u = (c = (a = i.system) == null ? void 0 : a.abilities) == null ? void 0 : c.con) == null ? void 0 : u.check) == null ? void 0 : d.mod) ?? 0) * i.levels.character, n = ((g = (m = (p = i.system) == null ? void 0 : p.attributes) == null ? void 0 : m.hp) == null ? void 0 : g.bonus) ?? 0, l = at(
    i.BonusesManager.getHitPointsBonusFormula(),
    i.getRollData()
  ) ?? 0, r = at(
    `${t} + ${s} + ${n} + ${l}`,
    i.getRollData()
  );
  let o = "";
  return t && (o += e.map(([h, _]) => `${h}[${_}]`).join(" + ")), s && (o += ` + ${s}[Con Mod]`), n + l && (o += ` + ${n + l}[Bonuses]`), r;
}
f(Xae, "getTotalHp");
function SN(i, e, t) {
  const s = i.slice();
  return s[19] = e[t][0], s[20] = e[t][1], s;
}
f(SN, "get_each_context$u");
function Jae(i) {
  let e, t, s, n, l, r, o;
  return {
    c() {
      e = E("div"), t = E("input"), n = R(), l = E("button"), l.innerHTML = '<i class="fas fa-solid fa-rotate-left"></i>', b(t, "class", "a5e-input a5e-input--slim slug-input svelte-1n9fr00"), t.value = s = /*$item*/
      i[0].system.slug || /*$item*/
      i[0].slug || "", b(t, "type", "text"), b(l, "class", "slug-reset-button svelte-1n9fr00"), z(e, "display", "flex"), z(e, "gap", "0.5rem");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(e, n), A(e, l), r || (o = [
        V(
          t,
          "change",
          /*change_handler*/
          i[8]
        ),
        V(
          l,
          "click",
          /*click_handler*/
          i[9]
        )
      ], r = !0);
    },
    p(a, c) {
      c & /*$item*/
      1 && s !== (s = /*$item*/
      a[0].system.slug || /*$item*/
      a[0].slug || "") && t.value !== s && (t.value = s);
    },
    d(a) {
      a && S(e), r = !1, Ne(o);
    }
  };
}
f(Jae, "create_default_slot_7$6");
function Zae(i) {
  let e, t, s;
  return e = new de({
    props: {
      heading: "Class Identifier",
      $$slots: { default: [Jae] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-field-wrapper-header-item-justification", "flex-start"), z(t, "--a5e-field-wrapper-header-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, $item*/
      8388609 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(Zae, "create_default_slot_6$7");
function TN(i) {
  let e, t;
  return e = new de({
    props: {
      heading: "Hit Dice Used",
      $$slots: { default: [Qae] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, classLevel, $item*/
      8388613 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(TN, "create_if_block_4$d");
function Qae(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input a5e-input--small a5e-input--slim"), b(e, "type", "number"), b(
        e,
        "max",
        /*classLevel*/
        i[2]
      ), b(e, "min", "0"), e.value = t = /*$item*/
      i[0].system.hp.hitDiceUsed;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[11]
      ), s = !0);
    },
    p(l, r) {
      r & /*classLevel*/
      4 && b(
        e,
        "max",
        /*classLevel*/
        l[2]
      ), r & /*$item*/
      1 && t !== (t = /*$item*/
      l[0].system.hp.hitDiceUsed) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Qae, "create_default_slot_5$9");
function xae(i) {
  let e, t, s, n;
  e = new Ye({
    props: {
      heading: "Hit Dice Size",
      options: (
        /*hitDiceSize*/
        i[7]
      ),
      selected: (
        /*$item*/
        i[0].system.hp.hitDiceSize
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[10]
  );
  let l = (
    /*$item*/
    i[0].actor && TN(i)
  );
  return {
    c() {
      L(e.$$.fragment), t = R(), l && l.c(), s = $e();
    },
    m(r, o) {
      N(e, r, o), T(r, t, o), l && l.m(r, o), T(r, s, o), n = !0;
    },
    p(r, o) {
      const a = {};
      o & /*$item*/
      1 && (a.selected = /*$item*/
      r[0].system.hp.hitDiceSize), e.$set(a), /*$item*/
      r[0].actor ? l ? (l.p(r, o), o & /*$item*/
      1 && w(l, 1)) : (l = TN(r), l.c(), w(l, 1), l.m(s.parentNode, s)) : l && (ce(), C(l, 1, 1, () => {
        l = null;
      }), ue());
    },
    i(r) {
      n || (w(e.$$.fragment, r), w(l), n = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(l), n = !1;
    },
    d(r) {
      r && (S(t), S(s)), j(e, r), l && l.d(r);
    }
  };
}
f(xae, "create_default_slot_4$a");
function CN(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Hit Points",
      $$slots: { default: [ece] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, hpData, $item, classLevel*/
      8388615 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(CN, "create_if_block_2$p");
function ON(i) {
  let e, t, s, n, l = (
    /*$item*/
    i[0].actor.system.abilities.con.check.mod + ""
  ), r, o, a, c = (
    /*hpData*/
    i[1].hpBonusPerLevel + ""
  ), u, d, p, m = (
    /*hp*/
    i[20] + /*$item*/
    i[0].actor.system.abilities.con.check.mod + /*hpData*/
    i[1].hpBonusPerLevel + ""
  ), g, h, _;
  function y(...k) {
    return (
      /*change_handler_2*/
      i[12](
        /*level*/
        i[19],
        ...k
      )
    );
  }
  return f(y, "change_handler_2"), {
    c() {
      e = E("input"), s = R(), n = E("span"), r = x(l), o = R(), a = E("span"), u = x(c), d = R(), p = E("span"), g = x(m), b(e, "class", "a5e-class-hp-table__field svelte-1n9fr00"), b(e, "type", "number"), e.value = t = /*hp*/
      i[20] ?? 0, b(e, "min", "0"), b(n, "class", "a5e-class-hp-table__field svelte-1n9fr00"), b(a, "class", "a5e-class-hp-table__field svelte-1n9fr00"), b(p, "class", "a5e-class-hp-table__field svelte-1n9fr00");
    },
    m(k, v) {
      T(k, e, v), T(k, s, v), T(k, n, v), A(n, r), T(k, o, v), T(k, a, v), A(a, u), T(k, d, v), T(k, p, v), A(p, g), h || (_ = V(e, "change", y), h = !0);
    },
    p(k, v) {
      i = k, v & /*$item*/
      1 && t !== (t = /*hp*/
      i[20] ?? 0) && e.value !== t && (e.value = t), v & /*$item*/
      1 && l !== (l = /*$item*/
      i[0].actor.system.abilities.con.check.mod + "") && _e(r, l), v & /*hpData*/
      2 && c !== (c = /*hpData*/
      i[1].hpBonusPerLevel + "") && _e(u, c), v & /*$item, hpData*/
      3 && m !== (m = /*hp*/
      i[20] + /*$item*/
      i[0].actor.system.abilities.con.check.mod + /*hpData*/
      i[1].hpBonusPerLevel + "") && _e(g, m);
    },
    d(k) {
      k && (S(e), S(s), S(n), S(o), S(a), S(d), S(p)), h = !1, _();
    }
  };
}
f(ON, "create_if_block_3$g");
function DN(i) {
  let e, t = (
    /*level*/
    i[19] <= /*classLevel*/
    i[2] && ON(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*level*/
      s[19] <= /*classLevel*/
      s[2] ? t ? t.p(s, n) : (t = ON(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && S(e), t && t.d(s);
    }
  };
}
f(DN, "create_each_block$u");
function ece(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m = (
    /*hpData*/
    i[1].otherHpBonuses + ""
  ), g, h, _, y, k, v = (
    /*hpData*/
    i[1].totalHp + ""
  ), O, P = oe(Object.entries(
    /*$item*/
    i[0].system.hp.levels
  )), D = [];
  for (let I = 0; I < P.length; I += 1)
    D[I] = DN(SN(i, P, I));
  return {
    c() {
      e = E("div"), t = E("header"), t.innerHTML = '<h3 class="a5e-class-hp-table__heading svelte-1n9fr00">Base HP</h3> <h3 class="a5e-class-hp-table__heading svelte-1n9fr00">Con Mod</h3> <h3 class="a5e-class-hp-table__heading svelte-1n9fr00">Bonus HP</h3> <h3 class="a5e-class-hp-table__heading svelte-1n9fr00">Total HP</h3>', s = R(), n = E("hr"), l = R();
      for (let I = 0; I < D.length; I += 1)
        D[I].c();
      r = R(), o = E("hr"), a = R(), c = E("footer"), u = E("h3"), u.textContent = "Other Bonuses", d = R(), p = E("span"), g = x(m), h = R(), _ = E("h3"), _.textContent = "Total HP", y = R(), k = E("span"), O = x(v), b(t, "class", "a5e-class-hp-table__header svelte-1n9fr00"), b(n, "class", "a5e-class-hp-table__rule svelte-1n9fr00"), b(o, "class", "a5e-class-hp-table__rule svelte-1n9fr00"), b(u, "class", "a5e-class-hp-table__heading a5e-class-hp-table__heading--footer svelte-1n9fr00"), b(p, "class", "a5e-class-hp-table__field svelte-1n9fr00"), b(_, "class", "a5e-class-hp-table__heading a5e-class-hp-table__heading--footer svelte-1n9fr00"), b(k, "class", "a5e-class-hp-table__field a5e-class-hp-table__field--total svelte-1n9fr00"), b(c, "class", "a5e-class-hp-table__footer svelte-1n9fr00"), b(e, "class", "a5e-class-hp-table svelte-1n9fr00");
    },
    m(I, B) {
      T(I, e, B), A(e, t), A(e, s), A(e, n), A(e, l);
      for (let F = 0; F < D.length; F += 1)
        D[F] && D[F].m(e, null);
      A(e, r), A(e, o), A(e, a), A(e, c), A(c, u), A(c, d), A(c, p), A(p, g), A(c, h), A(c, _), A(c, y), A(c, k), A(k, O);
    },
    p(I, B) {
      if (B & /*Object, $item, hpData, Number, classLevel*/
      7) {
        P = oe(Object.entries(
          /*$item*/
          I[0].system.hp.levels
        ));
        let F;
        for (F = 0; F < P.length; F += 1) {
          const H = SN(I, P, F);
          D[F] ? D[F].p(H, B) : (D[F] = DN(H), D[F].c(), D[F].m(e, r));
        }
        for (; F < D.length; F += 1)
          D[F].d(1);
        D.length = P.length;
      }
      B & /*hpData*/
      2 && m !== (m = /*hpData*/
      I[1].otherHpBonuses + "") && _e(g, m), B & /*hpData*/
      2 && v !== (v = /*hpData*/
      I[1].totalHp + "") && _e(O, v);
    },
    d(I) {
      I && S(e), Le(D, I);
    }
  };
}
f(ece, "create_default_slot_3$c");
function IN(i) {
  let e, t, s, n;
  return e = new Ye({
    props: {
      heading: "Default Spellcasting Ability",
      options: Object.entries(
        /*abilities*/
        i[4]
      ),
      selected: (
        /*$item*/
        i[0].system.spellcasting.ability.base
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[13]
  ), s = new Ze({
    props: {
      heading: "Optional Spellcasting Abilities",
      options: Object.entries(
        /*abilitiesWithoutNone*/
        i[5]
      ),
      selected: (
        /*$item*/
        i[0].system.spellcasting.ability.options
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[14]
  ), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$item*/
      1 && (o.selected = /*$item*/
      l[0].system.spellcasting.ability.base), e.$set(o);
      const a = {};
      r & /*$item*/
      1 && (a.selected = /*$item*/
      l[0].system.spellcasting.ability.options), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(IN, "create_if_block_1$A");
function PN(i) {
  let e, t;
  return e = new Ye({
    props: {
      heading: "Spellcasting Ability",
      options: Object.entries(
        /*abilities*/
        i[4]
      ),
      selected: (
        /*$item*/
        i[0].system.spellcasting.ability.value
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[15]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.selected = /*$item*/
      s[0].system.spellcasting.ability.value), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(PN, "create_if_block$M");
function tce(i) {
  let e, t, s, n, l = !/*$item*/
  i[0].parent && IN(i), r = (
    /*$item*/
    i[0].parent && PN(i)
  );
  return s = new Ye({
    props: {
      heading: "Caster Type",
      options: Object.entries(
        /*casterTypes*/
        i[6]
      ),
      selected: (
        /*$item*/
        i[0].system.spellcasting.casterType
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[16]
  ), {
    c() {
      l && l.c(), e = R(), r && r.c(), t = R(), L(s.$$.fragment);
    },
    m(o, a) {
      l && l.m(o, a), T(o, e, a), r && r.m(o, a), T(o, t, a), N(s, o, a), n = !0;
    },
    p(o, a) {
      /*$item*/
      o[0].parent ? l && (ce(), C(l, 1, 1, () => {
        l = null;
      }), ue()) : l ? (l.p(o, a), a & /*$item*/
      1 && w(l, 1)) : (l = IN(o), l.c(), w(l, 1), l.m(e.parentNode, e)), /*$item*/
      o[0].parent ? r ? (r.p(o, a), a & /*$item*/
      1 && w(r, 1)) : (r = PN(o), r.c(), w(r, 1), r.m(t.parentNode, t)) : r && (ce(), C(r, 1, 1, () => {
        r = null;
      }), ue());
      const c = {};
      a & /*$item*/
      1 && (c.selected = /*$item*/
      o[0].system.spellcasting.casterType), s.$set(c);
    },
    i(o) {
      n || (w(l), w(r), w(s.$$.fragment, o), n = !0);
    },
    o(o) {
      C(l), C(r), C(s.$$.fragment, o), n = !1;
    },
    d(o) {
      o && (S(e), S(t)), l && l.d(o), r && r.d(o), j(s, o);
    }
  };
}
f(tce, "create_default_slot_2$d");
function sce(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = t = /*$item*/
      i[0].system.wealth;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_3*/
        i[17]
      ), s = !0);
    },
    p(l, r) {
      r & /*$item*/
      1 && t !== (t = /*$item*/
      l[0].system.wealth) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(sce, "create_default_slot_1$e");
function nce(i) {
  let e, t;
  return e = new de({
    props: {
      hint: "Enter a number value or a roll formula",
      $$slots: { default: [sce] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $item*/
      8388609 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(nce, "create_default_slot$F");
function ice(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g;
  t = new Me({
    props: {
      heading: "Metadata",
      $$slots: { default: [Zae] },
      $$scope: { ctx: i }
    }
  }), l = new Me({
    props: {
      heading: "Hit Dice",
      $$slots: { default: [xae] },
      $$scope: { ctx: i }
    }
  });
  let h = (
    /*$item*/
    i[0].actor && CN(i)
  );
  return c = new Me({
    props: {
      heading: "Spell Casting",
      $$slots: { default: [tce] },
      $$scope: { ctx: i }
    }
  }), p = new Me({
    props: {
      heading: "Wealth",
      $$slots: { default: [nce] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("article"), s = E("div"), L(t.$$.fragment), n = R(), r = E("div"), L(l.$$.fragment), o = R(), h && h.c(), a = R(), u = E("div"), L(c.$$.fragment), d = R(), m = E("div"), L(p.$$.fragment), z(s, "display", "contents"), z(s, "--a5e-section-body-gap", "0.75rem"), z(r, "display", "contents"), z(r, "--a5e-section-body-gap", "0.75rem"), z(u, "display", "contents"), z(u, "--a5e-section-body-gap", "0.75rem"), z(m, "display", "contents"), z(m, "--a5e-section-body-gap", "0.75rem"), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable");
    },
    m(_, y) {
      T(_, e, y), A(e, s), N(t, s, null), A(e, n), A(e, r), N(l, r, null), A(e, o), h && h.m(e, null), A(e, a), A(e, u), N(c, u, null), A(e, d), A(e, m), N(p, m, null), g = !0;
    },
    p(_, [y]) {
      const k = {};
      y & /*$$scope, $item*/
      8388609 && (k.$$scope = { dirty: y, ctx: _ }), t.$set(k);
      const v = {};
      y & /*$$scope, classLevel, $item*/
      8388613 && (v.$$scope = { dirty: y, ctx: _ }), l.$set(v), /*$item*/
      _[0].actor ? h ? (h.p(_, y), y & /*$item*/
      1 && w(h, 1)) : (h = CN(_), h.c(), w(h, 1), h.m(e, a)) : h && (ce(), C(h, 1, 1, () => {
        h = null;
      }), ue());
      const O = {};
      y & /*$$scope, $item*/
      8388609 && (O.$$scope = { dirty: y, ctx: _ }), c.$set(O);
      const P = {};
      y & /*$$scope, $item*/
      8388609 && (P.$$scope = { dirty: y, ctx: _ }), p.$set(P);
    },
    i(_) {
      g || (w(t.$$.fragment, _), w(l.$$.fragment, _), w(h), w(c.$$.fragment, _), w(p.$$.fragment, _), g = !0);
    },
    o(_) {
      C(t.$$.fragment, _), C(l.$$.fragment, _), C(h), C(c.$$.fragment, _), C(p.$$.fragment, _), g = !1;
    },
    d(_) {
      _ && S(e), j(t), j(l), h && h.d(), j(c), j(p);
    }
  };
}
f(ice, "create_fragment$1r");
function lce(i, e, t) {
  let s, n, l;
  const r = fe("item");
  pe(i, r, (D) => t(0, l = D));
  const o = { none: "None", ...CONFIG.A5E.abilities }, a = CONFIG.A5E.abilities, c = CONFIG.A5E.casterTypes;
  function u() {
    const D = l.actor;
    if (!D)
      return {
        totalHp: 0,
        hpBonusPerLevel: 0,
        otherHpBonuses: 0
      };
    const I = Xae(l.parent), B = at(D.BonusesManager.getHitPointsBonusPerLevelFormula() ?? 0, D == null ? void 0 : D.getRollData()) ?? 0, H = (at(D.BonusesManager.getHitPointsBonusFormula() ?? 0, D.getRollData()) ?? 0) - B * D.levels.character, G = D.system.attributes.hp.bonus;
    return {
      totalHp: I,
      hpBonusPerLevel: B,
      otherHpBonuses: H + G
    };
  }
  f(u, "getHpData");
  const d = [[6, "d6"], [8, "d8"], [10, "d10"], [12, "d12"]], p = /* @__PURE__ */ f(({ target: D }) => {
    se(l, "system.slug", D.value.slugify());
  }, "change_handler"), m = /* @__PURE__ */ f(() => se(l, "system.slug", ""), "click_handler"), g = /* @__PURE__ */ f(({ detail: D }) => se(l, "system.hp.hitDiceSize", D), "updateSelection_handler"), h = /* @__PURE__ */ f(({ target: D }) => se(l, "system.hp.hitDiceUsed", Number(D.value)), "change_handler_1"), _ = /* @__PURE__ */ f((D, { target: I }) => se(l, `system.hp.levels.${D}`, Number(I.value)), "change_handler_2"), y = /* @__PURE__ */ f(({ detail: D }) => {
    se(l, "system.spellcasting.ability.options", []), se(l, "system.spellcasting.ability.base", D);
  }, "updateSelection_handler_1"), k = /* @__PURE__ */ f(({ detail: D }) => {
    se(l, "system.spellcasting.ability.base", "none"), se(l, "system.spellcasting.ability.options", D);
  }, "updateSelection_handler_2"), v = /* @__PURE__ */ f(({ detail: D }) => se(l, "system.spellcasting.ability.value", D), "updateSelection_handler_3"), O = /* @__PURE__ */ f(({ detail: D }) => se(l, "system.spellcasting.casterType", D), "updateSelection_handler_4"), P = /* @__PURE__ */ f(({ target: D }) => se(l, "system.wealth", D.value), "change_handler_3");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1 && t(2, s = l.system.classLevels), i.$$.dirty & /*$item*/
    1 && t(1, n = u(l.actor));
  }, [
    l,
    n,
    s,
    r,
    o,
    a,
    c,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    k,
    v,
    O,
    P
  ];
}
f(lce, "instance$1l");
const XT = class XT extends ie {
  constructor(e) {
    super(), le(this, e, lce, ice, ne, {});
  }
};
f(XT, "ClassPropertiesTab");
let Sk = XT;
function rce(i) {
  let e, t, s, n, l, r, o;
  t = new vl({}), n = new bn({
    props: {
      currentTab: (
        /*currentTab*/
        i[1]
      ),
      tabs: (
        /*tabs*/
        i[3]
      )
    }
  }), n.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[2]
  );
  var a = (
    /*currentTab*/
    i[1].component
  );
  function c(u, d) {
    return {};
  }
  return f(c, "switch_props"), a && (r = nt(a, c())), {
    c() {
      e = E("main"), L(t.$$.fragment), s = R(), L(n.$$.fragment), l = R(), r && L(r.$$.fragment), b(e, "class", "svelte-d53nbt");
    },
    m(u, d) {
      T(u, e, d), N(t, e, null), A(e, s), N(n, e, null), A(e, l), r && N(r, e, null), o = !0;
    },
    p(u, d) {
      const p = {};
      if (d & /*currentTab*/
      2 && (p.currentTab = /*currentTab*/
      u[1]), n.$set(p), d & /*currentTab*/
      2 && a !== (a = /*currentTab*/
      u[1].component)) {
        if (r) {
          ce();
          const m = r;
          C(m.$$.fragment, 1, 0, () => {
            j(m, 1);
          }), ue();
        }
        a ? (r = nt(a, c()), L(r.$$.fragment), w(r.$$.fragment, 1), N(r, e, null)) : r = null;
      }
    },
    i(u) {
      o || (w(t.$$.fragment, u), w(n.$$.fragment, u), r && w(r.$$.fragment, u), o = !0);
    },
    o(u) {
      C(t.$$.fragment, u), C(n.$$.fragment, u), r && C(r.$$.fragment, u), o = !1;
    },
    d(u) {
      u && S(e), j(t), j(n), r && j(r);
    }
  };
}
f(rce, "create_default_slot$E");
function oce(i) {
  let e, t, s;
  function n(r) {
    i[5](r);
  }
  f(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [rce] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Ss({ props: l }), st.push(() => mt(e, "elementRoot", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, currentTab*/
        130 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(oce, "create_fragment$1q");
function ace(i, e, t) {
  let { document: s } = fe("#external").application, { document: n = s } = e, { elementRoot: l } = e;
  const r = n;
  function o(d) {
    t(1, c = a[d.detail]);
  }
  f(o, "updateCurrentTab");
  const a = [
    {
      name: "description",
      label: "A5E.Description",
      component: yl
    },
    {
      name: "properties",
      label: "A5E.ItemSheetLabelPropertiesTab",
      component: Sk
    },
    {
      name: "grants",
      label: "A5E.TabGrants",
      component: Mr
    }
  ];
  let c = a[0];
  et("item", r);
  function u(d) {
    l = d, t(0, l);
  }
  return f(u, "applicationshell_elementRoot_binding"), i.$$set = (d) => {
    "document" in d && t(4, n = d.document), "elementRoot" in d && t(0, l = d.elementRoot);
  }, [
    l,
    c,
    o,
    a,
    n,
    u
  ];
}
f(ace, "instance$1k");
const JT = class JT extends ie {
  constructor(e) {
    super(), le(this, e, ace, oce, ne, { document: 4, elementRoot: 0 });
  }
  get document() {
    return this.$$.ctx[4];
  }
  set document(e) {
    this.$$set({ document: e }), Ke();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Ke();
  }
};
f(JT, "ClassSheet");
let Tk = JT;
function cce(i) {
  let e, t, s, n, l, r, o;
  t = new vl({}), n = new bn({
    props: {
      currentTab: (
        /*currentTab*/
        i[1]
      ),
      tabs: (
        /*tabs*/
        i[3]
      )
    }
  }), n.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[2]
  );
  var a = (
    /*currentTab*/
    i[1].component
  );
  function c(u, d) {
    return {};
  }
  return f(c, "switch_props"), a && (r = nt(a, c())), {
    c() {
      e = E("main"), L(t.$$.fragment), s = R(), L(n.$$.fragment), l = R(), r && L(r.$$.fragment), b(e, "class", "svelte-d53nbt");
    },
    m(u, d) {
      T(u, e, d), N(t, e, null), A(e, s), N(n, e, null), A(e, l), r && N(r, e, null), o = !0;
    },
    p(u, d) {
      const p = {};
      if (d & /*currentTab*/
      2 && (p.currentTab = /*currentTab*/
      u[1]), n.$set(p), d & /*currentTab*/
      2 && a !== (a = /*currentTab*/
      u[1].component)) {
        if (r) {
          ce();
          const m = r;
          C(m.$$.fragment, 1, 0, () => {
            j(m, 1);
          }), ue();
        }
        a ? (r = nt(a, c()), L(r.$$.fragment), w(r.$$.fragment, 1), N(r, e, null)) : r = null;
      }
    },
    i(u) {
      o || (w(t.$$.fragment, u), w(n.$$.fragment, u), r && w(r.$$.fragment, u), o = !0);
    },
    o(u) {
      C(t.$$.fragment, u), C(n.$$.fragment, u), r && C(r.$$.fragment, u), o = !1;
    },
    d(u) {
      u && S(e), j(t), j(n), r && j(r);
    }
  };
}
f(cce, "create_default_slot$D");
function uce(i) {
  let e, t, s;
  function n(r) {
    i[5](r);
  }
  f(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [cce] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Ss({ props: l }), st.push(() => mt(e, "elementRoot", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, currentTab*/
        130 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(uce, "create_fragment$1p");
function fce(i, e, t) {
  let { document: s } = fe("#external").application, { document: n = s } = e, { elementRoot: l } = e;
  const r = n;
  function o(d) {
    t(1, c = a[d.detail]);
  }
  f(o, "updateCurrentTab");
  const a = [
    {
      name: "description",
      label: "A5E.Description",
      component: yl
    },
    {
      name: "grants",
      label: "A5E.TabGrants",
      component: Mr
    }
  ];
  let c = a[0];
  et("item", r);
  function u(d) {
    l = d, t(0, l);
  }
  return f(u, "applicationshell_elementRoot_binding"), i.$$set = (d) => {
    "document" in d && t(4, n = d.document), "elementRoot" in d && t(0, l = d.elementRoot);
  }, [
    l,
    c,
    o,
    a,
    n,
    u
  ];
}
f(fce, "instance$1j");
const ZT = class ZT extends ie {
  constructor(e) {
    super(), le(this, e, fce, uce, ne, { document: 4, elementRoot: 0 });
  }
  get document() {
    return this.$$.ctx[4];
  }
  set document(e) {
    this.$$set({ document: e }), Ke();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Ke();
  }
};
f(ZT, "CultureSheet");
let Ck = ZT;
function dce(i) {
  let e, t, s, n, l, r;
  return {
    c() {
      var o, a, c;
      e = E("div"), t = E("input"), b(t, "class", "number-input svelte-1r4h9xt"), b(t, "id", s = /*uuid*/
      i[1] + "-quantityOverride"), b(t, "type", "number"), t.value = n = /*$originItem*/
      ((c = (a = (o = i[3].system) == null ? void 0 : o[
        /*attribute*/
        i[2]
      ]) == null ? void 0 : a[
        /*docId*/
        i[8]
      ]) == null ? void 0 : c.quantityOverride) || /*originalQuantity*/
      i[10], b(t, "min", "1"), b(e, "class", "quantity-wrapper svelte-1r4h9xt");
    },
    m(o, a) {
      T(o, e, a), A(e, t), l || (r = V(
        t,
        "change",
        /*change_handler*/
        i[12]
      ), l = !0);
    },
    p(o, a) {
      var c, u, d;
      a & /*uuid*/
      2 && s !== (s = /*uuid*/
      o[1] + "-quantityOverride") && b(t, "id", s), a & /*$originItem, attribute*/
      12 && n !== (n = /*$originItem*/
      ((d = (u = (c = o[3].system) == null ? void 0 : c[
        /*attribute*/
        o[2]
      ]) == null ? void 0 : u[
        /*docId*/
        o[8]
      ]) == null ? void 0 : d.quantityOverride) || /*originalQuantity*/
      o[10]) && t.value !== n && (t.value = n);
    },
    d(o) {
      o && S(e), l = !1, r();
    }
  };
}
f(dce, "create_if_block$L");
function pce(i) {
  var _;
  let e, t, s, n, l, r, o, a = (
    /*doc*/
    ((_ = i[0]) == null ? void 0 : _.name) + ""
  ), c, u, d, p, m, g, h = (
    /*docData*/
    i[9] && /*showQuantity*/
    i[6] && !/*actorParent*/
    i[7] && dce(i)
  );
  return {
    c() {
      e = E("li"), t = E("img"), r = R(), o = E("h3"), c = x(a), u = R(), h && h.c(), d = R(), p = E("button"), b(t, "class", "document-image svelte-1r4h9xt"), ze(t.src, s = /*doc*/
      i[0].img) || b(t, "src", s), b(t, "alt", n = /*doc*/
      i[0].name), b(t, "title", l = /*doc*/
      i[0].name), b(o, "class", "svelte-1r4h9xt"), b(p, "class", "a5e-button a5e-button--delete delete-button fas fa-trash svelte-1r4h9xt"), b(p, "data-tooltip", "A5E.ButtonToolTipDelete"), b(p, "data-tooltip-direction", "UP"), b(e, "class", "document-wrapper svelte-1r4h9xt");
    },
    m(y, k) {
      T(y, e, k), A(e, t), A(e, r), A(e, o), A(o, c), A(e, u), h && h.m(e, null), A(e, d), A(e, p), m || (g = V(
        p,
        "click",
        /*click_handler*/
        i[13]
      ), m = !0);
    },
    p(y, [k]) {
      var v;
      k & /*doc*/
      1 && !ze(t.src, s = /*doc*/
      y[0].img) && b(t, "src", s), k & /*doc*/
      1 && n !== (n = /*doc*/
      y[0].name) && b(t, "alt", n), k & /*doc*/
      1 && l !== (l = /*doc*/
      y[0].name) && b(t, "title", l), k & /*doc*/
      1 && a !== (a = /*doc*/
      ((v = y[0]) == null ? void 0 : v.name) + "") && _e(c, a), /*docData*/
      y[9] && /*showQuantity*/
      y[6] && !/*actorParent*/
      y[7] && h.p(y, k);
    },
    i: ee,
    o: ee,
    d(y) {
      y && S(e), h && h.d(), m = !1, g();
    }
  };
}
f(pce, "create_fragment$1o");
function mce(i, e, t) {
  var y, k, v, O, P, D;
  let s, { doc: n } = e, { uuid: l } = e, { attribute: r = null } = e, { topLevelAttribute: o = null } = e;
  const a = fe("item");
  pe(i, a, (I) => t(3, s = I));
  const c = it(), u = ["equipment", "items"].includes(r), d = ((y = s == null ? void 0 : s.parent) == null ? void 0 : y.documentName) === "Actor";
  let p = s ? o ? (k = s[o]) == null ? void 0 : k.getIdByUuid(l) : (v = s[r]) == null ? void 0 : v.getIdByUuid(l) : null, m = s ? o ? (O = s[o]) == null ? void 0 : O.get(p) : (P = s[r]) == null ? void 0 : P.getUuid(l) : null, g = (n == null ? void 0 : n.type) === "object" ? (D = n == null ? void 0 : n.system) == null ? void 0 : D.quantity : 1;
  const h = /* @__PURE__ */ f(({ target: I }) => se(s, `system.${r}.${p}.quantityOverride`, parseInt(I.value)), "change_handler"), _ = /* @__PURE__ */ f((I) => c("item-deleted", [I, l]), "click_handler");
  return i.$$set = (I) => {
    "doc" in I && t(0, n = I.doc), "uuid" in I && t(1, l = I.uuid), "attribute" in I && t(2, r = I.attribute), "topLevelAttribute" in I && t(11, o = I.topLevelAttribute);
  }, [
    n,
    l,
    r,
    s,
    a,
    c,
    u,
    d,
    p,
    m,
    g,
    o,
    h,
    _
  ];
}
f(mce, "instance$1i");
const QT = class QT extends ie {
  constructor(e) {
    super(), le(this, e, mce, pce, ne, {
      doc: 0,
      uuid: 1,
      attribute: 2,
      topLevelAttribute: 11
    });
  }
};
f(QT, "OriginItemWrapper");
let hp = QT;
function hce(i) {
  let e, t;
  return {
    c() {
      e = E("div"), t = E("div"), b(t, "class", "shadow svelte-bvfe75"), Q(
        t,
        "pause-animation",
        /*pause*/
        i[4]
      ), b(e, "class", "wrapper svelte-bvfe75"), z(
        e,
        "--size",
        /*size*/
        i[3] + /*unit*/
        i[1]
      ), z(
        e,
        "--color",
        /*color*/
        i[0]
      ), z(
        e,
        "--duration",
        /*duration*/
        i[2]
      );
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, [n]) {
      n & /*pause*/
      16 && Q(
        t,
        "pause-animation",
        /*pause*/
        s[4]
      ), n & /*size, unit*/
      10 && z(
        e,
        "--size",
        /*size*/
        s[3] + /*unit*/
        s[1]
      ), n & /*color*/
      1 && z(
        e,
        "--color",
        /*color*/
        s[0]
      ), n & /*duration*/
      4 && z(
        e,
        "--duration",
        /*duration*/
        s[2]
      );
    },
    i: ee,
    o: ee,
    d(s) {
      s && S(e);
    }
  };
}
f(hce, "create_fragment$1n");
function gce(i, e, t) {
  let { color: s = "$color-primary" } = e, { unit: n = "px" } = e, { duration: l = "3s" } = e, { size: r = "30" } = e, { pause: o = !1 } = e;
  return i.$$set = (a) => {
    "color" in a && t(0, s = a.color), "unit" in a && t(1, n = a.unit), "duration" in a && t(2, l = a.duration), "size" in a && t(3, r = a.size), "pause" in a && t(4, o = a.pause);
  }, [s, n, l, r, o];
}
f(gce, "instance$1h");
const xT = class xT extends ie {
  constructor(e) {
    super(), le(this, e, gce, hce, ne, {
      color: 0,
      unit: 1,
      duration: 2,
      size: 3,
      pause: 4
    });
  }
};
f(xT, "Spinner");
let Ok = xT;
function MN(i, e, t) {
  const s = i.slice();
  return s[12] = e[t][0], s[13] = e[t][1], s;
}
f(MN, "get_each_context$t");
function bce(i) {
  return {
    c: ee,
    m: ee,
    p: ee,
    i: ee,
    o: ee,
    d: ee
  };
}
f(bce, "create_catch_block");
function _ce(i) {
  let e, t, s, n, l;
  const r = [vce, yce], o = [];
  function a(u, d) {
    return (
      /*singleDocument*/
      u[0] && /*firstDocument*/
      u[4] ? 0 : 1
    );
  }
  f(a, "select_block_type"), t = a(i), s = o[t] = r[t](i);
  let c = !/*singleDocument*/
  i[0] && RN(i);
  return {
    c() {
      e = E("section"), s.c(), n = R(), c && c.c(), b(e, "class", "drop-container svelte-1gbd50w");
    },
    m(u, d) {
      T(u, e, d), o[t].m(e, null), A(e, n), c && c.m(e, null), l = !0;
    },
    p(u, d) {
      let p = t;
      t = a(u), t === p ? o[t].p(u, d) : (ce(), C(o[p], 1, 1, () => {
        o[p] = null;
      }), ue(), s = o[t], s ? s.p(u, d) : (s = o[t] = r[t](u), s.c()), w(s, 1), s.m(e, n)), /*singleDocument*/
      u[0] ? c && (ce(), C(c, 1, 1, () => {
        c = null;
      }), ue()) : c ? (c.p(u, d), d & /*singleDocument*/
      1 && w(c, 1)) : (c = RN(u), c.c(), w(c, 1), c.m(e, null));
    },
    i(u) {
      l || (w(s), w(c), l = !0);
    },
    o(u) {
      C(s), C(c), l = !1;
    },
    d(u) {
      u && S(e), o[t].d(), c && c.d();
    }
  };
}
f(_ce, "create_then_block");
function yce(i) {
  let e, t, s;
  function n(...l) {
    return (
      /*drop_handler_1*/
      i[9](
        /*docs*/
        i[3],
        ...l
      )
    );
  }
  return f(n, "drop_handler_1"), {
    c() {
      e = E("div"), e.innerHTML = '<i class="drop-icon fa-sold fa-plus svelte-1gbd50w"></i>', b(e, "class", "drop-area svelte-1gbd50w");
    },
    m(l, r) {
      T(l, e, r), t || (s = V(e, "drop", We(tt(n))), t = !0);
    },
    p(l, r) {
      i = l;
    },
    i: ee,
    o: ee,
    d(l) {
      l && S(e), t = !1, s();
    }
  };
}
f(yce, "create_else_block$i");
function vce(i) {
  let e, t, s, n, l;
  t = new hp({
    props: {
      uuid: (
        /*firstDocument*/
        i[4].uuid
      ),
      doc: (
        /*firstDocument*/
        i[4]
      )
    }
  }), t.$on(
    "item-deleted",
    /*item_deleted_handler*/
    i[7]
  );
  function r(...o) {
    return (
      /*drop_handler*/
      i[8](
        /*docs*/
        i[3],
        ...o
      )
    );
  }
  return f(r, "drop_handler"), {
    c() {
      e = E("div"), L(t.$$.fragment), b(e, "class", "drop-area svelte-1gbd50w");
    },
    m(o, a) {
      T(o, e, a), N(t, e, null), s = !0, n || (l = V(e, "drop", We(tt(r))), n = !0);
    },
    p(o, a) {
      i = o;
      const c = {};
      a & /*firstDocument*/
      16 && (c.uuid = /*firstDocument*/
      i[4].uuid), a & /*firstDocument*/
      16 && (c.doc = /*firstDocument*/
      i[4]), t.$set(c);
    },
    i(o) {
      s || (w(t.$$.fragment, o), s = !0);
    },
    o(o) {
      C(t.$$.fragment, o), s = !1;
    },
    d(o) {
      o && S(e), j(t), n = !1, l();
    }
  };
}
f(vce, "create_if_block_1$z");
function RN(i) {
  let e, t, s = oe(
    /*docs*/
    i[3]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = FN(MN(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("div");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "document-list svelte-1gbd50w");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, o) {
      if (o & /*docs, attribute, topLevelAttribute, dispatch*/
      46) {
        s = oe(
          /*docs*/
          r[3]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = MN(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = FN(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f(RN, "create_if_block$K");
function FN(i) {
  let e, t;
  function s(...n) {
    return (
      /*item_deleted_handler_1*/
      i[10](
        /*uuid*/
        i[12],
        ...n
      )
    );
  }
  return f(s, "item_deleted_handler_1"), e = new hp({
    props: {
      uuid: (
        /*uuid*/
        i[12]
      ),
      doc: (
        /*doc*/
        i[13]
      ),
      attribute: (
        /*attribute*/
        i[1]
      ),
      topLevelAttribute: (
        /*topLevelAttribute*/
        i[2]
      )
    }
  }), e.$on("item-deleted", s), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      i = n;
      const r = {};
      l & /*docs*/
      8 && (r.uuid = /*uuid*/
      i[12]), l & /*docs*/
      8 && (r.doc = /*doc*/
      i[13]), l & /*attribute*/
      2 && (r.attribute = /*attribute*/
      i[1]), l & /*topLevelAttribute*/
      4 && (r.topLevelAttribute = /*topLevelAttribute*/
      i[2]), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(FN, "create_each_block$t");
function kce(i) {
  let e, t;
  return e = new Ok({}), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p: ee,
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(kce, "create_pending_block");
function wce(i) {
  let e, t, s, n = {
    ctx: i,
    current: null,
    token: null,
    hasCatch: !1,
    pending: kce,
    then: _ce,
    catch: bce,
    value: 3,
    blocks: [, , ,]
  };
  return OO(t = /*docs*/
  i[3], n), {
    c() {
      e = $e(), n.block.c();
    },
    m(l, r) {
      T(l, e, r), n.block.m(l, n.anchor = r), n.mount = () => e.parentNode, n.anchor = e, s = !0;
    },
    p(l, [r]) {
      i = l, n.ctx = i, r & /*docs*/
      8 && t !== (t = /*docs*/
      i[3]) && OO(t, n) || Sz(n, i, r);
    },
    i(l) {
      s || (w(n.block), s = !0);
    },
    o(l) {
      for (let r = 0; r < 3; r += 1) {
        const o = n.blocks[r];
        C(o);
      }
      s = !1;
    },
    d(l) {
      l && S(e), n.block.d(l), n.token = null, n = null;
    }
  };
}
f(wce, "create_fragment$1m");
function $ce(i, e, t) {
  let s, n, { uuids: l = [] } = e, { singleDocument: r = !1 } = e, { attribute: o = null } = e, { topLevelAttribute: a = null } = e;
  const c = it();
  async function u() {
    const h = /* @__PURE__ */ new Map();
    for await (const _ of l) {
      const y = await fromUuid(_);
      y && h.set(_, y);
    }
    return h;
  }
  f(u, "getDocs");
  const d = /* @__PURE__ */ f((h) => c("item-deleted", [h, n.uuid]), "item_deleted_handler"), p = /* @__PURE__ */ f((h, _) => {
    r && c("item-dropped", [_, h]);
  }, "drop_handler"), m = /* @__PURE__ */ f((h, _) => c("item-dropped", [_, h]), "drop_handler_1"), g = /* @__PURE__ */ f((h, _) => c("item-deleted", [_, h]), "item_deleted_handler_1");
  return i.$$set = (h) => {
    "uuids" in h && t(6, l = h.uuids), "singleDocument" in h && t(0, r = h.singleDocument), "attribute" in h && t(1, o = h.attribute), "topLevelAttribute" in h && t(2, a = h.topLevelAttribute);
  }, i.$$.update = () => {
    var h, _;
    i.$$.dirty & /*uuids*/
    64 && t(3, s = u().then((y) => t(3, s = y)).catch((y) => t(3, s = y))), i.$$.dirty & /*docs*/
    8 && t(4, n = ((_ = (h = Array.from(s)) == null ? void 0 : h[0]) == null ? void 0 : _[1]) ?? null);
  }, [
    r,
    o,
    a,
    s,
    n,
    c,
    l,
    d,
    p,
    m,
    g
  ];
}
f($ce, "instance$1g");
const eC = class eC extends ie {
  constructor(e) {
    super(), le(this, e, $ce, wce, ne, {
      uuids: 6,
      singleDocument: 0,
      attribute: 1,
      topLevelAttribute: 2
    });
  }
};
f(eC, "OriginDropArea");
let lo = eC;
function Ace(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _;
  return l = new lo({
    props: {
      uuids: [
        /*source*/
        i[2]
      ],
      singleDocument: !0
    }
  }), l.$on(
    "item-dropped",
    /*item_dropped_handler*/
    i[7]
  ), l.$on(
    "item-deleted",
    /*item_deleted_handler*/
    i[8]
  ), u = new lo({
    props: {
      uuids: [
        /*inspiration*/
        i[1]
      ],
      singleDocument: !0
    }
  }), u.$on(
    "item-dropped",
    /*item_dropped_handler_1*/
    i[9]
  ), u.$on(
    "item-deleted",
    /*item_deleted_handler_1*/
    i[10]
  ), h = new lo({
    props: {
      uuids: [
        /*fulfillment*/
        i[0]
      ],
      singleDocument: !0
    }
  }), h.$on(
    "item-dropped",
    /*item_dropped_handler_2*/
    i[11]
  ), h.$on(
    "item-deleted",
    /*item_deleted_handler_2*/
    i[12]
  ), {
    c() {
      e = E("article"), t = E("section"), s = E("h3"), s.textContent = `${K("A5E.DestinyFeatureSource")}`, n = R(), L(l.$$.fragment), r = R(), o = E("section"), a = E("h3"), a.textContent = `${K("A5E.DestinyFeatureInspiration")}`, c = R(), L(u.$$.fragment), d = R(), p = E("section"), m = E("h3"), m.textContent = `${K("A5E.DestinyFeatureFulfillment")}`, g = R(), L(h.$$.fragment), b(s, "class", "section-title svelte-1dsxa33"), b(t, "class", "section-wrapper drop-area svelte-1dsxa33"), b(a, "class", "section-title svelte-1dsxa33"), b(o, "class", "section-wrapper drop-area svelte-1dsxa33"), b(m, "class", "section-title svelte-1dsxa33"), b(p, "class", "section-wrapper drop-area svelte-1dsxa33"), b(e, "class", "svelte-1dsxa33");
    },
    m(y, k) {
      T(y, e, k), A(e, t), A(t, s), A(t, n), N(l, t, null), A(e, r), A(e, o), A(o, a), A(o, c), N(u, o, null), A(e, d), A(e, p), A(p, m), A(p, g), N(h, p, null), _ = !0;
    },
    p(y, [k]) {
      const v = {};
      k & /*source*/
      4 && (v.uuids = [
        /*source*/
        y[2]
      ]), l.$set(v);
      const O = {};
      k & /*inspiration*/
      2 && (O.uuids = [
        /*inspiration*/
        y[1]
      ]), u.$set(O);
      const P = {};
      k & /*fulfillment*/
      1 && (P.uuids = [
        /*fulfillment*/
        y[0]
      ]), h.$set(P);
    },
    i(y) {
      _ || (w(l.$$.fragment, y), w(u.$$.fragment, y), w(h.$$.fragment, y), _ = !0);
    },
    o(y) {
      C(l.$$.fragment, y), C(u.$$.fragment, y), C(h.$$.fragment, y), _ = !1;
    },
    d(y) {
      y && S(e), j(l), j(u), j(h);
    }
  };
}
f(Ace, "create_fragment$1l");
function Ece(i, e, t) {
  let s, n, l, r;
  const o = fe("item");
  pe(i, o, (_) => t(6, r = _));
  async function a(_, y) {
    var v;
    const [k] = _.detail;
    try {
      const { uuid: O } = JSON.parse(k.dataTransfer.getData("text/plain")), P = await fromUuid(O);
      if ((P == null ? void 0 : P.type) !== "feature" || ((v = P == null ? void 0 : P.system) == null ? void 0 : v.featureType) !== "destiny")
        return ui.notifications.warn(K("A5E.validations.warnings.InvalidForeignDocument"));
      r.update({ [`system.${y}`]: O });
    } catch (O) {
      console.error(O);
    }
  }
  f(a, "addFeature");
  function c(_, y) {
    r.update({ [`system.${y}`]: "" });
  }
  f(c, "deleteFeature");
  const u = /* @__PURE__ */ f((_) => a(_, "sourceOfInspiration"), "item_dropped_handler"), d = /* @__PURE__ */ f((_) => c(_, "sourceOfInspiration"), "item_deleted_handler"), p = /* @__PURE__ */ f((_) => a(_, "inspirationFeature"), "item_dropped_handler_1"), m = /* @__PURE__ */ f((_) => c(_, "inspirationFeature"), "item_deleted_handler_1"), g = /* @__PURE__ */ f((_) => a(_, "fulfillmentFeature"), "item_dropped_handler_2"), h = /* @__PURE__ */ f((_) => c(_, "fulfillmentFeature"), "item_deleted_handler_2");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    64 && t(2, s = r.system.sourceOfInspiration || null), i.$$.dirty & /*$item*/
    64 && t(1, n = r.system.inspirationFeature || null), i.$$.dirty & /*$item*/
    64 && t(0, l = r.system.fulfillmentFeature || null);
  }, [
    l,
    n,
    s,
    o,
    a,
    c,
    r,
    u,
    d,
    p,
    m,
    g,
    h
  ];
}
f(Ece, "instance$1f");
const tC = class tC extends ie {
  constructor(e) {
    super(), le(this, e, Ece, Ace, ne, {});
  }
};
f(tC, "DestinyFeaturesTab");
let Dk = tC;
function Sce(i) {
  let e, t, s, n, l, r, o;
  t = new vl({}), n = new bn({
    props: {
      currentTab: (
        /*currentTab*/
        i[1]
      ),
      tabs: (
        /*tabs*/
        i[3]
      )
    }
  }), n.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[2]
  );
  var a = (
    /*currentTab*/
    i[1].component
  );
  function c(u, d) {
    return {};
  }
  return f(c, "switch_props"), a && (r = nt(a, c())), {
    c() {
      e = E("main"), L(t.$$.fragment), s = R(), L(n.$$.fragment), l = R(), r && L(r.$$.fragment), b(e, "class", "svelte-d53nbt");
    },
    m(u, d) {
      T(u, e, d), N(t, e, null), A(e, s), N(n, e, null), A(e, l), r && N(r, e, null), o = !0;
    },
    p(u, d) {
      const p = {};
      if (d & /*currentTab*/
      2 && (p.currentTab = /*currentTab*/
      u[1]), n.$set(p), d & /*currentTab*/
      2 && a !== (a = /*currentTab*/
      u[1].component)) {
        if (r) {
          ce();
          const m = r;
          C(m.$$.fragment, 1, 0, () => {
            j(m, 1);
          }), ue();
        }
        a ? (r = nt(a, c()), L(r.$$.fragment), w(r.$$.fragment, 1), N(r, e, null)) : r = null;
      }
    },
    i(u) {
      o || (w(t.$$.fragment, u), w(n.$$.fragment, u), r && w(r.$$.fragment, u), o = !0);
    },
    o(u) {
      C(t.$$.fragment, u), C(n.$$.fragment, u), r && C(r.$$.fragment, u), o = !1;
    },
    d(u) {
      u && S(e), j(t), j(n), r && j(r);
    }
  };
}
f(Sce, "create_default_slot$C");
function Tce(i) {
  let e, t, s;
  function n(r) {
    i[5](r);
  }
  f(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [Sce] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Ss({ props: l }), st.push(() => mt(e, "elementRoot", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, currentTab*/
        130 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(Tce, "create_fragment$1k");
function Cce(i, e, t) {
  let { document: s } = fe("#external").application, { document: n = s } = e, { elementRoot: l } = e;
  const r = n;
  function o(d) {
    t(1, c = a[d.detail]);
  }
  f(o, "updateCurrentTab");
  const a = [
    {
      name: "description",
      label: "A5E.Description",
      component: yl
    },
    {
      name: "features",
      label: "A5E.TabFeatures",
      component: Dk
    }
  ];
  let c = a[0];
  et("item", r);
  function u(d) {
    l = d, t(0, l);
  }
  return f(u, "applicationshell_elementRoot_binding"), i.$$set = (d) => {
    "document" in d && t(4, n = d.document), "elementRoot" in d && t(0, l = d.elementRoot);
  }, [
    l,
    c,
    o,
    a,
    n,
    u
  ];
}
f(Cce, "instance$1e");
const sC = class sC extends ie {
  constructor(e) {
    super(), le(this, e, Cce, Tce, ne, { document: 4, elementRoot: 0 });
  }
  get document() {
    return this.$$.ctx[4];
  }
  set document(e) {
    this.$$set({ document: e }), Ke();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Ke();
  }
};
f(sC, "DestinySheet");
let Ik = sC;
function Oce(i) {
  let e, t, s, n, l, r, o;
  t = new vl({}), n = new bn({
    props: {
      currentTab: (
        /*currentTab*/
        i[1]
      ),
      tabs: (
        /*tabs*/
        i[3]
      )
    }
  }), n.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[2]
  );
  var a = (
    /*currentTab*/
    i[1].component
  );
  function c(u, d) {
    return {};
  }
  return f(c, "switch_props"), a && (r = nt(a, c())), {
    c() {
      e = E("main"), L(t.$$.fragment), s = R(), L(n.$$.fragment), l = R(), r && L(r.$$.fragment), b(e, "class", "svelte-1bx1z8o");
    },
    m(u, d) {
      T(u, e, d), N(t, e, null), A(e, s), N(n, e, null), A(e, l), r && N(r, e, null), o = !0;
    },
    p(u, d) {
      const p = {};
      if (d & /*currentTab*/
      2 && (p.currentTab = /*currentTab*/
      u[1]), n.$set(p), d & /*currentTab*/
      2 && a !== (a = /*currentTab*/
      u[1].component)) {
        if (r) {
          ce();
          const m = r;
          C(m.$$.fragment, 1, 0, () => {
            j(m, 1);
          }), ue();
        }
        a ? (r = nt(a, c()), L(r.$$.fragment), w(r.$$.fragment, 1), N(r, e, null)) : r = null;
      }
    },
    i(u) {
      o || (w(t.$$.fragment, u), w(n.$$.fragment, u), r && w(r.$$.fragment, u), o = !0);
    },
    o(u) {
      C(t.$$.fragment, u), C(n.$$.fragment, u), r && C(r.$$.fragment, u), o = !1;
    },
    d(u) {
      u && S(e), j(t), j(n), r && j(r);
    }
  };
}
f(Oce, "create_default_slot$B");
function Dce(i) {
  let e, t, s;
  function n(r) {
    i[5](r);
  }
  f(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [Oce] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Ss({ props: l }), st.push(() => mt(e, "elementRoot", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, currentTab*/
        130 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(Dce, "create_fragment$1j");
function Ice(i, e, t) {
  let { document: s } = fe("#external").application, { document: n = s } = e, { elementRoot: l } = e;
  const r = n;
  function o(d) {
    t(1, c = a[d.detail]);
  }
  f(o, "updateCurrentTab");
  const a = [
    {
      name: "description",
      label: "A5E.Description",
      component: yl
    },
    {
      name: "grants",
      label: "A5E.TabGrants",
      component: Mr
    }
  ];
  let c = a[0];
  et("item", r);
  function u(d) {
    l = d, t(0, l);
  }
  return f(u, "applicationshell_elementRoot_binding"), i.$$set = (d) => {
    "document" in d && t(4, n = d.document), "elementRoot" in d && t(0, l = d.elementRoot);
  }, [
    l,
    c,
    o,
    a,
    n,
    u
  ];
}
f(Ice, "instance$1d");
const nC = class nC extends ie {
  constructor(e) {
    super(), le(this, e, Ice, Dce, ne, { document: 4, elementRoot: 0 });
  }
  get document() {
    return this.$$.ctx[4];
  }
  set document(e) {
    this.$$set({ document: e }), Ke();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Ke();
  }
};
f(nC, "HeritageSheet");
let Pk = nC;
function NN(i, e, t) {
  const s = i.slice();
  return s[12] = e[t][0], s[13] = e[t][1], s;
}
f(NN, "get_each_context$s");
function jN(i, e) {
  var B;
  let t, s, n, l, r = (
    /*action*/
    ((B = e[13]) == null ? void 0 : B.name) + ""
  ), o, a, c, u, d, p, m, g, h, _, y, k;
  function v() {
    return (
      /*click_handler*/
      e[7](
        /*id*/
        e[12]
      )
    );
  }
  f(v, "click_handler");
  function O() {
    return (
      /*click_handler_1*/
      e[8](
        /*id*/
        e[12]
      )
    );
  }
  f(O, "click_handler_1");
  function P() {
    return (
      /*click_handler_2*/
      e[9](
        /*id*/
        e[12]
      )
    );
  }
  f(P, "click_handler_2");
  function D(...F) {
    return (
      /*dragstart_handler*/
      e[10](
        /*id*/
        e[12],
        ...F
      )
    );
  }
  f(D, "dragstart_handler");
  function I() {
    return (
      /*auxclick_handler*/
      e[11](
        /*id*/
        e[12]
      )
    );
  }
  return f(I, "auxclick_handler"), {
    key: i,
    first: null,
    c() {
      var F;
      t = E("li"), s = E("img"), l = R(), o = x(r), a = R(), c = E("div"), u = E("button"), d = R(), p = E("button"), m = R(), g = E("button"), h = R(), b(s, "class", "a5e-item__image a5e-item__image--action"), ze(s.src, n = /*action*/
      ((F = e[13]) == null ? void 0 : F.img) ?? /*$item*/
      e[0].img ?? "icons/svg/item-bag.svg") || b(s, "src", n), b(s, "alt", ""), b(u, "class", "action-button fas fa-cog svelte-ekhss5"), b(u, "data-tooltip", "A5E.ButtonToolTipConfigure"), b(u, "data-tooltip-direction", "UP"), b(p, "class", "action-button fa-solid fa-clone svelte-ekhss5"), b(p, "data-tooltip", "A5E.ButtonToolTipDuplicate"), b(p, "data-tooltip-direction", "UP"), b(g, "class", "action-button delete-button fas fa-trash svelte-ekhss5"), b(g, "data-tooltip", "A5E.ButtonToolTipDelete"), b(g, "data-tooltip-direction", "UP"), b(c, "class", "action-buttons svelte-ekhss5"), b(t, "class", "a5e-item a5e-item--action"), b(t, "data-action-id", _ = /*id*/
      e[12]), b(t, "draggable", "true"), this.first = t;
    },
    m(F, H) {
      T(F, t, H), A(t, s), A(t, l), A(t, o), A(t, a), A(t, c), A(c, u), A(c, d), A(c, p), A(c, m), A(c, g), A(t, h), y || (k = [
        V(u, "click", v),
        V(p, "click", O),
        V(g, "click", P),
        V(t, "dragstart", D),
        V(t, "auxclick", I)
      ], y = !0);
    },
    p(F, H) {
      var G, U;
      e = F, H & /*$item*/
      1 && !ze(s.src, n = /*action*/
      ((G = e[13]) == null ? void 0 : G.img) ?? /*$item*/
      e[0].img ?? "icons/svg/item-bag.svg") && b(s, "src", n), H & /*$item*/
      1 && r !== (r = /*action*/
      ((U = e[13]) == null ? void 0 : U.name) + "") && _e(o, r), H & /*$item*/
      1 && _ !== (_ = /*id*/
      e[12]) && b(t, "data-action-id", _);
    },
    d(F) {
      F && S(t), y = !1, Ne(k);
    }
  };
}
f(jN, "create_each_block$s");
function Pce(i) {
  let e, t = [], s = /* @__PURE__ */ new Map(), n = oe(Object.entries(
    /*$item*/
    i[0].system.actions ?? {}
  ));
  const l = /* @__PURE__ */ f((r) => (
    /*id*/
    r[12]
  ), "get_key");
  for (let r = 0; r < n.length; r += 1) {
    let o = NN(i, n, r), a = l(o);
    s.set(a, t[r] = jN(a, o));
  }
  return {
    c() {
      e = E("ul");
      for (let r = 0; r < t.length; r += 1)
        t[r].c();
      b(e, "class", "a5e-item-list");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < t.length; a += 1)
        t[a] && t[a].m(e, null);
    },
    p(r, o) {
      o & /*Object, $item, _onDragStart, configureAction, deleteAction, duplicateAction*/
      121 && (n = oe(Object.entries(
        /*$item*/
        r[0].system.actions ?? {}
      )), t = kt(t, o, l, 1, r, n, s, e, vs, jN, null, NN));
    },
    d(r) {
      r && S(e);
      for (let o = 0; o < t.length; o += 1)
        t[o].d();
    }
  };
}
f(Pce, "create_default_slot$A");
function Mce(i) {
  let e, t, s, n;
  return t = new Me({
    props: {
      heading: "A5E.TabActions",
      headerButtons: [
        {
          classes: "add-button",
          handler: (
            /*addAction*/
            i[2]
          ),
          label: "A5E.ButtonAddAction"
        }
      ],
      $$slots: { default: [Pce] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("div"), s = E("div"), L(t.$$.fragment), z(s, "display", "contents"), z(s, "--a5e-section-gap", "0.125rem"), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable");
    },
    m(l, r) {
      T(l, e, r), A(e, s), N(t, s, null), n = !0;
    },
    p(l, [r]) {
      const o = {};
      r & /*$$scope, $item*/
      65537 && (o.$$scope = { dirty: r, ctx: l }), t.$set(o);
    },
    i(l) {
      n || (w(t.$$.fragment, l), n = !0);
    },
    o(l) {
      C(t.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(e), j(t);
    }
  };
}
f(Mce, "create_fragment$1i");
function Rce(i, e, t) {
  let s;
  const n = fe("item");
  pe(i, n, (h) => t(0, s = h));
  function l() {
    s.actions.add();
  }
  f(l, "addAction");
  function r(h) {
    s.actions.duplicate(h);
  }
  f(r, "duplicateAction");
  function o(h) {
    s.actions.configure(h);
  }
  f(o, "configureAction");
  function a(h) {
    s.actions.remove(h);
  }
  f(a, "deleteAction");
  async function c(h, _) {
    const y = {
      actionId: _,
      itemUuid: s.uuid,
      type: "Action"
    };
    return h.dataTransfer.setData("text/plain", JSON.stringify(y));
  }
  return f(c, "_onDragStart"), [
    s,
    n,
    l,
    r,
    o,
    a,
    c,
    /* @__PURE__ */ f((h) => o(h), "click_handler"),
    /* @__PURE__ */ f((h) => r(h), "click_handler_1"),
    /* @__PURE__ */ f((h) => a(h), "click_handler_2"),
    /* @__PURE__ */ f((h, _) => c(_, h), "dragstart_handler"),
    /* @__PURE__ */ f((h) => o(h), "auxclick_handler")
  ];
}
f(Rce, "instance$1c");
const iC = class iC extends ie {
  constructor(e) {
    super(), le(this, e, Rce, Mce, ne, {});
  }
};
f(iC, "ItemActionsTab");
let Mk = iC;
function Fce(i) {
  let e, t, s, n, l, r = (
    /*selectedAmmunitionProperties*/
    (i[2] || K("A5E.None")) + ""
  ), o;
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.AmmunitionProperties")}:`, n = R(), l = E("dd"), o = x(r), b(s, "class", "u-text-bold"), b(l, "class", "u-m-0 u-p-0"), b(t, "class", "u-flex u-gap-md"), b(e, "class", "a5e-box u-flex u-flex-col u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(t, s), A(t, n), A(t, l), A(l, o);
    },
    p(a, c) {
      c & /*selectedAmmunitionProperties*/
      4 && r !== (r = /*selectedAmmunitionProperties*/
      (a[2] || K("A5E.None")) + "") && _e(o, r);
    },
    i: ee,
    o: ee,
    d(a) {
      a && S(e);
    }
  };
}
f(Fce, "create_else_block$h");
function Nce(i) {
  let e, t;
  return e = new Ze({
    props: {
      heading: "A5E.AmmunitionProperties",
      options: Object.entries(
        /*ammunitionProperties*/
        i[4]
      ),
      selected: (
        /*$item*/
        i[0].system.ammunitionProperties
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[5]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.selected = /*$item*/
      s[0].system.ammunitionProperties), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Nce, "create_if_block$J");
function jce(i) {
  let e, t, s, n;
  const l = [Nce, Fce], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[1] ? 0 : 1
    );
  }
  return f(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let u = e;
      e = o(a), e === u ? r[e].p(a, c) : (ce(), C(r[u], 1, 1, () => {
        r[u] = null;
      }), ue(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), r[e].d(a);
    }
  };
}
f(jce, "create_default_slot$z");
function Lce(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Ammunition Configuration",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[6]
          )
        }
      ],
      $$slots: { default: [jce] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-heading-gap", "0.5rem"), z(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      2 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[6]
          )
        }
      ]), l & /*$$scope, $item, editMode, selectedAmmunitionProperties*/
      263 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(Lce, "create_fragment$1h");
function Bce(i, e, t) {
  let s, n;
  function l(d) {
    const p = d.system.ammunitionProperties.map((m) => o[m] ?? m);
    return p.sort((m, g) => m.localeCompare(g)), p.join(", ");
  }
  f(l, "prepareAmmunitionProperties");
  const r = fe("item");
  pe(i, r, (d) => t(0, n = d));
  const o = CONFIG.A5E.ammunitionProperties;
  let a = !1;
  const c = /* @__PURE__ */ f((d) => se(n, "system.ammunitionProperties", d.detail), "updateSelection_handler"), u = /* @__PURE__ */ f(() => t(1, a = !a), "func");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1 && t(2, s = l(n));
  }, [
    n,
    a,
    s,
    r,
    o,
    c,
    u
  ];
}
f(Bce, "instance$1b");
const lC = class lC extends ie {
  constructor(e) {
    super(), le(this, e, Bce, Lce, ne, {});
  }
};
f(lC, "AmmunitionConfiguration");
let Rk = lC;
function LN(i, e, t) {
  const s = i.slice();
  return s[14] = e[t][0], s[15] = e[t][1], s;
}
f(LN, "get_each_context$r");
function qce(i) {
  var te, J, re, ae, be;
  let e, t, s, n, l, r = (
    /*$item*/
    (((te = i[1].system.ac) == null ? void 0 : te.formula) ?? "") + ""
  ), o, a, c, u, d, p, m = (
    /*$item*/
    (((J = i[1].system.ac) == null ? void 0 : J.maxDex) ?? 0) + ""
  ), g, h, _, y, k, v, O = (
    /*$item*/
    (((re = i[1].system.ac) == null ? void 0 : re.minStr) ?? 0) + ""
  ), P, D, I, B, F, H, G = (
    /*armorModes*/
    i[4][
      /*$item*/
      (ae = i[1].system.ac) == null ? void 0 : ae.mode
    ] + ""
  ), U, q, W = !["armor", "shield"].includes(
    /*$item*/
    (be = i[1].system) == null ? void 0 : be.objectType
  ), X = W && BN(i);
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.armorClass.formula")}:`, n = R(), l = E("dd"), o = x(r), a = R(), c = E("div"), u = E("dt"), u.textContent = `${K("A5E.armorClass.maxDex")}:`, d = R(), p = E("dd"), g = x(m), h = R(), _ = E("div"), y = E("dt"), y.textContent = `${K("A5E.armorClass.minStr")}:`, k = R(), v = E("dd"), P = x(O), D = R(), I = E("div"), B = E("dt"), B.textContent = `${K("A5E.armorClass.mode")}:`, F = R(), H = E("dd"), U = x(G), q = R(), X && X.c(), b(s, "class", "u-text-bold"), b(l, "class", "u-m-0 u-p-0"), b(t, "class", "u-flex u-gap-md"), b(u, "class", "u-text-bold"), b(p, "class", "u-m-0 u-p-0"), b(c, "class", "u-flex u-gap-md"), b(y, "class", "u-text-bold"), b(v, "class", "u-m-0 u-p-0"), b(_, "class", "u-flex u-gap-md"), b(B, "class", "u-text-bold"), b(H, "class", "u-m-0 u-p-0"), b(I, "class", "u-flex u-gap-md"), b(e, "class", "a5e-box u-flex u-flex-col u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(we, ve) {
      T(we, e, ve), A(e, t), A(t, s), A(t, n), A(t, l), A(l, o), A(t, a), A(e, c), A(c, u), A(c, d), A(c, p), A(p, g), A(c, h), A(e, _), A(_, y), A(_, k), A(_, v), A(v, P), A(_, D), A(e, I), A(I, B), A(I, F), A(I, H), A(H, U), A(I, q), X && X.m(e, null);
    },
    p(we, ve) {
      var me, he, Ae, Fe, Ve;
      ve & /*$item*/
      2 && r !== (r = /*$item*/
      (((me = we[1].system.ac) == null ? void 0 : me.formula) ?? "") + "") && _e(o, r), ve & /*$item*/
      2 && m !== (m = /*$item*/
      (((he = we[1].system.ac) == null ? void 0 : he.maxDex) ?? 0) + "") && _e(g, m), ve & /*$item*/
      2 && O !== (O = /*$item*/
      (((Ae = we[1].system.ac) == null ? void 0 : Ae.minStr) ?? 0) + "") && _e(P, O), ve & /*$item*/
      2 && G !== (G = /*armorModes*/
      we[4][
        /*$item*/
        (Fe = we[1].system.ac) == null ? void 0 : Fe.mode
      ] + "") && _e(U, G), ve & /*$item*/
      2 && (W = !["armor", "shield"].includes(
        /*$item*/
        (Ve = we[1].system) == null ? void 0 : Ve.objectType
      )), W ? X ? X.p(we, ve) : (X = BN(we), X.c(), X.m(e, null)) : X && (X.d(1), X = null);
    },
    i: ee,
    o: ee,
    d(we) {
      we && S(e), X && X.d();
    }
  };
}
f(qce, "create_else_block$g");
function Gce(i) {
  var p, m;
  let e, t, s, n, l, r, o = !["armor", "shield"].includes(
    /*$item*/
    (p = i[1].system) == null ? void 0 : p.objectType
  ), a, c;
  e = new de({
    props: {
      heading: "A5E.armorClass.formula",
      $$slots: { default: [zce] },
      $$scope: { ctx: i }
    }
  }), s = new Me({
    props: {
      $$slots: { default: [Wce] },
      $$scope: { ctx: i }
    }
  });
  let u = (
    /*$item*/
    ((m = i[1].system) == null ? void 0 : m.objectType) === "armor" && GN(i)
  ), d = o && zN(i);
  return {
    c() {
      L(e.$$.fragment), t = R(), n = E("div"), L(s.$$.fragment), l = R(), u && u.c(), r = R(), d && d.c(), a = $e(), z(n, "display", "contents"), z(n, "--a5e-section-body-direction", "row");
    },
    m(g, h) {
      N(e, g, h), T(g, t, h), T(g, n, h), N(s, n, null), T(g, l, h), u && u.m(g, h), T(g, r, h), d && d.m(g, h), T(g, a, h), c = !0;
    },
    p(g, h) {
      var k, v;
      const _ = {};
      h & /*$$scope, $item*/
      262146 && (_.$$scope = { dirty: h, ctx: g }), e.$set(_);
      const y = {};
      h & /*$$scope, $item*/
      262146 && (y.$$scope = { dirty: h, ctx: g }), s.$set(y), /*$item*/
      ((k = g[1].system) == null ? void 0 : k.objectType) === "armor" ? u ? (u.p(g, h), h & /*$item*/
      2 && w(u, 1)) : (u = GN(g), u.c(), w(u, 1), u.m(r.parentNode, r)) : u && (ce(), C(u, 1, 1, () => {
        u = null;
      }), ue()), h & /*$item*/
      2 && (o = !["armor", "shield"].includes(
        /*$item*/
        (v = g[1].system) == null ? void 0 : v.objectType
      )), o ? d ? (d.p(g, h), h & /*$item*/
      2 && w(d, 1)) : (d = zN(g), d.c(), w(d, 1), d.m(a.parentNode, a)) : d && (ce(), C(d, 1, 1, () => {
        d = null;
      }), ue());
    },
    i(g) {
      c || (w(e.$$.fragment, g), w(s.$$.fragment, g), w(u), w(d), c = !0);
    },
    o(g) {
      C(e.$$.fragment, g), C(s.$$.fragment, g), C(u), C(d), c = !1;
    },
    d(g) {
      g && (S(t), S(l), S(r), S(a)), j(e, g), g && s && S(n), j(s, g), u && u.d(g), d && d.d(g);
    }
  };
}
f(Gce, "create_if_block$I");
function BN(i) {
  var g, h;
  let e, t, s, n, l = (
    /*$item*/
    (((g = i[1].system.ac) == null ? void 0 : g.requiresNoShield) ?? !1) + ""
  ), r, o, a, c, u, d, p = (
    /*$item*/
    (((h = i[1].system.ac) == null ? void 0 : h.requiresUnarmored) ?? !1) + ""
  ), m;
  return {
    c() {
      e = E("div"), t = E("dt"), t.textContent = `${K("A5E.armorClass.requiresNoShield")}:`, s = R(), n = E("dd"), r = x(l), o = R(), a = E("div"), c = E("dt"), c.textContent = `${K("A5E.armorClass.requiresUnarmored")}:`, u = R(), d = E("dd"), m = x(p), b(t, "class", "u-text-bold"), b(n, "class", "u-m-0 u-p-0"), b(e, "class", "u-flex u-gap-md"), b(c, "class", "u-text-bold"), b(d, "class", "u-m-0 u-p-0"), b(a, "class", "u-flex u-gap-md");
    },
    m(_, y) {
      T(_, e, y), A(e, t), A(e, s), A(e, n), A(n, r), A(e, o), T(_, a, y), A(a, c), A(a, u), A(a, d), A(d, m);
    },
    p(_, y) {
      var k, v;
      y & /*$item*/
      2 && l !== (l = /*$item*/
      (((k = _[1].system.ac) == null ? void 0 : k.requiresNoShield) ?? !1) + "") && _e(r, l), y & /*$item*/
      2 && p !== (p = /*$item*/
      (((v = _[1].system.ac) == null ? void 0 : v.requiresUnarmored) ?? !1) + "") && _e(m, p);
    },
    d(_) {
      _ && (S(e), S(a));
    }
  };
}
f(BN, "create_if_block_3$f");
function zce(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "type", "text"), b(e, "name", "system.ac.baseFormula"), b(
        e,
        "id",
        /*appId*/
        i[3] + "-ac-base-formula"
      ), e.value = t = /*$item*/
      ((l = i[1].system.ac) == null ? void 0 : l.baseFormula) ?? "";
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[6]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r & /*$item, modes*/
      34 && t !== (t = /*$item*/
      ((o = l[1].system.ac) == null ? void 0 : o.baseFormula) ?? "") && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(zce, "create_default_slot_8$3");
function Hce(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "type", "number"), b(e, "data-dtype", "Number"), b(e, "name", "system.ac.maxDex"), b(
        e,
        "id",
        /*appId*/
        i[3] + "-ac-max-dex"
      ), e.value = t = /*$item*/
      ((l = i[1].system.ac) == null ? void 0 : l.maxDex) ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[7]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r & /*$item, modes*/
      34 && t !== (t = /*$item*/
      ((o = l[1].system.ac) == null ? void 0 : o.maxDex) ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Hce, "create_default_slot_7$5");
function Uce(i) {
  let e, t, s, n;
  return {
    c() {
      var l;
      e = E("input"), b(e, "type", "number"), b(e, "data-dtype", "Number"), b(e, "name", "system.ac.minStr"), b(
        e,
        "id",
        /*appId*/
        i[3] + "-ac-min-str"
      ), e.value = t = /*$item*/
      ((l = i[1].system.ac) == null ? void 0 : l.minStr) ?? 0;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_2*/
        i[8]
      ), s = !0);
    },
    p(l, r) {
      var o;
      r & /*$item, modes*/
      34 && t !== (t = /*$item*/
      ((o = l[1].system.ac) == null ? void 0 : o.minStr) ?? 0) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Uce, "create_default_slot_6$6");
function qN(i) {
  let e, t = (
    /*label*/
    i[14] + ""
  ), s, n;
  return {
    c() {
      e = E("option"), s = x(t), n = R(), e.__value = /*mode*/
      i[15], qe(e, e.__value);
    },
    m(l, r) {
      T(l, e, r), A(e, s), A(e, n);
    },
    p: ee,
    d(l) {
      l && S(e);
    }
  };
}
f(qN, "create_each_block$r");
function Vce(i) {
  let e, t, s, n, l = oe(
    /*modes*/
    i[5]
  ), r = [];
  for (let o = 0; o < l.length; o += 1)
    r[o] = qN(LN(i, l, o));
  return {
    c() {
      e = E("select");
      for (let o = 0; o < r.length; o += 1)
        r[o].c();
      b(e, "name", "system.ac.mode"), b(
        e,
        "id",
        /*appId*/
        i[3] + "-ac-mode"
      );
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < r.length; c += 1)
        r[c] && r[c].m(e, null);
      ds(
        e,
        /*$item*/
        i[1].system.ac.mode
      ), s || (n = V(
        e,
        "change",
        /*change_handler_3*/
        i[9]
      ), s = !0);
    },
    p(o, a) {
      if (a & /*modes*/
      32) {
        l = oe(
          /*modes*/
          o[5]
        );
        let c;
        for (c = 0; c < l.length; c += 1) {
          const u = LN(o, l, c);
          r[c] ? r[c].p(u, a) : (r[c] = qN(u), r[c].c(), r[c].m(e, null));
        }
        for (; c < r.length; c += 1)
          r[c].d(1);
        r.length = l.length;
      }
      a & /*$item, modes*/
      34 && t !== (t = /*$item*/
      o[1].system.ac.mode) && ds(
        e,
        /*$item*/
        o[1].system.ac.mode
      );
    },
    d(o) {
      o && S(e), Le(r, o), s = !1, n();
    }
  };
}
f(Vce, "create_default_slot_5$8");
function Wce(i) {
  let e, t, s, n, l, r;
  return e = new de({
    props: {
      heading: "A5E.armorClass.maxDex",
      $$slots: { default: [Hce] },
      $$scope: { ctx: i }
    }
  }), s = new de({
    props: {
      heading: "A5E.armorClass.minStr",
      $$slots: { default: [Uce] },
      $$scope: { ctx: i }
    }
  }), l = new de({
    props: {
      heading: "A5E.armorClass.mode",
      $$slots: { default: [Vce] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment);
    },
    m(o, a) {
      N(e, o, a), T(o, t, a), N(s, o, a), T(o, n, a), N(l, o, a), r = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$$scope, $item*/
      262146 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const u = {};
      a & /*$$scope, $item*/
      262146 && (u.$$scope = { dirty: a, ctx: o }), s.$set(u);
      const d = {};
      a & /*$$scope, $item*/
      262146 && (d.$$scope = { dirty: a, ctx: o }), l.$set(d);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(s.$$.fragment, o), C(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (S(t), S(n)), j(e, o), j(s, o), j(l, o);
    }
  };
}
f(Wce, "create_default_slot_4$9");
function GN(i) {
  let e, t;
  return e = new de({
    props: {
      $$slots: { default: [Kce] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $item*/
      262146 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(GN, "create_if_block_2$o");
function Kce(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.armorClass.grantsDisadvantage",
      checked: (
        /*$item*/
        ((s = i[1].system.ac) == null ? void 0 : s.grantsDisadvantage) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[10]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*$item*/
      2 && (r.checked = /*$item*/
      ((o = n[1].system.ac) == null ? void 0 : o.grantsDisadvantage) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(Kce, "create_default_slot_3$b");
function zN(i) {
  let e, t, s, n;
  return e = new de({
    props: {
      $$slots: { default: [Yce] },
      $$scope: { ctx: i }
    }
  }), s = new de({
    props: {
      $$slots: { default: [Xce] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$$scope, $item*/
      262146 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$$scope, $item*/
      262146 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(zN, "create_if_block_1$y");
function Yce(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.armorClass.requiresNoShield",
      checked: (
        /*$item*/
        ((s = i[1].system.ac) == null ? void 0 : s.requiresNoShield) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[11]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*$item*/
      2 && (r.checked = /*$item*/
      ((o = n[1].system.ac) == null ? void 0 : o.requiresNoShield) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(Yce, "create_default_slot_2$c");
function Xce(i) {
  var s;
  let e, t;
  return e = new De({
    props: {
      label: "A5E.armorClass.requiresUnarmored",
      checked: (
        /*$item*/
        ((s = i[1].system.ac) == null ? void 0 : s.requiresUnarmored) ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[12]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      var o;
      const r = {};
      l & /*$item*/
      2 && (r.checked = /*$item*/
      ((o = n[1].system.ac) == null ? void 0 : o.requiresUnarmored) ?? !1), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(Xce, "create_default_slot_1$d");
function Jce(i) {
  let e, t, s, n;
  const l = [Gce, qce], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[0] ? 0 : 1
    );
  }
  return f(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let u = e;
      e = o(a), e === u ? r[e].p(a, c) : (ce(), C(r[u], 1, 1, () => {
        r[u] = null;
      }), ue(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), r[e].d(a);
    }
  };
}
f(Jce, "create_default_slot$y");
function Zce(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "A5E.TabArmorClassProperties",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[13]
          )
        }
      ],
      $$slots: { default: [Jce] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem"), z(t, "--a5e-section-heading-gap", "0.5rem"), z(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      1 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[13]
          )
        }
      ]), l & /*$$scope, $item, editMode*/
      262147 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(Zce, "create_fragment$1g");
function Qce(i, e, t) {
  let s;
  const n = fe("item");
  pe(i, n, (y) => t(1, s = y));
  const l = fe("appId"), { armorModes: r } = CONFIG.A5E, o = [
    ["Add", CONFIG.A5E.ARMOR_MODES.ADD],
    ["Override", CONFIG.A5E.ARMOR_MODES.OVERRIDE]
  ];
  let a = !1;
  return [
    a,
    s,
    n,
    l,
    r,
    o,
    /* @__PURE__ */ f(({ target: y }) => se(s, y.name, y.value), "change_handler"),
    /* @__PURE__ */ f(({ target: y }) => se(s, y.name, Number(y.value)), "change_handler_1"),
    /* @__PURE__ */ f(({ target: y }) => se(s, y.name, Number(y.value)), "change_handler_2"),
    /* @__PURE__ */ f(({ target: y }) => se(s, y.name, Number(y.value)), "change_handler_3"),
    /* @__PURE__ */ f(({ detail: y }) => se(s, "system.ac.grantsDisadvantage", y), "updateSelection_handler"),
    /* @__PURE__ */ f(({ detail: y }) => se(s, "system.ac.requiresNoShield", y), "updateSelection_handler_1"),
    /* @__PURE__ */ f(({ detail: y }) => se(s, "system.ac.requiresUnarmored", y), "updateSelection_handler_2"),
    /* @__PURE__ */ f(() => t(0, a = !a), "func")
  ];
}
f(Qce, "instance$1a");
const rC = class rC extends ie {
  constructor(e) {
    super(), le(this, e, Qce, Zce, ne, {});
  }
};
f(rC, "ArmorClassConfiguration");
let gp = rC;
function xce(i) {
  let e, t, s, n, l, r, o, a, c, u, d = (
    /*selectedArmorProperties*/
    (i[2] || K("A5E.None")) + ""
  ), p;
  function m(_, y) {
    return (
      /*$item*/
      _[0].system.armorCategory ? sue : tue
    );
  }
  f(m, "select_block_type_1");
  let g = m(i), h = g(i);
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.ArmorCategory")}:`, n = R(), l = E("dd"), h.c(), r = R(), o = E("div"), a = E("dt"), a.textContent = `${K("A5E.ArmorProperties")}:`, c = R(), u = E("dd"), p = x(d), b(s, "class", "u-text-bold"), b(l, "class", "u-m-0 u-p-0"), b(t, "class", "u-flex u-gap-md"), b(a, "class", "u-text-bold"), b(u, "class", "u-m-0 u-p-0"), b(o, "class", "u-flex u-gap-md"), b(e, "class", "a5e-box u-flex u-flex-col u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(_, y) {
      T(_, e, y), A(e, t), A(t, s), A(t, n), A(t, l), h.m(l, null), A(t, r), A(e, o), A(o, a), A(o, c), A(o, u), A(u, p);
    },
    p(_, y) {
      g === (g = m(_)) && h ? h.p(_, y) : (h.d(1), h = g(_), h && (h.c(), h.m(l, null))), y & /*selectedArmorProperties*/
      4 && d !== (d = /*selectedArmorProperties*/
      (_[2] || K("A5E.None")) + "") && _e(p, d);
    },
    i: ee,
    o: ee,
    d(_) {
      _ && S(e), h.d();
    }
  };
}
f(xce, "create_else_block$f");
function eue(i) {
  let e, t, s, n;
  return e = new Ye({
    props: {
      heading: "A5E.ArmorCategory",
      options: Object.entries(
        /*armorTypes*/
        i[4]
      ),
      selected: (
        /*$item*/
        i[0].system.armorCategory
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[6]
  ), s = new Ze({
    props: {
      heading: "A5E.ArmorProperties",
      options: Object.entries(
        /*armorProperties*/
        i[5]
      ),
      selected: (
        /*$item*/
        i[0].system.armorProperties
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[7]
  ), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$item*/
      1 && (o.selected = /*$item*/
      l[0].system.armorCategory), e.$set(o);
      const a = {};
      r & /*$item*/
      1 && (a.selected = /*$item*/
      l[0].system.armorProperties), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(eue, "create_if_block$H");
function tue(i) {
  let e = K("A5E.Unknown") + "", t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p: ee,
    d(s) {
      s && S(t);
    }
  };
}
f(tue, "create_else_block_1$4");
function sue(i) {
  let e = (
    /*armorTypes*/
    (i[4][
      /*$item*/
      i[0].system.armorCategory
    ] ?? /*$item*/
    i[0].system.armorCategory) + ""
  ), t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*$item*/
      1 && e !== (e = /*armorTypes*/
      (s[4][
        /*$item*/
        s[0].system.armorCategory
      ] ?? /*$item*/
      s[0].system.armorCategory) + "") && _e(t, e);
    },
    d(s) {
      s && S(t);
    }
  };
}
f(sue, "create_if_block_1$x");
function nue(i) {
  let e, t, s, n;
  const l = [eue, xce], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[1] ? 0 : 1
    );
  }
  return f(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let u = e;
      e = o(a), e === u ? r[e].p(a, c) : (ce(), C(r[u], 1, 1, () => {
        r[u] = null;
      }), ue(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), r[e].d(a);
    }
  };
}
f(nue, "create_default_slot$x");
function iue(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Armor Configuration",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[8]
          )
        }
      ],
      $$slots: { default: [nue] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem"), z(t, "--a5e-section-heading-gap", "0.5rem"), z(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      2 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[8]
          )
        }
      ]), l & /*$$scope, $item, editMode, selectedArmorProperties*/
      1031 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(iue, "create_fragment$1f");
function lue(i, e, t) {
  let s, n;
  function l(m) {
    const g = m.system.armorProperties.map((h) => a[h] ?? h);
    return g.sort((h, _) => h.localeCompare(_)), g.join(", ");
  }
  f(l, "prepareArmorProperties");
  const r = fe("item");
  pe(i, r, (m) => t(0, n = m));
  const { armor: o, armorProperties: a } = CONFIG.A5E;
  let c = !1;
  const u = /* @__PURE__ */ f((m) => se(n, "system.armorCategory", m.detail), "updateSelection_handler"), d = /* @__PURE__ */ f((m) => se(n, "system.armorProperties", m.detail), "updateSelection_handler_1"), p = /* @__PURE__ */ f(() => t(1, c = !c), "func");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1 && t(2, s = l(n));
  }, [
    n,
    c,
    s,
    r,
    o,
    a,
    u,
    d,
    p
  ];
}
f(lue, "instance$19");
const oC = class oC extends ie {
  constructor(e) {
    super(), le(this, e, lue, iue, ne, {});
  }
};
f(oC, "ArmorConfiguration");
let Fk = oC;
function rue(i) {
  let e, t, s, n, l, r = (
    /*featureTypes*/
    (i[6][
      /*$item*/
      i[1].system.featureType
    ] ?? K("A5E.None")) + ""
  ), o, a, c = ["class", "knack"].includes(
    /*$item*/
    i[1].system.featureType
  ) && /*$item*/
  i[1].system.classes, u = c && HN(i);
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.FeatureTypePrompt")}:`, n = R(), l = E("dd"), o = x(r), a = R(), u && u.c(), b(s, "class", "u-text-bold"), b(l, "class", "u-m-0 u-p-0"), b(t, "class", "u-flex u-gap-md"), b(e, "class", "a5e-box u-flex u-flex-col u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(t, s), A(t, n), A(t, l), A(l, o), A(t, a), u && u.m(e, null);
    },
    p(d, p) {
      p & /*$item*/
      2 && r !== (r = /*featureTypes*/
      (d[6][
        /*$item*/
        d[1].system.featureType
      ] ?? K("A5E.None")) + "") && _e(o, r), p & /*$item*/
      2 && (c = ["class", "knack"].includes(
        /*$item*/
        d[1].system.featureType
      ) && /*$item*/
      d[1].system.classes), c ? u ? u.p(d, p) : (u = HN(d), u.c(), u.m(e, null)) : u && (u.d(1), u = null);
    },
    i: ee,
    o: ee,
    d(d) {
      d && S(e), u && u.d();
    }
  };
}
f(rue, "create_else_block$e");
function oue(i) {
  let e, t, s = ["class", "knack"].includes(
    /*$item*/
    i[1].system.featureType
  ), n, l, r, o, a;
  e = new Ye({
    props: {
      heading: "A5E.FeatureTypePrompt",
      options: Object.entries(
        /*featureTypes*/
        i[6]
      ),
      selected: (
        /*$item*/
        i[1].system.featureType
      ),
      allowDeselect: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  );
  let c = s && UN(i);
  return l = new de({
    props: {
      $$slots: { default: [aue] },
      $$scope: { ctx: i }
    }
  }), o = new de({
    props: {
      $$slots: { default: [cue] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), c && c.c(), n = R(), L(l.$$.fragment), r = R(), L(o.$$.fragment);
    },
    m(u, d) {
      N(e, u, d), T(u, t, d), c && c.m(u, d), T(u, n, d), N(l, u, d), T(u, r, d), N(o, u, d), a = !0;
    },
    p(u, d) {
      const p = {};
      d & /*$item*/
      2 && (p.selected = /*$item*/
      u[1].system.featureType), e.$set(p), d & /*$item*/
      2 && (s = ["class", "knack"].includes(
        /*$item*/
        u[1].system.featureType
      )), s ? c ? (c.p(u, d), d & /*$item*/
      2 && w(c, 1)) : (c = UN(u), c.c(), w(c, 1), c.m(n.parentNode, n)) : c && (ce(), C(c, 1, 1, () => {
        c = null;
      }), ue());
      const m = {};
      d & /*$$scope, $item*/
      8194 && (m.$$scope = { dirty: d, ctx: u }), l.$set(m);
      const g = {};
      d & /*$$scope, $item*/
      8194 && (g.$$scope = { dirty: d, ctx: u }), o.$set(g);
    },
    i(u) {
      a || (w(e.$$.fragment, u), w(c), w(l.$$.fragment, u), w(o.$$.fragment, u), a = !0);
    },
    o(u) {
      C(e.$$.fragment, u), C(c), C(l.$$.fragment, u), C(o.$$.fragment, u), a = !1;
    },
    d(u) {
      u && (S(t), S(n), S(r)), j(e, u), c && c.d(u), j(l, u), j(o, u);
    }
  };
}
f(oue, "create_if_block$G");
function HN(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("div"), t = E("dt"), t.textContent = "Class:", s = R(), n = E("dd"), n.textContent = `${/*getClassSummary*/
      i[2]()}`, b(t, "class", "u-text-bold"), b(n, "class", "u-m-0 u-p-0"), b(e, "class", "u-flex u-gap-md");
    },
    m(l, r) {
      T(l, e, r), A(e, t), A(e, s), A(e, n);
    },
    p: ee,
    d(l) {
      l && S(e);
    }
  };
}
f(HN, "create_if_block_2$n");
function UN(i) {
  let e, t, s, n;
  return e = new Ye({
    props: {
      heading: "A5E Classes",
      options: Object.entries(
        /*classes*/
        i[4]
      ),
      selected: (
        /*$item*/
        i[1].system.classes
      ),
      allowDeselect: !0
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[8]
  ), s = new Ye({
    props: {
      heading: "5E Classes",
      options: Object.entries(
        /*classes5e*/
        i[5]
      ),
      selected: (
        /*$item*/
        i[1].system.classes
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[9]
  ), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$item*/
      2 && (o.selected = /*$item*/
      l[1].system.classes), e.$set(o);
      const a = {};
      r & /*$item*/
      2 && (a.selected = /*$item*/
      l[1].system.classes), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(UN, "create_if_block_1$w");
function aue(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.SpellConcentration",
      checked: (
        /*$item*/
        i[1].system.concentration
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[10]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      2 && (l.checked = /*$item*/
      s[1].system.concentration), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(aue, "create_default_slot_2$b");
function cue(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.RequiresBloodied",
      checked: (
        /*$item*/
        i[1].system.requiresBloodied
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[11]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      2 && (l.checked = /*$item*/
      s[1].system.requiresBloodied), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(cue, "create_default_slot_1$c");
function uue(i) {
  let e, t, s, n;
  const l = [oue, rue], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[0] ? 0 : 1
    );
  }
  return f(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let u = e;
      e = o(a), e === u ? r[e].p(a, c) : (ce(), C(r[u], 1, 1, () => {
        r[u] = null;
      }), ue(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), r[e].d(a);
    }
  };
}
f(uue, "create_default_slot$w");
function fue(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "A5E.TabFeatureProperties",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[12]
          )
        }
      ],
      $$slots: { default: [uue] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem"), z(t, "--a5e-section-heading-gap", "0.5rem"), z(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      1 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[12]
          )
        }
      ]), l & /*$$scope, $item, editMode*/
      8195 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(fue, "create_fragment$1e");
function due(i, e, t) {
  let s;
  function n() {
    const _ = s.system.classes;
    return K(r[_] ?? o[_]);
  }
  f(n, "getClassSummary");
  const l = fe("item");
  pe(i, l, (_) => t(1, s = _));
  const { classes: r, classes5e: o, featureTypes: a } = CONFIG.A5E;
  let c = !1;
  return [
    c,
    s,
    n,
    l,
    r,
    o,
    a,
    /* @__PURE__ */ f((_) => se(s, "system.featureType", _.detail), "updateSelection_handler"),
    /* @__PURE__ */ f(({ detail: _ }) => {
      se(s, "system.classes", _);
    }, "updateSelection_handler_1"),
    /* @__PURE__ */ f(({ detail: _ }) => {
      se(s, "system.classes", _);
    }, "updateSelection_handler_2"),
    /* @__PURE__ */ f(({ detail: _ }) => {
      se(s, "system.concentration", _);
    }, "updateSelection_handler_3"),
    /* @__PURE__ */ f(({ detail: _ }) => {
      se(s, "system.requiresBloodied", _);
    }, "updateSelection_handler_4"),
    /* @__PURE__ */ f(() => t(0, c = !c), "func")
  ];
}
f(due, "instance$18");
const aC = class aC extends ie {
  constructor(e) {
    super(), le(this, e, due, fue, ne, {});
  }
};
f(aC, "FeatureConfiguration");
let Nk = aC;
function dq(i) {
  return Object.entries(i).map(([e, t]) => [Number(e), t]);
}
f(dq, "objectEntriesNumberKeyConverter");
function pue(i) {
  let e, t, s, n, l, r = (
    /*maneuverDegrees*/
    i[4][
      /*$item*/
      i[1].system.degree
    ] + ""
  ), o, a, c, u = (
    /*$item*/
    i[1].system.degree > 0 && /*$item*/
    i[1].system.isStance && VN()
  ), d = (
    /*$item*/
    i[1].system.degree > 0 && WN(i)
  );
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.ManeuverDegreePrompt")}:`, n = R(), l = E("dd"), o = x(r), a = R(), u && u.c(), c = R(), d && d.c(), b(s, "class", "u-text-bold"), b(l, "class", "u-m-0 u-p-0"), b(t, "class", "u-flex u-gap-md"), b(e, "class", "a5e-box u-flex u-flex-col u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(p, m) {
      T(p, e, m), A(e, t), A(t, s), A(t, n), A(t, l), A(l, o), A(l, a), u && u.m(l, null), A(t, c), d && d.m(e, null);
    },
    p(p, m) {
      m & /*$item*/
      2 && r !== (r = /*maneuverDegrees*/
      p[4][
        /*$item*/
        p[1].system.degree
      ] + "") && _e(o, r), /*$item*/
      p[1].system.degree > 0 && /*$item*/
      p[1].system.isStance ? u || (u = VN(), u.c(), u.m(l, null)) : u && (u.d(1), u = null), /*$item*/
      p[1].system.degree > 0 ? d ? d.p(p, m) : (d = WN(p), d.c(), d.m(e, null)) : d && (d.d(1), d = null);
    },
    i: ee,
    o: ee,
    d(p) {
      p && S(e), u && u.d(), d && d.d();
    }
  };
}
f(pue, "create_else_block$d");
function mue(i) {
  let e, t, s, n;
  e = new Ye({
    props: {
      heading: "A5E.ManeuverDegreePrompt",
      options: dq(
        /*maneuverDegrees*/
        i[4]
      ),
      selected: parseInt(
        /*$item*/
        i[1].system.degree,
        10
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[6]
  );
  let l = (
    /*$item*/
    i[1].system.degree > 0 && KN(i)
  );
  return {
    c() {
      L(e.$$.fragment), t = R(), l && l.c(), s = $e();
    },
    m(r, o) {
      N(e, r, o), T(r, t, o), l && l.m(r, o), T(r, s, o), n = !0;
    },
    p(r, o) {
      const a = {};
      o & /*$item*/
      2 && (a.selected = parseInt(
        /*$item*/
        r[1].system.degree,
        10
      )), e.$set(a), /*$item*/
      r[1].system.degree > 0 ? l ? (l.p(r, o), o & /*$item*/
      2 && w(l, 1)) : (l = KN(r), l.c(), w(l, 1), l.m(s.parentNode, s)) : l && (ce(), C(l, 1, 1, () => {
        l = null;
      }), ue());
    },
    i(r) {
      n || (w(e.$$.fragment, r), w(l), n = !0);
    },
    o(r) {
      C(e.$$.fragment, r), C(l), n = !1;
    },
    d(r) {
      r && (S(t), S(s)), j(e, r), l && l.d(r);
    }
  };
}
f(mue, "create_if_block$F");
function VN(i) {
  let e = K("A5E.ManeuverStance") + "", t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    d(s) {
      s && S(t);
    }
  };
}
f(VN, "create_if_block_3$e");
function WN(i) {
  let e, t, s, n, l = (
    /*maneuverTraditions*/
    (i[5][
      /*$item*/
      i[1].system.tradition
    ] ?? K("A5E.None")) + ""
  ), r, o, a, c, u, d, p = (
    /*$item*/
    (i[1].system.exertionCost || 0) + ""
  ), m;
  return {
    c() {
      e = E("div"), t = E("dt"), t.textContent = `${K("A5E.ManeuverTraditionPrompt")}:`, s = R(), n = E("dd"), r = x(l), o = R(), a = E("div"), c = E("dt"), c.textContent = `${K("A5E.ItemExertionCost")}:`, u = R(), d = E("dd"), m = x(p), b(t, "class", "u-text-bold"), b(n, "class", "u-m-0 u-p-0"), b(e, "class", "u-flex u-gap-md"), b(c, "class", "u-text-bold"), b(d, "class", "u-m-0 u-p-0"), b(a, "class", "u-flex u-gap-md");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(e, s), A(e, n), A(n, r), A(e, o), T(g, a, h), A(a, c), A(a, u), A(a, d), A(d, m);
    },
    p(g, h) {
      h & /*$item*/
      2 && l !== (l = /*maneuverTraditions*/
      (g[5][
        /*$item*/
        g[1].system.tradition
      ] ?? K("A5E.None")) + "") && _e(r, l), h & /*$item*/
      2 && p !== (p = /*$item*/
      (g[1].system.exertionCost || 0) + "") && _e(m, p);
    },
    d(g) {
      g && (S(e), S(a));
    }
  };
}
f(WN, "create_if_block_2$m");
function KN(i) {
  let e, t, s, n, l, r, o, a;
  return e = new Ye({
    props: {
      heading: "A5E.ManeuverTraditionPrompt",
      options: Object.entries(
        /*maneuverTraditions*/
        i[5]
      ),
      selected: (
        /*$item*/
        i[1].system.tradition
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[7]
  ), s = new de({
    props: {
      $$slots: { default: [hue] },
      $$scope: { ctx: i }
    }
  }), l = new de({
    props: {
      $$slots: { default: [gue] },
      $$scope: { ctx: i }
    }
  }), o = new de({
    props: {
      heading: "A5E.ItemExertionCost",
      $$slots: { default: [bue] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment), r = R(), L(o.$$.fragment);
    },
    m(c, u) {
      N(e, c, u), T(c, t, u), N(s, c, u), T(c, n, u), N(l, c, u), T(c, r, u), N(o, c, u), a = !0;
    },
    p(c, u) {
      const d = {};
      u & /*$item*/
      2 && (d.selected = /*$item*/
      c[1].system.tradition), e.$set(d);
      const p = {};
      u & /*$$scope, $item*/
      4098 && (p.$$scope = { dirty: u, ctx: c }), s.$set(p);
      const m = {};
      u & /*$$scope, $item*/
      4098 && (m.$$scope = { dirty: u, ctx: c }), l.$set(m);
      const g = {};
      u & /*$$scope, $item*/
      4098 && (g.$$scope = { dirty: u, ctx: c }), o.$set(g);
    },
    i(c) {
      a || (w(e.$$.fragment, c), w(s.$$.fragment, c), w(l.$$.fragment, c), w(o.$$.fragment, c), a = !0);
    },
    o(c) {
      C(e.$$.fragment, c), C(s.$$.fragment, c), C(l.$$.fragment, c), C(o.$$.fragment, c), a = !1;
    },
    d(c) {
      c && (S(t), S(n), S(r)), j(e, c), j(s, c), j(l, c), j(o, c);
    }
  };
}
f(KN, "create_if_block_1$v");
function hue(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.ManeuverIsStance",
      checked: (
        /*$item*/
        i[1].system.isStance
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[8]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      2 && (l.checked = /*$item*/
      s[1].system.isStance), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(hue, "create_default_slot_3$a");
function gue(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.SpellConcentration",
      checked: (
        /*$item*/
        i[1].system.concentration
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[9]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      2 && (l.checked = /*$item*/
      s[1].system.concentration), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(gue, "create_default_slot_2$a");
function bue(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("div"), t = E("input"), b(t, "type", "number"), b(t, "data-dtype", "Number"), b(t, "name", "system.exertionCost"), t.value = s = /*$item*/
      i[1].system.exertionCost, b(
        t,
        "id",
        /*appId*/
        i[3] + "-exertion-cost"
      ), b(e, "class", "u-w-20");
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = V(
        t,
        "change",
        /*change_handler*/
        i[10]
      ), n = !0);
    },
    p(r, o) {
      o & /*$item*/
      2 && s !== (s = /*$item*/
      r[1].system.exertionCost) && t.value !== s && (t.value = s);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(bue, "create_default_slot_1$b");
function _ue(i) {
  let e, t, s, n;
  const l = [mue, pue], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[0] ? 0 : 1
    );
  }
  return f(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let u = e;
      e = o(a), e === u ? r[e].p(a, c) : (ce(), C(r[u], 1, 1, () => {
        r[u] = null;
      }), ue(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), r[e].d(a);
    }
  };
}
f(_ue, "create_default_slot$v");
function yue(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "A5E.TabManeuverProperties",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[11]
          )
        }
      ],
      $$slots: { default: [_ue] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem"), z(t, "--a5e-section-heading-gap", "0.5rem"), z(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      1 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[11]
          )
        }
      ]), l & /*$$scope, $item, editMode*/
      4099 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(yue, "create_fragment$1d");
function vue(i, e, t) {
  let s;
  const n = fe("item");
  pe(i, n, (h) => t(1, s = h));
  const l = fe("appId"), { maneuverDegrees: r, maneuverTraditions: o } = CONFIG.A5E;
  let a = !1;
  return [
    a,
    s,
    n,
    l,
    r,
    o,
    /* @__PURE__ */ f((h) => se(s, "system.degree", h.detail), "updateSelection_handler"),
    /* @__PURE__ */ f((h) => se(s, "system.tradition", h.detail), "updateSelection_handler_1"),
    /* @__PURE__ */ f(({ detail: h }) => {
      se(s, "system.isStance", h);
    }, "updateSelection_handler_2"),
    /* @__PURE__ */ f(({ detail: h }) => {
      se(s, "system.concentration", h);
    }, "updateSelection_handler_3"),
    /* @__PURE__ */ f(({ target: h }) => se(s, h.name, Number(h.value)), "change_handler"),
    /* @__PURE__ */ f(() => t(0, a = !a), "func")
  ];
}
f(vue, "instance$17");
const cC = class cC extends ie {
  constructor(e) {
    super(), le(this, e, vue, yue, ne, {});
  }
};
f(cC, "ManeuverConfiguration");
let jk = cC;
function kue(i) {
  let e, t, s, n, l, r = (
    /*selectedMaterialProperties*/
    (i[2] || K("A5E.None")) + ""
  ), o;
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.MaterialProperties")}:`, n = R(), l = E("dd"), o = x(r), b(s, "class", "u-text-bold"), b(l, "class", "u-m-0 u-p-0"), b(t, "class", "u-flex u-gap-md"), b(e, "class", "a5e-box u-flex u-flex-col u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(t, s), A(t, n), A(t, l), A(l, o);
    },
    p(a, c) {
      c & /*selectedMaterialProperties*/
      4 && r !== (r = /*selectedMaterialProperties*/
      (a[2] || K("A5E.None")) + "") && _e(o, r);
    },
    i: ee,
    o: ee,
    d(a) {
      a && S(e);
    }
  };
}
f(kue, "create_else_block$c");
function wue(i) {
  let e, t, s = (
    /*$item*/
    i[0].system.materialProperties.includes("flaw")
  ), n, l;
  e = new Ze({
    props: {
      heading: "A5E.MaterialProperties",
      options: Object.entries(
        /*materialProperties*/
        i[5]
      ),
      selected: (
        /*$item*/
        i[0].system.materialProperties
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[6]
  );
  let r = s && YN(i);
  return {
    c() {
      L(e.$$.fragment), t = R(), r && r.c(), n = $e();
    },
    m(o, a) {
      N(e, o, a), T(o, t, a), r && r.m(o, a), T(o, n, a), l = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$item*/
      1 && (c.selected = /*$item*/
      o[0].system.materialProperties), e.$set(c), a & /*$item*/
      1 && (s = /*$item*/
      o[0].system.materialProperties.includes("flaw")), s ? r ? (r.p(o, a), a & /*$item*/
      1 && w(r, 1)) : (r = YN(o), r.c(), w(r, 1), r.m(n.parentNode, n)) : r && (ce(), C(r, 1, 1, () => {
        r = null;
      }), ue());
    },
    i(o) {
      l || (w(e.$$.fragment, o), w(r), l = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(r), l = !1;
    },
    d(o) {
      o && (S(t), S(n)), j(e, o), r && r.d(o);
    }
  };
}
f(wue, "create_if_block$E");
function YN(i) {
  let e, t;
  return e = new Ze({
    props: {
      heading: "Flaw Properties",
      options: Object.entries(
        /*flaws*/
        i[4]
      ),
      selected: (
        /*$item*/
        i[0].system.flaws
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[7]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.selected = /*$item*/
      s[0].system.flaws), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(YN, "create_if_block_1$u");
function $ue(i) {
  let e, t, s, n;
  const l = [wue, kue], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[1] ? 0 : 1
    );
  }
  return f(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let u = e;
      e = o(a), e === u ? r[e].p(a, c) : (ce(), C(r[u], 1, 1, () => {
        r[u] = null;
      }), ue(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), r[e].d(a);
    }
  };
}
f($ue, "create_default_slot$u");
function Aue(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "A5E.MaterialProperties",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[8]
          )
        }
      ],
      $$slots: { default: [$ue] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem"), z(t, "--a5e-section-heading-gap", "0.5rem"), z(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      2 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[8]
          )
        }
      ]), l & /*$$scope, $item, editMode, selectedMaterialProperties*/
      519 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(Aue, "create_fragment$1c");
function Eue(i, e, t) {
  let s, n;
  const l = fe("item");
  pe(i, l, (p) => t(0, n = p));
  const { flaws: r, materialProperties: o } = CONFIG.A5E;
  let a = !1;
  const c = /* @__PURE__ */ f((p) => se(n, "system.materialProperties", p.detail), "updateSelection_handler"), u = /* @__PURE__ */ f((p) => se(n, "system.flaws", p.detail), "updateSelection_handler_1"), d = /* @__PURE__ */ f(() => t(1, a = !a), "func");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1 && t(2, s = Z9(n).filter(Boolean).join(", "));
  }, [
    n,
    a,
    s,
    l,
    r,
    o,
    c,
    u,
    d
  ];
}
f(Eue, "instance$16");
const uC = class uC extends ie {
  constructor(e) {
    super(), le(this, e, Eue, Aue, ne, {});
  }
};
f(uC, "MaterialConfiguration");
let Lk = uC;
function Sue(i) {
  let e, t, s, n, l, r = (
    /*A5E*/
    (i[4].objectTypes[
      /*$item*/
      i[1].system.objectType
    ] ?? K("A5E.None")) + ""
  ), o, a, c, u, d, p, m = K(
    /*A5E*/
    i[4].itemRarity[
      /*$item*/
      i[1].system.rarity
    ] ?? /*$item*/
    i[1].system.rarity
  ) + "", g, h, _, y, k, v, O, P, D, I, B, F, H = (
    /*$item*/
    i[1].system.weight + ""
  ), G, U, q = K("A5E.DetailsWeightLbs") + "", W, X, te, J, re, ae, be, we = (
    /*$item*/
    (i[1].system.quantity || 0) + ""
  ), ve, me, he, Ae, Fe, Ve, je = (
    /*$item*/
    (i[1].system.price ?? K("A5E.None")) + ""
  ), Pe, rt;
  function Te(Oe, Je) {
    return (
      /*$item*/
      Oe[1].system.requiresAttunement ? Oue : Cue
    );
  }
  f(Te, "select_block_type_1");
  let Ee = Te(i), Be = Ee(i), Ce = (
    /*$item*/
    i[1].system.bulky && XN()
  ), Re = (
    /*$item*/
    i[1].system.craftingComponents != "" && JN(i)
  );
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.ObjectTypePrompt")}:`, n = R(), l = E("dd"), o = x(r), a = R(), c = E("div"), u = E("dt"), u.textContent = `${K("A5E.ItemRarity")}:`, d = R(), p = E("dd"), g = x(m), h = R(), _ = E("div"), y = E("dt"), y.textContent = `${K("A5E.Attunement")}:`, k = R(), v = E("dd"), Be.c(), O = R(), P = E("hr"), D = E("div"), I = E("dt"), I.textContent = `${K("A5E.ItemWeight")}:`, B = R(), F = E("dd"), G = x(H), U = R(), W = x(q), X = R(), Ce && Ce.c(), te = R(), J = E("div"), re = E("dt"), re.textContent = `${K("A5E.ItemQuantity")}:`, ae = R(), be = E("dd"), ve = x(we), me = R(), he = E("div"), Ae = E("dt"), Ae.textContent = `${K("A5E.ItemPrice")}:`, Fe = R(), Ve = E("dd"), Pe = x(je), rt = R(), Re && Re.c(), b(s, "class", "u-text-bold"), b(l, "class", "u-m-0 u-p-0"), b(t, "class", "u-flex u-gap-md"), b(u, "class", "u-text-bold"), b(p, "class", "u-m-0 u-p-0"), b(c, "class", "u-flex u-gap-md"), b(y, "class", "u-text-bold"), b(v, "class", "align-center u-flex u-gap-sm u-m-0 u-p-0"), b(_, "class", "u-flex u-gap-md"), b(P, "class", "a5e-rule u-my-sm"), b(I, "class", "u-text-bold"), b(F, "class", "align-center u-flex u-gap-sm u-m-0 u-p-0"), b(D, "class", "u-flex u-gap-md"), b(re, "class", "u-text-bold"), b(be, "class", "u-m-0 u-p-0"), b(J, "class", "u-flex u-gap-md"), b(Ae, "class", "u-text-bold"), b(Ve, "class", "u-m-0 u-p-0"), b(he, "class", "u-flex u-gap-md"), b(e, "class", "a5e-box u-flex u-flex-col u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(Oe, Je) {
      T(Oe, e, Je), A(e, t), A(t, s), A(t, n), A(t, l), A(l, o), A(t, a), A(e, c), A(c, u), A(c, d), A(c, p), A(p, g), A(c, h), A(e, _), A(_, y), A(_, k), A(_, v), Be.m(v, null), A(_, O), A(e, P), A(e, D), A(D, I), A(D, B), A(D, F), A(F, G), A(F, U), A(F, W), A(F, X), Ce && Ce.m(F, null), A(D, te), A(e, J), A(J, re), A(J, ae), A(J, be), A(be, ve), A(J, me), A(e, he), A(he, Ae), A(he, Fe), A(he, Ve), A(Ve, Pe), A(he, rt), Re && Re.m(e, null);
    },
    p(Oe, Je) {
      Je & /*$item*/
      2 && r !== (r = /*A5E*/
      (Oe[4].objectTypes[
        /*$item*/
        Oe[1].system.objectType
      ] ?? K("A5E.None")) + "") && _e(o, r), Je & /*$item*/
      2 && m !== (m = K(
        /*A5E*/
        Oe[4].itemRarity[
          /*$item*/
          Oe[1].system.rarity
        ] ?? /*$item*/
        Oe[1].system.rarity
      ) + "") && _e(g, m), Ee === (Ee = Te(Oe)) && Be ? Be.p(Oe, Je) : (Be.d(1), Be = Ee(Oe), Be && (Be.c(), Be.m(v, null))), Je & /*$item*/
      2 && H !== (H = /*$item*/
      Oe[1].system.weight + "") && _e(G, H), /*$item*/
      Oe[1].system.bulky ? Ce || (Ce = XN(), Ce.c(), Ce.m(F, null)) : Ce && (Ce.d(1), Ce = null), Je & /*$item*/
      2 && we !== (we = /*$item*/
      (Oe[1].system.quantity || 0) + "") && _e(ve, we), Je & /*$item*/
      2 && je !== (je = /*$item*/
      (Oe[1].system.price ?? K("A5E.None")) + "") && _e(Pe, je), /*$item*/
      Oe[1].system.craftingComponents != "" ? Re ? Re.p(Oe, Je) : (Re = JN(Oe), Re.c(), Re.m(e, null)) : Re && (Re.d(1), Re = null);
    },
    i: ee,
    o: ee,
    d(Oe) {
      Oe && S(e), Be.d(), Ce && Ce.d(), Re && Re.d();
    }
  };
}
f(Sue, "create_else_block$b");
function Tue(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k, v, O;
  e = new Ye({
    props: {
      heading: "A5E.ObjectTypePrompt",
      options: Object.entries(
        /*A5E*/
        i[4].objectTypes
      ),
      selected: (
        /*$item*/
        i[1].system.objectType
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  ), s = new Ye({
    props: {
      heading: "A5E.ItemRarity",
      options: Object.entries(
        /*A5E*/
        i[4].itemRarity
      ),
      selected: (
        /*$item*/
        i[1].system.rarity
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[8]
  ), l = new Me({
    props: {
      $$slots: { default: [Iue] },
      $$scope: { ctx: i }
    }
  }), a = new de({
    props: {
      heading: "A5E.ItemWeight",
      $$slots: { default: [Pue] },
      $$scope: { ctx: i }
    }
  }), d = new Ye({
    props: {
      heading: "A5E.ItemEquippedState",
      options: Object.entries(
        /*A5E*/
        i[4].equippedStates
      ),
      selected: (
        /*$item*/
        i[1].system.equippedState
      )
    }
  }), d.$on(
    "updateSelection",
    /*updateSelection_handler_7*/
    i[15]
  ), m = new de({
    props: {
      heading: "A5E.ItemQuantity",
      $$slots: { default: [Mue] },
      $$scope: { ctx: i }
    }
  }), h = new de({
    props: {
      heading: "A5E.ItemPrice",
      $$slots: { default: [Rue] },
      $$scope: { ctx: i }
    }
  }), y = new de({
    props: {
      heading: "A5E.CraftingComponents",
      $$slots: { default: [Fue] },
      $$scope: { ctx: i }
    }
  });
  let P = !/*hideBrokenAndDamaged*/
  i[6] && Nue(i);
  return {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), r = E("div"), L(l.$$.fragment), o = R(), c = E("div"), L(a.$$.fragment), u = R(), L(d.$$.fragment), p = R(), L(m.$$.fragment), g = R(), L(h.$$.fragment), _ = R(), L(y.$$.fragment), k = R(), P && P.c(), v = $e(), z(r, "display", "contents"), z(r, "--a5e-section-body-direction", "row"), z(r, "--a5e-section-body-gap", "0.75rem"), z(c, "display", "contents"), z(c, "--a5e-field-wrapper-gap", "0.375rem 1rem"), z(c, "--a5e-field-wrapper-direction", "row"), z(c, "--a5e-field-wrapper-header-width", "100%");
    },
    m(D, I) {
      N(e, D, I), T(D, t, I), N(s, D, I), T(D, n, I), T(D, r, I), N(l, r, null), T(D, o, I), T(D, c, I), N(a, c, null), T(D, u, I), N(d, D, I), T(D, p, I), N(m, D, I), T(D, g, I), N(h, D, I), T(D, _, I), N(y, D, I), T(D, k, I), P && P.m(D, I), T(D, v, I), O = !0;
    },
    p(D, I) {
      const B = {};
      I & /*$item*/
      2 && (B.selected = /*$item*/
      D[1].system.objectType), e.$set(B);
      const F = {};
      I & /*$item*/
      2 && (F.selected = /*$item*/
      D[1].system.rarity), s.$set(F);
      const H = {};
      I & /*$$scope, $item*/
      2097154 && (H.$$scope = { dirty: I, ctx: D }), l.$set(H);
      const G = {};
      I & /*$$scope, $item*/
      2097154 && (G.$$scope = { dirty: I, ctx: D }), a.$set(G);
      const U = {};
      I & /*$item*/
      2 && (U.selected = /*$item*/
      D[1].system.equippedState), d.$set(U);
      const q = {};
      I & /*$$scope, $item*/
      2097154 && (q.$$scope = { dirty: I, ctx: D }), m.$set(q);
      const W = {};
      I & /*$$scope, $item*/
      2097154 && (W.$$scope = { dirty: I, ctx: D }), h.$set(W);
      const X = {};
      I & /*$$scope, $item*/
      2097154 && (X.$$scope = { dirty: I, ctx: D }), y.$set(X), /*hideBrokenAndDamaged*/
      D[6] || P.p(D, I);
    },
    i(D) {
      O || (w(e.$$.fragment, D), w(s.$$.fragment, D), w(l.$$.fragment, D), w(a.$$.fragment, D), w(d.$$.fragment, D), w(m.$$.fragment, D), w(h.$$.fragment, D), w(y.$$.fragment, D), w(P), O = !0);
    },
    o(D) {
      C(e.$$.fragment, D), C(s.$$.fragment, D), C(l.$$.fragment, D), C(a.$$.fragment, D), C(d.$$.fragment, D), C(m.$$.fragment, D), C(h.$$.fragment, D), C(y.$$.fragment, D), C(P), O = !1;
    },
    d(D) {
      D && (S(t), S(n), S(o), S(u), S(p), S(g), S(_), S(k), S(v)), j(e, D), j(s, D), D && l && S(r), j(l, D), D && a && S(c), j(a, D), j(d, D), j(m, D), j(h, D), j(y, D), P && P.d(D);
    }
  };
}
f(Tue, "create_if_block$D");
function Cue(i) {
  let e = K("A5E.AttunementNotRequired") + "", t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p: ee,
    d(s) {
      s && S(t);
    }
  };
}
f(Cue, "create_else_block_1$3");
function Oue(i) {
  let e = K("A5E.AttunementRequired") + "", t, s, n = K(
    /*$item*/
    i[1].system.attuned ? "A5E.Attuned" : "A5E.AttunedNot"
  ) + "", l, r;
  return {
    c() {
      t = x(e), s = x(`

                        (`), l = x(n), r = x(")");
    },
    m(o, a) {
      T(o, t, a), T(o, s, a), T(o, l, a), T(o, r, a);
    },
    p(o, a) {
      a & /*$item*/
      2 && n !== (n = K(
        /*$item*/
        o[1].system.attuned ? "A5E.Attuned" : "A5E.AttunedNot"
      ) + "") && _e(l, n);
    },
    d(o) {
      o && (S(t), S(s), S(l), S(r));
    }
  };
}
f(Oue, "create_if_block_6$6");
function XN(i) {
  let e, t = K("A5E.ItemBulky") + "", s, n;
  return {
    c() {
      e = x("("), s = x(t), n = x(")");
    },
    m(l, r) {
      T(l, e, r), T(l, s, r), T(l, n, r);
    },
    d(l) {
      l && (S(e), S(s), S(n));
    }
  };
}
f(XN, "create_if_block_5$7");
function JN(i) {
  let e, t, s, n, l = (
    /*$item*/
    (i[1].system.craftingComponents ?? K("A5E.None")) + ""
  ), r;
  return {
    c() {
      e = E("div"), t = E("dt"), t.textContent = `${K("A5E.CraftingComponents")}:`, s = R(), n = E("dd"), r = x(l), b(t, "class", "u-text-bold"), b(n, "class", "u-m-0 u-p-0"), b(e, "class", "u-flex u-gap-md");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(e, s), A(e, n), A(n, r);
    },
    p(o, a) {
      a & /*$item*/
      2 && l !== (l = /*$item*/
      (o[1].system.craftingComponents ?? K("A5E.None")) + "") && _e(r, l);
    },
    d(o) {
      o && S(e);
    }
  };
}
f(JN, "create_if_block_4$c");
function ZN(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.AttunementPrompt",
      checked: (
        /*$item*/
        i[1].system.attuned
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[10]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      2 && (l.checked = /*$item*/
      s[1].system.attuned), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(ZN, "create_if_block_3$d");
function Due(i) {
  let e, t, s, n;
  return e = new De({
    props: {
      label: "A5E.PlotItem",
      checked: (
        /*$item*/
        i[1].system.plotItem
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[11]
  ), s = new De({
    props: {
      label: "A5E.ItemUnidentified",
      checked: (
        /*$item*/
        i[1].system.unidentified
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[12]
  ), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$item*/
      2 && (o.checked = /*$item*/
      l[1].system.plotItem), e.$set(o);
      const a = {};
      r & /*$item*/
      2 && (a.checked = /*$item*/
      l[1].system.unidentified), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(Due, "create_if_block_2$l");
function Iue(i) {
  let e, t, s, n, l;
  e = new De({
    props: {
      label: "A5E.AttunementRequiredPrompt",
      checked: (
        /*$item*/
        i[1].system.requiresAttunement
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[9]
  );
  let r = (
    /*$item*/
    i[1].actor && /*$item*/
    i[1].system.requiresAttunement && ZN(i)
  ), o = (
    /*isGM*/
    i[5] && Due(i)
  );
  return {
    c() {
      L(e.$$.fragment), t = R(), r && r.c(), s = R(), o && o.c(), n = $e();
    },
    m(a, c) {
      N(e, a, c), T(a, t, c), r && r.m(a, c), T(a, s, c), o && o.m(a, c), T(a, n, c), l = !0;
    },
    p(a, c) {
      const u = {};
      c & /*$item*/
      2 && (u.checked = /*$item*/
      a[1].system.requiresAttunement), e.$set(u), /*$item*/
      a[1].actor && /*$item*/
      a[1].system.requiresAttunement ? r ? (r.p(a, c), c & /*$item*/
      2 && w(r, 1)) : (r = ZN(a), r.c(), w(r, 1), r.m(s.parentNode, s)) : r && (ce(), C(r, 1, 1, () => {
        r = null;
      }), ue()), /*isGM*/
      a[5] && o.p(a, c);
    },
    i(a) {
      l || (w(e.$$.fragment, a), w(r), w(o), l = !0);
    },
    o(a) {
      C(e.$$.fragment, a), C(r), C(o), l = !1;
    },
    d(a) {
      a && (S(t), S(s), S(n)), j(e, a), r && r.d(a), o && o.d(a);
    }
  };
}
f(Iue, "create_default_slot_5$7");
function Pue(i) {
  let e, t, s, n, l, r, o, a, c, u;
  return o = new De({
    props: {
      label: "A5E.ItemBulky",
      checked: (
        /*$item*/
        i[1].system.bulky
      )
    }
  }), o.$on(
    "updateSelection",
    /*updateSelection_handler_6*/
    i[14]
  ), {
    c() {
      e = E("div"), t = E("input"), n = R(), l = E("span"), l.textContent = `${K("A5E.DetailsWeightLbs")}`, r = R(), L(o.$$.fragment), b(t, "type", "number"), b(t, "data-dtype", "Number"), b(t, "name", "system.weight"), b(
        t,
        "id",
        /*appId*/
        i[3] + "-weight"
      ), t.value = s = /*$item*/
      i[1].system.weight, b(e, "class", "u-align-center u-flex u-gap-md u-w-30");
    },
    m(d, p) {
      T(d, e, p), A(e, t), A(e, n), A(e, l), T(d, r, p), N(o, d, p), a = !0, c || (u = V(
        t,
        "change",
        /*change_handler*/
        i[13]
      ), c = !0);
    },
    p(d, p) {
      (!a || p & /*$item*/
      2 && s !== (s = /*$item*/
      d[1].system.weight) && t.value !== s) && (t.value = s);
      const m = {};
      p & /*$item*/
      2 && (m.checked = /*$item*/
      d[1].system.bulky), o.$set(m);
    },
    i(d) {
      a || (w(o.$$.fragment, d), a = !0);
    },
    o(d) {
      C(o.$$.fragment, d), a = !1;
    },
    d(d) {
      d && (S(e), S(r)), j(o, d), c = !1, u();
    }
  };
}
f(Pue, "create_default_slot_4$8");
function Mue(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("div"), t = E("input"), b(t, "type", "number"), b(t, "data-dtype", "Number"), b(t, "min", "0"), b(t, "max", "9999"), b(t, "name", "system.quantity"), b(t, "id", `${/*appId*/
      i[3]}-quantity`), t.value = s = /*$item*/
      i[1].system.quantity, b(e, "class", "u-w-20");
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = V(
        t,
        "change",
        /*change_handler_1*/
        i[16]
      ), n = !0);
    },
    p(r, o) {
      o & /*$item*/
      2 && s !== (s = /*$item*/
      r[1].system.quantity) && t.value !== s && (t.value = s);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(Mue, "create_default_slot_3$9");
function Rue(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("div"), t = E("input"), b(t, "class", "u-pl-lg"), b(t, "type", "text"), b(t, "name", "system.price"), b(t, "id", `${/*appId*/
      i[3]}-price`), t.value = s = /*$item*/
      i[1].system.price, b(e, "class", "u-align-center u-flex u-gap-md u-w-30");
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = V(
        t,
        "change",
        /*change_handler_2*/
        i[17]
      ), n = !0);
    },
    p(r, o) {
      o & /*$item*/
      2 && s !== (s = /*$item*/
      r[1].system.price) && t.value !== s && (t.value = s);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(Rue, "create_default_slot_2$9");
function Fue(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "u-pl-lg"), b(e, "type", "text"), b(e, "name", "system.craftingComponents"), e.value = t = /*$item*/
      i[1].system.craftingComponents, b(e, "id", `${/*appId*/
      i[3]}-craftingComponents`);
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_3*/
        i[18]
      ), s = !0);
    },
    p(l, r) {
      r & /*$item*/
      2 && t !== (t = /*$item*/
      l[1].system.craftingComponents) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Fue, "create_default_slot_1$a");
function Nue(i) {
  let e, t;
  return e = new Ye({
    props: {
      heading: "A5E.ItemCondition",
      options: Object.entries(
        /*A5E*/
        i[4].damagedStates
      ),
      selected: (
        /*$item*/
        i[1].system.damagedState
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_8*/
    i[19]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      2 && (l.selected = /*$item*/
      s[1].system.damagedState), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Nue, "create_if_block_1$t");
function jue(i) {
  let e, t, s, n;
  const l = [Tue, Sue], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[0] ? 0 : 1
    );
  }
  return f(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let u = e;
      e = o(a), e === u ? r[e].p(a, c) : (ce(), C(r[u], 1, 1, () => {
        r[u] = null;
      }), ue(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), r[e].d(a);
    }
  };
}
f(jue, "create_default_slot$t");
function Lue(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "A5E.TabObjectProperties",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[20]
          )
        }
      ],
      $$slots: { default: [jue] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem"), z(t, "--a5e-section-heading-gap", "0.5rem"), z(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      1 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[20]
          )
        }
      ]), l & /*$$scope, $item, editMode*/
      2097155 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(Lue, "create_fragment$1b");
function Bue(i, e, t) {
  let s;
  const n = fe("item");
  pe(i, n, (B) => t(1, s = B));
  const l = fe("appId"), { A5E: r } = CONFIG, { isGM: o } = game.user;
  let a = !1, c = game.settings.get("a5e", "hideBrokenAndDamaged");
  return [
    a,
    s,
    n,
    l,
    r,
    o,
    c,
    /* @__PURE__ */ f((B) => se(s, "system.objectType", B.detail), "updateSelection_handler"),
    /* @__PURE__ */ f((B) => se(s, "system.rarity", B.detail), "updateSelection_handler_1"),
    /* @__PURE__ */ f(({ detail: B }) => se(s, "system.requiresAttunement", B), "updateSelection_handler_2"),
    /* @__PURE__ */ f(({ detail: B }) => se(s, "system.attuned", B), "updateSelection_handler_3"),
    /* @__PURE__ */ f(({ detail: B }) => se(s, "system.plotItem", B), "updateSelection_handler_4"),
    /* @__PURE__ */ f(({ detail: B }) => se(s, "system.unidentified", B), "updateSelection_handler_5"),
    /* @__PURE__ */ f(({ target: B }) => se(s, B.name, Number(B.value)), "change_handler"),
    /* @__PURE__ */ f(({ detail: B }) => se(s, "system.bulky", B), "updateSelection_handler_6"),
    /* @__PURE__ */ f(({ detail: B }) => se(s, "system.equippedState", parseInt(B, 10)), "updateSelection_handler_7"),
    /* @__PURE__ */ f(({ target: B }) => se(s, B.name, Number(B.value)), "change_handler_1"),
    /* @__PURE__ */ f(({ target: B }) => se(s, B.name, B.value), "change_handler_2"),
    /* @__PURE__ */ f(({ target: B }) => se(s, B.name, B.value), "change_handler_3"),
    /* @__PURE__ */ f(({ detail: B }) => se(s, "system.damagedState", parseInt(B, 10)), "updateSelection_handler_8"),
    /* @__PURE__ */ f(() => t(0, a = !a), "func")
  ];
}
f(Bue, "instance$15");
const fC = class fC extends ie {
  constructor(e) {
    super(), le(this, e, Bue, Lue, ne, {});
  }
};
f(fC, "ObjectConfiguration");
let Bk = fC;
function QN(i) {
  return i.sort((e, t) => e.toLowerCase().localeCompare(t.toLowerCase()));
}
f(QN, "localeSort");
function xN(i, e, t) {
  const s = i.slice();
  return s[8] = e[t], s;
}
f(xN, "get_each_context$q");
function que(i) {
  let e, t, s, n, l, r, o, a, c, u;
  function d(y, k) {
    return (
      /*$item*/
      y[1].system.shieldCategory ? Hue : zue
    );
  }
  f(d, "select_block_type_1");
  let p = d(i), m = p(i);
  function g(y, k) {
    var v;
    return (
      /*$item*/
      (v = y[1].system.shieldProperties) != null && v.length ? Vue : Uue
    );
  }
  f(g, "select_block_type_2");
  let h = g(i), _ = h(i);
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.ShieldCategory")}:`, n = R(), l = E("dd"), m.c(), r = R(), o = E("div"), a = E("dt"), a.textContent = `${K("A5E.ShieldProperties")}:`, c = R(), u = E("dd"), _.c(), b(s, "class", "u-text-bold"), b(l, "class", "u-m-0 u-p-0"), b(t, "class", "u-flex u-gap-md"), b(a, "class", "u-text-bold"), b(u, "class", "u-m-0 u-p-0"), b(o, "class", "u-flex u-gap-md"), b(e, "class", "a5e-box u-flex u-flex-col u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(y, k) {
      T(y, e, k), A(e, t), A(t, s), A(t, n), A(t, l), m.m(l, null), A(t, r), A(e, o), A(o, a), A(o, c), A(o, u), _.m(u, null);
    },
    p(y, k) {
      p === (p = d(y)) && m ? m.p(y, k) : (m.d(1), m = p(y), m && (m.c(), m.m(l, null))), h === (h = g(y)) && _ ? _.p(y, k) : (_.d(1), _ = h(y), _ && (_.c(), _.m(u, null)));
    },
    i: ee,
    o: ee,
    d(y) {
      y && S(e), m.d(), _.d();
    }
  };
}
f(que, "create_else_block$a");
function Gue(i) {
  let e, t, s, n;
  return e = new Ye({
    props: {
      heading: "A5E.ShieldCategory",
      options: Object.entries(
        /*shieldTypes*/
        i[3]
      ),
      selected: (
        /*$item*/
        i[1].system.shieldCategory
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[5]
  ), s = new Ze({
    props: {
      heading: "A5E.ShieldProperties",
      options: Object.entries(
        /*shieldProperties*/
        i[4]
      ),
      selected: (
        /*$item*/
        i[1].system.shieldProperties
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[6]
  ), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$item*/
      2 && (o.selected = /*$item*/
      l[1].system.shieldCategory), e.$set(o);
      const a = {};
      r & /*$item*/
      2 && (a.selected = /*$item*/
      l[1].system.shieldProperties), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(Gue, "create_if_block$C");
function zue(i) {
  let e = K("A5E.Unknown") + "", t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p: ee,
    d(s) {
      s && S(t);
    }
  };
}
f(zue, "create_else_block_2$1");
function Hue(i) {
  let e = (
    /*shieldTypes*/
    (i[3][
      /*$item*/
      i[1].system.shieldCategory
    ] ?? /*$item*/
    i[1].system.shieldCategory) + ""
  ), t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*$item*/
      2 && e !== (e = /*shieldTypes*/
      (s[3][
        /*$item*/
        s[1].system.shieldCategory
      ] ?? /*$item*/
      s[1].system.shieldCategory) + "") && _e(t, e);
    },
    d(s) {
      s && S(t);
    }
  };
}
f(Hue, "create_if_block_2$k");
function Uue(i) {
  let e = K("A5E.None") + "", t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p: ee,
    d(s) {
      s && S(t);
    }
  };
}
f(Uue, "create_else_block_1$2");
function Vue(i) {
  let e, t = oe(QN(
    /*$item*/
    i[1].system.shieldProperties
  )), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = e8(xN(i, t, n));
  return {
    c() {
      e = E("ul");
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      b(e, "class", "u-comma-list u-flex u-flex-shrink-0 u-gap-ch u-list-style-none u-m-0 u-p-0 u-w-fit ");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l & /*$item, shieldProperties*/
      18) {
        t = oe(QN(
          /*$item*/
          n[1].system.shieldProperties
        ));
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = xN(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = e8(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && S(e), Le(s, n);
    }
  };
}
f(Vue, "create_if_block_1$s");
function e8(i) {
  let e, t = (
    /*shieldProperties*/
    (i[4][
      /*property*/
      i[8]
    ] ?? /*property*/
    i[8]) + ""
  ), s, n, l;
  return {
    c() {
      e = E("li"), s = x(t), n = R(), b(e, "key", l = /*property*/
      i[8]);
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      o & /*$item*/
      2 && t !== (t = /*shieldProperties*/
      (r[4][
        /*property*/
        r[8]
      ] ?? /*property*/
      r[8]) + "") && _e(s, t), o & /*$item*/
      2 && l !== (l = /*property*/
      r[8]) && b(e, "key", l);
    },
    d(r) {
      r && S(e);
    }
  };
}
f(e8, "create_each_block$q");
function Wue(i) {
  let e, t, s, n;
  const l = [Gue, que], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[0] ? 0 : 1
    );
  }
  return f(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let u = e;
      e = o(a), e === u ? r[e].p(a, c) : (ce(), C(r[u], 1, 1, () => {
        r[u] = null;
      }), ue(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), r[e].d(a);
    }
  };
}
f(Wue, "create_default_slot$s");
function Kue(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "A5E.ShieldConfiguration",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[7]
          )
        }
      ],
      $$slots: { default: [Wue] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem"), z(t, "--a5e-section-heading-gap", "0.5rem"), z(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      1 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[0] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[7]
          )
        }
      ]), l & /*$$scope, $item, editMode*/
      2051 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(Kue, "create_fragment$1a");
function Yue(i, e, t) {
  let s;
  const n = fe("item");
  pe(i, n, (d) => t(1, s = d));
  let l = !1;
  const { shieldTypes: r, shieldProperties: o } = CONFIG.A5E;
  return [
    l,
    s,
    n,
    r,
    o,
    /* @__PURE__ */ f((d) => se(s, "system.shieldCategory", d.detail), "updateSelection_handler"),
    /* @__PURE__ */ f((d) => se(s, "system.shieldProperties", d.detail), "updateSelection_handler_1"),
    /* @__PURE__ */ f(() => t(0, l = !l), "func")
  ];
}
f(Yue, "instance$14");
const dC = class dC extends ie {
  constructor(e) {
    super(), le(this, e, Yue, Kue, ne, {});
  }
};
f(dC, "ShieldConfiguration");
let qk = dC;
function t8(i, e, t) {
  const s = i.slice();
  return s[26] = e[t][0], s[27] = e[t][1], s;
}
f(t8, "get_each_context$p");
function Xue(i) {
  let e, t;
  return e = new bt({
    props: {
      $$slots: { default: [Zue] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $item, selectedSpellComponents, selectedSecondarySpellSchools*/
      1073741837 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Xue, "create_else_block$9");
function Jue(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y;
  e = new Ze({
    props: {
      heading: "Classes",
      hint: "Select the classes that are eligible to select this spell.",
      options: Object.entries(
        /*classSpellLists*/
        i[6]
      ),
      selected: (
        /*$item*/
        i[0].system.classes
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[10]
  ), s = new Ye({
    props: {
      heading: "A5E.SpellLevel",
      options: dq(
        /*spellLevels*/
        i[8]
      ),
      selected: (
        /*$item*/
        i[0].system.level
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[11]
  ), l = new Ye({
    props: {
      heading: "A5E.SpellSchoolPrimary",
      options: Object.entries(
        /*spellSchools*/
        i[9].primary
      ),
      selected: (
        /*$item*/
        i[0].system.schools.primary
      )
    }
  }), l.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[12]
  ), o = new Ze({
    props: {
      heading: "A5E.SpellSchoolSecondaryPlural",
      options: Object.entries(
        /*spellSchools*/
        i[9].secondary
      ),
      selected: (
        /*$item*/
        i[0].system.schools.secondary
      )
    }
  }), o.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[13]
  ), c = new de({
    props: {
      heading: "A5E.SpellComponents",
      $$slots: { default: [Que] },
      $$scope: { ctx: i }
    }
  });
  let k = (
    /*$item*/
    i[0].system.components.material && i8(i)
  );
  return p = new Me({
    props: {
      $$slots: { default: [efe] },
      $$scope: { ctx: i }
    }
  }), h = new Me({
    props: {
      $$slots: { default: [sfe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment), r = R(), L(o.$$.fragment), a = R(), L(c.$$.fragment), u = R(), k && k.c(), d = R(), m = E("div"), L(p.$$.fragment), g = R(), _ = E("div"), L(h.$$.fragment), z(m, "display", "contents"), z(m, "--a5e-section-body-direction", "row"), z(m, "--a5e-section-body-gap", "0.75rem"), z(_, "display", "contents"), z(_, "--a5e-section-body-direction", "row"), z(_, "--a5e-section-body-gap", "0.75rem");
    },
    m(v, O) {
      N(e, v, O), T(v, t, O), N(s, v, O), T(v, n, O), N(l, v, O), T(v, r, O), N(o, v, O), T(v, a, O), N(c, v, O), T(v, u, O), k && k.m(v, O), T(v, d, O), T(v, m, O), N(p, m, null), T(v, g, O), T(v, _, O), N(h, _, null), y = !0;
    },
    p(v, O) {
      const P = {};
      O & /*$item*/
      1 && (P.selected = /*$item*/
      v[0].system.classes), e.$set(P);
      const D = {};
      O & /*$item*/
      1 && (D.selected = /*$item*/
      v[0].system.level), s.$set(D);
      const I = {};
      O & /*$item*/
      1 && (I.selected = /*$item*/
      v[0].system.schools.primary), l.$set(I);
      const B = {};
      O & /*$item*/
      1 && (B.selected = /*$item*/
      v[0].system.schools.secondary), o.$set(B);
      const F = {};
      O & /*$$scope, $item*/
      1073741825 && (F.$$scope = { dirty: O, ctx: v }), c.$set(F), /*$item*/
      v[0].system.components.material ? k ? (k.p(v, O), O & /*$item*/
      1 && w(k, 1)) : (k = i8(v), k.c(), w(k, 1), k.m(d.parentNode, d)) : k && (ce(), C(k, 1, 1, () => {
        k = null;
      }), ue());
      const H = {};
      O & /*$$scope, $item*/
      1073741825 && (H.$$scope = { dirty: O, ctx: v }), p.$set(H);
      const G = {};
      O & /*$$scope, $item*/
      1073741825 && (G.$$scope = { dirty: O, ctx: v }), h.$set(G);
    },
    i(v) {
      y || (w(e.$$.fragment, v), w(s.$$.fragment, v), w(l.$$.fragment, v), w(o.$$.fragment, v), w(c.$$.fragment, v), w(k), w(p.$$.fragment, v), w(h.$$.fragment, v), y = !0);
    },
    o(v) {
      C(e.$$.fragment, v), C(s.$$.fragment, v), C(l.$$.fragment, v), C(o.$$.fragment, v), C(c.$$.fragment, v), C(k), C(p.$$.fragment, v), C(h.$$.fragment, v), y = !1;
    },
    d(v) {
      v && (S(t), S(n), S(r), S(a), S(u), S(d), S(g)), j(e, v), j(s, v), j(l, v), j(o, v), j(c, v), k && k.d(v), v && p && S(m), j(p, v), v && h && S(_), j(h, v);
    }
  };
}
f(Jue, "create_if_block$B");
function s8(i) {
  let e, t, s, n, l = (
    /*$item*/
    i[0].system.materials + ""
  ), r;
  return {
    c() {
      e = E("div"), t = E("dt"), t.textContent = `${K("A5E.SpellMaterials")}:`, s = R(), n = E("dd"), r = x(l), b(t, "class", "summary-list__label svelte-1spbjs8"), b(n, "class", "summary-list__value svelte-1spbjs8"), b(e, "class", "summary-list__item svelte-1spbjs8");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(e, s), A(e, n), A(n, r);
    },
    p(o, a) {
      a & /*$item*/
      1 && l !== (l = /*$item*/
      o[0].system.materials + "") && _e(r, l);
    },
    d(o) {
      o && S(e);
    }
  };
}
f(s8, "create_if_block_4$b");
function Zue(i) {
  let e, t, s, n, l, r = (
    /*spellLevels*/
    i[8][
      /*$item*/
      i[0].system.level
    ] + ""
  ), o, a, c, u, d, p, m = (
    /*spellSchools*/
    i[9].primary[
      /*$item*/
      i[0].system.schools.primary
    ] + ""
  ), g, h, _, y, k, v, O = (
    /*selectedSecondarySpellSchools*/
    (i[2] || K("A5E.None")) + ""
  ), P, D, I, B, F, H, G, U = (
    /*selectedSpellComponents*/
    (i[3] || K("A5E.None")) + ""
  ), q, W, X = (
    /*$item*/
    i[0].system.components.material && /*$item*/
    i[0].system.materials && s8(i)
  );
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.SpellLevel")}:`, n = R(), l = E("dd"), o = x(r), a = R(), c = E("div"), u = E("dt"), u.textContent = `${K("A5E.SpellSchoolPrimary")}:`, d = R(), p = E("dd"), g = x(m), h = R(), _ = E("div"), y = E("dt"), y.textContent = `${K("A5E.SpellSchoolSecondaryPlural")}:`, k = R(), v = E("dd"), P = x(O), D = R(), I = E("hr"), B = E("div"), F = E("dt"), F.textContent = `${K("A5E.SpellComponents")}:`, H = R(), G = E("dd"), q = x(U), W = R(), X && X.c(), b(s, "class", "summary-list__label svelte-1spbjs8"), b(l, "class", "summary-list__value svelte-1spbjs8"), b(t, "class", "summary-list__item svelte-1spbjs8"), b(u, "class", "summary-list__label svelte-1spbjs8"), b(p, "class", "summary-list__value svelte-1spbjs8"), b(c, "class", "summary-list__item svelte-1spbjs8"), b(y, "class", "summary-list__label svelte-1spbjs8"), b(v, "class", "summary-list__value svelte-1spbjs8"), b(_, "class", "summary-list__item svelte-1spbjs8"), b(I, "class", "a5e-rule u-my-sm"), b(F, "class", "summary-list__label svelte-1spbjs8"), b(G, "class", "summary-list__value svelte-1spbjs8"), b(B, "class", "summary-list__item svelte-1spbjs8"), b(e, "class", "summary-list svelte-1spbjs8");
    },
    m(te, J) {
      T(te, e, J), A(e, t), A(t, s), A(t, n), A(t, l), A(l, o), A(t, a), A(e, c), A(c, u), A(c, d), A(c, p), A(p, g), A(c, h), A(e, _), A(_, y), A(_, k), A(_, v), A(v, P), A(_, D), A(e, I), A(e, B), A(B, F), A(B, H), A(B, G), A(G, q), A(B, W), X && X.m(e, null);
    },
    p(te, J) {
      J & /*$item*/
      1 && r !== (r = /*spellLevels*/
      te[8][
        /*$item*/
        te[0].system.level
      ] + "") && _e(o, r), J & /*$item*/
      1 && m !== (m = /*spellSchools*/
      te[9].primary[
        /*$item*/
        te[0].system.schools.primary
      ] + "") && _e(g, m), J & /*selectedSecondarySpellSchools*/
      4 && O !== (O = /*selectedSecondarySpellSchools*/
      (te[2] || K("A5E.None")) + "") && _e(P, O), J & /*selectedSpellComponents*/
      8 && U !== (U = /*selectedSpellComponents*/
      (te[3] || K("A5E.None")) + "") && _e(q, U), /*$item*/
      te[0].system.components.material && /*$item*/
      te[0].system.materials ? X ? X.p(te, J) : (X = s8(te), X.c(), X.m(e, null)) : X && (X.d(1), X = null);
    },
    d(te) {
      te && S(e), X && X.d();
    }
  };
}
f(Zue, "create_default_slot_6$5");
function n8(i) {
  let e, t;
  function s() {
    return (
      /*tagToggle_handler*/
      i[14](
        /*value*/
        i[26]
      )
    );
  }
  return f(s, "tagToggle_handler"), e = new Cr({
    props: {
      label: (
        /*label*/
        i[27]
      ),
      value: (
        /*value*/
        i[26]
      ),
      active: (
        /*$item*/
        i[0].system.components[
          /*value*/
          i[26]
        ]
      )
    }
  }), e.$on("tagToggle", s), {
    c() {
      L(e.$$.fragment);
    },
    m(n, l) {
      N(e, n, l), t = !0;
    },
    p(n, l) {
      i = n;
      const r = {};
      l & /*$item*/
      1 && (r.active = /*$item*/
      i[0].system.components[
        /*value*/
        i[26]
      ]), e.$set(r);
    },
    i(n) {
      t || (w(e.$$.fragment, n), t = !0);
    },
    o(n) {
      C(e.$$.fragment, n), t = !1;
    },
    d(n) {
      j(e, n);
    }
  };
}
f(n8, "create_each_block$p");
function Que(i) {
  let e, t, s = oe(Object.entries(
    /*spellComponents*/
    i[7]
  )), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = n8(t8(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("ul");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "u-flex u-flex-wrap u-gap-sm u-list-style-none u-m-0 u-p-0 u-text-xs u-w-full");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, o) {
      if (o & /*Object, spellComponents, $item*/
      129) {
        s = oe(Object.entries(
          /*spellComponents*/
          r[7]
        ));
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = t8(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = n8(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f(Que, "create_default_slot_5$6");
function i8(i) {
  let e, t;
  return e = new de({
    props: {
      heading: "A5E.SpellMaterials",
      $$slots: { default: [xue] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $item*/
      1073741825 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(i8, "create_if_block_3$c");
function xue(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), b(e, "name", "system.materials"), e.value = t = /*$item*/
      i[0].system.materials;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[15]
      ), s = !0);
    },
    p(l, r) {
      r & /*$item*/
      1 && t !== (t = /*$item*/
      l[0].system.materials) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(xue, "create_default_slot_4$7");
function l8(i) {
  let e, t;
  return e = new De({
    props: {
      label: "Always Prepared",
      checked: Number(
        /*$item*/
        i[0].system.prepared ?? 0
      ) === /*PREPARED_STATES*/
      i[5].ALWAYS_PREPARED
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_6*/
    i[18]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.checked = Number(
        /*$item*/
        s[0].system.prepared ?? 0
      ) === /*PREPARED_STATES*/
      s[5].ALWAYS_PREPARED), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(l8, "create_if_block_2$j");
function r8(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.SpellRitual",
      checked: (
        /*$item*/
        i[0].system.ritual
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_7*/
    i[19]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.checked = /*$item*/
      s[0].system.ritual), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(r8, "create_if_block_1$r");
function efe(i) {
  let e, t, s, n, l, r, o, a;
  e = new De({
    props: {
      label: "A5E.SpellConcentration",
      checked: (
        /*$item*/
        i[0].system.concentration
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[16]
  ), s = new De({
    props: {
      label: "A5E.ItemPrepared",
      checked: (
        /*$item*/
        i[0].system.prepared
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[17]
  );
  let c = (
    /*$item*/
    i[0].system.prepared && l8(i)
  ), u = (
    /*$item*/
    i[0].system.level > 0 && r8(i)
  );
  return o = new De({
    props: {
      label: "A5E.SpellRare",
      checked: (
        /*$item*/
        i[0].system.rare
      )
    }
  }), o.$on(
    "updateSelection",
    /*updateSelection_handler_8*/
    i[20]
  ), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), c && c.c(), l = R(), u && u.c(), r = R(), L(o.$$.fragment);
    },
    m(d, p) {
      N(e, d, p), T(d, t, p), N(s, d, p), T(d, n, p), c && c.m(d, p), T(d, l, p), u && u.m(d, p), T(d, r, p), N(o, d, p), a = !0;
    },
    p(d, p) {
      const m = {};
      p & /*$item*/
      1 && (m.checked = /*$item*/
      d[0].system.concentration), e.$set(m);
      const g = {};
      p & /*$item*/
      1 && (g.checked = /*$item*/
      d[0].system.prepared), s.$set(g), /*$item*/
      d[0].system.prepared ? c ? (c.p(d, p), p & /*$item*/
      1 && w(c, 1)) : (c = l8(d), c.c(), w(c, 1), c.m(l.parentNode, l)) : c && (ce(), C(c, 1, 1, () => {
        c = null;
      }), ue()), /*$item*/
      d[0].system.level > 0 ? u ? (u.p(d, p), p & /*$item*/
      1 && w(u, 1)) : (u = r8(d), u.c(), w(u, 1), u.m(r.parentNode, r)) : u && (ce(), C(u, 1, 1, () => {
        u = null;
      }), ue());
      const h = {};
      p & /*$item*/
      1 && (h.checked = /*$item*/
      d[0].system.rare), o.$set(h);
    },
    i(d) {
      a || (w(e.$$.fragment, d), w(s.$$.fragment, d), w(c), w(u), w(o.$$.fragment, d), a = !0);
    },
    o(d) {
      C(e.$$.fragment, d), C(s.$$.fragment, d), C(c), C(u), C(o.$$.fragment, d), a = !1;
    },
    d(d) {
      d && (S(t), S(n), S(l), S(r)), j(e, d), j(s, d), c && c.d(d), u && u.d(d), j(o, d);
    }
  };
}
f(efe, "create_default_slot_3$8");
function tfe(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.RequiresBloodied",
      checked: (
        /*$item*/
        i[0].system.requiresBloodied
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_9*/
    i[21]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.checked = /*$item*/
      s[0].system.requiresBloodied), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(tfe, "create_default_slot_2$8");
function sfe(i) {
  let e, t;
  return e = new de({
    props: {
      $$slots: { default: [tfe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $item*/
      1073741825 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(sfe, "create_default_slot_1$9");
function nfe(i) {
  let e, t, s, n;
  const l = [Jue, Xue], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[1] ? 0 : 1
    );
  }
  return f(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let u = e;
      e = o(a), e === u ? r[e].p(a, c) : (ce(), C(r[u], 1, 1, () => {
        r[u] = null;
      }), ue(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), r[e].d(a);
    }
  };
}
f(nfe, "create_default_slot$r");
function ife(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "A5E.TabSpellConfiguration",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[22]
          )
        }
      ],
      $$slots: { default: [nfe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem"), z(t, "--a5e-section-heading-gap", "0.5rem"), z(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      2 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[22]
          )
        }
      ]), l & /*$$scope, $item, editMode, selectedSpellComponents, selectedSecondarySpellSchools*/
      1073741839 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(ife, "create_fragment$19");
function lfe(i, e, t) {
  let s, n, l;
  function r(q) {
    return Object.entries(q.system.components).filter(([W, X]) => X).map(([W]) => p[W] ?? W).join(", ");
  }
  f(r, "prepareSpellComponents");
  function o(q) {
    const W = q.system.schools.secondary.map((X) => g.secondary[X] ?? X);
    return W.sort((X, te) => X.localeCompare(te)), W.join(", ");
  }
  f(o, "prepareSecondarySpellSchools");
  const a = fe("item");
  pe(i, a, (q) => t(0, l = q));
  const { PREPARED_STATES: c, classSpellLists: u, spellComponents: d, spellComponentAbbreviations: p, spellLevels: m, spellSchools: g } = CONFIG.A5E;
  let h = !1;
  const _ = /* @__PURE__ */ f((q) => se(l, "system.classes", q.detail), "updateSelection_handler"), y = /* @__PURE__ */ f((q) => se(l, "system.level", q.detail), "updateSelection_handler_1"), k = /* @__PURE__ */ f((q) => se(l, "system.schools.primary", q.detail), "updateSelection_handler_2"), v = /* @__PURE__ */ f((q) => se(l, "system.schools.secondary", q.detail), "updateSelection_handler_3"), O = /* @__PURE__ */ f((q) => se(l, `system.components.${q}`, !l.system.components[q]), "tagToggle_handler"), P = /* @__PURE__ */ f(({ target: q }) => se(l, q.name, q.value), "change_handler"), D = /* @__PURE__ */ f(({ detail: q }) => {
    se(l, "system.concentration", q);
  }, "updateSelection_handler_4"), I = /* @__PURE__ */ f(({ detail: q }) => {
    se(l, "system.prepared", q);
  }, "updateSelection_handler_5"), B = /* @__PURE__ */ f(({ detail: q }) => {
    se(l, "system.prepared", q ? 2 : 1);
  }, "updateSelection_handler_6"), F = /* @__PURE__ */ f(({ detail: q }) => {
    se(l, "system.ritual", q);
  }, "updateSelection_handler_7"), H = /* @__PURE__ */ f(({ detail: q }) => {
    se(l, "system.rare", q);
  }, "updateSelection_handler_8"), G = /* @__PURE__ */ f(({ detail: q }) => {
    se(l, "system.requiresBloodied", q);
  }, "updateSelection_handler_9"), U = /* @__PURE__ */ f(() => t(1, h = !h), "func");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1 && t(3, s = r(l)), i.$$.dirty & /*$item*/
    1 && t(2, n = o(l));
  }, [
    l,
    h,
    n,
    s,
    a,
    c,
    u,
    d,
    m,
    g,
    _,
    y,
    k,
    v,
    O,
    P,
    D,
    I,
    B,
    F,
    H,
    G,
    U
  ];
}
f(lfe, "instance$13");
const pC = class pC extends ie {
  constructor(e) {
    super(), le(this, e, lfe, ife, ne, {});
  }
};
f(pC, "SpellConfiguration");
let Gk = pC;
function rfe(i) {
  let e, t, s, n, l, r = (
    /*selectedWeaponProperties*/
    (i[2] || K("A5E.None")) + ""
  ), o;
  return {
    c() {
      e = E("dl"), t = E("div"), s = E("dt"), s.textContent = `${K("A5E.WeaponProperties")}:`, n = R(), l = E("dd"), o = x(r), b(s, "class", "u-text-bold"), b(l, "class", "u-m-0 u-p-0"), b(t, "class", "u-flex u-gap-md"), b(e, "class", "a5e-box u-flex u-flex-col u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(t, s), A(t, n), A(t, l), A(l, o);
    },
    p(a, c) {
      c & /*selectedWeaponProperties*/
      4 && r !== (r = /*selectedWeaponProperties*/
      (a[2] || K("A5E.None")) + "") && _e(o, r);
    },
    i: ee,
    o: ee,
    d(a) {
      a && S(e);
    }
  };
}
f(rfe, "create_else_block$8");
function ofe(i) {
  let e, t, s = (
    /*$item*/
    i[0].system.weaponProperties.includes("breaker")
  ), n, l = (
    /*$item*/
    i[0].system.weaponProperties.includes("defensive")
  ), r, o = (
    /*$item*/
    i[0].system.weaponProperties.includes("mounted")
  ), a, c = (
    /*$item*/
    i[0].system.weaponProperties.includes("versatile")
  ), u, d;
  e = new Ze({
    props: {
      heading: "A5E.WeaponProperties",
      options: Object.entries(
        /*weaponProperties*/
        i[7]
      ),
      selected: (
        /*$item*/
        i[0].system.weaponProperties
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[8]
  );
  let p = s && o8(i), m = l && a8(i), g = o && c8(i), h = c && u8(i);
  return {
    c() {
      L(e.$$.fragment), t = R(), p && p.c(), n = R(), m && m.c(), r = R(), g && g.c(), a = R(), h && h.c(), u = $e();
    },
    m(_, y) {
      N(e, _, y), T(_, t, y), p && p.m(_, y), T(_, n, y), m && m.m(_, y), T(_, r, y), g && g.m(_, y), T(_, a, y), h && h.m(_, y), T(_, u, y), d = !0;
    },
    p(_, y) {
      const k = {};
      y & /*$item*/
      1 && (k.selected = /*$item*/
      _[0].system.weaponProperties), e.$set(k), y & /*$item*/
      1 && (s = /*$item*/
      _[0].system.weaponProperties.includes("breaker")), s ? p ? (p.p(_, y), y & /*$item*/
      1 && w(p, 1)) : (p = o8(_), p.c(), w(p, 1), p.m(n.parentNode, n)) : p && (ce(), C(p, 1, 1, () => {
        p = null;
      }), ue()), y & /*$item*/
      1 && (l = /*$item*/
      _[0].system.weaponProperties.includes("defensive")), l ? m ? (m.p(_, y), y & /*$item*/
      1 && w(m, 1)) : (m = a8(_), m.c(), w(m, 1), m.m(r.parentNode, r)) : m && (ce(), C(m, 1, 1, () => {
        m = null;
      }), ue()), y & /*$item*/
      1 && (o = /*$item*/
      _[0].system.weaponProperties.includes("mounted")), o ? g ? (g.p(_, y), y & /*$item*/
      1 && w(g, 1)) : (g = c8(_), g.c(), w(g, 1), g.m(a.parentNode, a)) : g && (ce(), C(g, 1, 1, () => {
        g = null;
      }), ue()), y & /*$item*/
      1 && (c = /*$item*/
      _[0].system.weaponProperties.includes("versatile")), c ? h ? (h.p(_, y), y & /*$item*/
      1 && w(h, 1)) : (h = u8(_), h.c(), w(h, 1), h.m(u.parentNode, u)) : h && (ce(), C(h, 1, 1, () => {
        h = null;
      }), ue());
    },
    i(_) {
      d || (w(e.$$.fragment, _), w(p), w(m), w(g), w(h), d = !0);
    },
    o(_) {
      C(e.$$.fragment, _), C(p), C(m), C(g), C(h), d = !1;
    },
    d(_) {
      _ && (S(t), S(n), S(r), S(a), S(u)), j(e, _), p && p.d(_), m && m.d(_), g && g.d(_), h && h.d(_);
    }
  };
}
f(ofe, "create_if_block$A");
function o8(i) {
  let e, t;
  return e = new Ze({
    props: {
      heading: "Breaker Property",
      options: Object.entries(
        /*breakerProperties*/
        i[4]
      ),
      selected: (
        /*$item*/
        i[0].system.breakerProperties
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[9]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.selected = /*$item*/
      s[0].system.breakerProperties), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(o8, "create_if_block_4$a");
function a8(i) {
  let e, t;
  return e = new Ye({
    props: {
      heading: "Defensive Property",
      options: Object.entries(
        /*defensiveProperties*/
        i[5]
      ),
      selected: (
        /*$item*/
        i[0].system.defensiveProperties
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[10]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.selected = /*$item*/
      s[0].system.defensiveProperties), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(a8, "create_if_block_3$b");
function c8(i) {
  let e, t;
  return e = new Ze({
    props: {
      heading: "Mounted Property",
      options: Object.entries(
        /*versatileOptions*/
        i[6]
      ),
      selected: (
        /*$item*/
        i[0].system.mounted
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[11]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.selected = /*$item*/
      s[0].system.mounted), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(c8, "create_if_block_2$i");
function u8(i) {
  let e, t;
  return e = new Ye({
    props: {
      heading: "Versatile Property",
      options: Object.entries(
        /*versatileOptions*/
        i[6]
      ),
      selected: (
        /*$item*/
        i[0].system.versatile
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[12]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$item*/
      1 && (l.selected = /*$item*/
      s[0].system.versatile), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(u8, "create_if_block_1$q");
function afe(i) {
  let e, t, s, n;
  const l = [ofe, rfe], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[1] ? 0 : 1
    );
  }
  return f(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let u = e;
      e = o(a), e === u ? r[e].p(a, c) : (ce(), C(r[u], 1, 1, () => {
        r[u] = null;
      }), ue(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), r[e].d(a);
    }
  };
}
f(afe, "create_default_slot$q");
function cfe(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "A5E.TabWeaponProperties",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[13]
          )
        }
      ],
      $$slots: { default: [afe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem"), z(t, "--a5e-section-heading-gap", "0.5rem"), z(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      2 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[13]
          )
        }
      ]), l & /*$$scope, $item, editMode, selectedWeaponProperties*/
      16391 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(cfe, "create_fragment$18");
function ufe(i, e, t) {
  let s, n;
  const l = fe("item");
  pe(i, l, (y) => t(0, n = y));
  const { breakerProperties: r, defensiveProperties: o, versatileOptions: a, weaponProperties: c } = CONFIG.A5E;
  let u = !1;
  const d = /* @__PURE__ */ f((y) => se(n, "system.weaponProperties", y.detail), "updateSelection_handler"), p = /* @__PURE__ */ f((y) => se(n, "system.breakerProperties", y.detail), "updateSelection_handler_1"), m = /* @__PURE__ */ f((y) => se(n, "system.defensiveProperties", y.detail), "updateSelection_handler_2"), g = /* @__PURE__ */ f((y) => se(n, "system.mounted", y.detail), "updateSelection_handler_3"), h = /* @__PURE__ */ f((y) => se(n, "system.versatile", y.detail), "updateSelection_handler_4"), _ = /* @__PURE__ */ f(() => t(1, u = !u), "func");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1 && t(2, s = Q9(n).filter(Boolean).join(", "));
  }, [
    n,
    u,
    s,
    l,
    r,
    o,
    a,
    c,
    d,
    p,
    m,
    g,
    h,
    _
  ];
}
f(ufe, "instance$12");
const mC = class mC extends ie {
  constructor(e) {
    super(), le(this, e, ufe, cfe, ne, {});
  }
};
f(mC, "WeaponConfiguration");
let zk = mC;
function f8(i, e, t) {
  const s = i.slice();
  return s[12] = e[t][0], s[13] = e[t][1], s;
}
f(f8, "get_each_context$o");
function ffe(i) {
  let e, t, s, n = (
    /*usesSummary*/
    (i[2] || K("A5E.None")) + ""
  ), l, r;
  return {
    c() {
      e = E("dl"), t = E("dt"), t.textContent = `${K("A5E.Uses")}:`, s = E("dd"), l = x(n), b(t, "class", "u-text-bold"), b(s, "class", "align-center u-flex u-gap-sm u-m-0 u-p-0"), b(s, "data-tooltip", r = /*$item*/
      i[0].system.uses.per === "recharge" ? (
        /*$item*/
        i[0].system.uses.recharge.formula
      ) : null), b(s, "data-tooltip-direction", "UP"), b(e, "class", "a5e-box u-flex u-gap-sm u-m-0 u-p-md u-text-sm");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(e, s), A(s, l);
    },
    p(o, a) {
      a & /*usesSummary*/
      4 && n !== (n = /*usesSummary*/
      (o[2] || K("A5E.None")) + "") && _e(l, n), a & /*$item*/
      1 && r !== (r = /*$item*/
      o[0].system.uses.per === "recharge" ? (
        /*$item*/
        o[0].system.uses.recharge.formula
      ) : null) && b(s, "data-tooltip", r);
    },
    i: ee,
    o: ee,
    d(o) {
      o && S(e);
    }
  };
}
f(ffe, "create_else_block$7");
function dfe(i) {
  let e, t, s, n, l;
  e = new Me({
    props: {
      $$slots: { default: [gfe] },
      $$scope: { ctx: i }
    }
  });
  let r = (
    /*$item*/
    i[0].system.uses.per === "recharge" && p8(i)
  );
  return {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), r && r.c(), n = $e(), z(t, "display", "contents"), z(t, "--a5e-section-body-direction", "row"), z(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(o, a) {
      T(o, t, a), N(e, t, null), T(o, s, a), r && r.m(o, a), T(o, n, a), l = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$$scope, $item*/
      65537 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c), /*$item*/
      o[0].system.uses.per === "recharge" ? r ? (r.p(o, a), a & /*$item*/
      1 && w(r, 1)) : (r = p8(o), r.c(), w(r, 1), r.m(n.parentNode, n)) : r && (ce(), C(r, 1, 1, () => {
        r = null;
      }), ue());
    },
    i(o) {
      l || (w(e.$$.fragment, o), w(r), l = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(r), l = !1;
    },
    d(o) {
      o && (S(s), S(n)), o && e && S(t), j(e, o), r && r.d(o);
    }
  };
}
f(dfe, "create_if_block$z");
function pfe(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "number"), b(e, "d-type", "Number"), b(e, "name", "system.uses.value"), e.value = t = /*$item*/
      i[0].system.uses.value;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler*/
        i[5]
      ), s = !0);
    },
    p(l, r) {
      r & /*$item*/
      1 && t !== (t = /*$item*/
      l[0].system.uses.value) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(pfe, "create_default_slot_7$4");
function mfe(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), b(e, "name", "system.uses.max"), e.value = t = /*$item*/
      i[0].system.uses.max;
    },
    m(l, r) {
      T(l, e, r), s || (n = V(
        e,
        "change",
        /*change_handler_1*/
        i[6]
      ), s = !0);
    },
    p(l, r) {
      r & /*$item*/
      1 && t !== (t = /*$item*/
      l[0].system.uses.max) && e.value !== t && (e.value = t);
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(mfe, "create_default_slot_6$4");
function d8(i) {
  let e, t = K(
    /*name*/
    i[13]
  ) + "", s, n, l;
  return {
    c() {
      e = E("option"), s = x(t), n = R(), b(
        e,
        "key",
        /*key*/
        i[12]
      ), e.__value = /*key*/
      i[12], qe(e, e.__value), e.selected = l = /*$item*/
      i[0].system.uses.per === /*key*/
      i[12];
    },
    m(r, o) {
      T(r, e, o), A(e, s), A(e, n);
    },
    p(r, o) {
      o & /*$item*/
      1 && l !== (l = /*$item*/
      r[0].system.uses.per === /*key*/
      r[12]) && (e.selected = l);
    },
    d(r) {
      r && S(e);
    }
  };
}
f(d8, "create_each_block$o");
function hfe(i) {
  let e, t, s, n, l = oe(Object.entries(
    /*resourceRecoveryOptions*/
    i[4]
  )), r = [];
  for (let o = 0; o < l.length; o += 1)
    r[o] = d8(f8(i, l, o));
  return {
    c() {
      e = E("select"), t = E("option");
      for (let o = 0; o < r.length; o += 1)
        r[o].c();
      t.__value = "", qe(t, t.__value), b(e, "class", "u-h-8 u-w-40"), b(e, "name", "system.uses.per");
    },
    m(o, a) {
      T(o, e, a), A(e, t);
      for (let c = 0; c < r.length; c += 1)
        r[c] && r[c].m(e, null);
      s || (n = V(
        e,
        "change",
        /*change_handler_2*/
        i[7]
      ), s = !0);
    },
    p(o, a) {
      if (a & /*Object, resourceRecoveryOptions, $item*/
      17) {
        l = oe(Object.entries(
          /*resourceRecoveryOptions*/
          o[4]
        ));
        let c;
        for (c = 0; c < l.length; c += 1) {
          const u = f8(o, l, c);
          r[c] ? r[c].p(u, a) : (r[c] = d8(u), r[c].c(), r[c].m(e, null));
        }
        for (; c < r.length; c += 1)
          r[c].d(1);
        r.length = l.length;
      }
    },
    d(o) {
      o && S(e), Le(r, o), s = !1, n();
    }
  };
}
f(hfe, "create_default_slot_5$5");
function gfe(i) {
  let e, t, s, n, l, r;
  return e = new de({
    props: {
      heading: "A5E.UsesCurrent",
      $$slots: { default: [pfe] },
      $$scope: { ctx: i }
    }
  }), s = new de({
    props: {
      heading: "A5E.UsesMax",
      $$slots: { default: [mfe] },
      $$scope: { ctx: i }
    }
  }), l = new de({
    props: {
      heading: "A5E.UsesPer",
      $$slots: { default: [hfe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment);
    },
    m(o, a) {
      N(e, o, a), T(o, t, a), N(s, o, a), T(o, n, a), N(l, o, a), r = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$$scope, $item*/
      65537 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const u = {};
      a & /*$$scope, $item*/
      65537 && (u.$$scope = { dirty: a, ctx: o }), s.$set(u);
      const d = {};
      a & /*$$scope, $item*/
      65537 && (d.$$scope = { dirty: a, ctx: o }), l.$set(d);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(s.$$.fragment, o), C(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (S(t), S(n)), j(e, o), j(s, o), j(l, o);
    }
  };
}
f(gfe, "create_default_slot_4$6");
function p8(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "A5E.ItemRechargeConfiguration",
      $$slots: { default: [yfe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-direction", "row"), z(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, $item*/
      65537 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(p8, "create_if_block_1$p");
function bfe(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("input"), b(e, "id", t = /*$item*/
      i[0].id + "-recharge-formula"), b(e, "type", "text"), e.value = s = /*$item*/
      i[0].system.uses.recharge.formula, b(e, "placeholder", "1d6");
    },
    m(r, o) {
      T(r, e, o), n || (l = V(
        e,
        "change",
        /*change_handler_3*/
        i[8]
      ), n = !0);
    },
    p(r, o) {
      o & /*$item*/
      1 && t !== (t = /*$item*/
      r[0].id + "-recharge-formula") && b(e, "id", t), o & /*$item*/
      1 && s !== (s = /*$item*/
      r[0].system.uses.recharge.formula) && e.value !== s && (e.value = s);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(bfe, "create_default_slot_3$7");
function _fe(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("input"), b(e, "id", t = /*$item*/
      i[0].id + "-recharge-threshold"), b(e, "class", "u-text-center"), b(e, "type", "number"), e.value = s = /*$item*/
      i[0].system.uses.recharge.threshold;
    },
    m(r, o) {
      T(r, e, o), n || (l = V(
        e,
        "change",
        /*change_handler_4*/
        i[9]
      ), n = !0);
    },
    p(r, o) {
      o & /*$item*/
      1 && t !== (t = /*$item*/
      r[0].id + "-recharge-threshold") && b(e, "id", t), o & /*$item*/
      1 && s !== (s = /*$item*/
      r[0].system.uses.recharge.threshold) && e.value !== s && (e.value = s);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(_fe, "create_default_slot_2$7");
function yfe(i) {
  let e, t, s, n;
  return e = new de({
    props: {
      heading: "A5E.ItemRechargeFormula",
      $$slots: { default: [bfe] },
      $$scope: { ctx: i }
    }
  }), s = new de({
    props: {
      heading: "A5E.ItemRechargeThreshold",
      $$slots: { default: [_fe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$$scope, $item*/
      65537 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$$scope, $item*/
      65537 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(yfe, "create_default_slot_1$8");
function vfe(i) {
  let e, t, s, n;
  const l = [dfe, ffe], r = [];
  function o(a, c) {
    return (
      /*editMode*/
      a[1] ? 0 : 1
    );
  }
  return f(o, "select_block_type"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      let u = e;
      e = o(a), e === u ? r[e].p(a, c) : (ce(), C(r[u], 1, 1, () => {
        r[u] = null;
      }), ue(), t = r[e], t ? t.p(a, c) : (t = r[e] = l[e](a), t.c()), w(t, 1), t.m(s.parentNode, s));
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), r[e].d(a);
    }
  };
}
f(vfe, "create_default_slot$p");
function kfe(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "A5E.ItemUsesConfiguration",
      headerButtons: [
        {
          classes: `fa-solid ${/*editMode*/
          i[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            i[10]
          )
        }
      ],
      $$slots: { default: [vfe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem"), z(t, "--a5e-section-heading-gap", "0.5rem"), z(t, "--a5e-section-heading-template-columns", "max-content max-content");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*editMode*/
      2 && (r.headerButtons = [
        {
          classes: `fa-solid ${/*editMode*/
          n[1] ? "fa-chevron-up" : "fa-edit"}`,
          handler: (
            /*func*/
            n[10]
          )
        }
      ]), l & /*$$scope, $item, editMode, usesSummary*/
      65543 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(kfe, "create_fragment$17");
function wfe(i, e, t) {
  let s, n;
  function l(h) {
    var v;
    const { uses: _ } = h.system, y = h.actor ? at((_ == null ? void 0 : _.max) ?? 0, ((v = h.actor) == null ? void 0 : v.getRollData(h)) ?? {}) : _ == null ? void 0 : _.max;
    let k;
    if (_.value && y)
      k = `${_.value} / ${y}`;
    else if (_.value && !y)
      k = _.value;
    else if (!_.value && y)
      k = `0 / ${y}`;
    else
      return null;
    return _.per === "recharge" ? k = `${k} (Recharges on ${_.recharge.threshold})` : _.per && (k = `${k} (Per ${o[_.per]})`), k;
  }
  f(l, "prepareUsesSummary");
  const r = fe("item");
  pe(i, r, (h) => t(0, n = h));
  const { resourceRecoveryOptions: o } = CONFIG.A5E;
  let a = !1;
  const c = /* @__PURE__ */ f(({ target: h }) => se(n, h.name, Number(h.value)), "change_handler"), u = /* @__PURE__ */ f(({ target: h }) => {
    ka(h.value), se(n, h.name, h.value);
  }, "change_handler_1"), d = /* @__PURE__ */ f(({ target: h }) => se(n, h.name, h.value), "change_handler_2"), p = /* @__PURE__ */ f(({ target: h }) => {
    ka(h.value), se(n, "system.uses.recharge.formula", h.value);
  }, "change_handler_3"), m = /* @__PURE__ */ f(({ target: h }) => se(n, "system.uses.recharge.threshold", Number(h.value)), "change_handler_4"), g = /* @__PURE__ */ f(() => t(1, a = !a), "func");
  return i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1 && t(2, s = l(n));
  }, [
    n,
    a,
    s,
    r,
    o,
    c,
    u,
    d,
    p,
    m,
    g
  ];
}
f(wfe, "instance$11");
const hC = class hC extends ie {
  constructor(e) {
    super(), le(this, e, wfe, kfe, ne, {});
  }
};
f(hC, "UsesConfiguration");
let Hk = hC;
function $fe(i) {
  let e, t;
  return e = new Gk({}), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p: ee,
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f($fe, "create_if_block_7$5");
function Afe(i) {
  let e, t, s, n, l, r, o, a, c;
  e = new Bk({}), s = new Lk({});
  const u = [Dfe, Ofe, Cfe, Tfe], d = [];
  function p(m, g) {
    return (
      /*$item*/
      m[0].system.objectType === "ammunition" ? 0 : (
        /*$item*/
        m[0].system.objectType === "armor" ? 1 : (
          /*$item*/
          m[0].system.objectType === "shield" ? 2 : (
            /*$item*/
            m[0].system.objectType === "weapon" ? 3 : -1
          )
        )
      )
    );
  }
  return f(p, "select_block_type_1"), ~(l = p(i)) && (r = d[l] = u[l](i)), a = new gp({}), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), r && r.c(), o = R(), L(a.$$.fragment);
    },
    m(m, g) {
      N(e, m, g), T(m, t, g), N(s, m, g), T(m, n, g), ~l && d[l].m(m, g), T(m, o, g), N(a, m, g), c = !0;
    },
    p(m, g) {
      let h = l;
      l = p(m), l !== h && (r && (ce(), C(d[h], 1, 1, () => {
        d[h] = null;
      }), ue()), ~l ? (r = d[l], r || (r = d[l] = u[l](m), r.c()), w(r, 1), r.m(o.parentNode, o)) : r = null);
    },
    i(m) {
      c || (w(e.$$.fragment, m), w(s.$$.fragment, m), w(r), w(a.$$.fragment, m), c = !0);
    },
    o(m) {
      C(e.$$.fragment, m), C(s.$$.fragment, m), C(r), C(a.$$.fragment, m), c = !1;
    },
    d(m) {
      m && (S(t), S(n), S(o)), j(e, m), j(s, m), ~l && d[l].d(m), j(a, m);
    }
  };
}
f(Afe, "create_if_block_2$h");
function Efe(i) {
  let e, t;
  return e = new jk({}), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p: ee,
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Efe, "create_if_block_1$o");
function Sfe(i) {
  let e, t, s, n;
  return e = new Nk({}), s = new gp({}), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p: ee,
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(Sfe, "create_if_block$y");
function Tfe(i) {
  let e, t;
  return e = new zk({}), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Tfe, "create_if_block_6$5");
function Cfe(i) {
  let e, t;
  return e = new qk({}), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Cfe, "create_if_block_5$6");
function Ofe(i) {
  let e, t;
  return e = new Fk({}), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Ofe, "create_if_block_4$9");
function Dfe(i) {
  let e, t;
  return e = new Rk({}), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Dfe, "create_if_block_3$a");
function Ife(i) {
  let e, t, s, n, l, r;
  const o = [Sfe, Efe, Afe, $fe], a = [];
  function c(u, d) {
    return (
      /*$item*/
      u[0].type === "feature" ? 0 : (
        /*$item*/
        u[0].type === "maneuver" ? 1 : (
          /*$item*/
          u[0].type === "object" ? 2 : (
            /*$item*/
            u[0].type === "spell" ? 3 : -1
          )
        )
      )
    );
  }
  return f(c, "select_block_type"), ~(t = c(i)) && (s = a[t] = o[t](i)), l = new Hk({}), {
    c() {
      e = E("div"), s && s.c(), n = R(), L(l.$$.fragment), b(e, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable");
    },
    m(u, d) {
      T(u, e, d), ~t && a[t].m(e, null), A(e, n), N(l, e, null), r = !0;
    },
    p(u, [d]) {
      let p = t;
      t = c(u), t === p ? ~t && a[t].p(u, d) : (s && (ce(), C(a[p], 1, 1, () => {
        a[p] = null;
      }), ue()), ~t ? (s = a[t], s ? s.p(u, d) : (s = a[t] = o[t](u), s.c()), w(s, 1), s.m(e, n)) : s = null);
    },
    i(u) {
      r || (w(s), w(l.$$.fragment, u), r = !0);
    },
    o(u) {
      C(s), C(l.$$.fragment, u), r = !1;
    },
    d(u) {
      u && S(e), ~t && a[t].d(), j(l);
    }
  };
}
f(Ife, "create_fragment$16");
function Pfe(i, e, t) {
  let s;
  const n = fe("item");
  return pe(i, n, (l) => t(0, s = l)), [s, n];
}
f(Pfe, "instance$10");
const gC = class gC extends ie {
  constructor(e) {
    super(), le(this, e, Pfe, Ife, ne, {});
  }
};
f(gC, "ItemPropertiesTab");
let Uk = gC;
function Mfe(i) {
  let e, t;
  return e = new hl({
    props: {
      document: (
        /*item*/
        i[1]
      ),
      content: (
        /*content*/
        i[0]
      ),
      updatePath: "system.secretDescription"
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*content*/
      1 && (l.content = /*content*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Mfe, "create_fragment$15");
function Rfe(i, e, t) {
  let s, n;
  const l = fe("item");
  return pe(i, l, (r) => t(2, n = r)), i.$$.update = () => {
    i.$$.dirty & /*$item*/
    4 && t(0, s = n.system.secretDescription);
  }, [s, l, n];
}
f(Rfe, "instance$$");
const bC = class bC extends ie {
  constructor(e) {
    super(), le(this, e, Rfe, Mfe, ne, {});
  }
};
f(bC, "ItemGmNotesTab");
let Vk = bC;
function Ffe(i) {
  let e, t;
  return e = new hl({
    props: {
      document: (
        /*item*/
        i[1]
      ),
      content: (
        /*content*/
        i[0]
      ),
      updatePath: "system.unidentifiedDescription"
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, [n]) {
      const l = {};
      n & /*content*/
      1 && (l.content = /*content*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Ffe, "create_fragment$14");
function Nfe(i, e, t) {
  let s, n;
  const l = fe("item");
  return pe(i, l, (r) => t(2, n = r)), i.$$.update = () => {
    i.$$.dirty & /*$item*/
    4 && t(0, s = n.system.unidentifiedDescription);
  }, [s, l, n];
}
f(Nfe, "instance$_");
const _C = class _C extends ie {
  constructor(e) {
    super(), le(this, e, Nfe, Ffe, ne, {});
  }
};
f(_C, "ItemUnidentifiedDescriptionTab");
let Wk = _C;
function m8(i, e, t) {
  const s = i.slice();
  return s[5] = e[t][0], s[6] = e[t][1], s;
}
f(m8, "get_each_context$n");
function h8(i) {
  let e, t;
  return e = new ji({
    props: {
      $$slots: { default: [jfe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope*/
      512 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(h8, "create_if_block_1$n");
function jfe(i) {
  let e, t, s, n, l, r;
  return e = new Fi({ props: { reducerType: Rb } }), s = new Ni({
    props: {
      reducerType: Rb,
      documentName: "ActiveEffect"
    }
  }), l = new Ys({
    props: {
      reducerType: Rb,
      documentName: "ActiveEffect",
      options: { effectType: "passive" }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment);
    },
    m(o, a) {
      N(e, o, a), T(o, t, a), N(s, o, a), T(o, n, a), N(l, o, a), r = !0;
    },
    p: ee,
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(s.$$.fragment, o), C(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (S(t), S(n)), j(e, o), j(s, o), j(l, o);
    }
  };
}
f(jfe, "create_default_slot$o");
function g8(i) {
  let e, t;
  return e = new Fc({
    props: {
      label: (
        /*subTypes*/
        i[4][
          /*label*/
          i[5]
        ]
      ),
      effects: (
        /*effects*/
        i[6]
      )
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$activeEffects*/
      2 && (l.label = /*subTypes*/
      s[4][
        /*label*/
        s[5]
      ]), n & /*$activeEffects*/
      2 && (l.effects = /*effects*/
      s[6]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(g8, "create_if_block$x");
function b8(i) {
  let e, t, s = (
    /*effects*/
    i[6].length && /*label*/
    i[5] !== "onUse" && g8(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*effects*/
      n[6].length && /*label*/
      n[5] !== "onUse" ? s ? (s.p(n, l), l & /*$activeEffects*/
      2 && w(s, 1)) : (s = g8(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ce(), C(s, 1, 1, () => {
        s = null;
      }), ue());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f(b8, "create_each_block$n");
function Lfe(i) {
  let e, t, s, n = (
    /*$item*/
    i[0].isOwner && h8(i)
  ), l = oe(Object.entries(
    /*$activeEffects*/
    i[1]._types
  )), r = [];
  for (let a = 0; a < l.length; a += 1)
    r[a] = b8(m8(i, l, a));
  const o = /* @__PURE__ */ f((a) => C(r[a], 1, 1, () => {
    r[a] = null;
  }), "out");
  return {
    c() {
      n && n.c(), e = R(), t = E("section");
      for (let a = 0; a < r.length; a += 1)
        r[a].c();
      b(t, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable");
    },
    m(a, c) {
      n && n.m(a, c), T(a, e, c), T(a, t, c);
      for (let u = 0; u < r.length; u += 1)
        r[u] && r[u].m(t, null);
      s = !0;
    },
    p(a, [c]) {
      if (/*$item*/
      a[0].isOwner ? n ? (n.p(a, c), c & /*$item*/
      1 && w(n, 1)) : (n = h8(a), n.c(), w(n, 1), n.m(e.parentNode, e)) : n && (ce(), C(n, 1, 1, () => {
        n = null;
      }), ue()), c & /*subTypes, Object, $activeEffects*/
      18) {
        l = oe(Object.entries(
          /*$activeEffects*/
          a[1]._types
        ));
        let u;
        for (u = 0; u < l.length; u += 1) {
          const d = m8(a, l, u);
          r[u] ? (r[u].p(d, c), w(r[u], 1)) : (r[u] = b8(d), r[u].c(), w(r[u], 1), r[u].m(t, null));
        }
        for (ce(), u = l.length; u < r.length; u += 1)
          o(u);
        ue();
      }
    },
    i(a) {
      if (!s) {
        w(n);
        for (let c = 0; c < l.length; c += 1)
          w(r[c]);
        s = !0;
      }
    },
    o(a) {
      C(n), r = r.filter(Boolean);
      for (let c = 0; c < r.length; c += 1)
        C(r[c]);
      s = !1;
    },
    d(a) {
      a && (S(e), S(t)), n && n.d(a), Le(r, a);
    }
  };
}
f(Lfe, "create_fragment$13");
const Rb = "activeEffects";
function Bfe(i, e, t) {
  let s, n;
  const l = fe("item");
  pe(i, l, (a) => t(0, s = a));
  const { activeEffects: r } = l;
  pe(i, r, (a) => t(1, n = a));
  const o = CONFIG.A5E.itemActiveEffectTypesPlural;
  return [s, n, l, r, o];
}
f(Bfe, "instance$Z");
const yC = class yC extends ie {
  constructor(e) {
    super(), le(this, e, Bfe, Lfe, ne, {});
  }
};
f(yC, "ItemEffectsTab");
let Kk = yC;
function qfe(i) {
  let e, t, s, n;
  return s = new lo({
    props: {
      uuids: (
        /*uuids*/
        i[0]
      ),
      attribute: "items",
      topLevelAttribute: "containerItems"
    }
  }), s.$on(
    "item-dropped",
    /*updateEquipment*/
    i[2]
  ), s.$on(
    "item-deleted",
    /*deleteEquipment*/
    i[3]
  ), {
    c() {
      e = E("article"), t = E("section"), L(s.$$.fragment), b(t, "class", "section-wrapper svelte-3r30np"), b(e, "class", "svelte-3r30np");
    },
    m(l, r) {
      T(l, e, r), A(e, t), N(s, t, null), n = !0;
    },
    p(l, [r]) {
      const o = {};
      r & /*uuids*/
      1 && (o.uuids = /*uuids*/
      l[0]), s.$set(o);
    },
    i(l) {
      n || (w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(e), j(s);
    }
  };
}
f(qfe, "create_fragment$12");
function Gfe(i, e, t) {
  let s, n;
  const l = fe("item");
  pe(i, l, (a) => t(4, n = a));
  async function r(a) {
    var u, d;
    const [c] = a.detail;
    try {
      const { uuid: p } = JSON.parse(c.dataTransfer.getData("text/plain")), m = await fromUuid(p);
      if (!m)
        return;
      await n.containerItems.add(p, { optional: !0 });
      const g = ((u = n == null ? void 0 : n.parent) == null ? void 0 : u.documentName) === "Actor" ? n.parent : null;
      if (!g || g.uuid !== ((d = n.parent) == null ? void 0 : d.uuid))
        return;
      await m.update({ "system.containerId": n.uuid });
    } catch (p) {
      console.error(p);
    }
  }
  f(r, "updateEquipment");
  async function o(a) {
    var m, g;
    const [c, u] = a.detail, d = await fromUuid(u);
    await n.containerItems.delete(u);
    const p = ((m = n == null ? void 0 : n.parent) == null ? void 0 : m.documentName) === "Actor" ? n.parent : null;
    !p || !d || p.uuid === ((g = n.parent) == null ? void 0 : g.uuid) && await d.update({ "system.containerId": "" });
  }
  return f(o, "deleteEquipment"), i.$$.update = () => {
    i.$$.dirty & /*$item*/
    16 && t(0, s = Object.values(n.system.items ?? {}).map((a) => a.uuid));
  }, [s, l, r, o, n];
}
f(Gfe, "instance$Y");
const vC = class vC extends ie {
  constructor(e) {
    super(), le(this, e, Gfe, qfe, ne, {});
  }
};
f(vC, "ItemEquipmentTab");
let Yk = vC;
function zfe(i) {
  let e, t, s, n, l, r, o, a, c;
  t = new vl({}), n = new bn({
    props: {
      currentTab: (
        /*currentTab*/
        i[1]
      ),
      tabs: (
        /*tabs*/
        i[6]
      )
    }
  }), n.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[3]
  );
  var u = (
    /*currentTab*/
    i[1].component
  );
  function d(p, m) {
    return {
      props: { summaryData: (
        /*summaryData*/
        p[2]
      ) }
    };
  }
  return f(d, "switch_props"), u && (r = nt(u, d(i))), {
    c() {
      e = E("main"), L(t.$$.fragment), s = R(), L(n.$$.fragment), l = R(), r && L(r.$$.fragment), b(e, "class", "svelte-d53nbt");
    },
    m(p, m) {
      T(p, e, m), N(t, e, null), A(e, s), N(n, e, null), A(e, l), r && N(r, e, null), o = !0, a || (c = V(e, "drop", We(tt(
        /*drop_handler*/
        i[11]
      ))), a = !0);
    },
    p(p, m) {
      const g = {};
      if (m & /*currentTab*/
      2 && (g.currentTab = /*currentTab*/
      p[1]), n.$set(g), m & /*currentTab*/
      2 && u !== (u = /*currentTab*/
      p[1].component)) {
        if (r) {
          ce();
          const h = r;
          C(h.$$.fragment, 1, 0, () => {
            j(h, 1);
          }), ue();
        }
        u ? (r = nt(u, d(p)), L(r.$$.fragment), w(r.$$.fragment, 1), N(r, e, null)) : r = null;
      } else if (u) {
        const h = {};
        m & /*summaryData*/
        4 && (h.summaryData = /*summaryData*/
        p[2]), r.$set(h);
      }
    },
    i(p) {
      o || (w(t.$$.fragment, p), w(n.$$.fragment, p), r && w(r.$$.fragment, p), o = !0);
    },
    o(p) {
      C(t.$$.fragment, p), C(n.$$.fragment, p), r && C(r.$$.fragment, p), o = !1;
    },
    d(p) {
      p && S(e), j(t), j(n), r && j(r), a = !1, c();
    }
  };
}
f(zfe, "create_default_slot$n");
function Hfe(i) {
  let e, t, s;
  function n(r) {
    i[12](r);
  }
  f(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [zfe] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Ss({ props: l }), st.push(() => mt(e, "elementRoot", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, currentTab, summaryData*/
        8198 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(Hfe, "create_fragment$11");
function Ufe(i, e, t) {
  var v;
  let s, n, { appId: l, document: r, sheet: o } = fe("#external").application, { appId: a = l, document: c = r, sheet: u = o } = e, { elementRoot: d } = e;
  function p(O) {
    t(1, _ = h[O.detail]);
  }
  f(p, "updateCurrentTab");
  const m = c;
  pe(i, m, (O) => t(10, n = O));
  function g(O) {
    const P = O.dataTransfer.getData("text/plain");
    if (!P)
      return;
    const D = JSON.parse(P);
    u._onDropDocument(D);
  }
  f(g, "onDrop");
  const h = [
    {
      name: "description",
      label: "A5E.ItemSheetLabelDescriptionTab",
      component: yl,
      display: !n.system.unidentified || game.user.isGM
    },
    {
      name: "unidentifiedDescription",
      label: "A5E.ItemSheetLabelUnidentifiedDescriptionTab",
      component: Wk,
      display: n.type === "object" && (n.system.unidentified || game.user.isGM)
    },
    {
      name: "gmNotes",
      label: "GM Notes",
      component: Vk,
      display: game.user.isGM
    },
    {
      name: "properties",
      label: "A5E.ItemSheetLabelPropertiesTab",
      component: Uk,
      display: !n.system.unidentified || game.user.isGM
    },
    {
      name: "equipment",
      label: "A5E.Equipment",
      component: Yk,
      display: n.type === "object" && n.system.objectType === "container" && (!n.system.unidentified || game.user.isGM)
    },
    {
      name: "actions",
      label: "A5E.ItemSheetLabelActionsTab",
      component: Mk,
      display: !n.system.unidentified || game.user.isGM
    },
    {
      name: "effects",
      label: "A5E.TabEffects",
      component: Kk,
      display: !n.system.unidentified || game.user.isGM
    },
    {
      name: "grants",
      label: "A5E.TabGrants",
      component: Mr,
      display: n.type === "feature"
    }
  ];
  let _ = (v = n.system) != null && v.unidentified && !game.user.isGM ? h[1] : h[0];
  et("item", m), et("appId", a);
  const y = /* @__PURE__ */ f((O) => g(O), "drop_handler");
  function k(O) {
    d = O, t(0, d);
  }
  return f(k, "applicationshell_elementRoot_binding"), i.$$set = (O) => {
    "appId" in O && t(7, a = O.appId), "document" in O && t(8, c = O.document), "sheet" in O && t(9, u = O.sheet), "elementRoot" in O && t(0, d = O.elementRoot);
  }, i.$$.update = () => {
    i.$$.dirty & /*$item*/
    1024 && t(2, s = Of(n));
  }, [
    d,
    _,
    s,
    p,
    m,
    g,
    h,
    a,
    c,
    u,
    n,
    y,
    k
  ];
}
f(Ufe, "instance$X");
var gf;
let Vfe = (gf = class extends ie {
  constructor(e) {
    super(), le(this, e, Ufe, Hfe, ne, {
      appId: 7,
      document: 8,
      sheet: 9,
      elementRoot: 0
    });
  }
  get appId() {
    return this.$$.ctx[7];
  }
  set appId(e) {
    this.$$set({ appId: e }), Ke();
  }
  get document() {
    return this.$$.ctx[8];
  }
  set document(e) {
    this.$$set({ document: e }), Ke();
  }
  get sheet() {
    return this.$$.ctx[9];
  }
  set sheet(e) {
    this.$$set({ sheet: e }), Ke();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Ke();
  }
}, f(gf, "ItemSheet"), gf);
var s1, pq, n1, mq, i1, hq, l1, gq, Pa;
let _8 = (Pa = class extends _s {
  /**
   * @inheritDoc
   */
  constructor(t, s = {}) {
    var l, r;
    s.svelte ?? (s.svelte = {}), [
      CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE,
      CONST.DOCUMENT_OWNERSHIP_LEVELS.LIMITED
    ].includes(t.permission) ? (s.classes = ["a5e-sheet", "a5e-sheet--item", "a5e-actor-sheet--limited"], s.svelte.class = cp, s.width = 512, s.resizable = !1) : (s.svelte.class = Pa.getSheetComponent(t.type), s.classes = ["a5e-sheet", "a5e-sheet--item"], s.width = 555, s.height = 592, s.resizable = !0);
    const n = t.parent ? (l = t == null ? void 0 : t.parent) != null && l.isToken ? ((r = t == null ? void 0 : t.parent) == null ? void 0 : r.parent.id) ?? t.parent.id : t.parent.id : null;
    super(foundry.utils.mergeObject(
      s,
      {
        baseApplication: "ItemSheet",
        id: n ? `item-sheet-${n}-${t.id}` : `item-sheet-${t.id}`,
        classes: ["a5e-sheet", "a5e-sheet--item"],
        title: t.name,
        focusAuto: t.type !== "heritage",
        svelte: {
          props: {}
        }
      }
    ));
    Y(this, s1);
    Y(this, n1);
    Y(this, i1);
    Y(this, l1);
    Ge(this, "item");
    this.item = t, this.options.svelte.props.document = new Kd(
      this.item,
      { delete: this.close.bind(this) }
    ), this.options.svelte.props.sheet = this;
  }
  /**
   * Default Application options
   *
   * @returns {object} options - Application options.
   * @see https://foundryvtt.com/api/Application.html#options
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      baseApplication: "ItemSheet",
      classes: ["a5e-sheet", "a5e-item-sheet"],
      minimizable: !0,
      svelte: {
        target: document.body
      }
    });
  }
  get object() {
    return this.item;
  }
  _getHeaderButtons() {
    const t = super._getHeaderButtons();
    return this.item.pack || t.unshift({
      label: "Sheet Configuration",
      class: "configure-sheet",
      icon: "fas fa-cog fa-fw",
      title: "Configure Sheet",
      onclick: (s) => this._onConfigureSheet(s)
    }), this.item.pack && t.unshift({
      label: "Import",
      class: "import",
      icon: "fas fa-download",
      onclick: (s) => this._onImport(s)
    }), t;
  }
  _onImport(t) {
    return t && t.preventDefault(), this.item.collection.importFromCompendium(this.item.compendium, this.item.id);
  }
  _onConfigureSheet(t) {
    t && t.preventDefault(), new DocumentSheetConfig(this.item, { top: this.position.top + 40 }).render(!0);
  }
  async _onDropDocument(t) {
    t.type === "Action" && await Z(this, s1, pq).call(this, t), t.type === "Grant" && await Z(this, n1, mq).call(this, t), t.type === "Item" && await Z(this, i1, hq).call(this, t);
  }
  static getSheetComponent(t) {
    return t === "background" ? Ek : t === "class" ? Tk : t === "culture" ? Ck : t === "destiny" ? Ik : t === "heritage" ? Pk : Vfe;
  }
  async _render(t = !1, s = {}) {
    var d, p;
    await super._render(t, s);
    const l = this.element[0].querySelector(".window-header .window-title");
    if (l.querySelector(".document-id-link"))
      return;
    const o = this.item.id, a = this.item.uuid, c = CONFIG.A5E.products[(p = (d = this.item) == null ? void 0 : d.system) == null ? void 0 : p.source];
    if (c != null && c.abbreviation) {
      const m = document.createElement("a");
      m.classList.add("a5e-document-source-link"), m.setAttribute("alt", c == null ? void 0 : c.title), m.dataset.tooltip = _n(c), m.dataset.tooltipClass = "a5e-tooltip a5e-tooltip--dark a5e-tooltip--document-source", m.dataset.tooltipDirection = "DOWN", m.innerHTML = `<i class="fa-solid fa-book-open"></i> ${c == null ? void 0 : c.abbreviation}`, m.href = c == null ? void 0 : c.url, m.target = "_blank", l.append(m);
    }
    const u = document.createElement("a");
    u.classList.add("document-id-link"), u.setAttribute("alt", "Copy Document ID"), u.dataset.tooltip = "Copy Document ID", u.dataset.tooltipDirection = "UP", u.innerHTML = '<i class="fa-solid fa-passport"></i>', u.addEventListener("click", (m) => {
      m.preventDefault(), game.clipboard.copyPlainText(o), ui.notifications.info(game.i18n.format(
        "DOCUMENT.IdCopiedClipboard",
        { label: "Item", type: "id", id: o }
      ));
    }), u.addEventListener("contextmenu", (m) => {
      m.preventDefault(), game.clipboard.copyPlainText(a), ui.notifications.info(game.i18n.format(
        "DOCUMENT.IdCopiedClipboard",
        { label: "Item", type: "uuid", id: a }
      ));
    }), l.append(u);
  }
}, s1 = new WeakSet(), pq = /* @__PURE__ */ f(async function(t) {
  const { actionId: s, itemUuid: n } = t;
  if (!s || !n)
    return;
  const l = await fromUuid(n), r = foundry.utils.duplicate(l.actions.get(s));
  if (!r)
    return;
  r.img ?? (r.img = l.img);
  const [o] = await this.item.actions.add(r, !0, !0);
  if (!o)
    return;
  const a = Array.from(l.effects).filter((m) => {
    var g, h, _, y;
    return ((h = (g = m.flags) == null ? void 0 : g.a5e) == null ? void 0 : h.transferType) === "onUse" && ((y = (_ = m.flags) == null ? void 0 : _.a5e) == null ? void 0 : y.actionId);
  });
  if (!a.length)
    return;
  let c = a.map((m) => {
    const g = m.toObject();
    return g.flags.a5e.actionId = o, g;
  });
  c = await this.item.createEmbeddedDocuments("ActiveEffect", c);
  const u = Object.entries(r.prompts ?? {}).filter(([, m]) => m.type === "effect"), d = u.reduce((m, [g, h]) => {
    const _ = a.find((k) => k._id === h.effectId);
    if (!_)
      return m;
    const y = c.find((k) => k.equals(_));
    return y && (m[g] = y._id), m;
  }, {}), p = {};
  u.forEach(([m]) => {
    p[`system.actions.${o}.prompts.${m}.effectId`] = d[m] ?? "";
  }), this.item.update(p);
}, "#onDropAction"), n1 = new WeakSet(), mq = /* @__PURE__ */ f(async function(t) {
  const { grantId: s, itemUuid: n } = t;
  if (!s || !n)
    return;
  const l = await fromUuid(n), r = foundry.utils.duplicate(l.grants.get(s));
  r && (r.img ?? (r.img = l.img), await this.item.grants.add(r));
}, "#onDropGrant"), i1 = new WeakSet(), hq = /* @__PURE__ */ f(async function(t) {
  const { uuid: s } = t, n = await fromUuid(s);
  n && n.type === "spell" && Z(this, l1, gq).call(this, n);
}, "#onDropItem"), l1 = new WeakSet(), gq = /* @__PURE__ */ f(async function(t) {
  t.actions.values().map((l) => (l.img ?? (l.img = t.img), l.description ?? (l.description = t.system.description), l.descriptionOutputs = ["action"], l)).forEach((l) => {
    this.item.actions.add(foundry.utils.duplicate(l));
  });
}, "#onDropSpell"), f(Pa, "ItemSheet"), Pa);
const kC = class kC extends Roll {
  constructor(e, t, s) {
    if (super(e, t, s), !(this.terms[0] instanceof Die && this.terms[0].faces === 20))
      throw new Error(
        `Invalid D20Roll formula provided: ${this._formula}. D20Roll formulae must begin with a 20-sided die term.`
      );
  }
  static get TOOLTIP_TEMPLATE() {
    return "systems/a5e/templates/chat/roll-tooltip.hbs";
  }
};
f(kC, "D20Roll");
let ic = kC;
const wC = class wC {
  constructor(e) {
    Ge(this, "initialLayer");
    Ge(this, "moveTime", 0);
    Ge(this, "events", {});
    Ge(this, "token");
    this.token = e, this.initialLayer = canvas.activeLayer;
  }
  async preview() {
    return this.token.draw(), this.token.layer.preview.addChild(this.token), this.activatePreviewListeners();
  }
  activatePreviewListeners() {
    return new Promise((e, t) => {
      this.events = {
        cancel: this._onCancel.bind(this),
        confirm: this._onConfirm.bind(this),
        move: this._onMove.bind(this),
        rotate: this._onRotate.bind(this),
        resolve: e,
        reject: t
      }, canvas.stage.on("mousemove", this.events.move), canvas.stage.on("mousedown", this.events.confirm), canvas.app.view.oncontextmenu = this.events.cancel, canvas.app.view.onwheel = this.events.rotate;
    });
  }
  _cleanup() {
    canvas.stage.off("mousemove", this.events.move), canvas.stage.off("mousedown", this.events.confirm), canvas.app.view.oncontextmenu = null, canvas.app.view.onwheel = null;
  }
  _onMove(e) {
    e.stopPropagation();
    const t = Date.now();
    if (t - this.moveTime <= 10)
      return;
    const s = e.data.getLocalPosition(this.token.layer), n = canvas.grid.w / 2, l = canvas.grid.h / 2, r = s.x - this.token.document.width * n, o = s.y - this.token.document.height * l, a = e.shiftKey ? { x: r, y: o } : canvas.grid.getSnappedPosition(r, o);
    this.token.document.updateSource({ x: a.x, y: a.y }), this.token.refresh(), this.moveTime = t;
  }
  _onRotate(e) {
    e.ctrlKey && e.preventDefault(), e.stopPropagation();
    const t = Math.sign(e.deltaY), s = this.token.rotation + t * Math.PI / 6;
    this.token.document.updateSource({ rotation: s }), this.token.refresh();
  }
  _onCancel(e) {
    this.token.layer._onDragLeftCancel(e ?? {}), this._cleanup(), this.token.layer.preview.removeChild(this.token), this.token.destroy(), this.events.reject();
  }
  _onConfirm() {
    this._cleanup();
    const { token: e } = this, t = canvas.grid.type === CONST.GRID_TYPES.GRIDLESS ? 0 : 2, s = canvas.grid.getSnappedPosition(e.document.x, e.document.y, t);
    e.document.updateSource({ x: s.x, y: s.y }), e.refresh(), e.destroy(), this.events.resolve(
      canvas.scene.createEmbeddedDocuments("Token", [e.document.toObject()])
    );
  }
};
f(wC, "TokenPreviewManager");
let Xk = wC;
const qa = {
  iconScale: (i) => i >= 5 ? 2.5 : i >= 4 ? 2.25 : i >= 3 ? 1.55 : i >= 2 ? 1.25 : 1.4,
  maxIcons: (i) => i >= 3 ? 22 : i >= 2 ? 17 : i >= 1 ? 14 : 10,
  ringOffset: (i) => i >= 5 ? 0.125 : i >= 3 || i >= 2 ? 0.225 : i >= 1 ? 0.425 : 1.45,
  ringRotation: (i) => i >= 3 ? 0.02 : i >= 2 ? 0.03 : (i >= 1, 0.035),
  sizeOffset: (i) => i >= 5 || i >= 3 ? 1.08 : i >= 2 ? 1.12 : i >= 1 ? 1.25 : 1.45
};
let Fb = null;
const $C = class $C extends Token {
  /**
   * Get an array of icon paths which represent valid status effect choices
   * @private
   */
  _getStatusEffectChoices() {
    const e = this, t = e.document, s = e.actor || null, n = s ? s.effects.reduce((r, o) => {
      for (const a of o.statuses)
        r[a] = { id: a, overlay: !!o.getFlag("core", "overlay") };
      return r;
    }, {}) : {}, l = foundry.utils.deepClone(t.effects) || [];
    return t.overlayEffect && l.push(t.overlayEffect), CONFIG.statusEffects.concat(l).reduce((r, o) => {
      const a = o.icon ?? o;
      if (a in r)
        return r;
      const c = n[o.id] || {}, u = !!c.id || t.effects.includes(a), d = !!c.overlay || t.overlayEffect === a, p = o.name ?? o.label;
      return r[a] = {
        id: o.id ?? "",
        title: p ? game.i18n.localize(p) : null,
        src: a,
        isActive: u,
        isOverlay: d,
        cssClass: [
          u ? "active" : null,
          d ? "overlay" : null
        ].filterJoin(" ")
      }, r;
    }, {});
  }
  _getActiveConditions() {
    return Object.values(this._getStatusEffectChoices()).reduce((e, t) => (t.isActive && e.push(t.id), e), []);
  }
  _addStatusEffect({ id: e, src: t }, { overlay: s = !1 } = {}) {
    const n = e && this.actor ? CONFIG.statusEffects.find((r) => r.id === e) : t;
    return ["fatigue", "exhaustion", "strife"].includes(e) ? this._handleMultiLevelEffectsAdd(n) : this._getActiveConditions().includes(e) ? this._removeStatusEffect({ id: e, src: t }, { overlay: s }) : this.toggleEffect(n, { active: !0, overlay: s });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _removeStatusEffect({ id: e, src: t }, { overlay: s = !1 } = {}) {
    const n = e && this.actor ? CONFIG.statusEffects.find((c) => c.id === e) : t;
    if (typeof n != "object")
      return null;
    if (["fatigue", "exhaustion", "strife"].includes(e))
      return this._handleMultiLevelEffectsRemove(n);
    const l = CONFIG.statusEffects.reduce((c, u) => {
      var d;
      return (d = u == null ? void 0 : u.statuses) != null && d.length && u.statuses.forEach((p) => {
        c[p] ?? (c[p] = []), c[p].push(u.id);
      }), c;
    }, {}), r = this._getActiveConditions(), { existing: o, associated: a } = this.actor.effects.reduce((c, u) => {
      var d;
      return u.statuses.size === 1 && u.statuses.has(e) && c.existing.push(u.id), (d = n == null ? void 0 : n.statuses) == null || d.forEach((p) => {
        var m;
        if (u.statuses.size === 1 && u.statuses.has(p)) {
          const g = (m = l[p]) == null ? void 0 : m.filter((h) => r.includes(h));
          if ((g == null ? void 0 : g.length) > 1)
            return;
          c.associated.push(u.id);
        }
      }), c;
    }, { existing: [], associated: [] });
    return !o.length && !a.length ? null : this.actor.deleteEmbeddedDocuments(
      "ActiveEffect",
      [...o, ...a]
    );
  }
  async _handleMultiLevelEffectsAdd(e) {
    var a, c;
    if (!e)
      return;
    const t = e.id, s = (a = this.actor.system.attributes) == null ? void 0 : a[t], n = CONFIG.A5E.multiLevelConditionsMaxLevel[t] ?? 7;
    if (s >= n)
      return;
    const l = (c = this.actor.effects.reduce((u, d) => (d.statuses.size === 1 && d.statuses.has(e.id) && u.push(d), u), [])) == null ? void 0 : c[0], r = t === "fatigue" && game.settings.get("a5e", "replaceFatigueAndStrife") ? "exhaustion" : t, o = Object.entries(CONFIG.A5E.multiLevelConditions[r] ?? {}).reduce((u, [d, p]) => (d > s + 1 || u.push(...p), u), []);
    if (l)
      l.update({ changes: o });
    else {
      const u = foundry.utils.deepClone(e);
      u.changes = o, this.toggleEffect(u, { active: !0, overlay: !1 });
    }
    await this.actor.update({
      [`system.attributes.${t}`]: Math.min(s + 1, n),
      "flags.a5e.autoApplyFSConditions": !1
    });
  }
  async _handleMultiLevelEffectsRemove(e) {
    var o, a;
    if (!e)
      return;
    const t = e.id, s = (o = this.actor.system.attributes) == null ? void 0 : o[t];
    if (s <= 0)
      return;
    const n = (a = this.actor.effects.reduce((c, u) => (u.statuses.size === 1 && u.statuses.has(e.id) && c.push(u), c), [])) == null ? void 0 : a[0], l = t === "fatigue" && game.settings.get("a5e", "replaceFatigueAndStrife") ? "exhaustion" : t, r = Object.entries(CONFIG.A5E.multiLevelConditions[l] ?? {}).reduce((c, [u, d]) => (u > s - 1 || c.push(...d), c), []);
    n && s > 1 ? n.update({ changes: r }) : this.toggleEffect(e, { active: !1, overlay: !1 }), await this.actor.update({
      [`system.attributes.${t}`]: Math.max(s - 1, 0),
      "flags.a5e.autoApplyFSConditions": !1
    });
  }
  /** @inheritdoc */
  _drawBar(e, t, s) {
    return s.attribute === "attributes.hp" ? this._drawHPBar(e, t, s) : super._drawBar(e, t, s);
  }
  /* -------------------------------------------- */
  /**
   * Specialized drawing function for HP bars.
   *
   * @param {number} number      The Bar number
   * @param {PIXI.Graphics} bar  The Bar container
   * @private
   */
  _drawHPBar(e, t) {
    const { value: s, max: n, temp: l } = this.document.actor.system.attributes.hp, r = Math.clamped(l, 0, n) / n, o = Math.clamped(s, 0, n) / n, a = Math.clamped(s, 0, n) / n, c = 0, u = PIXI.utils.rgb2hex([1 - a / 2, a, 0]), d = CONFIG.A5E.tokenHPColors, { w: p } = this;
    let m = Math.max(canvas.dimensions.size / 12, 8);
    this.document.height >= 2 && (m *= 1.6);
    const g = Math.clamped(m / 8, 1, 2), h = g + 1;
    t.clear(), t.beginFill(c, 0.5).lineStyle(g, c, 1).drawRoundedRect(0, 0, p, m, 3), t.beginFill(u, 1).lineStyle(g, c, 1).drawRoundedRect(0, 0, o * p, m, 2), l > 0 && t.beginFill(d.temp, 1).lineStyle(0).drawRoundedRect(h, h, r * p - 2 * h, m - 2 * h, 1);
    const _ = e === 0 ? this.h - m : 0;
    t.position.set(0, _);
  }
  // ********************************************************************
  //                            Radial Effects
  // ********************************************************************
  _refreshEffects() {
    var a, c, u, d, p;
    if (super._refreshEffects(), !game.settings.get("a5e", "enableRadialEffects"))
      return;
    const e = ((u = (c = (a = this.actor) == null ? void 0 : a.effects) == null ? void 0 : c.filter((m) => {
      if ((m.getFlag("core", "overlay") ?? !1) || (m.isSuppressed ?? !1))
        return !1;
      const _ = m.isTemporary ?? !1, y = m.getFlag("a5e", "transferType") === "onUse";
      return !(!_ && !y);
    })) == null ? void 0 : u.length) ?? 0;
    if (!e || !this.effects.children.length)
      return;
    const t = this.effects.children[0];
    if (!(t instanceof PIXI.Graphics))
      return;
    t.clear();
    const s = this.effects.children.slice(1, 1 + e), n = Math.max(this.document.height, this.document.width), l = ((p = (d = this == null ? void 0 : this.scene) == null ? void 0 : d.grid) == null ? void 0 : p.size) ?? 100, r = qa.maxIcons(n) ?? 10;
    let o = 0;
    s.forEach((m, g) => {
      var q;
      if (!(m instanceof PIXI.Sprite))
        return;
      g !== 0 && g % r === 0 && (o += 1), m.anchor.set(0.5);
      const h = qa.iconScale(n) ?? 1.4, _ = l / 100, y = 12 * h * _;
      m.width = y, m.height = y;
      const k = g / r, v = ((q = this == null ? void 0 : this.document) == null ? void 0 : q.width) ?? 1, O = qa.ringOffset(n) * o, D = ((qa.sizeOffset(n) ?? 1.4) + O) * v * l, I = o % 2 === 0 ? 0 : qa.ringRotation(n), B = (0.5 + 1 / r * Math.PI) * Math.PI, F = (k + I) * 2 * Math.PI + B, H = Math.cos(F) * D, G = Math.sin(F) * D;
      m.position.x = H / 2 + l * v / 2, m.position.y = -1 * G / 2 + l * v / 2;
      const U = m.width / 2;
      t.lineStyle(1 * _ / 2, 15325089, 1, 0), t.drawCircle(m.position.x, m.position.y, U + 1 * _), t.beginFill(0, 0.6), t.drawCircle(m.position.x, m.position.y, U + 1 * _), t.endFill();
    });
  }
  /**
   * @override
   */
  async _drawEffect(e, t, s = !1) {
    if (!game.settings.get("a5e", "enableRadialEffects"))
      return super._drawEffect(e, t);
    if (!e)
      return null;
    const n = await loadTexture(e, { fallback: "icons/svg/aura.svg" }), l = new PIXI.Sprite(n);
    if (s)
      return t && (l.tint = t), this.effects.addChild(l);
    if (!Fb) {
      Fb = PIXI.RenderTexture.create(110, 110);
      const a = new PIXI.Graphics().beginFill(16777215).drawCircle(55, 55, 55).endFill(), c = new PIXI.filters.BlurFilter(2);
      a.filters = [c], canvas.app.renderer.render(a, Fb);
    }
    const r = Math.min(l.width, l.height), o = new PIXI.Graphics().beginFill(16777215).drawCircle(55, 55, 55).endFill();
    return o.width = r, o.height = r, o.x = -l.width / 2, o.y = -l.height / 2, l.mask = o, l.addChild(o), t && (l.tint = t), this.effects.addChild(l);
  }
  /**
   * @override
   */
  async _drawOverlay(e, t) {
    if (!game.settings.get("a5e", "enableRadialEffects"))
      return super._drawOverlay(e, t);
    const s = await this._drawEffect(e, t, !0);
    return s && (s.alpha = 0.8), s;
  }
  // ********************************************************************
  //                         Token Preview Draw
  // ********************************************************************
  async drawPreview() {
    return new Xk(this).preview();
  }
};
f($C, "TokenA5e");
let bp = $C;
const AC = class AC extends TokenDocument {
  constructor() {
    super(...arguments);
    Ge(this, "overrides", this.overrides ?? {});
    Ge(this, "automateVision", game.settings.storage.get("world").getItem("a5e.automatedVisionRules"));
  }
  get scene() {
    return this.parent;
  }
  prepareBaseData() {
    super.prepareBaseData(), this.applyActiveEffects();
  }
  applyActiveEffects() {
    var t;
    this.overrides = {}, this.actor && da.applyEffects(
      this,
      ((t = this.actor.effects) == null ? void 0 : t.contents) ?? [],
      "afterDerived",
      null,
      (s) => s.key.startsWith("@token")
    );
  }
  _prepareDetectionModes() {
    this.automateVision ?? (this.automateVision = game.settings.storage.get("world").getItem("a5e.automateVisionRules")), this.automateVision && (this.sight.enabled = !0), super._prepareDetectionModes();
    const { actor: t, scene: s } = this;
    if (!s || !t || !this.automateVision)
      return;
    this.sight.attenuation = 0.1, this.sight.brightness = 0, this.sight.contrast = 0, this.sight.range = 0, this.sight.saturation = 0, this.sight.visionMode = "basic";
    const { visionData: n } = t, l = n.hasDarkvision ? "darkvision" : "basic", { defaults: r } = CONFIG.Canvas.visionModes[l].vision;
    if (this.sight.visionMode = l, this.sight.brightness = r.brightness ?? 0, this.sight.saturation = r.saturation ?? 0, l === "darkvision") {
      const o = this.detectionModes.at(0);
      if (!o)
        return;
      o.range = n.senses.darkvision.distance, this.sight.range = n.senses.darkvision.distance;
    }
    n.hasBlindsight && this.detectionModes.push(
      { id: "blindsight", enabled: !0, range: n.senses.blindsight.distance ?? 0 }
    ), n.hasTremorsense && this.detectionModes.push(
      { id: "feelTremor", enabled: !0, range: n.senses.tremorsense.distance ?? 0 }
    ), n.hasTruesight && this.detectionModes.push(
      { id: "seeInvisibility", enabled: !0, range: n.senses.truesight.distance ?? 0 }
    );
  }
  updateTokenSize() {
    const { actor: t } = this;
    if (!t)
      return;
    const { size: s } = t.system.traits, n = CONFIG.A5E.tokenDimensions[s];
    this.width = n ?? this.width ?? 1, this.height = n ?? this.height ?? 1;
  }
  /**
   * Overrides base functionality and doesn't update unlinked tokens.
   * @override
   * */
  _onUpdateBaseActor(t = {}, s = {}) {
    if (!this.isLinked && this.delta) {
      this.delta.updateSyntheticActor();
      for (const n of Object.values(this.delta.collections))
        n.initialize({ full: !0 });
    }
    this._onRelatedUpdate(t, s), this._updateCanvas(t);
  }
  // Update canvas if there are changes that affect the canvas
  _updateCanvas(t) {
    var n, l;
    if (!((n = this.scene) != null && n.isInFocus) && !((l = this.scene) != null && l.isView) || !this.automateVision || !this.sight.enabled)
      return;
    Object.keys(foundry.utils.flattenObject(t)).some((r) => r.startsWith("system.attributes.senses")) && (canvas.perception.update({ initializeVision: !0 }, !0), this.reset());
  }
  /** @inheritdoc */
  getBarAttribute(t, { alternative: s } = {}) {
    const n = super.getBarAttribute(t, { alternative: s });
    return n && n.attribute === "attributes.hp" && (n.value += parseInt(foundry.utils.getProperty(this.actor.system, "attributes.hp.temp") || 0, 10), n.max += parseInt(foundry.utils.getProperty(this.actor.system, "attributes.hp.temp") || 0, 10)), n;
  }
};
f(AC, "TokenDocumentA5e");
let _p = AC;
const Wfe = new Proxy(ga, {
  construct(i, e) {
    const t = CONFIG.A5E.Actor.documentClasses[e[0].type] ?? ga;
    return new t(...e);
  }
}), Kfe = new Proxy(Pc, {
  construct(i, e) {
    var s;
    const t = CONFIG.A5E.Item.documentClasses[(s = e[0]) == null ? void 0 : s.type] ?? $a;
    return new t(...e);
  }
}), EC = class EC extends DetectionMode {
  constructor() {
    super({
      angle: !1,
      id: "blindsight",
      label: "A5E.SenseBlindsight",
      type: DetectionMode.DETECTION_TYPES.OTHER,
      walls: !0
    });
  }
  static getDetectionFilter() {
    return this._detectionFilter ?? (this._detectionFilter = OutlineOverlayFilter.create({
      outlineColor: [1, 1, 1, 1],
      knockout: !0,
      wave: !0
    })), this._detectionFilter;
  }
  _canDetect() {
    return !0;
  }
  _testLOS(e, t, s, n) {
    return !CONFIG.Canvas.polygonBackends.sight.testCollision(
      { x: e.x, y: e.y },
      n.point,
      {
        type: "sight",
        mode: "any",
        source: e,
        useThreshold: !1
      }
    );
  }
};
f(EC, "DetectionModeBlindSight");
let Jk = EC;
function Yfe() {
  CONFIG.Canvas.detectionModes.blindsight = new Jk();
}
f(Yfe, "prepareDetectionModes");
function Xfe(i) {
  let e, t, s, n, l, r, o = (
    /*filterSelections*/
    i[1][
      /*filterKey*/
      i[0]
    ].inclusiveMode == 1 ? "AND" : "OR"
  ), a, c, u, d = (
    /*filterSelections*/
    i[1][
      /*filterKey*/
      i[0]
    ].exclusiveMode == 1 ? "AND" : "OR"
  ), p, m, g, h, _, y;
  return g = new rp({
    props: {
      color: "red",
      options: Object.entries(
        /*options*/
        i[3]
      ),
      selected: [
        /*filterSelections*/
        i[1][
          /*filterKey*/
          i[0]
        ].inclusive,
        /*filterSelections*/
        i[1][
          /*filterKey*/
          i[0]
        ].exclusive
      ]
    }
  }), g.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  ), {
    c() {
      e = E("header"), t = E("h3"), s = x(
        /*heading*/
        i[2]
      ), n = R(), l = E("div"), r = E("button"), a = x(o), c = R(), u = E("button"), p = x(d), m = R(), L(g.$$.fragment), b(t, "class", "a5efc-filter-heading svelte-qrtq7g"), b(r, "class", "a5efc-filter-mode-button a5efc-filter-mode-button--inclusive svelte-qrtq7g"), b(r, "data-tooltip", "Toggle Inclusive Filter Mode"), b(r, "data-tooltip-direction", "UP"), b(u, "class", "a5efc-filter-mode-button a5efc-filter-mode-button--exclusive svelte-qrtq7g"), b(u, "data-tooltip", "Toggle Exclusive Filter Mode"), b(u, "data-tooltip-direction", "UP"), b(l, "class", "a5efc-filter-mode-button-wrapper svelte-qrtq7g"), b(e, "class", "a5efc-filter-header svelte-qrtq7g");
    },
    m(k, v) {
      T(k, e, v), A(e, t), A(t, s), A(e, n), A(e, l), A(l, r), A(r, a), A(l, c), A(l, u), A(u, p), T(k, m, v), N(g, k, v), h = !0, _ || (y = [
        V(
          r,
          "click",
          /*click_handler*/
          i[5]
        ),
        V(
          u,
          "click",
          /*click_handler_1*/
          i[6]
        )
      ], _ = !0);
    },
    p(k, v) {
      (!h || v & /*heading*/
      4) && _e(
        s,
        /*heading*/
        k[2]
      ), (!h || v & /*filterSelections, filterKey*/
      3) && o !== (o = /*filterSelections*/
      k[1][
        /*filterKey*/
        k[0]
      ].inclusiveMode == 1 ? "AND" : "OR") && _e(a, o), (!h || v & /*filterSelections, filterKey*/
      3) && d !== (d = /*filterSelections*/
      k[1][
        /*filterKey*/
        k[0]
      ].exclusiveMode == 1 ? "AND" : "OR") && _e(p, d);
      const O = {};
      v & /*options*/
      8 && (O.options = Object.entries(
        /*options*/
        k[3]
      )), v & /*filterSelections, filterKey*/
      3 && (O.selected = [
        /*filterSelections*/
        k[1][
          /*filterKey*/
          k[0]
        ].inclusive,
        /*filterSelections*/
        k[1][
          /*filterKey*/
          k[0]
        ].exclusive
      ]), g.$set(O);
    },
    i(k) {
      h || (w(g.$$.fragment, k), h = !0);
    },
    o(k) {
      C(g.$$.fragment, k), h = !1;
    },
    d(k) {
      k && (S(e), S(m)), j(g, k), _ = !1, Ne(y);
    }
  };
}
f(Xfe, "create_default_slot$m");
function Jfe(i) {
  let e, t, s;
  return e = new bt({
    props: {
      $$slots: { default: [Xfe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--direction", "column");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, options, filterSelections, filterKey, heading*/
      271 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(Jfe, "create_fragment$10");
function Zfe(i, e, t) {
  let { filterKey: s } = e, { filterSelections: n } = e, { heading: l } = e, { options: r } = e;
  const o = it(), a = /* @__PURE__ */ f(() => o("updateInclusiveMode", !n[s].inclusiveMode == 1), "click_handler"), c = /* @__PURE__ */ f(() => o("updateExclusiveMode", !n[s].exclusiveMode == 1), "click_handler_1");
  function u(d) {
    gt.call(this, i, d);
  }
  return f(u, "updateSelection_handler"), i.$$set = (d) => {
    "filterKey" in d && t(0, s = d.filterKey), "filterSelections" in d && t(1, n = d.filterSelections), "heading" in d && t(2, l = d.heading), "options" in d && t(3, r = d.options);
  }, [
    s,
    n,
    l,
    r,
    o,
    a,
    c,
    u
  ];
}
f(Zfe, "instance$W");
const SC = class SC extends ie {
  constructor(e) {
    super(), le(this, e, Zfe, Jfe, ne, {
      filterKey: 0,
      filterSelections: 1,
      heading: 2,
      options: 3
    });
  }
};
f(SC, "CompendiumFilterCategory");
let Oa = SC;
function y8(i) {
  return Object.prototype.toString.call(i) === "[object Date]";
}
f(y8, "is_date");
function Zk(i, e, t, s) {
  if (typeof t == "number" || y8(t)) {
    const n = s - t, l = (t - e) / (i.dt || 1 / 60), r = i.opts.stiffness * n, o = i.opts.damping * l, a = (r - o) * i.inv_mass, c = (l + a) * i.dt;
    return Math.abs(c) < i.opts.precision && Math.abs(n) < i.opts.precision ? s : (i.settled = !1, y8(t) ? new Date(t.getTime() + c) : t + c);
  } else {
    if (Array.isArray(t))
      return t.map(
        (n, l) => Zk(i, e[l], t[l], s[l])
      );
    if (typeof t == "object") {
      const n = {};
      for (const l in t)
        n[l] = Zk(i, e[l], t[l], s[l]);
      return n;
    } else
      throw new Error(`Cannot spring ${typeof t} values`);
  }
}
f(Zk, "tick_spring");
function Qfe(i, e = {}) {
  const t = It(i), { stiffness: s = 0.15, damping: n = 0.8, precision: l = 0.01 } = e;
  let r, o, a, c = i, u = i, d = 1, p = 0, m = !1;
  function g(_, y = {}) {
    u = _;
    const k = a = {};
    return i == null || y.hard || h.stiffness >= 1 && h.damping >= 1 ? (m = !0, r = vc(), c = _, t.set(i = u), Promise.resolve()) : (y.soft && (p = 1 / ((y.soft === !0 ? 0.5 : +y.soft) * 60), d = 0), o || (r = vc(), m = !1, o = tb((v) => {
      if (m)
        return m = !1, o = null, !1;
      d = Math.min(d + p, 1);
      const O = {
        inv_mass: d,
        opts: h,
        settled: !0,
        dt: (v - r) * 60 / 1e3
      }, P = Zk(O, c, i, u);
      return r = v, c = i, t.set(i = P), O.settled && (o = null), !O.settled;
    })), new Promise((v) => {
      o.promise.then(() => {
        k === a && v();
      });
    }));
  }
  f(g, "set");
  const h = {
    set: g,
    update: (_, y) => g(_(u, i), y),
    subscribe: t.subscribe,
    stiffness: s,
    damping: n,
    precision: l
  };
  return h;
}
f(Qfe, "spring");
function v8(i, e, t) {
  const s = i.slice();
  return s[37] = e[t], s[39] = t, s;
}
f(v8, "get_each_context$m");
function k8(i) {
  let e, t, s, n, l = (
    /*all*/
    (i[6] === "label" || /*first*/
    i[7] === "label") && w8(i)
  );
  return {
    c() {
      e = E("span"), l && l.c(), b(e, "class", "pip first"), b(e, "style", t = /*orientationStart*/
      i[14] + ": 0%;"), Q(
        e,
        "selected",
        /*isSelected*/
        i[18](
          /*min*/
          i[0]
        )
      ), Q(
        e,
        "in-range",
        /*inRange*/
        i[17](
          /*min*/
          i[0]
        )
      );
    },
    m(r, o) {
      T(r, e, o), l && l.m(e, null), s || (n = [
        V(
          e,
          "pointerdown",
          /*pointerdown_handler*/
          i[30]
        ),
        V(
          e,
          "pointerup",
          /*pointerup_handler*/
          i[31]
        )
      ], s = !0);
    },
    p(r, o) {
      /*all*/
      r[6] === "label" || /*first*/
      r[7] === "label" ? l ? l.p(r, o) : (l = w8(r), l.c(), l.m(e, null)) : l && (l.d(1), l = null), o[0] & /*orientationStart*/
      16384 && t !== (t = /*orientationStart*/
      r[14] + ": 0%;") && b(e, "style", t), o[0] & /*isSelected, min*/
      262145 && Q(
        e,
        "selected",
        /*isSelected*/
        r[18](
          /*min*/
          r[0]
        )
      ), o[0] & /*inRange, min*/
      131073 && Q(
        e,
        "in-range",
        /*inRange*/
        r[17](
          /*min*/
          r[0]
        )
      );
    },
    d(r) {
      r && S(e), l && l.d(), s = !1, Ne(n);
    }
  };
}
f(k8, "create_if_block_9$3");
function w8(i) {
  let e, t, s, n = (
    /*formatter*/
    i[12](
      /*fixFloat*/
      i[16](
        /*min*/
        i[0]
      ),
      0,
      0
    ) + ""
  ), l, r = (
    /*prefix*/
    i[10] && $8(i)
  ), o = (
    /*suffix*/
    i[11] && A8(i)
  );
  return {
    c() {
      e = E("span"), r && r.c(), t = $e(), s = new As(!1), l = $e(), o && o.c(), s.a = l, b(e, "class", "pipVal");
    },
    m(a, c) {
      T(a, e, c), r && r.m(e, null), A(e, t), s.m(n, e), A(e, l), o && o.m(e, null);
    },
    p(a, c) {
      /*prefix*/
      a[10] ? r ? r.p(a, c) : (r = $8(a), r.c(), r.m(e, t)) : r && (r.d(1), r = null), c[0] & /*formatter, fixFloat, min*/
      69633 && n !== (n = /*formatter*/
      a[12](
        /*fixFloat*/
        a[16](
          /*min*/
          a[0]
        ),
        0,
        0
      ) + "") && s.p(n), /*suffix*/
      a[11] ? o ? o.p(a, c) : (o = A8(a), o.c(), o.m(e, null)) : o && (o.d(1), o = null);
    },
    d(a) {
      a && S(e), r && r.d(), o && o.d();
    }
  };
}
f(w8, "create_if_block_10");
function $8(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = x(
        /*prefix*/
        i[10]
      ), b(e, "class", "pipVal-prefix");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n[0] & /*prefix*/
      1024 && _e(
        t,
        /*prefix*/
        s[10]
      );
    },
    d(s) {
      s && S(e);
    }
  };
}
f($8, "create_if_block_12");
function A8(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = x(
        /*suffix*/
        i[11]
      ), b(e, "class", "pipVal-suffix");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n[0] & /*suffix*/
      2048 && _e(
        t,
        /*suffix*/
        s[11]
      );
    },
    d(s) {
      s && S(e);
    }
  };
}
f(A8, "create_if_block_11");
function E8(i) {
  let e, t = oe(Array(
    /*pipCount*/
    i[20] + 1
  )), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = D8(v8(i, t, n));
  return {
    c() {
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      e = $e();
    },
    m(n, l) {
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(n, l);
      T(n, e, l);
    },
    p(n, l) {
      if (l[0] & /*orientationStart, percentOf, pipVal, isSelected, inRange, labelDown, labelUp, suffix, formatter, prefix, all, rest, min, max, pipCount*/
      8314435) {
        t = oe(Array(
          /*pipCount*/
          n[20] + 1
        ));
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = v8(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = D8(o), s[r].c(), s[r].m(e.parentNode, e));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && S(e), Le(s, n);
    }
  };
}
f(E8, "create_if_block_4$8");
function S8(i) {
  let e, t, s, n, l, r = (
    /*all*/
    (i[6] === "label" || /*rest*/
    i[9] === "label") && T8(i)
  );
  function o(...a) {
    return (
      /*pointerup_handler_1*/
      i[33](
        /*i*/
        i[39],
        ...a
      )
    );
  }
  return f(o, "pointerup_handler_1"), {
    c() {
      e = E("span"), r && r.c(), t = R(), b(e, "class", "pip"), b(e, "style", s = /*orientationStart*/
      i[14] + ": " + /*percentOf*/
      i[15](
        /*pipVal*/
        i[19](
          /*i*/
          i[39]
        )
      ) + "%;"), Q(
        e,
        "selected",
        /*isSelected*/
        i[18](
          /*pipVal*/
          i[19](
            /*i*/
            i[39]
          )
        )
      ), Q(
        e,
        "in-range",
        /*inRange*/
        i[17](
          /*pipVal*/
          i[19](
            /*i*/
            i[39]
          )
        )
      );
    },
    m(a, c) {
      T(a, e, c), r && r.m(e, null), A(e, t), n || (l = [
        V(
          e,
          "pointerdown",
          /*pointerdown_handler_1*/
          i[32]
        ),
        V(e, "pointerup", o)
      ], n = !0);
    },
    p(a, c) {
      i = a, /*all*/
      i[6] === "label" || /*rest*/
      i[9] === "label" ? r ? r.p(i, c) : (r = T8(i), r.c(), r.m(e, t)) : r && (r.d(1), r = null), c[0] & /*orientationStart, percentOf, pipVal*/
      573440 && s !== (s = /*orientationStart*/
      i[14] + ": " + /*percentOf*/
      i[15](
        /*pipVal*/
        i[19](
          /*i*/
          i[39]
        )
      ) + "%;") && b(e, "style", s), c[0] & /*isSelected, pipVal*/
      786432 && Q(
        e,
        "selected",
        /*isSelected*/
        i[18](
          /*pipVal*/
          i[19](
            /*i*/
            i[39]
          )
        )
      ), c[0] & /*inRange, pipVal*/
      655360 && Q(
        e,
        "in-range",
        /*inRange*/
        i[17](
          /*pipVal*/
          i[19](
            /*i*/
            i[39]
          )
        )
      );
    },
    d(a) {
      a && S(e), r && r.d(), n = !1, Ne(l);
    }
  };
}
f(S8, "create_if_block_5$5");
function T8(i) {
  let e, t, s, n = (
    /*formatter*/
    i[12](
      /*pipVal*/
      i[19](
        /*i*/
        i[39]
      ),
      /*i*/
      i[39],
      /*percentOf*/
      i[15](
        /*pipVal*/
        i[19](
          /*i*/
          i[39]
        )
      )
    ) + ""
  ), l, r = (
    /*prefix*/
    i[10] && C8(i)
  ), o = (
    /*suffix*/
    i[11] && O8(i)
  );
  return {
    c() {
      e = E("span"), r && r.c(), t = $e(), s = new As(!1), l = $e(), o && o.c(), s.a = l, b(e, "class", "pipVal");
    },
    m(a, c) {
      T(a, e, c), r && r.m(e, null), A(e, t), s.m(n, e), A(e, l), o && o.m(e, null);
    },
    p(a, c) {
      /*prefix*/
      a[10] ? r ? r.p(a, c) : (r = C8(a), r.c(), r.m(e, t)) : r && (r.d(1), r = null), c[0] & /*formatter, pipVal, percentOf*/
      561152 && n !== (n = /*formatter*/
      a[12](
        /*pipVal*/
        a[19](
          /*i*/
          a[39]
        ),
        /*i*/
        a[39],
        /*percentOf*/
        a[15](
          /*pipVal*/
          a[19](
            /*i*/
            a[39]
          )
        )
      ) + "") && s.p(n), /*suffix*/
      a[11] ? o ? o.p(a, c) : (o = O8(a), o.c(), o.m(e, null)) : o && (o.d(1), o = null);
    },
    d(a) {
      a && S(e), r && r.d(), o && o.d();
    }
  };
}
f(T8, "create_if_block_6$4");
function C8(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = x(
        /*prefix*/
        i[10]
      ), b(e, "class", "pipVal-prefix");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n[0] & /*prefix*/
      1024 && _e(
        t,
        /*prefix*/
        s[10]
      );
    },
    d(s) {
      s && S(e);
    }
  };
}
f(C8, "create_if_block_8$3");
function O8(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = x(
        /*suffix*/
        i[11]
      ), b(e, "class", "pipVal-suffix");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n[0] & /*suffix*/
      2048 && _e(
        t,
        /*suffix*/
        s[11]
      );
    },
    d(s) {
      s && S(e);
    }
  };
}
f(O8, "create_if_block_7$4");
function D8(i) {
  let e = (
    /*pipVal*/
    i[19](
      /*i*/
      i[39]
    ) !== /*min*/
    i[0] && /*pipVal*/
    i[19](
      /*i*/
      i[39]
    ) !== /*max*/
    i[1]
  ), t, s = e && S8(i);
  return {
    c() {
      s && s.c(), t = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, t, l);
    },
    p(n, l) {
      l[0] & /*pipVal, min, max*/
      524291 && (e = /*pipVal*/
      n[19](
        /*i*/
        n[39]
      ) !== /*min*/
      n[0] && /*pipVal*/
      n[19](
        /*i*/
        n[39]
      ) !== /*max*/
      n[1]), e ? s ? s.p(n, l) : (s = S8(n), s.c(), s.m(t.parentNode, t)) : s && (s.d(1), s = null);
    },
    d(n) {
      n && S(t), s && s.d(n);
    }
  };
}
f(D8, "create_each_block$m");
function I8(i) {
  let e, t, s, n, l = (
    /*all*/
    (i[6] === "label" || /*last*/
    i[8] === "label") && P8(i)
  );
  return {
    c() {
      e = E("span"), l && l.c(), b(e, "class", "pip last"), b(e, "style", t = /*orientationStart*/
      i[14] + ": 100%;"), Q(
        e,
        "selected",
        /*isSelected*/
        i[18](
          /*max*/
          i[1]
        )
      ), Q(
        e,
        "in-range",
        /*inRange*/
        i[17](
          /*max*/
          i[1]
        )
      );
    },
    m(r, o) {
      T(r, e, o), l && l.m(e, null), s || (n = [
        V(
          e,
          "pointerdown",
          /*pointerdown_handler_2*/
          i[34]
        ),
        V(
          e,
          "pointerup",
          /*pointerup_handler_2*/
          i[35]
        )
      ], s = !0);
    },
    p(r, o) {
      /*all*/
      r[6] === "label" || /*last*/
      r[8] === "label" ? l ? l.p(r, o) : (l = P8(r), l.c(), l.m(e, null)) : l && (l.d(1), l = null), o[0] & /*orientationStart*/
      16384 && t !== (t = /*orientationStart*/
      r[14] + ": 100%;") && b(e, "style", t), o[0] & /*isSelected, max*/
      262146 && Q(
        e,
        "selected",
        /*isSelected*/
        r[18](
          /*max*/
          r[1]
        )
      ), o[0] & /*inRange, max*/
      131074 && Q(
        e,
        "in-range",
        /*inRange*/
        r[17](
          /*max*/
          r[1]
        )
      );
    },
    d(r) {
      r && S(e), l && l.d(), s = !1, Ne(n);
    }
  };
}
f(I8, "create_if_block$w");
function P8(i) {
  let e, t, s, n = (
    /*formatter*/
    i[12](
      /*fixFloat*/
      i[16](
        /*max*/
        i[1]
      ),
      /*pipCount*/
      i[20],
      100
    ) + ""
  ), l, r = (
    /*prefix*/
    i[10] && M8(i)
  ), o = (
    /*suffix*/
    i[11] && R8(i)
  );
  return {
    c() {
      e = E("span"), r && r.c(), t = $e(), s = new As(!1), l = $e(), o && o.c(), s.a = l, b(e, "class", "pipVal");
    },
    m(a, c) {
      T(a, e, c), r && r.m(e, null), A(e, t), s.m(n, e), A(e, l), o && o.m(e, null);
    },
    p(a, c) {
      /*prefix*/
      a[10] ? r ? r.p(a, c) : (r = M8(a), r.c(), r.m(e, t)) : r && (r.d(1), r = null), c[0] & /*formatter, fixFloat, max, pipCount*/
      1118210 && n !== (n = /*formatter*/
      a[12](
        /*fixFloat*/
        a[16](
          /*max*/
          a[1]
        ),
        /*pipCount*/
        a[20],
        100
      ) + "") && s.p(n), /*suffix*/
      a[11] ? o ? o.p(a, c) : (o = R8(a), o.c(), o.m(e, null)) : o && (o.d(1), o = null);
    },
    d(a) {
      a && S(e), r && r.d(), o && o.d();
    }
  };
}
f(P8, "create_if_block_1$m");
function M8(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = x(
        /*prefix*/
        i[10]
      ), b(e, "class", "pipVal-prefix");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n[0] & /*prefix*/
      1024 && _e(
        t,
        /*prefix*/
        s[10]
      );
    },
    d(s) {
      s && S(e);
    }
  };
}
f(M8, "create_if_block_3$9");
function R8(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = x(
        /*suffix*/
        i[11]
      ), b(e, "class", "pipVal-suffix");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n[0] & /*suffix*/
      2048 && _e(
        t,
        /*suffix*/
        s[11]
      );
    },
    d(s) {
      s && S(e);
    }
  };
}
f(R8, "create_if_block_2$g");
function xfe(i) {
  let e, t, s, n = (
    /*all*/
    (i[6] && /*first*/
    i[7] !== !1 || /*first*/
    i[7]) && k8(i)
  ), l = (
    /*all*/
    (i[6] && /*rest*/
    i[9] !== !1 || /*rest*/
    i[9]) && E8(i)
  ), r = (
    /*all*/
    (i[6] && /*last*/
    i[8] !== !1 || /*last*/
    i[8]) && I8(i)
  );
  return {
    c() {
      e = E("div"), n && n.c(), t = R(), l && l.c(), s = R(), r && r.c(), b(e, "class", "rangePips"), Q(
        e,
        "disabled",
        /*disabled*/
        i[5]
      ), Q(
        e,
        "hoverable",
        /*hoverable*/
        i[4]
      ), Q(
        e,
        "vertical",
        /*vertical*/
        i[2]
      ), Q(
        e,
        "reversed",
        /*reversed*/
        i[3]
      ), Q(
        e,
        "focus",
        /*focus*/
        i[13]
      );
    },
    m(o, a) {
      T(o, e, a), n && n.m(e, null), A(e, t), l && l.m(e, null), A(e, s), r && r.m(e, null);
    },
    p(o, a) {
      /*all*/
      o[6] && /*first*/
      o[7] !== !1 || /*first*/
      o[7] ? n ? n.p(o, a) : (n = k8(o), n.c(), n.m(e, t)) : n && (n.d(1), n = null), /*all*/
      o[6] && /*rest*/
      o[9] !== !1 || /*rest*/
      o[9] ? l ? l.p(o, a) : (l = E8(o), l.c(), l.m(e, s)) : l && (l.d(1), l = null), /*all*/
      o[6] && /*last*/
      o[8] !== !1 || /*last*/
      o[8] ? r ? r.p(o, a) : (r = I8(o), r.c(), r.m(e, null)) : r && (r.d(1), r = null), a[0] & /*disabled*/
      32 && Q(
        e,
        "disabled",
        /*disabled*/
        o[5]
      ), a[0] & /*hoverable*/
      16 && Q(
        e,
        "hoverable",
        /*hoverable*/
        o[4]
      ), a[0] & /*vertical*/
      4 && Q(
        e,
        "vertical",
        /*vertical*/
        o[2]
      ), a[0] & /*reversed*/
      8 && Q(
        e,
        "reversed",
        /*reversed*/
        o[3]
      ), a[0] & /*focus*/
      8192 && Q(
        e,
        "focus",
        /*focus*/
        o[13]
      );
    },
    i: ee,
    o: ee,
    d(o) {
      o && S(e), n && n.d(), l && l.d(), r && r.d();
    }
  };
}
f(xfe, "create_fragment$$");
function ede(i, e, t) {
  let s, n, l, r, o, { range: a = !1 } = e, { min: c = 0 } = e, { max: u = 100 } = e, { step: d = 1 } = e, { values: p = [(u + c) / 2] } = e, { vertical: m = !1 } = e, { reversed: g = !1 } = e, { hoverable: h = !0 } = e, { disabled: _ = !1 } = e, { pipstep: y = void 0 } = e, { all: k = !0 } = e, { first: v = void 0 } = e, { last: O = void 0 } = e, { rest: P = void 0 } = e, { prefix: D = "" } = e, { suffix: I = "" } = e, { formatter: B = /* @__PURE__ */ f((he, Ae, Fe) => he, "formatter") } = e, { focus: F = void 0 } = e, { orientationStart: H = void 0 } = e, { percentOf: G = void 0 } = e, { moveHandle: U = void 0 } = e, { fixFloat: q = void 0 } = e, { normalisedClient: W = void 0 } = e, X;
  function te(he) {
    he = W(he), X = { x: he.clientX, y: he.clientY };
  }
  f(te, "labelDown");
  function J(he, Ae) {
    if (Ae = W(Ae), !_) {
      const Fe = Math.sqrt(Math.pow(X.x - Ae.clientX, 2) + Math.pow(X.y - Ae.clientY, 2));
      X && Fe <= 5 && U(void 0, he);
    }
  }
  f(J, "labelUp");
  const re = /* @__PURE__ */ f((he) => {
    te(he);
  }, "pointerdown_handler"), ae = /* @__PURE__ */ f((he) => {
    J(c, he);
  }, "pointerup_handler"), be = /* @__PURE__ */ f((he) => {
    te(he);
  }, "pointerdown_handler_1"), we = /* @__PURE__ */ f((he, Ae) => {
    J(l(he), Ae);
  }, "pointerup_handler_1"), ve = /* @__PURE__ */ f((he) => {
    te(he);
  }, "pointerdown_handler_2"), me = /* @__PURE__ */ f((he) => {
    J(u, he);
  }, "pointerup_handler_2");
  return i.$$set = (he) => {
    "range" in he && t(23, a = he.range), "min" in he && t(0, c = he.min), "max" in he && t(1, u = he.max), "step" in he && t(24, d = he.step), "values" in he && t(25, p = he.values), "vertical" in he && t(2, m = he.vertical), "reversed" in he && t(3, g = he.reversed), "hoverable" in he && t(4, h = he.hoverable), "disabled" in he && t(5, _ = he.disabled), "pipstep" in he && t(26, y = he.pipstep), "all" in he && t(6, k = he.all), "first" in he && t(7, v = he.first), "last" in he && t(8, O = he.last), "rest" in he && t(9, P = he.rest), "prefix" in he && t(10, D = he.prefix), "suffix" in he && t(11, I = he.suffix), "formatter" in he && t(12, B = he.formatter), "focus" in he && t(13, F = he.focus), "orientationStart" in he && t(14, H = he.orientationStart), "percentOf" in he && t(15, G = he.percentOf), "moveHandle" in he && t(27, U = he.moveHandle), "fixFloat" in he && t(16, q = he.fixFloat), "normalisedClient" in he && t(28, W = he.normalisedClient);
  }, i.$$.update = () => {
    i.$$.dirty[0] & /*pipstep, max, min, step, vertical*/
    83886087 && t(29, s = y || ((u - c) / d >= (m ? 50 : 100) ? (u - c) / (m ? 10 : 20) : 1)), i.$$.dirty[0] & /*max, min, step, pipStep*/
    553648131 && t(20, n = parseInt((u - c) / (d * s), 10)), i.$$.dirty[0] & /*fixFloat, min, step, pipStep*/
    553713665 && t(19, l = /* @__PURE__ */ f(function(he) {
      return q(c + he * d * s);
    }, "pipVal")), i.$$.dirty[0] & /*values, fixFloat*/
    33619968 && t(18, r = /* @__PURE__ */ f(function(he) {
      return p.some((Ae) => q(Ae) === q(he));
    }, "isSelected")), i.$$.dirty[0] & /*range, values*/
    41943040 && t(17, o = /* @__PURE__ */ f(function(he) {
      if (a === "min")
        return p[0] > he;
      if (a === "max")
        return p[0] < he;
      if (a)
        return p[0] < he && p[1] > he;
    }, "inRange"));
  }, [
    c,
    u,
    m,
    g,
    h,
    _,
    k,
    v,
    O,
    P,
    D,
    I,
    B,
    F,
    H,
    G,
    q,
    o,
    r,
    l,
    n,
    te,
    J,
    a,
    d,
    p,
    y,
    U,
    W,
    s,
    re,
    ae,
    be,
    we,
    ve,
    me
  ];
}
f(ede, "instance$V");
const TC = class TC extends ie {
  constructor(e) {
    super(), le(
      this,
      e,
      ede,
      xfe,
      ne,
      {
        range: 23,
        min: 0,
        max: 1,
        step: 24,
        values: 25,
        vertical: 2,
        reversed: 3,
        hoverable: 4,
        disabled: 5,
        pipstep: 26,
        all: 6,
        first: 7,
        last: 8,
        rest: 9,
        prefix: 10,
        suffix: 11,
        formatter: 12,
        focus: 13,
        orientationStart: 14,
        percentOf: 15,
        moveHandle: 27,
        fixFloat: 16,
        normalisedClient: 28
      },
      null,
      [-1, -1]
    );
  }
};
f(TC, "RangePips");
let Qk = TC;
function F8(i, e, t) {
  const s = i.slice();
  return s[65] = e[t], s[67] = t, s;
}
f(F8, "get_each_context$l");
function N8(i) {
  let e, t, s, n = (
    /*handleFormatter*/
    i[21](
      /*value*/
      i[65],
      /*index*/
      i[67],
      /*percentOf*/
      i[24](
        /*value*/
        i[65]
      )
    ) + ""
  ), l, r = (
    /*prefix*/
    i[18] && j8(i)
  ), o = (
    /*suffix*/
    i[19] && L8(i)
  );
  return {
    c() {
      e = E("span"), r && r.c(), t = $e(), s = new As(!1), l = $e(), o && o.c(), s.a = l, b(e, "class", "rangeFloat");
    },
    m(a, c) {
      T(a, e, c), r && r.m(e, null), A(e, t), s.m(n, e), A(e, l), o && o.m(e, null);
    },
    p(a, c) {
      /*prefix*/
      a[18] ? r ? r.p(a, c) : (r = j8(a), r.c(), r.m(e, t)) : r && (r.d(1), r = null), c[0] & /*handleFormatter, values, percentOf*/
      18874369 && n !== (n = /*handleFormatter*/
      a[21](
        /*value*/
        a[65],
        /*index*/
        a[67],
        /*percentOf*/
        a[24](
          /*value*/
          a[65]
        )
      ) + "") && s.p(n), /*suffix*/
      a[19] ? o ? o.p(a, c) : (o = L8(a), o.c(), o.m(e, null)) : o && (o.d(1), o = null);
    },
    d(a) {
      a && S(e), r && r.d(), o && o.d();
    }
  };
}
f(N8, "create_if_block_2$f");
function j8(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = x(
        /*prefix*/
        i[18]
      ), b(e, "class", "rangeFloat-prefix");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n[0] & /*prefix*/
      262144 && _e(
        t,
        /*prefix*/
        s[18]
      );
    },
    d(s) {
      s && S(e);
    }
  };
}
f(j8, "create_if_block_4$7");
function L8(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = x(
        /*suffix*/
        i[19]
      ), b(e, "class", "rangeFloat-suffix");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n[0] & /*suffix*/
      524288 && _e(
        t,
        /*suffix*/
        s[19]
      );
    },
    d(s) {
      s && S(e);
    }
  };
}
f(L8, "create_if_block_3$8");
function B8(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g = (
    /*float*/
    i[7] && N8(i)
  );
  return {
    c() {
      e = E("span"), t = E("span"), s = R(), g && g.c(), b(t, "class", "rangeNub"), b(e, "role", "slider"), b(e, "class", "rangeHandle"), b(
        e,
        "data-handle",
        /*index*/
        i[67]
      ), b(e, "style", n = /*orientationStart*/
      i[29] + ": " + /*$springPositions*/
      i[30][
        /*index*/
        i[67]
      ] + "%; z-index: " + /*activeHandle*/
      (i[27] === /*index*/
      i[67] ? 3 : 2) + ";"), b(e, "aria-label", l = /*ariaLabels*/
      i[22][
        /*index*/
        i[67]
      ]), b(e, "aria-valuemin", r = /*range*/
      i[2] === !0 && /*index*/
      i[67] === 1 ? (
        /*values*/
        i[0][0]
      ) : (
        /*min*/
        i[3]
      )), b(e, "aria-valuemax", o = /*range*/
      i[2] === !0 && /*index*/
      i[67] === 0 ? (
        /*values*/
        i[0][1]
      ) : (
        /*max*/
        i[4]
      )), b(e, "aria-valuenow", a = /*value*/
      i[65]), b(e, "aria-valuetext", c = "" + /*prefix*/
      (i[18] + H8(
        /*handleFormatter*/
        i[21](
          /*value*/
          i[65],
          /*index*/
          i[67],
          /*percentOf*/
          i[24](
            /*value*/
            i[65]
          )
        )
      ) + /*suffix*/
      i[19])), b(e, "aria-orientation", u = /*vertical*/
      i[6] ? "vertical" : "horizontal"), b(
        e,
        "aria-disabled",
        /*disabled*/
        i[10]
      ), b(
        e,
        "disabled",
        /*disabled*/
        i[10]
      ), b(e, "tabindex", d = /*disabled*/
      i[10] ? -1 : 0), Q(
        e,
        "active",
        /*focus*/
        i[25] && /*activeHandle*/
        i[27] === /*index*/
        i[67]
      ), Q(
        e,
        "press",
        /*handlePressed*/
        i[26] && /*activeHandle*/
        i[27] === /*index*/
        i[67]
      );
    },
    m(h, _) {
      T(h, e, _), A(e, t), A(e, s), g && g.m(e, null), p || (m = [
        V(
          e,
          "blur",
          /*sliderBlurHandle*/
          i[35]
        ),
        V(
          e,
          "focus",
          /*sliderFocusHandle*/
          i[36]
        ),
        V(
          e,
          "keydown",
          /*sliderKeydown*/
          i[37]
        )
      ], p = !0);
    },
    p(h, _) {
      /*float*/
      h[7] ? g ? g.p(h, _) : (g = N8(h), g.c(), g.m(e, null)) : g && (g.d(1), g = null), _[0] & /*orientationStart, $springPositions, activeHandle*/
      1744830464 && n !== (n = /*orientationStart*/
      h[29] + ": " + /*$springPositions*/
      h[30][
        /*index*/
        h[67]
      ] + "%; z-index: " + /*activeHandle*/
      (h[27] === /*index*/
      h[67] ? 3 : 2) + ";") && b(e, "style", n), _[0] & /*ariaLabels*/
      4194304 && l !== (l = /*ariaLabels*/
      h[22][
        /*index*/
        h[67]
      ]) && b(e, "aria-label", l), _[0] & /*range, values, min*/
      13 && r !== (r = /*range*/
      h[2] === !0 && /*index*/
      h[67] === 1 ? (
        /*values*/
        h[0][0]
      ) : (
        /*min*/
        h[3]
      )) && b(e, "aria-valuemin", r), _[0] & /*range, values, max*/
      21 && o !== (o = /*range*/
      h[2] === !0 && /*index*/
      h[67] === 0 ? (
        /*values*/
        h[0][1]
      ) : (
        /*max*/
        h[4]
      )) && b(e, "aria-valuemax", o), _[0] & /*values*/
      1 && a !== (a = /*value*/
      h[65]) && b(e, "aria-valuenow", a), _[0] & /*prefix, handleFormatter, values, percentOf, suffix*/
      19660801 && c !== (c = "" + /*prefix*/
      (h[18] + H8(
        /*handleFormatter*/
        h[21](
          /*value*/
          h[65],
          /*index*/
          h[67],
          /*percentOf*/
          h[24](
            /*value*/
            h[65]
          )
        )
      ) + /*suffix*/
      h[19])) && b(e, "aria-valuetext", c), _[0] & /*vertical*/
      64 && u !== (u = /*vertical*/
      h[6] ? "vertical" : "horizontal") && b(e, "aria-orientation", u), _[0] & /*disabled*/
      1024 && b(
        e,
        "aria-disabled",
        /*disabled*/
        h[10]
      ), _[0] & /*disabled*/
      1024 && b(
        e,
        "disabled",
        /*disabled*/
        h[10]
      ), _[0] & /*disabled*/
      1024 && d !== (d = /*disabled*/
      h[10] ? -1 : 0) && b(e, "tabindex", d), _[0] & /*focus, activeHandle*/
      167772160 && Q(
        e,
        "active",
        /*focus*/
        h[25] && /*activeHandle*/
        h[27] === /*index*/
        h[67]
      ), _[0] & /*handlePressed, activeHandle*/
      201326592 && Q(
        e,
        "press",
        /*handlePressed*/
        h[26] && /*activeHandle*/
        h[27] === /*index*/
        h[67]
      );
    },
    d(h) {
      h && S(e), g && g.d(), p = !1, Ne(m);
    }
  };
}
f(B8, "create_each_block$l");
function q8(i) {
  let e, t;
  return {
    c() {
      e = E("span"), b(e, "class", "rangeBar"), b(e, "style", t = /*orientationStart*/
      i[29] + ": " + /*rangeStart*/
      i[33](
        /*$springPositions*/
        i[30]
      ) + "%; " + /*orientationEnd*/
      i[28] + ": " + /*rangeEnd*/
      i[34](
        /*$springPositions*/
        i[30]
      ) + "%;");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n[0] & /*orientationStart, $springPositions, orientationEnd*/
      1879048192 && t !== (t = /*orientationStart*/
      s[29] + ": " + /*rangeStart*/
      s[33](
        /*$springPositions*/
        s[30]
      ) + "%; " + /*orientationEnd*/
      s[28] + ": " + /*rangeEnd*/
      s[34](
        /*$springPositions*/
        s[30]
      ) + "%;") && b(e, "style", t);
    },
    d(s) {
      s && S(e);
    }
  };
}
f(q8, "create_if_block_1$l");
function G8(i) {
  let e, t;
  return e = new Qk({
    props: {
      values: (
        /*values*/
        i[0]
      ),
      min: (
        /*min*/
        i[3]
      ),
      max: (
        /*max*/
        i[4]
      ),
      step: (
        /*step*/
        i[5]
      ),
      range: (
        /*range*/
        i[2]
      ),
      vertical: (
        /*vertical*/
        i[6]
      ),
      reversed: (
        /*reversed*/
        i[8]
      ),
      orientationStart: (
        /*orientationStart*/
        i[29]
      ),
      hoverable: (
        /*hoverable*/
        i[9]
      ),
      disabled: (
        /*disabled*/
        i[10]
      ),
      all: (
        /*all*/
        i[13]
      ),
      first: (
        /*first*/
        i[14]
      ),
      last: (
        /*last*/
        i[15]
      ),
      rest: (
        /*rest*/
        i[16]
      ),
      pipstep: (
        /*pipstep*/
        i[12]
      ),
      prefix: (
        /*prefix*/
        i[18]
      ),
      suffix: (
        /*suffix*/
        i[19]
      ),
      formatter: (
        /*formatter*/
        i[20]
      ),
      focus: (
        /*focus*/
        i[25]
      ),
      percentOf: (
        /*percentOf*/
        i[24]
      ),
      moveHandle: (
        /*moveHandle*/
        i[32]
      ),
      fixFloat: (
        /*fixFloat*/
        i[31]
      ),
      normalisedClient: gd
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*values*/
      1 && (l.values = /*values*/
      s[0]), n[0] & /*min*/
      8 && (l.min = /*min*/
      s[3]), n[0] & /*max*/
      16 && (l.max = /*max*/
      s[4]), n[0] & /*step*/
      32 && (l.step = /*step*/
      s[5]), n[0] & /*range*/
      4 && (l.range = /*range*/
      s[2]), n[0] & /*vertical*/
      64 && (l.vertical = /*vertical*/
      s[6]), n[0] & /*reversed*/
      256 && (l.reversed = /*reversed*/
      s[8]), n[0] & /*orientationStart*/
      536870912 && (l.orientationStart = /*orientationStart*/
      s[29]), n[0] & /*hoverable*/
      512 && (l.hoverable = /*hoverable*/
      s[9]), n[0] & /*disabled*/
      1024 && (l.disabled = /*disabled*/
      s[10]), n[0] & /*all*/
      8192 && (l.all = /*all*/
      s[13]), n[0] & /*first*/
      16384 && (l.first = /*first*/
      s[14]), n[0] & /*last*/
      32768 && (l.last = /*last*/
      s[15]), n[0] & /*rest*/
      65536 && (l.rest = /*rest*/
      s[16]), n[0] & /*pipstep*/
      4096 && (l.pipstep = /*pipstep*/
      s[12]), n[0] & /*prefix*/
      262144 && (l.prefix = /*prefix*/
      s[18]), n[0] & /*suffix*/
      524288 && (l.suffix = /*suffix*/
      s[19]), n[0] & /*formatter*/
      1048576 && (l.formatter = /*formatter*/
      s[20]), n[0] & /*focus*/
      33554432 && (l.focus = /*focus*/
      s[25]), n[0] & /*percentOf*/
      16777216 && (l.percentOf = /*percentOf*/
      s[24]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(G8, "create_if_block$v");
function tde(i) {
  let e, t, s, n, l, r, o = oe(
    /*values*/
    i[0]
  ), a = [];
  for (let d = 0; d < o.length; d += 1)
    a[d] = B8(F8(i, o, d));
  let c = (
    /*range*/
    i[2] && q8(i)
  ), u = (
    /*pips*/
    i[11] && G8(i)
  );
  return {
    c() {
      e = E("div");
      for (let d = 0; d < a.length; d += 1)
        a[d].c();
      t = R(), c && c.c(), s = R(), u && u.c(), b(
        e,
        "id",
        /*id*/
        i[17]
      ), b(e, "role", "none"), b(e, "class", "rangeSlider"), Q(
        e,
        "range",
        /*range*/
        i[2]
      ), Q(
        e,
        "disabled",
        /*disabled*/
        i[10]
      ), Q(
        e,
        "hoverable",
        /*hoverable*/
        i[9]
      ), Q(
        e,
        "vertical",
        /*vertical*/
        i[6]
      ), Q(
        e,
        "reversed",
        /*reversed*/
        i[8]
      ), Q(
        e,
        "focus",
        /*focus*/
        i[25]
      ), Q(
        e,
        "min",
        /*range*/
        i[2] === "min"
      ), Q(
        e,
        "max",
        /*range*/
        i[2] === "max"
      ), Q(
        e,
        "pips",
        /*pips*/
        i[11]
      ), Q(
        e,
        "pip-labels",
        /*all*/
        i[13] === "label" || /*first*/
        i[14] === "label" || /*last*/
        i[15] === "label" || /*rest*/
        i[16] === "label"
      );
    },
    m(d, p) {
      T(d, e, p);
      for (let m = 0; m < a.length; m += 1)
        a[m] && a[m].m(e, null);
      A(e, t), c && c.m(e, null), A(e, s), u && u.m(e, null), i[51](e), n = !0, l || (r = [
        V(
          window,
          "mousedown",
          /*bodyInteractStart*/
          i[40]
        ),
        V(
          window,
          "touchstart",
          /*bodyInteractStart*/
          i[40]
        ),
        V(
          window,
          "mousemove",
          /*bodyInteract*/
          i[41]
        ),
        V(
          window,
          "touchmove",
          /*bodyInteract*/
          i[41]
        ),
        V(
          window,
          "mouseup",
          /*bodyMouseUp*/
          i[42]
        ),
        V(
          window,
          "touchend",
          /*bodyTouchEnd*/
          i[43]
        ),
        V(
          window,
          "keydown",
          /*bodyKeyDown*/
          i[44]
        ),
        V(
          e,
          "mousedown",
          /*sliderInteractStart*/
          i[38]
        ),
        V(
          e,
          "mouseup",
          /*sliderInteractEnd*/
          i[39]
        ),
        V(e, "touchstart", tt(
          /*sliderInteractStart*/
          i[38]
        )),
        V(e, "touchend", tt(
          /*sliderInteractEnd*/
          i[39]
        ))
      ], l = !0);
    },
    p(d, p) {
      if (p[0] & /*orientationStart, $springPositions, activeHandle, ariaLabels, range, values, min, max, prefix, handleFormatter, percentOf, suffix, vertical, disabled, focus, handlePressed, float*/
      1869350109 | p[1] & /*sliderBlurHandle, sliderFocusHandle, sliderKeydown*/
      112) {
        o = oe(
          /*values*/
          d[0]
        );
        let m;
        for (m = 0; m < o.length; m += 1) {
          const g = F8(d, o, m);
          a[m] ? a[m].p(g, p) : (a[m] = B8(g), a[m].c(), a[m].m(e, t));
        }
        for (; m < a.length; m += 1)
          a[m].d(1);
        a.length = o.length;
      }
      /*range*/
      d[2] ? c ? c.p(d, p) : (c = q8(d), c.c(), c.m(e, s)) : c && (c.d(1), c = null), /*pips*/
      d[11] ? u ? (u.p(d, p), p[0] & /*pips*/
      2048 && w(u, 1)) : (u = G8(d), u.c(), w(u, 1), u.m(e, null)) : u && (ce(), C(u, 1, 1, () => {
        u = null;
      }), ue()), (!n || p[0] & /*id*/
      131072) && b(
        e,
        "id",
        /*id*/
        d[17]
      ), (!n || p[0] & /*range*/
      4) && Q(
        e,
        "range",
        /*range*/
        d[2]
      ), (!n || p[0] & /*disabled*/
      1024) && Q(
        e,
        "disabled",
        /*disabled*/
        d[10]
      ), (!n || p[0] & /*hoverable*/
      512) && Q(
        e,
        "hoverable",
        /*hoverable*/
        d[9]
      ), (!n || p[0] & /*vertical*/
      64) && Q(
        e,
        "vertical",
        /*vertical*/
        d[6]
      ), (!n || p[0] & /*reversed*/
      256) && Q(
        e,
        "reversed",
        /*reversed*/
        d[8]
      ), (!n || p[0] & /*focus*/
      33554432) && Q(
        e,
        "focus",
        /*focus*/
        d[25]
      ), (!n || p[0] & /*range*/
      4) && Q(
        e,
        "min",
        /*range*/
        d[2] === "min"
      ), (!n || p[0] & /*range*/
      4) && Q(
        e,
        "max",
        /*range*/
        d[2] === "max"
      ), (!n || p[0] & /*pips*/
      2048) && Q(
        e,
        "pips",
        /*pips*/
        d[11]
      ), (!n || p[0] & /*all, first, last, rest*/
      122880) && Q(
        e,
        "pip-labels",
        /*all*/
        d[13] === "label" || /*first*/
        d[14] === "label" || /*last*/
        d[15] === "label" || /*rest*/
        d[16] === "label"
      );
    },
    i(d) {
      n || (w(u), n = !0);
    },
    o(d) {
      C(u), n = !1;
    },
    d(d) {
      d && S(e), Le(a, d), c && c.d(), u && u.d(), i[51](null), l = !1, Ne(r);
    }
  };
}
f(tde, "create_fragment$_");
function z8(i) {
  if (!i)
    return -1;
  for (var e = 0; i = i.previousElementSibling; )
    e++;
  return e;
}
f(z8, "index");
function gd(i) {
  return i.type.includes("touch") ? i.touches[0] || i.changedTouches[0] : i;
}
f(gd, "normalisedClient");
function H8(i) {
  return `${i}`.replace(/<[^>]*>/g, "");
}
f(H8, "pureText");
function sde(i, e, t) {
  let s, n, l, r, o, a, c = ee, u = /* @__PURE__ */ f(() => (c(), c = Et(rt, (Se) => t(30, a = Se)), rt), "$$subscribe_springPositions");
  i.$$.on_destroy.push(() => c());
  let { slider: d = void 0 } = e, { range: p = !1 } = e, { pushy: m = !1 } = e, { min: g = 0 } = e, { max: h = 100 } = e, { step: _ = 1 } = e, { values: y = [(h + g) / 2] } = e, { vertical: k = !1 } = e, { float: v = !1 } = e, { reversed: O = !1 } = e, { hoverable: P = !0 } = e, { disabled: D = !1 } = e, { pips: I = !1 } = e, { pipstep: B = void 0 } = e, { all: F = void 0 } = e, { first: H = void 0 } = e, { last: G = void 0 } = e, { rest: U = void 0 } = e, { id: q = void 0 } = e, { prefix: W = "" } = e, { suffix: X = "" } = e, { formatter: te = /* @__PURE__ */ f((Se, xe, Tt) => Se, "formatter") } = e, { handleFormatter: J = te } = e, { ariaLabels: re = [] } = e, { precision: ae = 2 } = e, { springValues: be = { stiffness: 0.15, damping: 0.4 } } = e;
  const we = it();
  let ve = 0, me = !1, he = !1, Ae = !1, Fe = !1, Ve = y.length - 1, je, Pe, rt;
  const Te = /* @__PURE__ */ f((Se) => parseFloat((+Se).toFixed(ae)), "fixFloat");
  function Ee(Se) {
    const xe = d.querySelectorAll(".handle"), Tt = Array.prototype.includes.call(xe, Se), Ct = Array.prototype.some.call(xe, (yn) => yn.contains(Se));
    return Tt || Ct;
  }
  f(Ee, "targetIsHandle");
  function Be(Se) {
    return p === "min" || p === "max" ? Se.slice(0, 1) : p ? Se.slice(0, 2) : Se;
  }
  f(Be, "trimRange");
  function Ce() {
    return d.getBoundingClientRect();
  }
  f(Ce, "getSliderDimensions");
  function Re(Se) {
    const xe = Ce();
    let Tt = 0, Ct = 0, yn = 0;
    k ? (Tt = Se.clientY - xe.top, Ct = Tt / xe.height * 100, Ct = O ? Ct : 100 - Ct) : (Tt = Se.clientX - xe.left, Ct = Tt / xe.width * 100, Ct = O ? 100 - Ct : Ct), yn = (h - g) / 100 * Ct + g;
    let Pf;
    return p === !0 && y[0] === y[1] ? yn > y[1] ? 1 : 0 : (Pf = y.indexOf(
      [...y].sort((Mf, mb) => Math.abs(yn - Mf) - Math.abs(yn - mb))[0]
    ), Pf);
  }
  f(Re, "getClosestHandle");
  function Oe(Se) {
    const xe = Ce();
    let Tt = 0, Ct = 0, yn = 0;
    k ? (Tt = Se.clientY - xe.top, Ct = Tt / xe.height * 100, Ct = O ? Ct : 100 - Ct) : (Tt = Se.clientX - xe.left, Ct = Tt / xe.width * 100, Ct = O ? 100 - Ct : Ct), yn = (h - g) / 100 * Ct + g, Je(Ve, yn);
  }
  f(Oe, "handleInteract");
  function Je(Se, xe) {
    return xe = l(xe), typeof Se > "u" && (Se = Ve), p && (Se === 0 && xe > y[1] ? m ? t(0, y[1] = xe, y) : xe = y[1] : Se === 1 && xe < y[0] && (m ? t(0, y[0] = xe, y) : xe = y[0])), y[Se] !== xe && t(0, y[Se] = xe, y), Pe !== xe && (Vi(), Pe = xe), xe;
  }
  f(Je, "moveHandle");
  function Xe(Se) {
    return p === "min" ? 0 : Se[0];
  }
  f(Xe, "rangeStart");
  function Gt(Se) {
    return p === "max" ? 0 : p === "min" ? 100 - Se[0] : 100 - Se[1];
  }
  f(Gt, "rangeEnd");
  function zt(Se) {
    Fe && (t(25, me = !1), he = !1, t(26, Ae = !1));
  }
  f(zt, "sliderBlurHandle");
  function Hi(Se) {
    D || (t(27, Ve = z8(Se.target)), t(25, me = !0));
  }
  f(Hi, "sliderFocusHandle");
  function wl(Se) {
    if (!D) {
      const xe = z8(Se.target);
      let Tt = Se.ctrlKey || Se.metaKey || Se.shiftKey ? _ * 10 : _, Ct = !1;
      switch (Se.key) {
        case "PageDown":
          Tt *= 10;
        case "ArrowRight":
        case "ArrowUp":
          Je(xe, y[xe] + Tt), Ct = !0;
          break;
        case "PageUp":
          Tt *= 10;
        case "ArrowLeft":
        case "ArrowDown":
          Je(xe, y[xe] - Tt), Ct = !0;
          break;
        case "Home":
          Je(xe, g), Ct = !0;
          break;
        case "End":
          Je(xe, h), Ct = !0;
          break;
      }
      Ct && (Se.preventDefault(), Se.stopPropagation());
    }
  }
  f(wl, "sliderKeydown");
  function Ui(Se) {
    if (!D) {
      const xe = Se.target, Tt = gd(Se);
      t(25, me = !0), he = !0, t(26, Ae = !0), t(27, Ve = Re(Tt)), je = Pe = l(y[Ve]), Na(), Se.type === "touchstart" && !xe.matches(".pipVal") && Oe(Tt);
    }
  }
  f(Ui, "sliderInteractStart");
  function St(Se) {
    Se.type === "touchend" && If(), t(26, Ae = !1);
  }
  f(St, "sliderInteractEnd");
  function Xs(Se) {
    Fe = !1, me && Se.target !== d && !d.contains(Se.target) && t(25, me = !1);
  }
  f(Xs, "bodyInteractStart");
  function $l(Se) {
    D || he && Oe(gd(Se));
  }
  f($l, "bodyInteract");
  function Ht(Se) {
    if (!D) {
      const xe = Se.target;
      he && ((xe === d || d.contains(xe)) && (t(25, me = !0), !Ee(xe) && !xe.matches(".pipVal") && Oe(gd(Se))), If());
    }
    he = !1, t(26, Ae = !1);
  }
  f(Ht, "bodyMouseUp");
  function fi(Se) {
    he = !1, t(26, Ae = !1);
  }
  f(fi, "bodyTouchEnd");
  function Fa(Se) {
    D || (Se.target === d || d.contains(Se.target)) && (Fe = !0);
  }
  f(Fa, "bodyKeyDown");
  function Na() {
    !D && we("start", {
      activeHandle: Ve,
      value: je,
      values: y.map((Se) => l(Se))
    });
  }
  f(Na, "eStart");
  function If() {
    !D && we("stop", {
      activeHandle: Ve,
      startValue: je,
      value: y[Ve],
      values: y.map((Se) => l(Se))
    });
  }
  f(If, "eStop");
  function Vi() {
    !D && we("change", {
      activeHandle: Ve,
      startValue: je,
      previousValue: typeof Pe > "u" ? je : Pe,
      value: y[Ve],
      values: y.map((Se) => l(Se))
    });
  }
  f(Vi, "eChange");
  function pb(Se) {
    st[Se ? "unshift" : "push"](() => {
      d = Se, t(1, d);
    });
  }
  return f(pb, "div_binding"), i.$$set = (Se) => {
    "slider" in Se && t(1, d = Se.slider), "range" in Se && t(2, p = Se.range), "pushy" in Se && t(45, m = Se.pushy), "min" in Se && t(3, g = Se.min), "max" in Se && t(4, h = Se.max), "step" in Se && t(5, _ = Se.step), "values" in Se && t(0, y = Se.values), "vertical" in Se && t(6, k = Se.vertical), "float" in Se && t(7, v = Se.float), "reversed" in Se && t(8, O = Se.reversed), "hoverable" in Se && t(9, P = Se.hoverable), "disabled" in Se && t(10, D = Se.disabled), "pips" in Se && t(11, I = Se.pips), "pipstep" in Se && t(12, B = Se.pipstep), "all" in Se && t(13, F = Se.all), "first" in Se && t(14, H = Se.first), "last" in Se && t(15, G = Se.last), "rest" in Se && t(16, U = Se.rest), "id" in Se && t(17, q = Se.id), "prefix" in Se && t(18, W = Se.prefix), "suffix" in Se && t(19, X = Se.suffix), "formatter" in Se && t(20, te = Se.formatter), "handleFormatter" in Se && t(21, J = Se.handleFormatter), "ariaLabels" in Se && t(22, re = Se.ariaLabels), "precision" in Se && t(46, ae = Se.precision), "springValues" in Se && t(47, be = Se.springValues);
  }, i.$$.update = () => {
    if (i.$$.dirty[0] & /*min, max*/
    24 && t(50, n = /* @__PURE__ */ f(function(Se) {
      return Se <= g ? g : Se >= h ? h : Se;
    }, "clampValue")), i.$$.dirty[0] & /*min, max, step*/
    56 | i.$$.dirty[1] & /*clampValue*/
    524288 && t(49, l = /* @__PURE__ */ f(function(Se) {
      if (Se <= g)
        return Te(g);
      if (Se >= h)
        return Te(h);
      Se = Te(Se);
      let xe = (Se - g) % _, Tt = Se - xe;
      return Math.abs(xe) * 2 >= _ && (Tt += xe > 0 ? _ : -_), Tt = n(Tt), Te(Tt);
    }, "alignValueToStep")), i.$$.dirty[0] & /*min, max*/
    24 && t(24, s = /* @__PURE__ */ f(function(Se) {
      let xe = (Se - g) / (h - g) * 100;
      return isNaN(xe) || xe <= 0 ? 0 : xe >= 100 ? 100 : Te(xe);
    }, "percentOf")), i.$$.dirty[0] & /*values, max, min, percentOf, springPositions, ariaLabels*/
    29360153 | i.$$.dirty[1] & /*alignValueToStep, valueLength, springValues*/
    458752) {
      Array.isArray(y) || (t(0, y = [(h + g) / 2]), console.error("'values' prop should be an Array (https://github.com/simeydotme/svelte-range-slider-pips#slider-props)"));
      const Se = Be(y.map((xe) => l(xe)));
      (y.length !== Se.length || !y.every((xe, Tt) => Te(xe) === Se[Tt])) && t(0, y = Se), ve !== y.length ? u(t(23, rt = Qfe(y.map((xe) => s(xe)), be))) : rt.set(y.map((xe) => s(xe))), t(48, ve = y.length), y.length > 1 && !Array.isArray(re) && console.warn("'ariaLabels' prop should be an Array (https://github.com/simeydotme/svelte-range-slider-pips#slider-props)");
    }
    i.$$.dirty[0] & /*vertical, reversed*/
    320 && t(29, r = k ? O ? "top" : "bottom" : O ? "right" : "left"), i.$$.dirty[0] & /*vertical, reversed*/
    320 && t(28, o = k ? O ? "bottom" : "top" : O ? "left" : "right");
  }, [
    y,
    d,
    p,
    g,
    h,
    _,
    k,
    v,
    O,
    P,
    D,
    I,
    B,
    F,
    H,
    G,
    U,
    q,
    W,
    X,
    te,
    J,
    re,
    rt,
    s,
    me,
    Ae,
    Ve,
    o,
    r,
    a,
    Te,
    Je,
    Xe,
    Gt,
    zt,
    Hi,
    wl,
    Ui,
    St,
    Xs,
    $l,
    Ht,
    fi,
    Fa,
    m,
    ae,
    be,
    ve,
    l,
    n,
    pb
  ];
}
f(sde, "instance$U");
const CC = class CC extends ie {
  constructor(e) {
    super(), le(
      this,
      e,
      sde,
      tde,
      ne,
      {
        slider: 1,
        range: 2,
        pushy: 45,
        min: 3,
        max: 4,
        step: 5,
        values: 0,
        vertical: 6,
        float: 7,
        reversed: 8,
        hoverable: 9,
        disabled: 10,
        pips: 11,
        pipstep: 12,
        all: 13,
        first: 14,
        last: 15,
        rest: 16,
        id: 17,
        prefix: 18,
        suffix: 19,
        formatter: 20,
        handleFormatter: 21,
        ariaLabels: 22,
        precision: 46,
        springValues: 47
      },
      null,
      [-1, -1, -1]
    );
  }
};
f(CC, "RangeSlider");
let yp = CC;
function U8(i, e, t) {
  const s = i.slice();
  return s[11] = e[t].display, s[12] = e[t].heading, s[13] = e[t].filterKey, s[14] = e[t].options, s;
}
f(U8, "get_each_context$k");
function nde(i) {
  let e, t, s;
  return e = new yp({
    props: {
      first: "label",
      last: "label",
      min: 0,
      max: 6,
      pips: !0,
      pipstep: 1,
      range: !0,
      springValues: { stiffness: 1, damping: 1 },
      step: 1,
      values: [
        /*filterSelections*/
        i[0].exertion.min,
        /*filterSelections*/
        i[0].exertion.max
      ]
    }
  }), e.$on(
    "change",
    /*change_handler*/
    i[5]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--range-handle", "#425f65"), z(t, "--range-handle-focus", "#425f65"), z(t, "--range-handle-inactive", "#425f65"), z(t, "--range-pip", "#7e7960"), z(t, "--range-slider", "#c8c6be");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*filterSelections*/
      1 && (r.values = [
        /*filterSelections*/
        n[0].exertion.min,
        /*filterSelections*/
        n[0].exertion.max
      ]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(nde, "create_default_slot$l");
function ide(i) {
  let e, t;
  function s(...r) {
    return (
      /*updateExclusiveMode_handler*/
      i[6](
        /*filterKey*/
        i[13],
        ...r
      )
    );
  }
  f(s, "updateExclusiveMode_handler");
  function n(...r) {
    return (
      /*updateInclusiveMode_handler*/
      i[7](
        /*filterKey*/
        i[13],
        ...r
      )
    );
  }
  f(n, "updateInclusiveMode_handler");
  function l(...r) {
    return (
      /*updateSelection_handler*/
      i[8](
        /*filterKey*/
        i[13],
        ...r
      )
    );
  }
  return f(l, "updateSelection_handler"), e = new Oa({
    props: {
      filterKey: (
        /*filterKey*/
        i[13]
      ),
      filterSelections: (
        /*filterSelections*/
        i[0]
      ),
      heading: (
        /*heading*/
        i[12]
      ),
      options: (
        /*options*/
        i[14]
      )
    }
  }), e.$on("updateExclusiveMode", s), e.$on("updateInclusiveMode", n), e.$on("updateSelection", l), {
    c() {
      L(e.$$.fragment);
    },
    m(r, o) {
      N(e, r, o), t = !0;
    },
    p(r, o) {
      i = r;
      const a = {};
      o & /*filterSelections*/
      1 && (a.filterSelections = /*filterSelections*/
      i[0]), e.$set(a);
    },
    i(r) {
      t || (w(e.$$.fragment, r), t = !0);
    },
    o(r) {
      C(e.$$.fragment, r), t = !1;
    },
    d(r) {
      j(e, r);
    }
  };
}
f(ide, "create_if_block$u");
function V8(i) {
  let e, t, s = (
    /*display*/
    (i[11] ?? !0) && ide(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*display*/
      (n[11] ?? !0) && s.p(n, l);
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f(V8, "create_each_block$k");
function lde(i) {
  let e, t, s, n, l;
  e = new bt({
    props: {
      heading: "Exertion Cost Range (" + /*exertionCostLabel*/
      i[1] + ")",
      $$slots: { default: [nde] },
      $$scope: { ctx: i }
    }
  });
  let r = oe(
    /*formSectionMap*/
    i[4]
  ), o = [];
  for (let c = 0; c < r.length; c += 1)
    o[c] = V8(U8(i, r, c));
  const a = /* @__PURE__ */ f((c) => C(o[c], 1, 1, () => {
    o[c] = null;
  }), "out");
  return {
    c() {
      t = E("div"), L(e.$$.fragment), s = R();
      for (let c = 0; c < o.length; c += 1)
        o[c].c();
      n = $e(), z(t, "display", "contents"), z(t, "--label-width", "100%");
    },
    m(c, u) {
      T(c, t, u), N(e, t, null), T(c, s, u);
      for (let d = 0; d < o.length; d += 1)
        o[d] && o[d].m(c, u);
      T(c, n, u), l = !0;
    },
    p(c, [u]) {
      const d = {};
      if (u & /*exertionCostLabel*/
      2 && (d.heading = "Exertion Cost Range (" + /*exertionCostLabel*/
      c[1] + ")"), u & /*$$scope, filterSelections*/
      131073 && (d.$$scope = { dirty: u, ctx: c }), e.$set(d), u & /*formSectionMap, filterSelections, filterStore*/
      21) {
        r = oe(
          /*formSectionMap*/
          c[4]
        );
        let p;
        for (p = 0; p < r.length; p += 1) {
          const m = U8(c, r, p);
          o[p] ? (o[p].p(m, u), w(o[p], 1)) : (o[p] = V8(m), o[p].c(), w(o[p], 1), o[p].m(n.parentNode, n));
        }
        for (ce(), p = r.length; p < o.length; p += 1)
          a(p);
        ue();
      }
    },
    i(c) {
      if (!l) {
        w(e.$$.fragment, c);
        for (let u = 0; u < r.length; u += 1)
          w(o[u]);
        l = !0;
      }
    },
    o(c) {
      C(e.$$.fragment, c), o = o.filter(Boolean);
      for (let u = 0; u < o.length; u += 1)
        C(o[u]);
      l = !1;
    },
    d(c) {
      c && (S(s), S(n)), c && e && S(t), j(e, c), Le(o, c);
    }
  };
}
f(lde, "create_fragment$Z");
function rde({ exertion: i }) {
  const { min: e, max: t } = i;
  return e === t ? e : `${e}–${t}`;
}
f(rde, "getExertionCostLabel");
function ode(i, e, t) {
  let s;
  const n = fe("filterStore"), { maneuverDegrees: l, maneuverTraditions: r } = CONFIG.A5E;
  function o([g, h]) {
    n.update((_) => ({
      ..._,
      exertion: { min: g, max: h }
    }));
  }
  f(o, "updateExertionRange");
  let a = {};
  n.subscribe((g) => {
    t(0, a = g);
  });
  const c = [
    {
      filterKey: "maneuverDegrees",
      heading: "Maneuver Degrees",
      options: l
    },
    {
      filterKey: "maneuverTraditions",
      heading: "Maneuver Traditions",
      options: r
    },
    {
      filterKey: "miscellaneous",
      heading: "Miscellaneous",
      options: {
        concentration: "Concentration",
        stance: "Stance"
      }
    }
  ], u = /* @__PURE__ */ f(({ detail: g }) => o(g.values), "change_handler"), d = /* @__PURE__ */ f((g, { detail: h }) => {
    n.update((_) => ({
      ..._,
      [g]: {
        inclusive: a[g].inclusive,
        inclusiveMode: a[g].inclusiveMode,
        exclusive: a[g].exclusive,
        exclusiveMode: h
      }
    }));
  }, "updateExclusiveMode_handler"), p = /* @__PURE__ */ f((g, { detail: h }) => {
    n.update((_) => ({
      ..._,
      [g]: {
        inclusive: a[g].inclusive,
        inclusiveMode: h,
        exclusive: a[g].exclusive,
        exclusiveMode: a[g].exclusiveMode
      }
    }));
  }, "updateInclusiveMode_handler"), m = /* @__PURE__ */ f((g, { detail: h }) => {
    n.update((_) => ({
      ..._,
      [g]: {
        inclusive: h[0],
        inclusiveMode: a[g].inclusiveMode,
        exclusive: h[1],
        exclusiveMode: a[g].exclusiveMode
      }
    }));
  }, "updateSelection_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*filterSelections*/
    1 && t(1, s = rde(a));
  }, [
    a,
    s,
    n,
    o,
    c,
    u,
    d,
    p,
    m
  ];
}
f(ode, "instance$T");
const OC = class OC extends ie {
  constructor(e) {
    super(), le(this, e, ode, lde, ne, {});
  }
};
f(OC, "CompendiumManeuverFilters");
let xk = OC;
function W8(i, e, t) {
  const s = i.slice();
  return s[13] = e[t].heading, s[14] = e[t].filterKey, s[15] = e[t].options, s;
}
f(W8, "get_each_context$j");
function ade(i) {
  let e, t, s;
  return e = new yp({
    props: {
      first: "label",
      last: "label",
      min: 0,
      max: 30,
      pips: !0,
      pipstep: 1,
      range: !0,
      springValues: { stiffness: 1, damping: 1 },
      step: 1,
      values: [
        /*filterSelections*/
        i[0].cr.min,
        /*filterSelections*/
        i[0].cr.max
      ]
    }
  }), e.$on(
    "change",
    /*change_handler*/
    i[6]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--range-handle", "#425f65"), z(t, "--range-handle-focus", "#425f65"), z(t, "--range-handle-inactive", "#425f65"), z(t, "--range-pip", "#7e7960"), z(t, "--range-slider", "#c8c6be");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*filterSelections*/
      1 && (r.values = [
        /*filterSelections*/
        n[0].cr.min,
        /*filterSelections*/
        n[0].cr.max
      ]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(ade, "create_default_slot$k");
function K8(i) {
  let e, t;
  function s(...r) {
    return (
      /*updateExclusiveMode_handler*/
      i[7](
        /*filterKey*/
        i[14],
        ...r
      )
    );
  }
  f(s, "updateExclusiveMode_handler");
  function n(...r) {
    return (
      /*updateInclusiveMode_handler*/
      i[8](
        /*filterKey*/
        i[14],
        ...r
      )
    );
  }
  f(n, "updateInclusiveMode_handler");
  function l(...r) {
    return (
      /*updateSelection_handler*/
      i[9](
        /*filterKey*/
        i[14],
        ...r
      )
    );
  }
  return f(l, "updateSelection_handler"), e = new Oa({
    props: {
      filterKey: (
        /*filterKey*/
        i[14]
      ),
      filterSelections: (
        /*filterSelections*/
        i[0]
      ),
      heading: (
        /*heading*/
        i[13]
      ),
      options: (
        /*options*/
        i[15]
      )
    }
  }), e.$on("updateExclusiveMode", s), e.$on("updateInclusiveMode", n), e.$on("updateSelection", l), {
    c() {
      L(e.$$.fragment);
    },
    m(r, o) {
      N(e, r, o), t = !0;
    },
    p(r, o) {
      i = r;
      const a = {};
      o & /*filterSelections*/
      1 && (a.filterSelections = /*filterSelections*/
      i[0]), e.$set(a);
    },
    i(r) {
      t || (w(e.$$.fragment, r), t = !0);
    },
    o(r) {
      C(e.$$.fragment, r), t = !1;
    },
    d(r) {
      j(e, r);
    }
  };
}
f(K8, "create_each_block$j");
function cde(i) {
  let e, t, s, n, l;
  e = new bt({
    props: {
      heading: `CR Range (${/*crRangeLabel*/
      i[1]})`,
      $$slots: { default: [ade] },
      $$scope: { ctx: i }
    }
  });
  let r = oe(
    /*formSectionMap*/
    i[4]
  ), o = [];
  for (let c = 0; c < r.length; c += 1)
    o[c] = K8(W8(i, r, c));
  const a = /* @__PURE__ */ f((c) => C(o[c], 1, 1, () => {
    o[c] = null;
  }), "out");
  return {
    c() {
      t = E("div"), L(e.$$.fragment), s = R();
      for (let c = 0; c < o.length; c += 1)
        o[c].c();
      n = $e(), z(t, "display", "contents"), z(t, "--label-width", "100%");
    },
    m(c, u) {
      T(c, t, u), N(e, t, null), T(c, s, u);
      for (let d = 0; d < o.length; d += 1)
        o[d] && o[d].m(c, u);
      T(c, n, u), l = !0;
    },
    p(c, [u]) {
      const d = {};
      if (u & /*crRangeLabel*/
      2 && (d.heading = `CR Range (${/*crRangeLabel*/
      c[1]})`), u & /*$$scope, filterSelections*/
      262145 && (d.$$scope = { dirty: u, ctx: c }), e.$set(d), u & /*formSectionMap, filterSelections, filterStore*/
      21) {
        r = oe(
          /*formSectionMap*/
          c[4]
        );
        let p;
        for (p = 0; p < r.length; p += 1) {
          const m = W8(c, r, p);
          o[p] ? (o[p].p(m, u), w(o[p], 1)) : (o[p] = K8(m), o[p].c(), w(o[p], 1), o[p].m(n.parentNode, n));
        }
        for (ce(), p = r.length; p < o.length; p += 1)
          a(p);
        ue();
      }
    },
    i(c) {
      if (!l) {
        w(e.$$.fragment, c);
        for (let u = 0; u < r.length; u += 1)
          w(o[u]);
        l = !0;
      }
    },
    o(c) {
      C(e.$$.fragment, c), o = o.filter(Boolean);
      for (let u = 0; u < o.length; u += 1)
        C(o[u]);
      l = !1;
    },
    d(c) {
      c && (S(s), S(n)), c && e && S(t), j(e, c), Le(o, c);
    }
  };
}
f(cde, "create_fragment$Y");
function ude({ cr: i }) {
  const { min: e, max: t } = i;
  return e === t ? e : `${e}–${t}`;
}
f(ude, "getChallengeRatingRangeLabel");
function fde(i, e, t) {
  let s;
  const n = "monster", l = fe("filterStore"), { actorSizes: r, creatureTypes: o, terrainTypes: a } = CONFIG.A5E;
  function c([_, y]) {
    l.update((k) => ({
      ...k,
      cr: { min: _, max: y }
    }));
  }
  f(c, "updateChallengeRatingRange");
  const u = [
    {
      filterKey: "creatureTypes",
      heading: "Creature Types",
      options: o
    },
    {
      filterKey: "terrain",
      heading: "Terrain",
      options: a
    },
    {
      filterKey: "creatureSize",
      heading: "Creature Size",
      options: r
    },
    {
      filterKey: "miscellaneous",
      heading: "Miscellaneous",
      options: { elite: "Elite", swarm: "Swarm" }
    }
  ];
  let d = {};
  l.subscribe((_) => {
    t(0, d = _);
  });
  const p = /* @__PURE__ */ f(({ detail: _ }) => c(_.values), "change_handler"), m = /* @__PURE__ */ f((_, { detail: y }) => {
    l.update((k) => ({
      ...k,
      [_]: {
        inclusive: d[_].inclusive,
        inclusiveMode: d[_].inclusiveMode,
        exclusive: d[_].exclusive,
        exclusiveMode: y
      }
    }));
  }, "updateExclusiveMode_handler"), g = /* @__PURE__ */ f((_, { detail: y }) => {
    l.update((k) => ({
      ...k,
      [_]: {
        inclusive: d[_].inclusive,
        inclusiveMode: y,
        exclusive: d[_].exclusive,
        exclusiveMode: d[_].exclusiveMode
      }
    }));
  }, "updateInclusiveMode_handler"), h = /* @__PURE__ */ f((_, { detail: y }) => {
    l.update((k) => ({
      ...k,
      [_]: {
        inclusive: y[0],
        inclusiveMode: d[_].inclusiveMode,
        exclusive: y[1],
        exclusiveMode: d[_].exclusiveMode
      }
    }));
  }, "updateSelection_handler");
  return i.$$.update = () => {
    i.$$.dirty & /*filterSelections*/
    1 && t(1, s = ude(d));
  }, [
    d,
    s,
    l,
    c,
    u,
    n,
    p,
    m,
    g,
    h
  ];
}
f(fde, "instance$S");
const DC = class DC extends ie {
  constructor(e) {
    super(), le(this, e, fde, cde, ne, { compendiumType: 5 });
  }
  get compendiumType() {
    return this.$$.ctx[5];
  }
};
f(DC, "CompendiumMonsterFilters");
let ew = DC;
function Y8(i, e, t) {
  const s = i.slice();
  return s[9] = e[t].display, s[10] = e[t].heading, s[11] = e[t].filterKey, s[12] = e[t].options, s;
}
f(Y8, "get_each_context$i");
function dde(i) {
  let e, t;
  function s(...r) {
    return (
      /*updateExclusiveMode_handler*/
      i[4](
        /*filterKey*/
        i[11],
        ...r
      )
    );
  }
  f(s, "updateExclusiveMode_handler");
  function n(...r) {
    return (
      /*updateInclusiveMode_handler*/
      i[5](
        /*filterKey*/
        i[11],
        ...r
      )
    );
  }
  f(n, "updateInclusiveMode_handler");
  function l(...r) {
    return (
      /*updateSelection_handler*/
      i[6](
        /*filterKey*/
        i[11],
        ...r
      )
    );
  }
  return f(l, "updateSelection_handler"), e = new Oa({
    props: {
      filterKey: (
        /*filterKey*/
        i[11]
      ),
      filterSelections: (
        /*filterSelections*/
        i[0]
      ),
      heading: (
        /*heading*/
        i[10]
      ),
      options: (
        /*options*/
        i[12]
      )
    }
  }), e.$on("updateExclusiveMode", s), e.$on("updateInclusiveMode", n), e.$on("updateSelection", l), {
    c() {
      L(e.$$.fragment);
    },
    m(r, o) {
      N(e, r, o), t = !0;
    },
    p(r, o) {
      i = r;
      const a = {};
      o & /*filterSelections*/
      1 && (a.filterSelections = /*filterSelections*/
      i[0]), e.$set(a);
    },
    i(r) {
      t || (w(e.$$.fragment, r), t = !0);
    },
    o(r) {
      C(e.$$.fragment, r), t = !1;
    },
    d(r) {
      j(e, r);
    }
  };
}
f(dde, "create_if_block$t");
function X8(i) {
  let e, t, s = (
    /*display*/
    (i[9] ?? !0) && dde(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*display*/
      (n[9] ?? !0) && s.p(n, l);
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f(X8, "create_each_block$i");
function pde(i) {
  let e, t, s = oe(
    /*getFormSections*/
    i[2]()
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = X8(Y8(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, [o]) {
      if (o & /*getFormSections, filterSelections, filterStore*/
      7) {
        s = oe(
          /*getFormSections*/
          r[2]()
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = Y8(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = X8(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f(pde, "create_fragment$X");
function mde(i, e, t) {
  let { compendiumType: s = "magicItem" } = e;
  const n = fe("filterStore"), { itemRarity: l, objectTypes: r } = CONFIG.A5E;
  function o() {
    const p = [
      {
        filterKey: "objectType",
        heading: "Object Type",
        options: r
      },
      {
        filterKey: "rarity",
        heading: "Item Rarity",
        options: l,
        display: s === "magicItem"
      },
      {
        filterKey: "miscellaneous",
        heading: "Miscellaneous",
        options: { bulky: "Bulky" }
      }
    ];
    if (s === "magicItem") {
      const m = p.find((g) => g.filterKey === "miscellaneous");
      m.options.requiresAttunement = "Requires Attunement";
    }
    return p;
  }
  f(o, "getFormSections");
  let a = {};
  n.subscribe((p) => {
    t(0, a = p);
  });
  const c = /* @__PURE__ */ f((p, { detail: m }) => {
    n.update((g) => ({
      ...g,
      [p]: {
        inclusive: a[p].inclusive,
        inclusiveMode: a[p].inclusiveMode,
        exclusive: a[p].exclusive,
        exclusiveMode: m
      }
    }));
  }, "updateExclusiveMode_handler"), u = /* @__PURE__ */ f((p, { detail: m }) => {
    n.update((g) => ({
      ...g,
      [p]: {
        inclusive: a[p].inclusive,
        inclusiveMode: m,
        exclusive: a[p].exclusive,
        exclusiveMode: a[p].exclusiveMode
      }
    }));
  }, "updateInclusiveMode_handler"), d = /* @__PURE__ */ f((p, { detail: m }) => {
    n.update((g) => ({
      ...g,
      [p]: {
        inclusive: m[0],
        inclusiveMode: a[p].inclusiveMode,
        exclusive: m[1],
        exclusiveMode: a[p].exclusiveMode
      }
    }));
  }, "updateSelection_handler");
  return i.$$set = (p) => {
    "compendiumType" in p && t(3, s = p.compendiumType);
  }, [
    a,
    n,
    o,
    s,
    c,
    u,
    d
  ];
}
f(mde, "instance$R");
const IC = class IC extends ie {
  constructor(e) {
    super(), le(this, e, mde, pde, ne, { compendiumType: 3 });
  }
};
f(IC, "CompendiumObjectFilters");
let vp = IC;
function J8(i, e, t) {
  const s = i.slice();
  return s[11] = e[t].display, s[12] = e[t].heading, s[13] = e[t].filterKey, s[14] = e[t].options, s;
}
f(J8, "get_each_context$h");
function hde(i) {
  let e, t;
  function s(...r) {
    return (
      /*updateExclusiveMode_handler*/
      i[4](
        /*filterKey*/
        i[13],
        ...r
      )
    );
  }
  f(s, "updateExclusiveMode_handler");
  function n(...r) {
    return (
      /*updateInclusiveMode_handler*/
      i[5](
        /*filterKey*/
        i[13],
        ...r
      )
    );
  }
  f(n, "updateInclusiveMode_handler");
  function l(...r) {
    return (
      /*updateSelection_handler*/
      i[6](
        /*filterKey*/
        i[13],
        ...r
      )
    );
  }
  return f(l, "updateSelection_handler"), e = new Oa({
    props: {
      filterKey: (
        /*filterKey*/
        i[13]
      ),
      filterSelections: (
        /*filterSelections*/
        i[0]
      ),
      heading: (
        /*heading*/
        i[12]
      ),
      options: (
        /*options*/
        i[14]
      )
    }
  }), e.$on("updateExclusiveMode", s), e.$on("updateInclusiveMode", n), e.$on("updateSelection", l), {
    c() {
      L(e.$$.fragment);
    },
    m(r, o) {
      N(e, r, o), t = !0;
    },
    p(r, o) {
      i = r;
      const a = {};
      o & /*filterSelections*/
      1 && (a.filterSelections = /*filterSelections*/
      i[0]), e.$set(a);
    },
    i(r) {
      t || (w(e.$$.fragment, r), t = !0);
    },
    o(r) {
      C(e.$$.fragment, r), t = !1;
    },
    d(r) {
      j(e, r);
    }
  };
}
f(hde, "create_if_block$s");
function Z8(i) {
  let e, t, s = (
    /*display*/
    (i[11] ?? !0) && hde(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      /*display*/
      (n[11] ?? !0) && s.p(n, l);
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f(Z8, "create_each_block$h");
function gde(i) {
  let e, t, s = oe(
    /*formSectionMap*/
    i[2]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = Z8(J8(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, [o]) {
      if (o & /*formSectionMap, filterSelections, filterStore*/
      7) {
        s = oe(
          /*formSectionMap*/
          r[2]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = J8(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = Z8(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f(gde, "create_fragment$W");
function bde(i, e, t) {
  let { compendiumType: s = "spell" } = e;
  const n = fe("filterStore"), { classSpellLists: l, spellLevels: r, spellSchools: o, spellComponents: a } = CONFIG.A5E;
  let c = {};
  n.subscribe((g) => {
    t(0, c = g);
  });
  const u = [
    {
      filterKey: "spellLists",
      heading: "Spell Lists",
      options: l,
      display: s === "spell"
    },
    {
      filterKey: "spellLevels",
      heading: "Spell Levels",
      options: r
    },
    {
      filterKey: "primarySpellSchools",
      heading: s === "spell" ? "Primary Spell Schools" : "Spell Schools",
      options: o.primary
    },
    {
      filterKey: "secondarySpellSchools",
      heading: "Secondary Spell Schools",
      options: o.secondary,
      display: s === "spell"
    },
    {
      filterKey: "components",
      heading: "Components",
      options: a
    },
    {
      filterKey: "miscellaneous",
      heading: "Miscellaneous",
      options: {
        concentration: "Concentration",
        rare: "Rare",
        ritual: "Ritual"
      }
    }
  ], d = /* @__PURE__ */ f((g, { detail: h }) => {
    n.update((_) => ({
      ..._,
      [g]: {
        inclusive: c[g].inclusive,
        inclusiveMode: c[g].inclusiveMode,
        exclusive: c[g].exclusive,
        exclusiveMode: h
      }
    }));
  }, "updateExclusiveMode_handler"), p = /* @__PURE__ */ f((g, { detail: h }) => {
    n.update((_) => ({
      ..._,
      [g]: {
        inclusive: c[g].inclusive,
        inclusiveMode: h,
        exclusive: c[g].exclusive,
        exclusiveMode: c[g].exclusiveMode
      }
    }));
  }, "updateInclusiveMode_handler"), m = /* @__PURE__ */ f((g, { detail: h }) => {
    n.update((_) => ({
      ..._,
      [g]: {
        inclusive: h[0],
        inclusiveMode: c[g].inclusiveMode,
        exclusive: h[1],
        exclusiveMode: c[g].exclusiveMode
      }
    }));
  }, "updateSelection_handler");
  return i.$$set = (g) => {
    "compendiumType" in g && t(3, s = g.compendiumType);
  }, [
    c,
    n,
    u,
    s,
    d,
    p,
    m
  ];
}
f(bde, "instance$Q");
const PC = class PC extends ie {
  constructor(e) {
    super(), le(this, e, bde, gde, ne, { compendiumType: 3 });
  }
};
f(PC, "CompendiumSpellFilters");
let kp = PC;
function _de(i) {
  let e, t, s, n;
  var l = (
    /*compendiumItemComponents*/
    i[1][
      /*compendiumType*/
      i[0]
    ]
  );
  function r(o, a) {
    return {
      props: {
        compendiumType: (
          /*compendiumType*/
          o[0]
        )
      }
    };
  }
  return f(r, "switch_props"), l && (t = nt(l, r(i))), {
    c() {
      e = E("section"), t && L(t.$$.fragment), b(e, "class", "filter-page svelte-v03x0d");
    },
    m(o, a) {
      T(o, e, a), t && N(t, e, null), n = !0;
    },
    p(o, [a]) {
      if (a & /*compendiumType*/
      1 && l !== (l = /*compendiumItemComponents*/
      o[1][
        /*compendiumType*/
        o[0]
      ])) {
        if (t) {
          ce();
          const c = t;
          C(c.$$.fragment, 1, 0, () => {
            j(c, 1);
          }), ue();
        }
        l ? (t = nt(l, r(o)), L(t.$$.fragment), w(t.$$.fragment, 1), N(t, e, null)) : t = null;
      } else if (l) {
        const c = {};
        a & /*compendiumType*/
        1 && (c.compendiumType = /*compendiumType*/
        o[0]), t.$set(c);
      }
    },
    i(o) {
      n || (t && w(t.$$.fragment, o), o && is(() => {
        n && (s || (s = dl(e, fa, {}, !0)), s.run(1));
      }), n = !0);
    },
    o(o) {
      t && C(t.$$.fragment, o), o && (s || (s = dl(e, fa, {}, !1)), s.run(0)), n = !1;
    },
    d(o) {
      o && S(e), t && j(t), o && s && s.end();
    }
  };
}
f(_de, "create_fragment$V");
function yde(i, e, t) {
  let { compendiumType: s } = e;
  const n = {
    "5eSpell": kp,
    object: vp,
    magicItem: vp,
    maneuver: xk,
    monster: ew,
    spell: kp
  };
  return i.$$set = (l) => {
    "compendiumType" in l && t(0, s = l.compendiumType);
  }, [s, n];
}
f(yde, "instance$P");
const MC = class MC extends ie {
  constructor(e) {
    super(), le(this, e, yde, _de, ne, { compendiumType: 0 });
  }
};
f(MC, "CompendiumFilters");
let wp = MC;
function vde(i) {
  return i == 0.125 ? "CR ⅛" : i == 0.25 ? "CR ¼" : i == 0.5 ? "CR ½" : `CR ${i}`;
}
f(vde, "getCRLabel$1");
function kde(i) {
  return i == 0 ? "Basic Maneuvers" : (typeof i == "string" && (i = parseInt(i, 10)), i = isNaN(i) ? 1 .ordinalString() : i.ordinalString(), `${i} Degree Maneuvers`);
}
f(kde, "getManueverDegreeLabel");
function wde(i) {
  return `${i.capitalize()} Items`;
}
f(wde, "getRarityLabel");
function $de(i) {
  return i == 0 ? "Cantrips" : (typeof i == "string" && (i = parseInt(i, 10)), i = isNaN(i) ? 1 .ordinalString() : i.ordinalString(), `${i} Level Spells`);
}
f($de, "getSpellLevelLabel");
function Ade(i, e) {
  return i === "monster" ? vde(e) : ["5eSpell", "spell"].includes(i) ? $de(e) : i === "maneuver" ? kde(e) : ["object", "magicItem"].includes(i) ? wde(e) : `${e}`;
}
f(Ade, "getCategoryNames");
function Ede(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "a5e-compendium-import-button fa-solid fa-download svelte-1pjwgjt"), b(e, "data-tooltip", t = `Import ${/*document*/
      i[0].name}`), b(e, "data-tooltip-direction", "UP");
    },
    m(l, r) {
      T(l, e, r), s || (n = V(e, "click", We(
        /*click_handler*/
        i[2]
      )), s = !0);
    },
    p(l, [r]) {
      r & /*document*/
      1 && t !== (t = `Import ${/*document*/
      l[0].name}`) && b(e, "data-tooltip", t);
    },
    i: ee,
    o: ee,
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Ede, "create_fragment$U");
function Sde(i, e, t) {
  let { document: s } = e;
  async function n() {
    const a = await l.getDocument(s._id);
    if (r) {
      r([a.toObject()]);
      return;
    }
    a.collection.importFromCompendium(a.compendium, a._id);
  }
  f(n, "importDocument");
  const l = fe("collection"), r = fe("customImporter"), o = /* @__PURE__ */ f(async () => n(), "click_handler");
  return i.$$set = (a) => {
    "document" in a && t(0, s = a.document);
  }, [s, n, o];
}
f(Sde, "instance$O");
const RC = class RC extends ie {
  constructor(e) {
    super(), le(this, e, Sde, Ede, ne, { document: 0 });
  }
};
f(RC, "ImportButton");
let Rr = RC;
function Tde(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("button"), b(e, "class", "a5e-compendium-delete-button fa-solid fa-trash svelte-j9zptw"), b(e, "data-tooltip", t = `Delete ${/*document*/
      i[0].name}`), b(e, "data-tooltip-direction", "UP");
    },
    m(l, r) {
      T(l, e, r), s || (n = V(e, "click", We(
        /*click_handler*/
        i[2]
      )), s = !0);
    },
    p(l, [r]) {
      r & /*document*/
      1 && t !== (t = `Delete ${/*document*/
      l[0].name}`) && b(e, "data-tooltip", t);
    },
    i: ee,
    o: ee,
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Tde, "create_fragment$T");
function Cde(i, e, t) {
  let { document: s } = e;
  async function n() {
    const a = { name: s.name, type: "Document" }, c = new Rc(a, !0);
    await c.render(!0);
    const u = await c.promise;
    !u || !(u != null && u.confirmDeletion) || (await l.delete(s._id), await r.render(!0));
  }
  f(n, "deleteDocument");
  const l = fe("collection"), r = fe("sheet"), o = /* @__PURE__ */ f(async () => n(), "click_handler");
  return i.$$set = (a) => {
    "document" in a && t(0, s = a.document);
  }, [s, n, o];
}
f(Cde, "instance$N");
const FC = class FC extends ie {
  constructor(e) {
    super(), le(this, e, Cde, Tde, ne, { document: 0 });
  }
};
f(FC, "CompendiumDeleteButton");
let Fr = FC;
function Q8(i) {
  let e, t;
  return {
    c() {
      e = E("i"), b(e, "class", "a5e-item__icon fa-solid fa-key"), b(e, "data-tooltip", t = ej(
        /*document*/
        i[0].system.prerequisite
      )), b(e, "data-tooltip-class", "a5e-tooltip a5e-tooltip--dark a5e-tooltip--basic"), b(e, "data-tooltip-direction", "DOWN");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*document*/
      1 && t !== (t = ej(
        /*document*/
        s[0].system.prerequisite
      )) && b(e, "data-tooltip", t);
    },
    d(s) {
      s && S(e);
    }
  };
}
f(Q8, "create_if_block_2$e");
function x8(i) {
  var a;
  let e, t = (
    /*featureSource*/
    ((a = i[1]) == null ? void 0 : a.abbreviation) + ""
  ), s, n, l, r, o;
  return {
    c() {
      var c;
      e = E("a"), s = x(t), b(e, "class", "a5e-item__source-tag"), b(e, "href", n = /*featureSource*/
      (c = i[1]) == null ? void 0 : c.url), b(e, "target", "_blank"), b(e, "data-tooltip", l = _n(
        /*featureSource*/
        i[1]
      )), b(e, "data-tooltip-class", "a5e-tooltip a5e-tooltip--dark a5e-tooltip--document-source");
    },
    m(c, u) {
      T(c, e, u), A(e, s), r || (o = V(e, "click", We(
        /*click_handler*/
        i[5]
      )), r = !0);
    },
    p(c, u) {
      var d, p;
      u & /*featureSource*/
      2 && t !== (t = /*featureSource*/
      ((d = c[1]) == null ? void 0 : d.abbreviation) + "") && _e(s, t), u & /*featureSource*/
      2 && n !== (n = /*featureSource*/
      (p = c[1]) == null ? void 0 : p.url) && b(e, "href", n), u & /*featureSource*/
      2 && l !== (l = _n(
        /*featureSource*/
        c[1]
      )) && b(e, "data-tooltip", l);
    },
    d(c) {
      c && S(e), r = !1, o();
    }
  };
}
f(x8, "create_if_block_1$k");
function Ode(i) {
  let e, t;
  return e = new Fr({ props: { document: (
    /*document*/
    i[0]
  ) } }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*document*/
      1 && (l.document = /*document*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Ode, "create_if_block$r");
function Dde(i) {
  var I;
  let e, t, s, n, l, r, o = (
    /*document*/
    i[0].name + ""
  ), a, c, u, d, p, m, g, h, _, y, k, v, O = (
    /*document*/
    i[0].system.prerequisite && Q8(i)
  ), P = (
    /*featureSource*/
    ((I = i[1]) == null ? void 0 : I.abbreviation) && x8(i)
  );
  h = new Rr({ props: { document: (
    /*document*/
    i[0]
  ) } });
  let D = !/*collection*/
  i[4].locked && Ode(i);
  return {
    c() {
      e = E("li"), t = E("img"), l = R(), r = E("h3"), a = x(o), c = R(), O && O.c(), u = R(), d = E("span"), P && P.c(), p = R(), m = x(
        /*featureDetails*/
        i[2]
      ), g = R(), L(h.$$.fragment), _ = R(), D && D.c(), b(t, "class", "a5e-item__image a5e-item__image--compendium-document"), ze(t.src, s = /*document*/
      i[0].img) || b(t, "src", s), b(t, "alt", n = /*document*/
      i[0].name), b(r, "class", "a5e-item__name a5e-item__name--compendium-document"), b(d, "class", "a5e-item__details"), b(e, "class", "a5e-item a5e-item--compendium-spell-document"), b(e, "draggable", "true");
    },
    m(B, F) {
      T(B, e, F), A(e, t), A(e, l), A(e, r), A(r, a), A(r, c), O && O.m(r, null), A(e, u), A(e, d), P && P.m(d, null), A(d, p), A(d, m), A(e, g), N(h, e, null), A(e, _), D && D.m(e, null), y = !0, k || (v = [
        V(
          e,
          "click",
          /*click_handler_1*/
          i[6]
        ),
        V(
          e,
          "dragstart",
          /*onDragStart*/
          i[3]
        )
      ], k = !0);
    },
    p(B, [F]) {
      var G;
      (!y || F & /*document*/
      1 && !ze(t.src, s = /*document*/
      B[0].img)) && b(t, "src", s), (!y || F & /*document*/
      1 && n !== (n = /*document*/
      B[0].name)) && b(t, "alt", n), (!y || F & /*document*/
      1) && o !== (o = /*document*/
      B[0].name + "") && _e(a, o), /*document*/
      B[0].system.prerequisite ? O ? O.p(B, F) : (O = Q8(B), O.c(), O.m(r, null)) : O && (O.d(1), O = null), /*featureSource*/
      (G = B[1]) != null && G.abbreviation ? P ? P.p(B, F) : (P = x8(B), P.c(), P.m(d, p)) : P && (P.d(1), P = null), (!y || F & /*featureDetails*/
      4) && _e(
        m,
        /*featureDetails*/
        B[2]
      );
      const H = {};
      F & /*document*/
      1 && (H.document = /*document*/
      B[0]), h.$set(H), /*collection*/
      B[4].locked || D.p(B, F);
    },
    i(B) {
      y || (w(h.$$.fragment, B), w(D), y = !0);
    },
    o(B) {
      C(h.$$.fragment, B), C(D), y = !1;
    },
    d(B) {
      B && S(e), O && O.d(), P && P.d(), j(h), D && D.d(), k = !1, Ne(v);
    }
  };
}
f(Dde, "create_fragment$S");
function ej(i) {
  return `<b>Prerequisites:</b> ${i}`;
}
f(ej, "getPrerequisiteTooltipContent");
function Ide(i, e, t) {
  let s, n, { document: l } = e;
  function r(_) {
    const y = {
      type: c.documentName,
      uuid: c.getUuid(l._id)
    };
    return _.dataTransfer.setData("text/plain", JSON.stringify(y));
  }
  f(r, "onDragStart");
  function o(_) {
    const y = _.system.classes, k = [u[y] ?? d[y]];
    return _.system.featureType === "knack" && k.push(p[y]), k.filter(Boolean).join(" | ");
  }
  f(o, "getFeatureDetailsLabel");
  function a(_) {
    return typeof _.system.source != "string" ? null : m[_.system.source] || null;
  }
  f(a, "getFeatureSource");
  const c = fe("collection"), { classes: u, classes5e: d, knackTypes: p, products: m } = CONFIG.A5E;
  function g(_) {
    gt.call(this, i, _);
  }
  f(g, "click_handler");
  const h = /* @__PURE__ */ f(async () => {
    var y;
    (y = (c.get(l._id) ?? await c.getDocument(l._id)).sheet) == null || y.render(!0);
  }, "click_handler_1");
  return i.$$set = (_) => {
    "document" in _ && t(0, l = _.document);
  }, i.$$.update = () => {
    i.$$.dirty & /*document*/
    1 && t(2, s = o(l)), i.$$.dirty & /*document*/
    1 && t(1, n = a(l));
  }, [
    l,
    n,
    s,
    r,
    c,
    g,
    h
  ];
}
f(Ide, "instance$M");
const NC = class NC extends ie {
  constructor(e) {
    super(), le(this, e, Ide, Dde, ne, { document: 0 });
  }
};
f(NC, "CompendiumClassFeatureItem");
let tw = NC;
function tj(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "a5e-item__icon fa-solid fa-street-view"), b(e, "data-tooltip", "Stance"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(tj, "create_if_block_2$d");
function sj(i) {
  var a;
  let e, t = (
    /*maneuverSource*/
    ((a = i[1]) == null ? void 0 : a.abbreviation) + ""
  ), s, n, l, r, o;
  return {
    c() {
      var c;
      e = E("a"), s = x(t), b(e, "class", "a5e-item__source-tag"), b(e, "href", n = /*maneuverSource*/
      (c = i[1]) == null ? void 0 : c.url), b(e, "target", "_blank"), b(e, "data-tooltip", l = _n(
        /*maneuverSource*/
        i[1]
      )), b(e, "data-tooltip-class", "a5e-tooltip a5e-tooltip--dark a5e-tooltip--document-source");
    },
    m(c, u) {
      T(c, e, u), A(e, s), r || (o = V(e, "click", We(
        /*click_handler*/
        i[5]
      )), r = !0);
    },
    p(c, u) {
      var d, p;
      u & /*maneuverSource*/
      2 && t !== (t = /*maneuverSource*/
      ((d = c[1]) == null ? void 0 : d.abbreviation) + "") && _e(s, t), u & /*maneuverSource*/
      2 && n !== (n = /*maneuverSource*/
      (p = c[1]) == null ? void 0 : p.url) && b(e, "href", n), u & /*maneuverSource*/
      2 && l !== (l = _n(
        /*maneuverSource*/
        c[1]
      )) && b(e, "data-tooltip", l);
    },
    d(c) {
      c && S(e), r = !1, o();
    }
  };
}
f(sj, "create_if_block_1$j");
function Pde(i) {
  let e, t;
  return e = new Fr({ props: { document: (
    /*document*/
    i[0]
  ) } }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*document*/
      1 && (l.document = /*document*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Pde, "create_if_block$q");
function Mde(i) {
  var I;
  let e, t, s, n, l, r, o = (
    /*document*/
    i[0].name + ""
  ), a, c, u, d, p, m, g, h, _, y, k, v, O = (
    /*document*/
    i[0].system.isStance && tj()
  ), P = (
    /*maneuverSource*/
    ((I = i[1]) == null ? void 0 : I.abbreviation) && sj(i)
  );
  h = new Rr({ props: { document: (
    /*document*/
    i[0]
  ) } });
  let D = !/*collection*/
  i[4].locked && Pde(i);
  return {
    c() {
      e = E("li"), t = E("img"), l = R(), r = E("h3"), a = x(o), c = R(), O && O.c(), u = R(), d = E("span"), P && P.c(), p = R(), m = x(
        /*maneuverDetails*/
        i[2]
      ), g = R(), L(h.$$.fragment), _ = R(), D && D.c(), b(t, "class", "a5e-item__image a5e-item__image--compendium-document"), ze(t.src, s = /*document*/
      i[0].img) || b(t, "src", s), b(t, "alt", n = /*document*/
      i[0].name), b(r, "class", "a5e-item__name a5e-item__name--compendium-document"), b(d, "class", "a5e-item__details"), b(e, "class", "a5e-item a5e-item--compendium-spell-document"), b(e, "draggable", "true");
    },
    m(B, F) {
      T(B, e, F), A(e, t), A(e, l), A(e, r), A(r, a), A(r, c), O && O.m(r, null), A(e, u), A(e, d), P && P.m(d, null), A(d, p), A(d, m), A(e, g), N(h, e, null), A(e, _), D && D.m(e, null), y = !0, k || (v = [
        V(
          e,
          "click",
          /*click_handler_1*/
          i[6]
        ),
        V(
          e,
          "dragstart",
          /*onDragStart*/
          i[3]
        )
      ], k = !0);
    },
    p(B, [F]) {
      var G;
      (!y || F & /*document*/
      1 && !ze(t.src, s = /*document*/
      B[0].img)) && b(t, "src", s), (!y || F & /*document*/
      1 && n !== (n = /*document*/
      B[0].name)) && b(t, "alt", n), (!y || F & /*document*/
      1) && o !== (o = /*document*/
      B[0].name + "") && _e(a, o), /*document*/
      B[0].system.isStance ? O || (O = tj(), O.c(), O.m(r, null)) : O && (O.d(1), O = null), /*maneuverSource*/
      (G = B[1]) != null && G.abbreviation ? P ? P.p(B, F) : (P = sj(B), P.c(), P.m(d, p)) : P && (P.d(1), P = null), (!y || F & /*maneuverDetails*/
      4) && _e(
        m,
        /*maneuverDetails*/
        B[2]
      );
      const H = {};
      F & /*document*/
      1 && (H.document = /*document*/
      B[0]), h.$set(H), /*collection*/
      B[4].locked || D.p(B, F);
    },
    i(B) {
      y || (w(h.$$.fragment, B), w(D), y = !0);
    },
    o(B) {
      C(h.$$.fragment, B), C(D), y = !1;
    },
    d(B) {
      B && S(e), O && O.d(), P && P.d(), j(h), D && D.d(), k = !1, Ne(v);
    }
  };
}
f(Mde, "create_fragment$R");
function Rde(i) {
  return typeof i.system.source != "string" ? null : CONFIG.A5E.products[i.system.source] || null;
}
f(Rde, "getManeuverSource");
function Fde(i, e, t) {
  let s, n, { document: l } = e;
  function r(m) {
    const g = {
      type: a.documentName,
      uuid: a.getUuid(l._id)
    };
    return m.dataTransfer.setData("text/plain", JSON.stringify(g));
  }
  f(r, "onDragStart");
  function o(m) {
    const g = c[parseInt(m.system.degree, 10)], h = u[m.system.tradition] ?? "", _ = m.system.isStance ? "Stance" : "", y = m.system.exertionCost ? `(${m.system.exertionCost} ${K(m.system.exertionCost > 1 ? "A5E.ExertionPointPlural" : "A5E.ExertionPoint")})` : "";
    return [g, h, _, y].filter(Boolean).join(" ");
  }
  f(o, "getManeuverDetailsLabel");
  const a = fe("collection"), { maneuverDegrees: c, maneuverTraditions: u } = CONFIG.A5E;
  function d(m) {
    gt.call(this, i, m);
  }
  f(d, "click_handler");
  const p = /* @__PURE__ */ f(async () => {
    var g;
    (g = (a.get(l._id) ?? await a.getDocument(l._id)).sheet) == null || g.render(!0);
  }, "click_handler_1");
  return i.$$set = (m) => {
    "document" in m && t(0, l = m.document);
  }, i.$$.update = () => {
    i.$$.dirty & /*document*/
    1 && t(2, s = o(l)), i.$$.dirty & /*document*/
    1 && t(1, n = Rde(l));
  }, [
    l,
    n,
    s,
    r,
    a,
    d,
    p
  ];
}
f(Fde, "instance$L");
const jC = class jC extends ie {
  constructor(e) {
    super(), le(this, e, Fde, Mde, ne, { document: 0 });
  }
};
f(jC, "CompendiumManeuverItem");
let sw = jC;
function nj(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "a5e-item__icon fa-solid fa-skull"), b(e, "data-tooltip", "Elite Monster"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(nj, "create_if_block_4$6");
function ij(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "a5e-item__icon fa-solid fa-people-group"), b(e, "data-tooltip", "Squad"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(ij, "create_if_block_3$7");
function lj(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "a5e-item__icon fa-solid fa-locust"), b(e, "data-tooltip", "Swarm"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(lj, "create_if_block_2$c");
function rj(i) {
  var a;
  let e, t = (
    /*monsterSource*/
    ((a = i[1]) == null ? void 0 : a.abbreviation) + ""
  ), s, n, l, r, o;
  return {
    c() {
      var c;
      e = E("a"), s = x(t), b(e, "class", "a5e-item__source-tag"), b(e, "href", n = /*monsterSource*/
      (c = i[1]) == null ? void 0 : c.url), b(e, "target", "_blank"), b(e, "data-tooltip", l = _n(
        /*monsterSource*/
        i[1]
      )), b(e, "data-tooltip-class", "a5e-tooltip a5e-tooltip--dark a5e-tooltip--document-source");
    },
    m(c, u) {
      T(c, e, u), A(e, s), r || (o = V(e, "click", We(
        /*click_handler*/
        i[5]
      )), r = !0);
    },
    p(c, u) {
      var d, p;
      u & /*monsterSource*/
      2 && t !== (t = /*monsterSource*/
      ((d = c[1]) == null ? void 0 : d.abbreviation) + "") && _e(s, t), u & /*monsterSource*/
      2 && n !== (n = /*monsterSource*/
      (p = c[1]) == null ? void 0 : p.url) && b(e, "href", n), u & /*monsterSource*/
      2 && l !== (l = _n(
        /*monsterSource*/
        c[1]
      )) && b(e, "data-tooltip", l);
    },
    d(c) {
      c && S(e), r = !1, o();
    }
  };
}
f(rj, "create_if_block_1$i");
function Nde(i) {
  let e, t;
  return e = new Fr({ props: { document: (
    /*document*/
    i[0]
  ) } }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*document*/
      1 && (l.document = /*document*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Nde, "create_if_block$p");
function jde(i) {
  var G, U, q, W, X, te, J, re, ae, be, we;
  let e, t, s, n, l, r, o = (
    /*document*/
    ((G = i[0]) == null ? void 0 : G.name) + ""
  ), a, c, u, d, p, m, g, h, _, y, k, v, O, P, D = (
    /*document*/
    ((W = (q = (U = i[0]) == null ? void 0 : U.system) == null ? void 0 : q.details) == null ? void 0 : W.elite) && nj()
  ), I = (
    /*document*/
    ((J = (te = (X = i[0]) == null ? void 0 : X.system) == null ? void 0 : te.details) == null ? void 0 : J.isSquad) && ij()
  ), B = (
    /*document*/
    ((be = (ae = (re = i[0]) == null ? void 0 : re.system) == null ? void 0 : ae.details) == null ? void 0 : be.isSwarm) && lj()
  ), F = (
    /*monsterSource*/
    ((we = i[1]) == null ? void 0 : we.abbreviation) && rj(i)
  );
  y = new Rr({ props: { document: (
    /*document*/
    i[0]
  ) } });
  let H = !/*collection*/
  i[4].locked && Nde(i);
  return {
    c() {
      var ve, me;
      e = E("li"), t = E("img"), l = R(), r = E("h3"), a = x(o), c = R(), D && D.c(), u = R(), I && I.c(), d = R(), B && B.c(), p = R(), m = E("div"), F && F.c(), g = R(), h = x(
        /*monsterDetails*/
        i[2]
      ), _ = R(), L(y.$$.fragment), k = R(), H && H.c(), b(t, "class", "a5e-item__image a5e-item__image--compendium-document"), ze(t.src, s = /*document*/
      (ve = i[0]) == null ? void 0 : ve.img) || b(t, "src", s), b(t, "alt", n = /*document*/
      (me = i[0]) == null ? void 0 : me.name), b(r, "class", "a5e-item__name a5e-item__name--compendium-document"), b(m, "class", "a5e-item__details"), b(e, "class", "a5e-item a5e-item--compendium-document"), b(e, "draggable", "true");
    },
    m(ve, me) {
      T(ve, e, me), A(e, t), A(e, l), A(e, r), A(r, a), A(r, c), D && D.m(r, null), A(r, u), I && I.m(r, null), A(r, d), B && B.m(r, null), A(e, p), A(e, m), F && F.m(m, null), A(m, g), A(m, h), A(e, _), N(y, e, null), A(e, k), H && H.m(e, null), v = !0, O || (P = [
        V(
          e,
          "click",
          /*click_handler_1*/
          i[6]
        ),
        V(
          e,
          "dragstart",
          /*onDragStart*/
          i[3]
        )
      ], O = !0);
    },
    p(ve, [me]) {
      var Ae, Fe, Ve, je, Pe, rt, Te, Ee, Be, Ce, Re, Oe, Je;
      (!v || me & /*document*/
      1 && !ze(t.src, s = /*document*/
      (Ae = ve[0]) == null ? void 0 : Ae.img)) && b(t, "src", s), (!v || me & /*document*/
      1 && n !== (n = /*document*/
      (Fe = ve[0]) == null ? void 0 : Fe.name)) && b(t, "alt", n), (!v || me & /*document*/
      1) && o !== (o = /*document*/
      ((Ve = ve[0]) == null ? void 0 : Ve.name) + "") && _e(a, o), /*document*/
      (rt = (Pe = (je = ve[0]) == null ? void 0 : je.system) == null ? void 0 : Pe.details) != null && rt.elite ? D || (D = nj(), D.c(), D.m(r, u)) : D && (D.d(1), D = null), /*document*/
      (Be = (Ee = (Te = ve[0]) == null ? void 0 : Te.system) == null ? void 0 : Ee.details) != null && Be.isSquad ? I || (I = ij(), I.c(), I.m(r, d)) : I && (I.d(1), I = null), /*document*/
      (Oe = (Re = (Ce = ve[0]) == null ? void 0 : Ce.system) == null ? void 0 : Re.details) != null && Oe.isSwarm ? B || (B = lj(), B.c(), B.m(r, null)) : B && (B.d(1), B = null), /*monsterSource*/
      (Je = ve[1]) != null && Je.abbreviation ? F ? F.p(ve, me) : (F = rj(ve), F.c(), F.m(m, g)) : F && (F.d(1), F = null), (!v || me & /*monsterDetails*/
      4) && _e(
        h,
        /*monsterDetails*/
        ve[2]
      );
      const he = {};
      me & /*document*/
      1 && (he.document = /*document*/
      ve[0]), y.$set(he), /*collection*/
      ve[4].locked || H.p(ve, me);
    },
    i(ve) {
      v || (w(y.$$.fragment, ve), w(H), v = !0);
    },
    o(ve) {
      C(y.$$.fragment, ve), C(H), v = !1;
    },
    d(ve) {
      ve && S(e), D && D.d(), I && I.d(), B && B.d(), F && F.d(), j(y), H && H.d(), O = !1, Ne(P);
    }
  };
}
f(jde, "create_fragment$Q");
function Lde(i) {
  var t, s;
  let e = (s = (t = i == null ? void 0 : i.system) == null ? void 0 : t.details) == null ? void 0 : s.cr;
  return e === void 0 ? "?" : e === 0.125 || e === "0.125" ? "⅛" : e === 0.25 || e === "0.25" ? "¼" : e === 0.5 || e === "0.5" ? "½" : e;
}
f(Lde, "getCRLabel");
function Bde(i) {
  return typeof i.system.source != "string" ? null : CONFIG.A5E.products[i.system.source] || null;
}
f(Bde, "getMonsterSource");
function qde(i, e, t) {
  let s, n, { document: l } = e;
  function r(g) {
    var h, _;
    return (((_ = (h = g == null ? void 0 : g.system) == null ? void 0 : h.details) == null ? void 0 : _.creatureTypes) ?? []).map((y) => d[y] ?? y ?? "").sort((y, k) => y.localeCompare(k)).join(", ");
  }
  f(r, "getCreatureTypes");
  function o(g) {
    var P, D, I, B;
    const h = [], _ = Lde(g), y = r(g), k = (D = (P = g == null ? void 0 : g.system) == null ? void 0 : P.details) == null ? void 0 : D.elite, v = u[(B = (I = g == null ? void 0 : g.system) == null ? void 0 : I.traits) == null ? void 0 : B.size] ?? "", O = YB(g);
    return _ === "?" ? h.push(v, y) : h.push(v, y, "|", k ? "Elite" : "", `CR ${_}`, `(${O} XP)`), h.filter((F) => !foundry.utils.isEmpty(F) && F !== "").join(" ");
  }
  f(o, "getMonsterDetailsLabel");
  function a(g) {
    const h = {
      type: c.documentName,
      uuid: c.getUuid(l._id)
    };
    return g.dataTransfer.setData("text/plain", JSON.stringify(h));
  }
  f(a, "onDragStart");
  const c = fe("collection"), { actorSizes: u, creatureTypes: d } = CONFIG.A5E;
  function p(g) {
    gt.call(this, i, g);
  }
  f(p, "click_handler");
  const m = /* @__PURE__ */ f(async () => {
    var h;
    (h = (c.get(l._id) ?? await c.getDocument(l._id)).sheet) == null || h.render(!0);
  }, "click_handler_1");
  return i.$$set = (g) => {
    "document" in g && t(0, l = g.document);
  }, i.$$.update = () => {
    i.$$.dirty & /*document*/
    1 && t(2, s = o(l)), i.$$.dirty & /*document*/
    1 && t(1, n = Bde(l));
  }, [
    l,
    n,
    s,
    a,
    c,
    p,
    m
  ];
}
f(qde, "instance$K");
const LC = class LC extends ie {
  constructor(e) {
    super(), le(this, e, qde, jde, ne, { document: 0 });
  }
};
f(LC, "CompendiumMonsterItem");
let nw = LC;
function oj(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "a5e-item__icon fa-solid fa-link"), b(e, "data-tooltip", "Requires Attunement"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(oj, "create_if_block_2$b");
function aj(i) {
  var a;
  let e, t = (
    /*objectSource*/
    ((a = i[1]) == null ? void 0 : a.abbreviation) + ""
  ), s, n, l, r, o;
  return {
    c() {
      var c;
      e = E("a"), s = x(t), b(e, "class", "a5e-item__source-tag"), b(e, "href", n = /*objectSource*/
      (c = i[1]) == null ? void 0 : c.url), b(e, "target", "_blank"), b(e, "data-tooltip", l = _n(
        /*objectSource*/
        i[1]
      )), b(e, "data-tooltip-class", "a5e-tooltip a5e-tooltip--dark a5e-tooltip--document-source");
    },
    m(c, u) {
      T(c, e, u), A(e, s), r || (o = V(e, "click", We(
        /*click_handler*/
        i[5]
      )), r = !0);
    },
    p(c, u) {
      var d, p;
      u & /*objectSource*/
      2 && t !== (t = /*objectSource*/
      ((d = c[1]) == null ? void 0 : d.abbreviation) + "") && _e(s, t), u & /*objectSource*/
      2 && n !== (n = /*objectSource*/
      (p = c[1]) == null ? void 0 : p.url) && b(e, "href", n), u & /*objectSource*/
      2 && l !== (l = _n(
        /*objectSource*/
        c[1]
      )) && b(e, "data-tooltip", l);
    },
    d(c) {
      c && S(e), r = !1, o();
    }
  };
}
f(aj, "create_if_block_1$h");
function Gde(i) {
  let e, t;
  return e = new Fr({ props: { document: (
    /*document*/
    i[0]
  ) } }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*document*/
      1 && (l.document = /*document*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Gde, "create_if_block$o");
function zde(i) {
  var I, B;
  let e, t, s, n, l, r, o = (
    /*document*/
    i[0].name + ""
  ), a, c, u, d, p, m, g, h, _, y, k, v, O = (
    /*document*/
    ((I = i[0].system) == null ? void 0 : I.requiresAttunement) && oj()
  ), P = (
    /*objectSource*/
    ((B = i[1]) == null ? void 0 : B.abbreviation) && aj(i)
  );
  h = new Rr({ props: { document: (
    /*document*/
    i[0]
  ) } });
  let D = !/*collection*/
  i[4].locked && Gde(i);
  return {
    c() {
      e = E("li"), t = E("img"), l = R(), r = E("h3"), a = x(o), c = R(), O && O.c(), u = R(), d = E("span"), P && P.c(), p = R(), m = x(
        /*objectDetails*/
        i[2]
      ), g = R(), L(h.$$.fragment), _ = R(), D && D.c(), b(t, "class", "a5e-item__image a5e-item__image--compendium-document"), ze(t.src, s = /*document*/
      i[0].img) || b(t, "src", s), b(t, "alt", n = /*document*/
      i[0].name), b(r, "class", "a5e-item__name a5e-item__name--compendium-document"), b(d, "class", "a5e-item__details"), b(e, "class", "a5e-item a5e-item--compendium-document"), b(e, "draggable", "true");
    },
    m(F, H) {
      T(F, e, H), A(e, t), A(e, l), A(e, r), A(r, a), A(r, c), O && O.m(r, null), A(e, u), A(e, d), P && P.m(d, null), A(d, p), A(d, m), A(e, g), N(h, e, null), A(e, _), D && D.m(e, null), y = !0, k || (v = [
        V(
          e,
          "click",
          /*click_handler_1*/
          i[6]
        ),
        V(
          e,
          "dragstart",
          /*onDragStart*/
          i[3]
        )
      ], k = !0);
    },
    p(F, [H]) {
      var U, q;
      (!y || H & /*document*/
      1 && !ze(t.src, s = /*document*/
      F[0].img)) && b(t, "src", s), (!y || H & /*document*/
      1 && n !== (n = /*document*/
      F[0].name)) && b(t, "alt", n), (!y || H & /*document*/
      1) && o !== (o = /*document*/
      F[0].name + "") && _e(a, o), /*document*/
      (U = F[0].system) != null && U.requiresAttunement ? O || (O = oj(), O.c(), O.m(r, null)) : O && (O.d(1), O = null), /*objectSource*/
      (q = F[1]) != null && q.abbreviation ? P ? P.p(F, H) : (P = aj(F), P.c(), P.m(d, p)) : P && (P.d(1), P = null), (!y || H & /*objectDetails*/
      4) && _e(
        m,
        /*objectDetails*/
        F[2]
      );
      const G = {};
      H & /*document*/
      1 && (G.document = /*document*/
      F[0]), h.$set(G), /*collection*/
      F[4].locked || D.p(F, H);
    },
    i(F) {
      y || (w(h.$$.fragment, F), w(D), y = !0);
    },
    o(F) {
      C(h.$$.fragment, F), C(D), y = !1;
    },
    d(F) {
      F && S(e), O && O.d(), P && P.d(), j(h), D && D.d(), k = !1, Ne(v);
    }
  };
}
f(zde, "create_fragment$P");
function Hde(i) {
  return typeof i.system.source != "string" ? null : CONFIG.A5E.products[i.system.source] || null;
}
f(Hde, "getObjectSource");
function Ude(i, e, t) {
  let s, n, { document: l } = e;
  function r(g) {
    return g.system.requiresAttunement ? K("A5E.AttunementRequiredPrompt") : null;
  }
  f(r, "getAttunementLabel");
  function o(g) {
    const h = r(g), { price: _ } = g.system, y = a(g);
    return y ? _ && h ? `${y} (${h}; Cost ${_})` : _ ? `${y} (Cost ${_})` : h ? `${y} (${h})` : y : _ && h ? `${h}; Cost ${_}` : _ ? `Cost ${_}` : h || null;
  }
  f(o, "getObjectDetailsLabel");
  function a(g) {
    const { rarity: h } = g.system;
    return !h || h === "mundane" ? null : d[h] ?? h;
  }
  f(a, "getRarityLabel");
  function c(g) {
    const h = {
      type: u.documentName,
      uuid: u.getUuid(l._id)
    };
    return g.dataTransfer.setData("text/plain", JSON.stringify(h));
  }
  f(c, "onDragStart");
  const u = fe("collection"), { itemRarity: d } = CONFIG.A5E;
  function p(g) {
    gt.call(this, i, g);
  }
  f(p, "click_handler");
  const m = /* @__PURE__ */ f(async () => {
    var h;
    (h = (u.get(l._id) ?? await u.getDocument(l._id)).sheet) == null || h.render(!0);
  }, "click_handler_1");
  return i.$$set = (g) => {
    "document" in g && t(0, l = g.document);
  }, i.$$.update = () => {
    i.$$.dirty & /*document*/
    1 && t(2, s = o(l)), i.$$.dirty & /*document*/
    1 && t(1, n = Hde(l));
  }, [
    l,
    n,
    s,
    c,
    u,
    p,
    m
  ];
}
f(Ude, "instance$J");
const BC = class BC extends ie {
  constructor(e) {
    super(), le(this, e, Ude, zde, ne, { document: 0 });
  }
};
f(BC, "CompendiumObjectItem");
let $p = BC;
function cj(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "a5e-item__icon fa-solid fa-sun"), b(e, "data-tooltip", "Rare Spell Variant"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(cj, "create_if_block_7$3");
function uj(i) {
  var a;
  let e, t = (
    /*spellSource*/
    ((a = i[1]) == null ? void 0 : a.abbreviation) + ""
  ), s, n, l, r, o;
  return {
    c() {
      var c;
      e = E("a"), s = x(t), b(e, "class", "a5e-item__source-tag"), b(e, "href", n = /*spellSource*/
      (c = i[1]) == null ? void 0 : c.url), b(e, "target", "_blank"), b(e, "data-tooltip", l = _n(
        /*spellSource*/
        i[1]
      )), b(e, "data-tooltip-class", "a5e-tooltip a5e-tooltip--dark a5e-tooltip--document-source");
    },
    m(c, u) {
      T(c, e, u), A(e, s), r || (o = V(e, "click", We(
        /*click_handler*/
        i[5]
      )), r = !0);
    },
    p(c, u) {
      var d, p;
      u & /*spellSource*/
      2 && t !== (t = /*spellSource*/
      ((d = c[1]) == null ? void 0 : d.abbreviation) + "") && _e(s, t), u & /*spellSource*/
      2 && n !== (n = /*spellSource*/
      (p = c[1]) == null ? void 0 : p.url) && b(e, "href", n), u & /*spellSource*/
      2 && l !== (l = _n(
        /*spellSource*/
        c[1]
      )) && b(e, "data-tooltip", l);
    },
    d(c) {
      c && S(e), r = !1, o();
    }
  };
}
f(uj, "create_if_block_6$3");
function fj(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellComponentVocalizedAbbr")}`, b(e, "class", "component svelte-9eapla"), b(e, "data-tooltip", "A5E.SpellComponentVocalized"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(fj, "create_if_block_5$4");
function dj(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellComponentSeenAbbr")}`, b(e, "class", "component svelte-9eapla"), b(e, "data-tooltip", "A5E.SpellComponentSeen"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(dj, "create_if_block_4$5");
function pj(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellComponentMaterialAbbr")}`, b(e, "class", "component svelte-9eapla"), b(e, "data-tooltip", "A5E.SpellComponentMaterial"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(pj, "create_if_block_3$6");
function mj(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellConcentrationAbbr")}`, b(e, "class", "component svelte-9eapla"), b(e, "data-tooltip", "A5E.SpellConcentration"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(mj, "create_if_block_2$a");
function hj(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${K("A5E.SpellRitualAbbr")}`, b(e, "class", "component svelte-9eapla"), b(e, "data-tooltip", "A5E.SpellRitual"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(hj, "create_if_block_1$g");
function Vde(i) {
  let e, t;
  return e = new Fr({ props: { document: (
    /*document*/
    i[0]
  ) } }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*document*/
      1 && (l.document = /*document*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Vde, "create_if_block$n");
function Wde(i) {
  var re;
  let e, t, s, n, l, r, o = (
    /*document*/
    i[0].name + ""
  ), a, c, u, d, p, m, g, h, _, y, k, v, O, P, D, I, B, F, H = (
    /*document*/
    i[0].system.rare && cj()
  ), G = (
    /*spellSource*/
    ((re = i[1]) == null ? void 0 : re.abbreviation) && uj(i)
  ), U = (
    /*document*/
    i[0].system.components.vocalized && fj()
  ), q = (
    /*document*/
    i[0].system.components.seen && dj()
  ), W = (
    /*document*/
    i[0].system.components.material && pj()
  ), X = (
    /*document*/
    i[0].system.concentration && mj()
  ), te = (
    /*document*/
    i[0].system.ritual && hj()
  );
  P = new Rr({ props: { document: (
    /*document*/
    i[0]
  ) } });
  let J = !/*collection*/
  i[4].locked && Vde(i);
  return {
    c() {
      e = E("li"), t = E("img"), l = R(), r = E("span"), a = x(o), c = R(), H && H.c(), u = R(), d = E("span"), G && G.c(), p = R(), m = x(
        /*spellDetails*/
        i[2]
      ), g = R(), h = E("ul"), U && U.c(), _ = R(), q && q.c(), y = R(), W && W.c(), k = R(), X && X.c(), v = R(), te && te.c(), O = R(), L(P.$$.fragment), D = R(), J && J.c(), b(t, "class", "a5e-item__image a5e-item__image--compendium-document"), ze(t.src, s = /*document*/
      i[0].img) || b(t, "src", s), b(t, "alt", n = /*document*/
      i[0].name), b(r, "class", "a5e-item__name--compendium-document"), b(d, "class", "a5e-item__details"), b(h, "class", "component-wrapper svelte-9eapla"), b(e, "class", "a5e-item a5e-item--compendium-spell-document"), b(e, "draggable", "true");
    },
    m(ae, be) {
      T(ae, e, be), A(e, t), A(e, l), A(e, r), A(r, a), A(r, c), H && H.m(r, null), A(e, u), A(e, d), G && G.m(d, null), A(d, p), A(d, m), A(e, g), A(e, h), U && U.m(h, null), A(h, _), q && q.m(h, null), A(h, y), W && W.m(h, null), A(h, k), X && X.m(h, null), A(h, v), te && te.m(h, null), A(e, O), N(P, e, null), A(e, D), J && J.m(e, null), I = !0, B || (F = [
        V(
          e,
          "click",
          /*click_handler_1*/
          i[6]
        ),
        V(
          e,
          "dragstart",
          /*onDragStart*/
          i[3]
        )
      ], B = !0);
    },
    p(ae, [be]) {
      var ve;
      (!I || be & /*document*/
      1 && !ze(t.src, s = /*document*/
      ae[0].img)) && b(t, "src", s), (!I || be & /*document*/
      1 && n !== (n = /*document*/
      ae[0].name)) && b(t, "alt", n), (!I || be & /*document*/
      1) && o !== (o = /*document*/
      ae[0].name + "") && _e(a, o), /*document*/
      ae[0].system.rare ? H || (H = cj(), H.c(), H.m(r, null)) : H && (H.d(1), H = null), /*spellSource*/
      (ve = ae[1]) != null && ve.abbreviation ? G ? G.p(ae, be) : (G = uj(ae), G.c(), G.m(d, p)) : G && (G.d(1), G = null), (!I || be & /*spellDetails*/
      4) && _e(
        m,
        /*spellDetails*/
        ae[2]
      ), /*document*/
      ae[0].system.components.vocalized ? U || (U = fj(), U.c(), U.m(h, _)) : U && (U.d(1), U = null), /*document*/
      ae[0].system.components.seen ? q || (q = dj(), q.c(), q.m(h, y)) : q && (q.d(1), q = null), /*document*/
      ae[0].system.components.material ? W || (W = pj(), W.c(), W.m(h, k)) : W && (W.d(1), W = null), /*document*/
      ae[0].system.concentration ? X || (X = mj(), X.c(), X.m(h, v)) : X && (X.d(1), X = null), /*document*/
      ae[0].system.ritual ? te || (te = hj(), te.c(), te.m(h, null)) : te && (te.d(1), te = null);
      const we = {};
      be & /*document*/
      1 && (we.document = /*document*/
      ae[0]), P.$set(we), /*collection*/
      ae[4].locked || J.p(ae, be);
    },
    i(ae) {
      I || (w(P.$$.fragment, ae), w(J), I = !0);
    },
    o(ae) {
      C(P.$$.fragment, ae), C(J), I = !1;
    },
    d(ae) {
      ae && S(e), H && H.d(), G && G.d(), U && U.d(), q && q.d(), W && W.d(), X && X.d(), te && te.d(), j(P), J && J.d(), B = !1, Ne(F);
    }
  };
}
f(Wde, "create_fragment$O");
function Kde(i) {
  return typeof i.system.source != "string" ? null : CONFIG.A5E.products[i.system.source] || null;
}
f(Kde, "getSpellSource");
function Yde(i, e, t) {
  let s, n, { document: l } = e;
  function r(m) {
    const { level: g, schools: h } = m.system, _ = u[g] ?? "", y = c.primary[h.primary] ?? h.primary, k = h.secondary.map((O) => c.secondary[O] ?? O);
    k.sort((O, P) => O.localeCompare(P));
    const v = [y, ...k].join(", ");
    return v ? `${_} (${v})` : _;
  }
  f(r, "getSpellDetailsLabel");
  function o(m) {
    const g = {
      type: a.documentName,
      uuid: a.getUuid(l._id)
    };
    return m.dataTransfer.setData("text/plain", JSON.stringify(g));
  }
  f(o, "onDragStart");
  const a = fe("collection"), { spellSchools: c, spellLevels: u } = CONFIG.A5E;
  function d(m) {
    gt.call(this, i, m);
  }
  f(d, "click_handler");
  const p = /* @__PURE__ */ f(async () => {
    var g;
    (g = (a.get(l._id) ?? await a.getDocument(l._id)).sheet) == null || g.render(!0);
  }, "click_handler_1");
  return i.$$set = (m) => {
    "document" in m && t(0, l = m.document);
  }, i.$$.update = () => {
    i.$$.dirty & /*document*/
    1 && t(2, s = r(l)), i.$$.dirty & /*document*/
    1 && t(1, n = Kde(l));
  }, [
    l,
    n,
    s,
    o,
    a,
    d,
    p
  ];
}
f(Yde, "instance$I");
const qC = class qC extends ie {
  constructor(e) {
    super(), le(this, e, Yde, Wde, ne, { document: 0 });
  }
};
f(qC, "CompendiumSpellItem");
let Ap = qC;
function gj(i, e, t) {
  const s = i.slice();
  return s[4] = e[t], s;
}
f(gj, "get_each_context$g");
function bj(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: (
        /*name*/
        i[1]
      ),
      $$slots: { default: [Xde] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-gap", "0");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*name*/
      2 && (r.heading = /*name*/
      n[1]), l & /*$$scope, $reducer, ItemComponent*/
      137 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(bj, "create_if_block$m");
function _j(i) {
  let e, t, s;
  var n = (
    /*ItemComponent*/
    i[0]
  );
  function l(r, o) {
    return { props: { document: (
      /*document*/
      r[4]
    ) } };
  }
  return f(l, "switch_props"), n && (e = nt(n, l(i))), {
    c() {
      e && L(e.$$.fragment), t = $e();
    },
    m(r, o) {
      e && N(e, r, o), T(r, t, o), s = !0;
    },
    p(r, o) {
      if (o & /*ItemComponent*/
      1 && n !== (n = /*ItemComponent*/
      r[0])) {
        if (e) {
          ce();
          const a = e;
          C(a.$$.fragment, 1, 0, () => {
            j(a, 1);
          }), ue();
        }
        n ? (e = nt(n, l(r)), L(e.$$.fragment), w(e.$$.fragment, 1), N(e, t.parentNode, t)) : e = null;
      } else if (n) {
        const a = {};
        o & /*$reducer*/
        8 && (a.document = /*document*/
        r[4]), e.$set(a);
      }
    },
    i(r) {
      s || (e && w(e.$$.fragment, r), s = !0);
    },
    o(r) {
      e && C(e.$$.fragment, r), s = !1;
    },
    d(r) {
      r && S(t), e && j(e, r);
    }
  };
}
f(_j, "create_each_block$g");
function Xde(i) {
  let e, t, s = oe([.../*$reducer*/
  i[3]]), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = _j(gj(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("ul");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "a5e-item-list a5e-item-list--compendium");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, o) {
      if (o & /*ItemComponent, $reducer*/
      9) {
        s = oe([.../*$reducer*/
        r[3]]);
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = gj(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = _j(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f(Xde, "create_default_slot$j");
function Jde(i) {
  let e, t, s = (
    /*reducer*/
    i[2].length && bj(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, [l]) {
      /*reducer*/
      n[2].length ? s ? (s.p(n, l), l & /*reducer*/
      4 && w(s, 1)) : (s = bj(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ce(), C(s, 1, 1, () => {
        s = null;
      }), ue());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f(Jde, "create_fragment$N");
function Zde(i, e, t) {
  let s, n = ee, l = /* @__PURE__ */ f(() => (n(), n = Et(a, (c) => t(3, s = c)), a), "$$subscribe_reducer");
  i.$$.on_destroy.push(() => n());
  let { ItemComponent: r } = e, { name: o } = e, { reducer: a } = e;
  return l(), i.$$set = (c) => {
    "ItemComponent" in c && t(0, r = c.ItemComponent), "name" in c && t(1, o = c.name), "reducer" in c && l(t(2, a = c.reducer));
  }, [r, o, a, s];
}
f(Zde, "instance$H");
const GC = class GC extends ie {
  constructor(e) {
    super(), le(this, e, Zde, Jde, ne, { ItemComponent: 0, name: 1, reducer: 2 });
  }
};
f(GC, "CompendiumSubItemList");
let iw = GC;
function yj(i, e, t) {
  const s = i.slice();
  return s[18] = e[t], s;
}
f(yj, "get_each_context_1$3");
function vj(i, e, t) {
  const s = i.slice();
  return s[14] = e[t].name, s[15] = e[t].derivedReducer, s;
}
f(vj, "get_each_context$f");
function Qde(i) {
  let e, t, s = oe(
    /*documents*/
    i[0]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = kj(yj(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, o) {
      if (o & /*compendiumItemComponents, compendiumType, documents*/
      11) {
        s = oe(
          /*documents*/
          r[0]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = yj(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = kj(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f(Qde, "create_else_block$6");
function xde(i) {
  let e, t, s = oe(
    /*derived*/
    i[2]
  ), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = $j(vj(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      e = $e();
    },
    m(r, o) {
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(r, o);
      T(r, e, o), t = !0;
    },
    p(r, o) {
      if (o & /*derived, compendiumItemComponents, compendiumType*/
      14) {
        s = oe(
          /*derived*/
          r[2]
        );
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = vj(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = $j(c), n[a].c(), w(n[a], 1), n[a].m(e.parentNode, e));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f(xde, "create_if_block$l");
function kj(i) {
  let e, t, s;
  var n = (
    /*compendiumItemComponents*/
    i[3][
      /*compendiumType*/
      i[1]
    ]
  );
  function l(r, o) {
    return {
      props: { document: (
        /*document*/
        r[18]
      ) }
    };
  }
  return f(l, "switch_props"), n && (e = nt(n, l(i))), {
    c() {
      e && L(e.$$.fragment), t = $e();
    },
    m(r, o) {
      e && N(e, r, o), T(r, t, o), s = !0;
    },
    p(r, o) {
      if (o & /*compendiumType*/
      2 && n !== (n = /*compendiumItemComponents*/
      r[3][
        /*compendiumType*/
        r[1]
      ])) {
        if (e) {
          ce();
          const a = e;
          C(a.$$.fragment, 1, 0, () => {
            j(a, 1);
          }), ue();
        }
        n ? (e = nt(n, l(r)), L(e.$$.fragment), w(e.$$.fragment, 1), N(e, t.parentNode, t)) : e = null;
      } else if (n) {
        const a = {};
        o & /*documents*/
        1 && (a.document = /*document*/
        r[18]), e.$set(a);
      }
    },
    i(r) {
      s || (e && w(e.$$.fragment, r), s = !0);
    },
    o(r) {
      e && C(e.$$.fragment, r), s = !1;
    },
    d(r) {
      r && S(t), e && j(e, r);
    }
  };
}
f(kj, "create_each_block_1$3");
function wj(i) {
  let e, t;
  return e = new iw({
    props: {
      name: (
        /*name*/
        i[14]
      ),
      ItemComponent: (
        /*compendiumItemComponents*/
        i[3][
          /*compendiumType*/
          i[1]
        ]
      ),
      reducer: (
        /*derivedReducer*/
        i[15]
      )
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*derived*/
      4 && (l.name = /*name*/
      s[14]), n & /*compendiumType*/
      2 && (l.ItemComponent = /*compendiumItemComponents*/
      s[3][
        /*compendiumType*/
        s[1]
      ]), n & /*derived*/
      4 && (l.reducer = /*derivedReducer*/
      s[15]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(wj, "create_if_block_1$f");
function $j(i) {
  let e, t, s = [.../*derivedReducer*/
  i[15]].length !== 0 && wj(i);
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, l) {
      [.../*derivedReducer*/
      n[15]].length !== 0 ? s ? (s.p(n, l), l & /*derived*/
      4 && w(s, 1)) : (s = wj(n), s.c(), w(s, 1), s.m(e.parentNode, e)) : s && (ce(), C(s, 1, 1, () => {
        s = null;
      }), ue());
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f($j, "create_each_block$f");
function epe(i) {
  let e, t, s, n, l, r, o;
  const a = [xde, Qde], c = [];
  function u(d, p) {
    return (
      /*derived*/
      d[2].length ? 0 : 1
    );
  }
  return f(u, "select_block_type"), t = u(i), s = c[t] = a[t](i), {
    c() {
      e = E("ul"), s.c(), b(e, "class", "a5e-item-list a5e-item-list--compendium");
    },
    m(d, p) {
      T(d, e, p), c[t].m(e, null), l = !0, r || (o = [
        V(
          e,
          "scroll",
          /*scroll_handler*/
          i[8]
        ),
        V(
          e,
          "drop",
          /*onDocumentDrop*/
          i[5]
        )
      ], r = !0);
    },
    p(d, [p]) {
      let m = t;
      t = u(d), t === m ? c[t].p(d, p) : (ce(), C(c[m], 1, 1, () => {
        c[m] = null;
      }), ue(), s = c[t], s ? s.p(d, p) : (s = c[t] = a[t](d), s.c()), w(s, 1), s.m(e, null));
    },
    i(d) {
      l || (w(s), d && is(() => {
        l && (n || (n = dl(e, fa, {}, !0)), n.run(1));
      }), l = !0);
    },
    o(d) {
      C(s), d && (n || (n = dl(e, fa, {}, !1)), n.run(0)), l = !1;
    },
    d(d) {
      d && S(e), c[t].d(), d && n && n.end(), r = !1, Ne(o);
    }
  };
}
f(epe, "create_fragment$M");
function tpe(i, e, t) {
  let s, { documents: n = [] } = e, { compendiumType: l } = e, { enableGrouping: r = !1 } = e;
  const o = fe("collection"), a = {
    "5eSpell": Ap,
    classFeature: tw,
    magicItem: $p,
    maneuver: sw,
    monster: nw,
    object: $p,
    spell: Ap
  }, c = {
    "5eSpell": "level",
    magicItem: "rarity",
    maneuver: "degree",
    monster: "details.cr",
    object: "rarity",
    spell: "level"
  }, u = {
    "5eSpell": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    magicItem: [
      "mundane",
      "common",
      "uncommon",
      "rare",
      "very rare",
      "legendary",
      "artifact"
    ],
    maneuver: [0, 1, 2, 3, 4, 5],
    monster: [0, 0.125, 0.25, 0.5, ...Array.from(Array(30).keys(), (y) => y + 1)],
    object: [
      "mundane",
      "common",
      "uncommon",
      "rare",
      "very rare",
      "legendary",
      "artifact"
    ],
    spell: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  }, d = fe("reducer");
  pe(i, d, (y) => t(9, s = y));
  let p = [];
  function m(y) {
    if (!y) {
      d.derived.clear(), t(2, p = []);
      return;
    }
    const k = u[l], v = `system.${c[l]}`;
    for (const O of k) {
      const P = s.derived.create(`${O}`);
      P.filters.add((I) => foundry.utils.getProperty(I, v) == O), P.index.update(!0);
      const D = Ade(l, O);
      p.push({ name: D, derivedReducer: P });
    }
    t(2, p);
  }
  f(m, "setupGrouping");
  async function g(y) {
    const k = y.dataTransfer.getData("text/plain");
    if (k)
      try {
        const v = JSON.parse(k), O = await fromUuid(v.uuid);
        return o.importDocument(O);
      } catch {
        return;
      }
  }
  f(g, "onDocumentDrop");
  const h = it(), _ = /* @__PURE__ */ f(({ target: y }) => h("listScrolled", y.scrollTop / (y.scrollHeight - y.clientHeight) * 100), "scroll_handler");
  return i.$$set = (y) => {
    "documents" in y && t(0, n = y.documents), "compendiumType" in y && t(1, l = y.compendiumType), "enableGrouping" in y && t(7, r = y.enableGrouping);
  }, i.$$.update = () => {
    i.$$.dirty & /*enableGrouping*/
    128 && m(r);
  }, [
    n,
    l,
    p,
    a,
    d,
    g,
    h,
    r,
    _
  ];
}
f(tpe, "instance$G");
const zC = class zC extends ie {
  constructor(e) {
    super(), le(this, e, tpe, epe, ne, {
      documents: 0,
      compendiumType: 1,
      enableGrouping: 7
    });
  }
};
f(zC, "CompendiumItemList");
let Ep = zC;
function spe(i) {
  let e, t, s;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), b(e, "placeholder", "New Rolltable");
    },
    m(n, l) {
      T(n, e, l), qe(
        e,
        /*rollTableName*/
        i[0]
      ), t || (s = V(
        e,
        "input",
        /*input_input_handler*/
        i[2]
      ), t = !0);
    },
    p(n, l) {
      l & /*rollTableName*/
      1 && e.value !== /*rollTableName*/
      n[0] && qe(
        e,
        /*rollTableName*/
        n[0]
      );
    },
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(spe, "create_default_slot$i");
function npe(i) {
  let e, t, s, n, l, r, o, a;
  return t = new de({
    props: {
      heading: "Rolltable Name",
      $$slots: { default: [spe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("section"), L(t.$$.fragment), s = R(), n = E("div"), l = E("button"), l.innerHTML = `<i class="fa-solid fa-table-list"></i>
            Create Rolltable`, b(l, "class", "submit-button svelte-1umr3fn"), b(n, "class", "u-flex u-justify-center"), b(e, "class", "svelte-1umr3fn");
    },
    m(c, u) {
      T(c, e, u), N(t, e, null), A(e, s), A(e, n), A(n, l), r = !0, o || (a = V(l, "click", tt(
        /*onSubmit*/
        i[1]
      )), o = !0);
    },
    p(c, [u]) {
      const d = {};
      u & /*$$scope, rollTableName*/
      17 && (d.$$scope = { dirty: u, ctx: c }), t.$set(d);
    },
    i(c) {
      r || (w(t.$$.fragment, c), r = !0);
    },
    o(c) {
      C(t.$$.fragment, c), r = !1;
    },
    d(c) {
      c && S(e), j(t), o = !1, a();
    }
  };
}
f(npe, "create_fragment$L");
function ipe(i, e, t) {
  let { application: s } = fe("#external");
  function n() {
    s.submit({
      rollTableName: l || "New RollTable"
    });
  }
  f(n, "onSubmit");
  let l = "";
  function r() {
    l = this.value, t(0, l);
  }
  return f(r, "input_input_handler"), [l, n, r];
}
f(ipe, "instance$F");
const HC = class HC extends ie {
  constructor(e) {
    super(), le(this, e, ipe, npe, ne, {});
  }
};
f(HC, "ExportToRollTableDialog");
let lw = HC;
const Aj = {
  spellLists: {
    key: "system.classes",
    type: "array"
  },
  spellLevels: {
    key: "system.level",
    type: "value"
  },
  primarySpellSchools: {
    key: "system.schools.primary",
    type: "value"
  },
  secondarySpellSchools: {
    key: "system.schools.secondary",
    type: "array"
  },
  components: {
    subFilters: {
      material: {
        key: "system.components.material",
        type: "boolean"
      },
      seen: {
        key: "system.components.seen",
        type: "boolean"
      },
      vocalized: {
        key: "system.components.vocalized",
        type: "boolean"
      }
    }
  },
  miscellaneous: {
    subFilters: {
      concentration: {
        key: "system.concentration",
        type: "boolean"
      },
      ritual: {
        key: "system.ritual",
        type: "boolean"
      },
      rare: {
        key: "system.rare",
        type: "boolean"
      }
    }
  }
}, lpe = {
  exertion: {
    key: "system.exertionCost",
    type: "range"
  },
  maneuverDegrees: {
    key: "system.degree",
    type: "value"
  },
  maneuverTraditions: {
    key: "system.tradition",
    type: "value"
  },
  miscellaneous: {
    subFilters: {
      concentration: {
        key: "system.concentration",
        type: "boolean"
      },
      stance: {
        key: "system.isStance",
        type: "boolean"
      }
    }
  }
}, rpe = {
  cr: {
    key: "system.details.cr",
    type: "range"
  },
  creatureSize: {
    key: "system.traits.size",
    type: "value"
  },
  creatureTypes: {
    key: "system.details.creatureTypes",
    type: "array"
  },
  miscellaneous: {
    subFilters: {
      elite: {
        key: "system.details.elite",
        type: "boolean"
      },
      swarm: {
        key: "system.details.isSwarm",
        type: "boolean"
      }
    }
  },
  terrain: {
    key: "system.details.terrain",
    type: "array"
  }
}, Ej = {
  objectType: {
    key: "system.objectType",
    type: "value"
  },
  rarity: {
    key: "system.rarity",
    type: "value"
  },
  miscellaneous: {
    subFilters: {
      bulky: {
        key: "system.bulky",
        type: "boolean"
      },
      requiresAttunement: {
        key: "system.requiresAttunement",
        type: "boolean"
      }
    }
  }
}, ope = {
  "5eSpell": Aj,
  object: Ej,
  magicItem: Ej,
  maneuver: lpe,
  monster: rpe,
  spell: Aj
};
function Sj(i, e, t) {
  return t ? (s) => {
    var n;
    return (n = foundry.utils.getProperty(s, i)) == null ? void 0 : n.includes(e);
  } : (s) => {
    var n;
    return !((n = foundry.utils.getProperty(s, i)) != null && n.includes(e));
  };
}
f(Sj, "arrayFilter");
function Jf(i, e) {
  return e ? (t) => foundry.utils.getProperty(t, i) : (t) => !foundry.utils.getProperty(t, i);
}
f(Jf, "booleanFilter");
function ape(i, { min: e, max: t }) {
  return (s) => {
    const n = foundry.utils.getProperty(s, i);
    return n >= e && n <= t;
  };
}
f(ape, "rangeFilter");
function Tj(i, e, t) {
  return t ? (s) => foundry.utils.getProperty(s, i) == e : (s) => foundry.utils.getProperty(s, i) != e;
}
f(Tj, "valueFilter");
function cpe(i, e, t) {
  const s = [...i.filters].filter((r) => r.id !== "searchFilter");
  i.filters.remove(...s);
  const n = ope[t], l = { and: 0, or: 0 };
  for (const [r, o] of Object.entries(e)) {
    const a = [], c = [], { key: u, type: d, subFilters: p } = (n == null ? void 0 : n[r]) ?? {};
    if (!((!u || !d) && !p)) {
      if (d === "range") {
        const { min: m, max: g } = o, h = ape(u, { min: m, max: g });
        a.push({ filter: h }), l.and += 1;
      } else {
        const {
          inclusive: m,
          inclusiveMode: g,
          exclusive: h,
          exclusiveMode: _
        } = o;
        m.forEach((y) => {
          var v;
          let k;
          if (d === "array")
            k = Sj(u, y, !0);
          else if (((v = p == null ? void 0 : p[y]) == null ? void 0 : v.type) === "boolean")
            k = Jf(p[y].key, !0);
          else if (d === "boolean")
            k = Jf(u, !0);
          else if (d === "value")
            k = Tj(u, y, !0);
          else
            return;
          g ? a.push({ filter: k }) : c.push(k);
        }), h.forEach((y) => {
          var v;
          let k;
          if (d === "array")
            k = Sj(u, y, !1);
          else if (((v = p == null ? void 0 : p[y]) == null ? void 0 : v.type) === "boolean")
            k = Jf(p[y].key, !1);
          else if (d === "boolean")
            k = Jf(u, !1);
          else if (d === "value")
            k = Tj(u, y, !1);
          else
            return;
          _ ? a.push({ filter: k }) : c.push(k);
        });
      }
      a.length && (i.filters.add(...a), l.and += a.length), c.length && (i.filters.add({
        filter: (m) => c.some((g) => g(m))
      }), l.or += 1);
    }
  }
  return l;
}
f(cpe, "constructReducerFilters");
function Cj(i) {
  let e, t, s, n, l, r, o = (
    /*tab*/
    i[6] === "items" && Oj(i)
  );
  return {
    c() {
      o && o.c(), e = R(), t = E("button"), s = E("i"), b(s, "class", "a5efc-filter-button__icon fa-solid fa-filter"), b(t, "class", "a5efc-filter-button"), b(t, "data-tooltip", n = /*tab*/
      i[6] === "items" ? "Open Filter Page" : "Close Filter Page"), b(t, "data-tooltip-direction", "UP"), Q(
        t,
        "a5efc-filter-button--active",
        /*tab*/
        i[6] === "filters" || /*filterCount*/
        i[5].and || /*filterCount*/
        i[5].or
      );
    },
    m(a, c) {
      o && o.m(a, c), T(a, e, c), T(a, t, c), A(t, s), l || (r = V(
        t,
        "click",
        /*click_handler_4*/
        i[22]
      ), l = !0);
    },
    p(a, c) {
      /*tab*/
      a[6] === "items" ? o ? o.p(a, c) : (o = Oj(a), o.c(), o.m(e.parentNode, e)) : o && (o.d(1), o = null), c & /*tab*/
      64 && n !== (n = /*tab*/
      a[6] === "items" ? "Open Filter Page" : "Close Filter Page") && b(t, "data-tooltip", n), c & /*tab, filterCount*/
      96 && Q(
        t,
        "a5efc-filter-button--active",
        /*tab*/
        a[6] === "filters" || /*filterCount*/
        a[5].and || /*filterCount*/
        a[5].or
      );
    },
    d(a) {
      a && (S(e), S(t)), o && o.d(a), l = !1, r();
    }
  };
}
f(Cj, "create_if_block_1$e");
function Oj(i) {
  let e, t, s, n, l, r, o, a, c, u, d;
  function p(h, _) {
    if (!/*customImporter*/
    h[2] && /*compendiumType*/
    h[1] !== "classFeature")
      return fpe;
    if (
      /*compendiumType*/
      h[1] === "spell" || /*compendiumType*/
      h[1] === "maneuver"
    )
      return upe;
  }
  f(p, "select_block_type");
  let m = p(i), g = m && m(i);
  return {
    c() {
      e = E("button"), t = E("i"), n = R(), l = E("button"), r = E("i"), a = R(), g && g.c(), c = $e(), b(t, "class", "a5efc-filter-button__icon fa-solid fa-book"), b(e, "class", "a5efc-filter-button"), b(e, "data-tooltip", s = /*includeDescriptions*/
      i[4] ? "Exclude item descriptions in search" : "Include item descriptions in search"), b(e, "data-tooltip-direction", "UP"), Q(
        e,
        "a5efc-filter-button--active",
        /*includeDescriptions*/
        i[4]
      ), b(r, "class", "a5efc-filter-button__icon fa-solid fa-bars-staggered"), b(l, "class", "a5efc-filter-button"), b(l, "data-tooltip", o = /*enableGrouping*/
      i[8] ? "Disable grouping of documents" : "Enable grouping of documents"), b(l, "data-tooltip-direction", "UP"), Q(
        l,
        "a5efc-filter-button--active",
        /*enableGrouping*/
        i[8]
      );
    },
    m(h, _) {
      T(h, e, _), A(e, t), T(h, n, _), T(h, l, _), A(l, r), T(h, a, _), g && g.m(h, _), T(h, c, _), u || (d = [
        V(
          e,
          "click",
          /*click_handler*/
          i[18]
        ),
        V(
          l,
          "click",
          /*click_handler_1*/
          i[19]
        )
      ], u = !0);
    },
    p(h, _) {
      _ & /*includeDescriptions*/
      16 && s !== (s = /*includeDescriptions*/
      h[4] ? "Exclude item descriptions in search" : "Include item descriptions in search") && b(e, "data-tooltip", s), _ & /*includeDescriptions*/
      16 && Q(
        e,
        "a5efc-filter-button--active",
        /*includeDescriptions*/
        h[4]
      ), _ & /*enableGrouping*/
      256 && o !== (o = /*enableGrouping*/
      h[8] ? "Disable grouping of documents" : "Enable grouping of documents") && b(l, "data-tooltip", o), _ & /*enableGrouping*/
      256 && Q(
        l,
        "a5efc-filter-button--active",
        /*enableGrouping*/
        h[8]
      ), m === (m = p(h)) && g ? g.p(h, _) : (g && g.d(1), g = m && m(h), g && (g.c(), g.m(c.parentNode, c)));
    },
    d(h) {
      h && (S(e), S(n), S(l), S(a), S(c)), g && g.d(h), u = !1, Ne(d);
    }
  };
}
f(Oj, "create_if_block_2$9");
function upe(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("button"), t = E("i"), b(t, "class", "a5efc-filter-button__icon fa-solid fa-download"), b(e, "class", "a5efc-filter-button"), b(e, "data-tooltip", s = "Export " + [.../*$reducer*/
      i[10]].length + " Documents to Actor"), b(e, "data-tooltip-direction", "UP");
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = V(
        e,
        "click",
        /*click_handler_3*/
        i[21]
      ), n = !0);
    },
    p(r, o) {
      o & /*$reducer*/
      1024 && s !== (s = "Export " + [.../*$reducer*/
      r[10]].length + " Documents to Actor") && b(e, "data-tooltip", s);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(upe, "create_if_block_4$4");
function fpe(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("button"), t = E("i"), b(t, "class", "a5efc-filter-button__icon fa-solid fa-table-list"), b(e, "class", "a5efc-filter-button"), b(e, "data-tooltip", s = "Export " + [.../*$reducer*/
      i[10]].length + " Documents to Rolltable"), b(e, "data-tooltip-direction", "UP");
    },
    m(r, o) {
      T(r, e, o), A(e, t), n || (l = V(
        e,
        "click",
        /*click_handler_2*/
        i[20]
      ), n = !0);
    },
    p(r, o) {
      o & /*$reducer*/
      1024 && s !== (s = "Export " + [.../*$reducer*/
      r[10]].length + " Documents to Rolltable") && b(e, "data-tooltip", s);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(fpe, "create_if_block_3$5");
function Dj(i) {
  let e, t, s = [.../*$reducer*/
  i[10]].length + "", n, l, r = [.../*document*/
  i[3].index].length + "", o, a;
  return {
    c() {
      e = E("footer"), t = x("Showing "), n = x(s), l = x(" of "), o = x(r), a = x(" items"), b(e, "class", "a5efc-footer");
    },
    m(c, u) {
      T(c, e, u), A(e, t), A(e, n), A(e, l), A(e, o), A(e, a);
    },
    p(c, u) {
      u & /*$reducer*/
      1024 && s !== (s = [.../*$reducer*/
      c[10]].length + "") && _e(n, s), u & /*document*/
      8 && r !== (r = [.../*document*/
      c[3].index].length + "") && _e(o, r);
    },
    d(c) {
      c && S(e);
    }
  };
}
f(Dj, "create_if_block$k");
function dpe(i) {
  let e, t, s, n, l, r, o, a, c;
  s = new xd({ props: { input: (
    /*searchInput*/
    i[9]
  ) } });
  let u = (
    /*compendiumType*/
    i[1] !== "classFeature" && Cj(i)
  );
  var d = (
    /*tab*/
    i[6] === "items" ? Ep : wp
  );
  function p(g, h) {
    return {
      props: {
        documents: [.../*$reducer*/
        g[10]].slice(
          0,
          /*visibleDocumentCount*/
          g[7]
        ),
        compendiumType: (
          /*compendiumType*/
          g[1]
        ),
        enableGrouping: (
          /*enableGrouping*/
          g[8]
        )
      }
    };
  }
  f(p, "switch_props"), d && (o = nt(d, p(i)), o.$on(
    "listScrolled",
    /*listScrolled_handler*/
    i[23]
  ));
  let m = (
    /*tab*/
    i[6] === "items" && Dj(i)
  );
  return {
    c() {
      e = E("main"), t = E("div"), n = E("div"), L(s.$$.fragment), l = R(), u && u.c(), r = R(), o && L(o.$$.fragment), a = R(), m && m.c(), z(n, "display", "contents"), z(n, "--tjs-input-placeholder-color", "#555"), z(n, "--tjs-input-text-margin", "0"), z(n, "--tjs-input-text-width", "100%"), b(t, "class", "a5efc-search-field"), b(e, "class", "a5efc-main-wrapper");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(t, n), N(s, n, null), A(t, l), u && u.m(t, null), A(e, r), o && N(o, e, null), A(e, a), m && m.m(e, null), c = !0;
    },
    p(g, h) {
      const _ = {};
      if (h & /*searchInput*/
      512 && (_.input = /*searchInput*/
      g[9]), s.$set(_), /*compendiumType*/
      g[1] !== "classFeature" ? u ? u.p(g, h) : (u = Cj(g), u.c(), u.m(t, null)) : u && (u.d(1), u = null), h & /*tab*/
      64 && d !== (d = /*tab*/
      g[6] === "items" ? Ep : wp)) {
        if (o) {
          ce();
          const y = o;
          C(y.$$.fragment, 1, 0, () => {
            j(y, 1);
          }), ue();
        }
        d ? (o = nt(d, p(g)), o.$on(
          "listScrolled",
          /*listScrolled_handler*/
          g[23]
        ), L(o.$$.fragment), w(o.$$.fragment, 1), N(o, e, a)) : o = null;
      } else if (d) {
        const y = {};
        h & /*$reducer, visibleDocumentCount*/
        1152 && (y.documents = [.../*$reducer*/
        g[10]].slice(
          0,
          /*visibleDocumentCount*/
          g[7]
        )), h & /*compendiumType*/
        2 && (y.compendiumType = /*compendiumType*/
        g[1]), h & /*enableGrouping*/
        256 && (y.enableGrouping = /*enableGrouping*/
        g[8]), o.$set(y);
      }
      /*tab*/
      g[6] === "items" ? m ? m.p(g, h) : (m = Dj(g), m.c(), m.m(e, null)) : m && (m.d(1), m = null);
    },
    i(g) {
      c || (w(s.$$.fragment, g), o && w(o.$$.fragment, g), c = !0);
    },
    o(g) {
      C(s.$$.fragment, g), o && C(o.$$.fragment, g), c = !1;
    },
    d(g) {
      g && S(e), j(s), u && u.d(), o && j(o), m && m.d();
    }
  };
}
f(dpe, "create_default_slot$h");
function ppe(i) {
  let e, t, s;
  function n(r) {
    i[24](r);
  }
  f(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [dpe] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Ss({ props: l }), st.push(() => mt(e, "elementRoot", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, document, $reducer, tab, visibleDocumentCount, compendiumType, enableGrouping, filterCount, customImporter, includeDescriptions, searchInput*/
        134219774 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(ppe, "create_fragment$K");
function mpe(i) {
  i.sort((t, s) => t.name.localeCompare(s.name));
  const e = /* @__PURE__ */ new Map();
  return i.forEach((t) => e.set(t._id, t)), e;
}
f(mpe, "getDocuments");
function hpe(i, e, t) {
  let s, n, l, r, { compendiumType: o, customImporter: a, document: c, filterStore: u, sheet: d } = fe("#external").application, { compendiumType: p = o, customImporter: m = a, document: g = c, filterStore: h = u, sheet: _ = d } = e, { elementRoot: y } = e;
  async function k() {
    const ae = g, be = (await Promise.all([...r].map(async (we) => ae.getDocument(we._id)))).map((we) => we.toObject());
    m(be);
  }
  f(k, "exportToActor");
  async function v() {
    let ae = new pa("Export to RollTable", lw);
    ae.render(!0);
    const { rollTableName: be } = await ae.promise ?? {};
    if (!be)
      return;
    const we = {
      name: `${be}`,
      formula: `1d${[...r].length}`,
      replacement: !0,
      results: [...r].map((ve, me) => ({
        documentCollection: g.metadata.id,
        documentId: ve._id,
        img: ve.img,
        text: ve.name,
        range: [me + 1, me + 1],
        type: 2,
        weight: 1
      }))
    };
    RollTable.create(we);
  }
  f(v, "exportToRollTable");
  function O(ae) {
    ae > 80 && t(7, B += 50);
  }
  f(O, "handleScroll");
  let P = "items", D = !1, I = new Ms();
  pe(i, I, (ae) => t(10, r = ae));
  let B = 100;
  I.setData(mpe([...g.index]), !0), et("collection", g), et("customImporter", m), et("filterStore", h), et("reducer", I), et("sheet", _);
  const F = I.subscribe(() => t(7, B = 100));
  let H = {};
  const G = h.subscribe((ae) => {
    t(17, H = ae);
  });
  Nt(() => {
    _B(I), F(), G();
  });
  const U = /* @__PURE__ */ f(() => t(4, D = !D), "click_handler"), q = /* @__PURE__ */ f(() => t(8, l = !l), "click_handler_1"), W = /* @__PURE__ */ f(() => v(), "click_handler_2"), X = /* @__PURE__ */ f(() => k(), "click_handler_3"), te = /* @__PURE__ */ f(() => {
    t(6, P = P === "items" ? "filters" : "items");
  }, "click_handler_4"), J = /* @__PURE__ */ f(({ detail: ae }) => O(ae), "listScrolled_handler");
  function re(ae) {
    y = ae, t(0, y);
  }
  return f(re, "applicationshell_elementRoot_binding"), i.$$set = (ae) => {
    "compendiumType" in ae && t(1, p = ae.compendiumType), "customImporter" in ae && t(2, m = ae.customImporter), "document" in ae && t(3, g = ae.document), "filterStore" in ae && t(15, h = ae.filterStore), "sheet" in ae && t(16, _ = ae.sheet), "elementRoot" in ae && t(0, y = ae.elementRoot);
  }, i.$$.update = () => {
    i.$$.dirty & /*includeDescriptions*/
    16 && t(9, s = bB(I)), i.$$.dirty & /*filterSelections, compendiumType*/
    131074 && t(5, n = cpe(I, H, p)), i.$$.dirty & /*filterCount*/
    32 && console.log(n);
  }, t(8, l = !1), [
    y,
    p,
    m,
    g,
    D,
    n,
    P,
    B,
    l,
    s,
    r,
    k,
    v,
    O,
    I,
    h,
    _,
    H,
    U,
    q,
    W,
    X,
    te,
    J,
    re
  ];
}
f(hpe, "instance$E");
const UC = class UC extends ie {
  constructor(e) {
    super(), le(this, e, hpe, ppe, ne, {
      compendiumType: 1,
      customImporter: 2,
      document: 3,
      filterStore: 15,
      sheet: 16,
      elementRoot: 0
    });
  }
  get compendiumType() {
    return this.$$.ctx[1];
  }
  set compendiumType(e) {
    this.$$set({ compendiumType: e }), Ke();
  }
  get customImporter() {
    return this.$$.ctx[2];
  }
  set customImporter(e) {
    this.$$set({ customImporter: e }), Ke();
  }
  get document() {
    return this.$$.ctx[3];
  }
  set document(e) {
    this.$$set({ document: e }), Ke();
  }
  get filterStore() {
    return this.$$.ctx[15];
  }
  set filterStore(e) {
    this.$$set({ filterStore: e }), Ke();
  }
  get sheet() {
    return this.$$.ctx[16];
  }
  set sheet(e) {
    this.$$set({ sheet: e }), Ke();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Ke();
  }
};
f(UC, "CompendiumSheet");
let kl = UC;
const gpe = It({
  spellLevels: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  miscellaneous: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  primarySpellSchools: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  }
}), VC = class VC extends _s {
  constructor(e, t = {}) {
    const { collection: s } = e;
    super(foundry.utils.mergeObject(t, {
      id: "collection.metadata.package",
      title: `${s.metadata.label} ${s.locked ? "[LOCKED]" : ""}`,
      width: 560,
      height: "auto",
      resizable: !0,
      svelte: {
        class: kl,
        props: {
          compendiumType: "5eSpell",
          customImporter: t.importer ?? null,
          document: null,
          filterStore: gpe
        }
      }
    })), this.compendiumCollection = e, this.options.svelte.props.document = s, this.options.svelte.props.sheet = this;
  }
  /**
  * Default Application options
  *
  * @returns {object} options - Application options.
  * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
  */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["a5efc-compendium-sheet"],
      minimizable: !0,
      svelte: {
        target: document.body
      }
    });
  }
};
f(VC, "DND5ESpellCompendiumSheet");
let Sp = VC;
const bpe = It({
  objectType: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  rarity: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  miscellaneous: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  }
}), WC = class WC extends _s {
  constructor(e, t = {}) {
    const { collection: s } = e;
    super(foundry.utils.mergeObject(t, {
      id: "collection.metadata.package",
      title: `${s.metadata.label} ${s.locked ? "[LOCKED]" : ""}`,
      width: 560,
      height: "auto",
      resizable: !0,
      svelte: {
        class: kl,
        props: {
          compendiumType: "magicItem",
          customImporter: t.importer ?? null,
          document: null,
          filterStore: bpe
        }
      }
    })), this.compendiumCollection = e, this.options.svelte.props.document = s, this.options.svelte.props.sheet = this;
  }
  /**
  * Default Application options
  *
  * @returns {object} options - Application options.
  * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
  */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["a5efc-compendium-sheet"],
      minimizable: !0,
      svelte: {
        target: document.body
      }
    });
  }
};
f(WC, "ItemCompendiumSheet");
let Bc = WC;
const _pe = It({
  exertion: {
    min: 0,
    max: 6
  },
  maneuverDegrees: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  maneuverTraditions: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  miscellaneous: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  }
}), KC = class KC extends _s {
  constructor(e, t = {}) {
    const { collection: s } = e;
    super(foundry.utils.mergeObject(t, {
      id: "collection.metadata.package",
      title: `${s.metadata.label} ${s.locked ? "[LOCKED]" : ""}`,
      width: 560,
      height: "auto",
      resizable: !0,
      svelte: {
        class: kl,
        props: {
          compendiumType: "maneuver",
          customImporter: t.importer ?? null,
          document: null,
          filterStore: _pe
        }
      }
    })), this.compendiumCollection = e, this.options.svelte.props.document = s, this.options.svelte.props.sheet = this;
  }
  /**
  * Default Application options
  *
  * @returns {object} options - Application options.
  * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
  */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["a5efc-compendium-sheet"],
      minimizable: !0,
      svelte: {
        target: document.body
      }
    });
  }
};
f(KC, "ManeuverCompendiumSheet");
let qc = KC;
const ype = It({
  cr: {
    min: 0,
    max: 30
  },
  creatureSize: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  creatureTypes: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  miscellaneous: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  terrain: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  }
}), YC = class YC extends _s {
  constructor(e, t = {}) {
    const { collection: s } = e;
    super(foundry.utils.mergeObject(t, {
      id: "collection.metadata.package",
      title: `${s.metadata.label} ${s.locked ? "[LOCKED]" : ""}`,
      width: 560,
      height: "auto",
      resizable: !0,
      svelte: {
        class: kl,
        props: {
          compendiumType: "monster",
          customImporter: t.importer ?? null,
          document: null,
          filterStore: ype
        }
      }
    })), this.compendiumCollection = e, this.options.svelte.props.document = s, this.options.svelte.props.sheet = this;
  }
  /**
  * Default Application options
  *
  * @returns {object} options - Application options.
  * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
  */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["a5efc-compendium-sheet"],
      minimizable: !0,
      svelte: {
        target: document.body
      }
    });
  }
};
f(YC, "MonsterCompendiumSheet");
let Gc = YC;
const vpe = It({
  spellLists: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 1
  },
  spellLevels: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  components: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 1
  },
  miscellaneous: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  primarySpellSchools: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  secondarySpellSchools: {
    inclusive: [],
    inclusiveMode: 1,
    exclusive: [],
    exclusiveMode: 1
  }
}), XC = class XC extends _s {
  constructor(e, t = {}) {
    const { collection: s } = e;
    super(foundry.utils.mergeObject(t, {
      id: "collection.metadata.package",
      title: `${s.metadata.label} ${s.locked ? "[LOCKED]" : ""}`,
      width: 560,
      height: "auto",
      resizable: !0,
      svelte: {
        class: kl,
        props: {
          compendiumType: "spell",
          customImporter: t.importer ?? null,
          document: null,
          filterStore: vpe
        }
      }
    })), this.compendiumCollection = e, this.options.svelte.props.document = s, this.options.svelte.props.sheet = this;
  }
  /**
  * Default Application options
  *
  * @returns {object} options - Application options.
  * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
  */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["a5efc-compendium-sheet"],
      minimizable: !0,
      svelte: {
        target: document.body
      }
    });
  }
};
f(XC, "SpellCompendiumSheet");
let zc = XC;
const JC = class JC extends foundry.abstract.TypeDataModel {
  static defineSchema() {
    return {
      schemaVersion: new foundry.data.fields.SchemaField({
        version: new foundry.data.fields.NumberField({
          nullable: !0,
          initial: Dn.LATEST_SCHEMA_VERSION
        }),
        lastMigration: new foundry.data.fields.SchemaField(
          {
            version: new foundry.data.fields.SchemaField({
              schema: new foundry.data.fields.NumberField({ nullable: !0 }),
              system: new foundry.data.fields.StringField({ nullable: !0, required: !1 }),
              foundry: new foundry.data.fields.StringField({ nullable: !0, required: !1 })
            })
          },
          { nullable: !0, initial: null }
        )
      })
    };
  }
};
f(JC, "SchemaDataModel");
let Gi = JC;
const r1 = class r1 extends foundry.data.fields.ObjectField {
  constructor(e, t, s) {
    if (super(s), !this._isValidKeyFieldType(e))
      throw new Error("key field must be a StringField or a NumberField");
    if (this.keyField = e, !(t instanceof foundry.data.fields.DataField))
      throw new Error(`${this.name} must have a DataField as its contained field`);
    this.valueField = t;
  }
  _isValidKeyFieldType(e) {
    if (e instanceof foundry.data.fields.StringField || e instanceof foundry.data.fields.NumberField) {
      if (e.options.required !== !0 || e.options.nullable === !0)
        throw new Error("key field must be required and non-nullable");
      return !0;
    }
    return !1;
  }
  // eslint-disable-next-line consistent-return
  _validateValues(e, t = {}) {
    const s = foundry.data.validation.DataModelValidationFailure, n = new s();
    for (const [l, r] of Object.entries(e)) {
      if (l.startsWith("-=") && (t != null && t.partial))
        continue;
      const o = this.keyField.validate(l, t);
      o && n.elements.push({ id: l, failure: o });
      const a = this.valueField.validate(r, t);
      a && n.elements.push({ id: `${l}-value`, failure: a });
    }
    if (n.elements.length)
      return n;
  }
  _cleanType(e, t = {}) {
    for (const [s, n] of Object.entries(e))
      e[s] = this.valueField.clean(n, t);
    return e;
  }
  _validateType(e, t = {}) {
    return e instanceof Object ? this._validateValues(e, t) : new foundry.data.validation.DataModelValidationFailure({ message: "must be an Object" });
  }
  initialize(e, t, s) {
    if (!e)
      return e;
    const n = {};
    for (const [l, r] of Object.entries(e))
      n[l] = this.valueField.initialize(r, t, s);
    return n;
  }
};
f(r1, "RecordField"), Ge(r1, "recursive", !0);
let Cs = r1;
const ZC = class ZC extends foundry.data.fields.SchemaField {
  // @ts-ignore
  _cast(e) {
    return e;
  }
  // @ts-ignore
  _cleanType(e, t) {
    return typeof e != "object" ? e : super._cleanType(e, t);
  }
};
f(ZC, "UnchasteSchemaField");
let rw = ZC;
function kpe() {
  const { fields: i } = foundry.data;
  return {
    context: new i.SchemaField(x9("bonus")),
    default: new i.BooleanField({ required: !0, initial: !0 }),
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
f(kpe, "getAbilitiesBonusData");
function wpe() {
  const { fields: i } = foundry.data;
  return {
    context: new i.SchemaField(eB("bonus")),
    default: new i.BooleanField({ required: !0, initial: !0 }),
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
f(wpe, "getAttackBonusData");
function $pe() {
  const { fields: i } = foundry.data;
  return {
    context: new i.SchemaField(tB("bonus")),
    damageType: new i.StringField({ required: !0, initial: "" }),
    default: new i.BooleanField({ required: !0, initial: !0 }),
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
f($pe, "getDamageBonusData");
function Ape() {
  const { fields: i } = foundry.data;
  return {
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
f(Ape, "getExertionBonusData");
function Epe() {
  const { fields: i } = foundry.data;
  return {
    context: new i.SchemaField(sB("bonus")),
    default: new i.BooleanField({ required: !0, initial: !0 }),
    healingType: new i.StringField({ required: !0, initial: "healing" }),
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
f(Epe, "getHealingBonusData");
function Spe() {
  const { fields: i } = foundry.data;
  return {
    context: new i.SchemaField(nB()),
    default: new i.BooleanField({ required: !0, initial: !0 }),
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
f(Spe, "getHitPointBonusData");
function Tpe() {
  const { fields: i } = foundry.data;
  return {
    context: new i.SchemaField(iB("bonus")),
    default: new i.BooleanField({ required: !0, initial: !0 }),
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
f(Tpe, "getInitiativeBonusData");
function Cpe() {
  const { fields: i } = foundry.data;
  return {
    context: new i.SchemaField(lB("bonus")),
    unit: new i.StringField({ required: !0, initial: "feet" }),
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
f(Cpe, "getMovementBonusData");
function Ope() {
  const { fields: i } = foundry.data;
  return {
    context: new i.SchemaField(rB("bonus")),
    unit: new i.StringField({ required: !0, initial: "feet" }),
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
f(Ope, "getSensesBonusData");
function Dpe() {
  const { fields: i } = foundry.data;
  return {
    context: new i.SchemaField(oB("bonus")),
    default: new i.BooleanField({ required: !0, initial: !0 }),
    formula: new i.StringField({ required: !0, initial: "" }),
    label: new i.StringField({ required: !0, initial: "" }),
    img: new i.StringField({ required: !0, initial: "icons/svg/upgrade.svg" })
  };
}
f(Dpe, "getSkillBonusData");
const QC = class QC extends ys.mixin(Gi) {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      abilities: new e.SchemaField(
        ["str", "dex", "con", "int", "wis", "cha"].reduce((t, s) => (t[s] = new e.SchemaField({
          value: new e.NumberField({ required: !0, initial: 10, integer: !0 }),
          check: new e.SchemaField({
            expertiseDice: new e.NumberField({
              required: !0,
              initial: 0,
              integer: !0
            }),
            bonus: new e.StringField({ required: !0, initial: "" })
            // notes: new RecordField(
            //   new fields.DocumentIdField({
            //     required: true, initial: () => foundry.utils.randomID()
            //   }),
            //   new fields.SchemaField(getCheckNotesData())
            // )
          }),
          save: new e.SchemaField({
            proficient: new e.BooleanField({ required: !0, initial: !1 }),
            expertiseDice: new e.NumberField({
              required: !0,
              initial: 0,
              integer: !0
            }),
            bonus: new e.StringField({ required: !0, initial: "" }),
            ...s === "con" ? { concentrationBonus: new e.StringField({ required: !0, initial: "" }) } : {}
            // notes: new RecordField(
            //   new fields.DocumentIdField({
            //     required: true, initial: () => foundry.utils.randomID()
            //   }),
            //   new fields.SchemaField(getCheckNotesData())
            // )
          })
        }), t), {})
      ),
      attributes: new e.SchemaField({
        ac: new e.SchemaField({
          baseFormula: new e.StringField({ required: !0, initial: "10 + @dex.mod" }),
          value: new e.NumberField({ required: !0, initial: 0, integer: !0 })
        }),
        death: new e.SchemaField({
          success: new e.NumberField({ required: !0, initial: 0, integer: !0 }),
          failure: new e.NumberField({ required: !0, initial: 0, integer: !0 })
        }),
        hp: new e.SchemaField({
          value: new e.NumberField({ required: !0, initial: 10, integer: !0 }),
          baseMax: new e.NumberField({ required: !0, initial: 10, integer: !0 }),
          temp: new e.NumberField({ required: !0, initial: 0, integer: !0 }),
          bonus: new e.NumberField({ required: !0, initial: 0, integer: !0 })
        }),
        hitDice: new e.SchemaField({
          ...["d6", "d8", "d10", "d12"].reduce((t, s) => (t[s] = new e.SchemaField({
            current: new e.NumberField({
              required: !0,
              initial: 0,
              integer: !0,
              min: 0
            }),
            total: new e.NumberField({
              required: !0,
              initial: 0,
              integer: !0,
              min: 0
            })
          }), t), {})
        }),
        initiative: new e.SchemaField({
          ability: new e.StringField({ required: !0, initial: "dex" }),
          // TODO: Migration Upgrade - Remove this at a later date when migration is guaranteed
          bonus: new e.StringField({ required: !0, initial: "" }),
          expertiseDice: new e.NumberField({ required: !0, initial: 0, integer: !0 })
        }),
        movement: new e.SchemaField({
          burrow: new e.SchemaField({
            distance: new e.NumberField({
              required: !0,
              initial: 0,
              integer: !0,
              min: 0
            }),
            unit: new e.StringField({ required: !0, initial: "feet" })
          }),
          climb: new e.SchemaField({
            distance: new e.NumberField({
              required: !0,
              initial: 0,
              integer: !0,
              min: 0
            }),
            unit: new e.StringField({ required: !0, initial: "feet" })
          }),
          fly: new e.SchemaField({
            distance: new e.NumberField({
              required: !0,
              initial: 0,
              integer: !0,
              min: 0
            }),
            unit: new e.StringField({ required: !0, initial: "feet" })
          }),
          swim: new e.SchemaField({
            distance: new e.NumberField({
              required: !0,
              initial: 0,
              integer: !0,
              min: 0
            }),
            unit: new e.StringField({ required: !0, initial: "feet" })
          }),
          walk: new e.SchemaField({
            distance: new e.NumberField({
              required: !0,
              initial: 0,
              integer: !0,
              min: 0
            }),
            unit: new e.StringField({ required: !0, initial: "feet" })
          }),
          traits: new e.SchemaField({
            hover: new e.BooleanField({ required: !0, initial: !1 })
          })
        }),
        senses: new e.SchemaField({
          blindsight: new e.SchemaField({
            distance: new e.NumberField({
              required: !0,
              initial: 0,
              integer: !0,
              min: 0
            }),
            unit: new e.StringField({ required: !0, initial: "feet" }),
            otherwiseBlind: new e.BooleanField({ required: !0, initial: !1 })
          }),
          darkvision: new e.SchemaField({
            distance: new e.NumberField({
              required: !0,
              initial: 0,
              integer: !0,
              min: 0
            }),
            unit: new e.StringField({ required: !0, initial: "feet" })
          }),
          tremorsense: new e.SchemaField({
            distance: new e.NumberField({
              required: !0,
              initial: 0,
              integer: !0,
              min: 0
            }),
            unit: new e.StringField({ required: !0, initial: "feet" })
          }),
          truesight: new e.SchemaField({
            distance: new e.NumberField({
              required: !0,
              initial: 0,
              integer: !0,
              min: 0
            }),
            unit: new e.StringField({ required: !0, initial: "feet" })
          })
        }),
        inspiration: new e.BooleanField({ required: !0, initial: !1 }),
        fatigue: new e.NumberField({ required: !0, initial: 0, integer: !0 }),
        strife: new e.NumberField({ required: !0, initial: 0, integer: !0 }),
        spellcasting: new e.StringField({ required: !0, initial: "int" })
      }),
      bonuses: new e.SchemaField({
        abilities: new Cs(
          new e.DocumentIdField({ required: !0, initial: () => foundry.utils.randomID() }),
          new rw(kpe())
        ),
        attacks: new Cs(
          new e.DocumentIdField({ required: !0, initial: () => foundry.utils.randomID() }),
          new e.SchemaField(wpe())
        ),
        damage: new Cs(
          new e.DocumentIdField({ required: !0, initial: () => foundry.utils.randomID() }),
          new e.SchemaField($pe())
        ),
        exertion: new Cs(
          new e.DocumentIdField({ required: !0, initial: () => foundry.utils.randomID() }),
          new e.SchemaField(Ape())
        ),
        healing: new Cs(
          new e.DocumentIdField({ required: !0, initial: () => foundry.utils.randomID() }),
          new e.SchemaField(Epe())
        ),
        hitPoint: new Cs(
          new e.DocumentIdField({ required: !0, initial: () => foundry.utils.randomID() }),
          new e.SchemaField(Spe())
        ),
        initiative: new Cs(
          new e.DocumentIdField({ required: !0, initial: () => foundry.utils.randomID() }),
          new e.SchemaField(Tpe())
        ),
        movement: new Cs(
          new e.DocumentIdField({ required: !0, initial: () => foundry.utils.randomID() }),
          new e.SchemaField(Cpe())
        ),
        senses: new Cs(
          new e.DocumentIdField({ required: !0, initial: () => foundry.utils.randomID() }),
          new e.SchemaField(Ope())
        ),
        skills: new Cs(
          new e.DocumentIdField({ required: !0, initial: () => foundry.utils.randomID() }),
          new e.SchemaField(Dpe())
        ),
        maneuverDC: new e.StringField({ initial: "" }),
        spellDC: new e.StringField({ initial: "" }),
        // TODO: Migration Upgrade - Remove these at a later date when migration is guaranteed
        meleeSpellAttack: new e.StringField({ initial: "" }),
        meleeWeaponAttack: new e.StringField({ initial: "" }),
        rangedSpellAttack: new e.StringField({ initial: "" }),
        rangedWeaponAttack: new e.StringField({ initial: "" })
      }),
      currency: new e.SchemaField({
        cp: new e.NumberField({ required: !0, initial: 0, integer: !0 }),
        sp: new e.NumberField({ required: !0, initial: 0, integer: !0 }),
        ep: new e.NumberField({ required: !0, initial: 0, integer: !0 }),
        gp: new e.NumberField({ required: !0, initial: 0, integer: !0 }),
        pp: new e.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      details: new e.SchemaField({
        bio: new e.StringField({ required: !0, initial: "" }),
        creatureTypes: new e.ArrayField(
          new e.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        isSwarm: new e.BooleanField({ required: !0, initial: !1 })
      }),
      grants: new Cs(
        new e.DocumentIdField({ required: !0, initial: () => foundry.utils.randomID() }),
        new e.ObjectField()
      ),
      proficiencies: new e.SchemaField({
        armor: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), { required: !0, initial: [] }),
        languages: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), { required: !0, initial: [] }),
        tools: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), { required: !0, initial: [] }),
        weapons: new e.ArrayField(new e.StringField({ required: !0, initial: "" }), { required: !0, initial: [] })
      }),
      resources: new e.SchemaField(
        ["primary", "secondary", "tertiary", "quaternary"].reduce((t, s) => (t[s] = new e.SchemaField({
          label: new e.StringField({ required: !0, initial: "" }),
          value: new e.NumberField({ required: !0, initial: 0, integer: !0 }),
          max: new e.StringField({ required: !0, initial: "" }),
          per: new e.StringField({ required: !0, initial: "" }),
          hideMax: new e.BooleanField({ required: !0, initial: !1 }),
          recharge: new e.SchemaField({
            formula: new e.StringField({ required: !0, initial: "1d6" }),
            threshold: new e.NumberField({ required: !0, initial: 6, integer: !0 })
          })
        }), t), {})
      ),
      skills: new e.SchemaField(
        Object.keys(CONFIG.A5E.skills ?? {}).reduce((t, s) => (t[s] = new e.SchemaField({
          ability: new e.StringField({
            required: !0,
            initial: CONFIG.A5E.skillDefaultAbilities[s] ?? "int"
          }),
          proficient: new e.NumberField({
            required: !0,
            initial: 0,
            integer: !0,
            min: 0,
            max: 2
          }),
          specialties: new e.ArrayField(
            new e.StringField({ required: !0, initial: "" }),
            { required: !0, initial: [] }
          ),
          expertiseDice: new e.NumberField({ required: !0, initial: 0, integer: !0 }),
          minRoll: new e.NumberField({
            required: !0,
            initial: 1,
            integer: !0,
            min: 1,
            max: 20
          }),
          bonuses: new e.SchemaField({
            check: new e.StringField({ required: !0, initial: "" }),
            passive: new e.NumberField({ required: !0, initial: 0, integer: !0 })
          })
        }), t), {})
      ),
      source: new e.StringField({ required: !0, initial: "" }),
      spellBooks: new Cs(
        new e.DocumentIdField({ required: !0, initial: () => foundry.utils.randomID() }),
        new e.ObjectField(),
        {
          required: !0,
          initial: () => ({ [foundry.utils.randomID()]: {} })
        }
      ),
      traits: new e.SchemaField({
        size: new e.StringField({ required: !0, initial: "med" }),
        alignment: new e.ArrayField(
          new e.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        conditionImmunities: new e.ArrayField(
          new e.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        damageImmunities: new e.ArrayField(
          new e.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        damageResistances: new e.ArrayField(
          new e.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        ),
        damageVulnerabilities: new e.ArrayField(
          new e.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        )
      })
    });
  }
};
f(QC, "BaseActorData");
let Tp = QC;
const xC = class xC extends Tp {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      attributes: new e.SchemaField({
        attunement: new e.SchemaField({
          current: new e.NumberField({ required: !0, initial: 0, integer: !0 }),
          max: new e.NumberField({ required: !0, initial: 3, integer: !0 })
        }),
        exertion: new e.SchemaField({
          current: new e.NumberField({ required: !0, initial: 0, integer: !0 }),
          max: new e.NumberField({ required: !0, initial: 0, integer: !0 }),
          recoverOnRest: new e.BooleanField({ required: !0, initial: !0 })
        })
      }),
      classes: new e.SchemaField({
        startingClass: new e.StringField({ required: !0, initial: "" })
      }),
      details: new e.SchemaField({
        age: new e.StringField({ required: !0, initial: "" }),
        appearance: new e.StringField({ required: !0, initial: "" }),
        archetype: new e.StringField({ required: !0, initial: "" }),
        background: new e.StringField({ required: !0, initial: "" }),
        classes: new e.StringField({ required: !0, initial: "" }),
        culture: new e.StringField({ required: !0, initial: "" }),
        destiny: new e.StringField({ required: !0, initial: "" }),
        eyeColor: new e.StringField({ required: !0, initial: "" }),
        gender: new e.StringField({ required: !0, initial: "" }),
        hairColor: new e.StringField({ required: !0, initial: "" }),
        heritage: new e.StringField({ required: !0, initial: "" }),
        height: new e.StringField({ required: !0, initial: "" }),
        level: new e.NumberField({ required: !0, initial: 1, integer: !0 }),
        notes: new e.StringField({ required: !0, initial: "" }),
        prestige: new e.NumberField({ required: !0, initial: 1, integer: !0 }),
        skinColor: new e.StringField({ required: !0, initial: "" }),
        weight: new e.StringField({ required: !0, initial: "" }),
        xp: new e.NumberField({ required: !0, initial: 0, integer: !0 })
      }),
      proficiencies: new e.SchemaField({
        traditions: new e.ArrayField(
          new e.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        )
      }),
      spellResources: new e.SchemaField({
        artifactCharges: new e.SchemaField({
          current: new e.NumberField({ nullable: !1, initial: 0, integer: !0 }),
          override: new e.NumberField({ nullable: !1, initial: 0, integer: !0 })
        }),
        inventions: new e.SchemaField({
          current: new e.NumberField({ nullable: !1, initial: 0, integer: !0 }),
          override: new e.NumberField({ nullable: !1, initial: 0, integer: !0 })
        }),
        points: new e.SchemaField({
          current: new e.NumberField({ nullable: !1, initial: 0, integer: !0 }),
          max: new e.NumberField({ nullable: !0, initial: 0, min: 0 }),
          override: new e.NumberField({ nullable: !1, initial: 0, integer: !0 })
        }),
        slots: new e.SchemaField(
          Array.from({ length: 9 }, (t, s) => s + 1).reduce((t, s) => (t[s] = new e.SchemaField({
            current: new e.NumberField({ nullable: !1, initial: 0, min: 0 }),
            max: new e.NumberField({ nullable: !0, initial: 0, min: 0 }),
            override: new e.NumberField({ nullable: !1, initial: 0, min: 0 })
          }), t), {})
        )
      }),
      supply: new e.NumberField({ required: !0, initial: 0, integer: !0 })
    });
  }
};
f(xC, "CharacterData");
let ow = xC;
const e3 = class e3 extends Tp {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      attributes: new e.SchemaField({
        casterLevel: new e.NumberField({ required: !0, initial: 0, integer: !0 }),
        hitDice: new e.SchemaField({
          d4: new e.SchemaField({
            current: new e.NumberField({ required: !0, initial: 0, integer: !0 }),
            total: new e.NumberField({ required: !0, initial: 0, integer: !0 })
          }),
          d20: new e.SchemaField({
            current: new e.NumberField({ required: !0, initial: 0, integer: !0 }),
            total: new e.NumberField({ required: !0, initial: 0, integer: !0 })
          })
        })
      }),
      details: new e.SchemaField({
        cr: new e.NumberField({ required: !0, initial: 0 }),
        elite: new e.BooleanField({ required: !0, initial: !1 }),
        isSquad: new e.BooleanField({ required: !0, initial: !1 }),
        notes: new e.HTMLField({ required: !0, initial: "" }),
        privateNotes: new e.HTMLField({ required: !0, initial: "" }),
        terrain: new e.ArrayField(
          new e.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        )
      }),
      spellResources: new e.SchemaField({
        artifactCharges: new e.SchemaField({
          current: new e.NumberField({ nullable: !1, initial: 0, integer: !0 }),
          max: new e.NumberField({ nullable: !1, initial: 0, integer: !0 })
        }),
        inventions: new e.SchemaField({
          current: new e.NumberField({ nullable: !1, initial: 0, integer: !0 }),
          max: new e.NumberField({ nullable: !1, initial: 0, integer: !0 })
        }),
        points: new e.SchemaField({
          current: new e.NumberField({ nullable: !1, initial: 0, integer: !0 }),
          max: new e.NumberField({ nullable: !1, initial: 0, integer: !0 })
        }),
        slots: new e.SchemaField(
          Array.from({ length: 9 }, (t, s) => s + 1).reduce((t, s) => (t[s] = new e.SchemaField({
            current: new e.NumberField({ nullable: !1, initial: 0, min: 0 }),
            max: new e.NumberField({ nullable: !1, initial: 0, min: 0 })
          }), t), {})
        )
      }),
      source: new e.StringField({ required: !1, initial: "" })
    });
  }
};
f(e3, "NPCData");
let aw = e3;
const t3 = class t3 extends ys.mixin(Gi) {
  static defineSchema() {
    return this.mergeSchema(super.defineSchema(), {
      description: new foundry.data.fields.StringField({ nullable: !1, initial: "" }),
      grants: new foundry.data.fields.ObjectField({
        nullable: !1,
        initial: () => ({
          // Default ASI
          [foundry.utils.randomID()]: {
            grantType: "ability",
            abilities: { options: Object.keys(CONFIG.A5E.abilities), total: 1 },
            context: { types: ["base"] },
            bonus: "1",
            label: "Default ASI"
          },
          // Skill Proficiency
          [foundry.utils.randomID()]: {
            grantType: "proficiency",
            keys: { total: 1 },
            proficiencyType: "skill",
            label: "Skill Proficiencies"
          },
          // Feature
          [foundry.utils.randomID()]: {
            grantType: "feature",
            label: "Background Feature"
          },
          // Suggested Equipment
          [foundry.utils.randomID()]: {
            grantType: "item",
            label: "Suggested Equipment",
            optional: !0
          },
          // Trait Proficiency
          [foundry.utils.randomID()]: {
            grantType: "proficiency",
            proficiencyType: "tool",
            label: "Tool Proficiencies"
          }
        })
      }),
      source: new foundry.data.fields.StringField({ nullable: !1, initial: "" })
    });
  }
};
f(t3, "BackgroundDataModel");
let cw = t3;
const s3 = class s3 extends ys.mixin(Gi) {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      slug: new e.StringField({ nullable: !1, initial: "" }),
      description: new e.HTMLField({ nullable: !1, initial: "" }),
      classLevels: new e.NumberField({
        nullable: !1,
        initial: 0,
        min: 0,
        max: 20
      }),
      hp: new e.SchemaField({
        hitDiceSize: new e.NumberField({
          nullable: !1,
          initial: 6,
          min: 4,
          max: 20
        }),
        hitDiceUsed: new e.NumberField({ nullable: !1, initial: 0, min: 0 }),
        levels: new e.SchemaField(
          Array.from({ length: 20 }, (t, s) => s + 1).reduce((t, s) => (t[s] = new e.NumberField({ nullable: !1, initial: 0, min: 0 }), t), {})
        )
      }),
      grants: new e.ObjectField({
        nullable: !1,
        initial: () => ({
          [foundry.utils.randomID()]: {
            grantType: "proficiency",
            keys: {
              base: [],
              options: [],
              total: 0
            },
            proficiencyType: "armor",
            label: "Armor Proficiencies",
            levelType: "class"
          },
          [foundry.utils.randomID()]: {
            grantType: "proficiency",
            keys: {
              base: [],
              options: [],
              total: 0
            },
            proficiencyType: "weapon",
            label: "Weapon Proficiencies",
            levelType: "class"
          },
          [foundry.utils.randomID()]: {
            grantType: "proficiency",
            keys: {
              base: [],
              options: [],
              total: 0
            },
            proficiencyType: "tool",
            label: "Tool Proficiencies",
            levelType: "character"
          },
          [foundry.utils.randomID()]: {
            grantType: "proficiency",
            keys: {
              base: [],
              options: [],
              total: 0
            },
            proficiencyType: "savingThrow",
            isExpertise: !1,
            label: "Saving Throw Proficiencies",
            levelType: "character"
          },
          [foundry.utils.randomID()]: {
            grantType: "proficiency",
            keys: {
              base: [],
              options: [],
              total: 0
            },
            proficiencyType: "skill",
            isExpertise: !1,
            label: "Skill Proficiencies",
            levelType: "character"
          },
          [foundry.utils.randomID()]: {
            grantType: "feature",
            features: {
              base: [],
              options: [],
              total: 0
            },
            label: "1st Level Class Features",
            levelType: "class"
          },
          [foundry.utils.randomID()]: {
            grantType: "item",
            items: {
              base: [],
              options: [],
              total: 0
            },
            label: "Starting Equipment",
            levelType: "character",
            optional: !0
          }
        })
      }),
      resources: new e.ArrayField(
        new e.SchemaField({
          name: new e.StringField({ nullable: !1, initial: "New Resource" }),
          reference: new e.SchemaField(
            Array.from({ length: 20 }, (t, s) => s + 1).reduce((t, s) => (t[s] = new e.StringField({ nullable: !1, initial: 0, min: 0 }), t), {})
          ),
          type: new e.StringField({
            nullable: !1,
            initial: "",
            choices: ["number", "dice", "string"]
          })
        })
      ),
      source: new e.StringField({ nullable: !1, initial: "" }),
      spellcasting: new e.SchemaField({
        ability: new e.SchemaField({
          base: new e.StringField({ nullable: !1, initial: "none" }),
          options: new e.ArrayField(
            new e.StringField({ nullable: !1, initial: "none" }),
            { nullable: !1, initial: [] }
          ),
          value: new e.StringField({ nullable: !1, initial: "none" })
        }),
        casterType: new e.StringField({ nullable: !1, initial: "none" }),
        knownCantrips: new e.SchemaField(
          Array.from({ length: 20 }, (t, s) => s + 1).reduce((t, s) => (t[s] = new e.NumberField({ nullable: !1, initial: 0, min: 0 }), t), {})
        ),
        knownSpells: new e.SchemaField(
          Array.from({ length: 20 }, (t, s) => s + 1).reduce((t, s) => (t[s] = new e.NumberField({ nullable: !1, initial: 0, min: 0 }), t), {})
        )
      }),
      wealth: new e.StringField({ nullable: !1, initial: "" })
    });
  }
};
f(s3, "ClassDataModel");
let uw = s3;
const n3 = class n3 extends ys.mixin(Gi) {
  static defineSchema() {
    return this.mergeSchema(super.defineSchema(), {
      description: new foundry.data.fields.StringField({ nullable: !1, initial: "" }),
      grants: new foundry.data.fields.ObjectField({
        nullable: !1,
        initial: () => ({
          // Feature Grant
          [foundry.utils.randomID()]: {
            grantType: "feature",
            label: "Culture Features"
          },
          // Languages
          [foundry.utils.randomID()]: {
            grantType: "trait",
            traits: { traitType: "languages" },
            label: "Languages"
          }
        })
      }),
      source: new foundry.data.fields.StringField({ nullable: !1, initial: "" })
    });
  }
};
f(n3, "CultureDataModel");
let fw = n3;
const i3 = class i3 extends ys.mixin(Gi) {
  static defineSchema() {
    return this.mergeSchema(super.defineSchema(), {
      description: new foundry.data.fields.StringField({ nullable: !1, initial: "" }),
      sourceOfInspiration: new foundry.data.fields.StringField({ nullable: !1, initial: "" }),
      inspirationFeature: new foundry.data.fields.StringField({ nullable: !1, initial: "" }),
      fulfillmentFeature: new foundry.data.fields.StringField({ nullable: !1, initial: "" }),
      source: new foundry.data.fields.StringField({ nullable: !1, initial: "" })
    });
  }
};
f(i3, "DestinyDataModel");
let dw = i3;
const l3 = class l3 extends ys.mixin(Gi) {
  static defineSchema() {
    return this.mergeSchema(super.defineSchema(), {
      description: new foundry.data.fields.StringField({ nullable: !1, initial: "" }),
      grants: new foundry.data.fields.ObjectField({
        nullable: !1,
        initial: () => ({
          [foundry.utils.randomID()]: {
            grantType: "movement",
            movementTypes: { base: ["walk"] },
            bonus: "30",
            unit: "feet",
            label: "Base Movement"
          }
        })
      }),
      source: new foundry.data.fields.StringField({ nullable: !1, initial: "" })
    });
  }
};
f(l3, "HeritageDataModel");
let pw = l3;
const r3 = class r3 extends foundry.abstract.TypeDataModel {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return {
      ac: new e.SchemaField({
        baseFormula: new e.StringField({ required: !0, initial: "" }),
        formula: new e.StringField({ required: !0, initial: "" }),
        grantsDisadvantage: new e.BooleanField({ required: !0, initial: !1 }),
        maxDex: new e.NumberField({ required: !0, initial: 0, min: 0 }),
        minStr: new e.NumberField({ required: !0, initial: 0, min: 0 }),
        mode: new e.NumberField({ required: !0, initial: 2 }),
        requiresNoShield: new e.BooleanField({ required: !0, initial: !1 }),
        requiresUnarmored: new e.BooleanField({ required: !0, initial: !1 })
      })
    };
  }
};
f(r3, "ArmorDataModel");
let Cp = r3;
const o3 = class o3 extends ys.mixin(Gi) {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      actions: new e.ObjectField({ required: !0, initial: {} }),
      description: new e.HTMLField({ required: !0, initial: "" }),
      favorite: new e.BooleanField({ required: !0, initial: !1 }),
      secretDescription: new e.HTMLField({ required: !0, initial: "" }),
      source: new e.StringField({ required: !0, initial: "" }),
      uses: new e.SchemaField({
        value: new e.NumberField({
          required: !0,
          initial: 0,
          min: 0,
          integer: !0,
          nullable: !1
        }),
        max: new e.StringField({ required: !0, initial: "", nullable: !1 }),
        per: new e.StringField({ required: !0, initial: "" }),
        recharge: new e.SchemaField({
          formula: new e.StringField({ required: !0, initial: "" }),
          threshold: new e.NumberField({ required: !0, initial: 0, integer: !0 })
        })
      })
    });
  }
};
f(o3, "BaseItemData");
let Da = o3;
const a3 = class a3 extends ys.mixin(Da, Cp) {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      classes: new e.StringField({ required: !0, initial: "" }),
      concentration: new e.BooleanField({ required: !0, initial: !1 }),
      featureType: new e.StringField({ required: !0, initial: "" }),
      grants: new e.ObjectField({ required: !0, initial: {} }),
      prerequisite: new e.StringField({ required: !0, initial: "" }),
      requiresBloodied: new e.BooleanField({ required: !0, initial: !1 })
    });
  }
};
f(a3, "FeatureDataModel");
let mw = a3;
const c3 = class c3 extends ys.mixin(Da) {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      concentration: new e.BooleanField({ required: !0, initial: !1 }),
      degree: new e.NumberField({
        required: !0,
        initial: 0,
        integer: !0,
        min: 0
      }),
      exertionCost: new e.NumberField({
        required: !0,
        initial: 0,
        integer: !0,
        min: 0
      }),
      isStance: new e.BooleanField({ required: !0, initial: !1 }),
      prerequisite: new e.StringField({ required: !0, initial: "" }),
      tradition: new e.StringField({ required: !0, initial: "" })
    });
  }
};
f(c3, "ManeuverDataModel");
let hw = c3;
const u3 = class u3 extends ys.mixin(Da, Cp) {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      ammunitionProperties: new e.ArrayField(
        new e.StringField({ required: !0, initial: "" }),
        { required: !0, initial: [] }
      ),
      armorCategory: new e.StringField({ required: !0, initial: "" }),
      armorProperties: new e.ArrayField(
        new e.StringField({ required: !0, initial: "" }),
        { required: !0, initial: [] }
      ),
      attuned: new e.BooleanField({ required: !0, initial: !1 }),
      bulky: new e.BooleanField({ required: !0, initial: !1 }),
      breakerProperties: new e.ArrayField(
        new e.StringField({ required: !0, initial: "" }),
        { required: !0, initial: [] }
      ),
      craftingComponents: new e.StringField({ required: !0, initial: "" }),
      containerId: new e.StringField({ required: !0, initial: "" }),
      damagedState: new e.NumberField({
        required: !0,
        initial: 0,
        integer: !0,
        min: 0,
        max: 2
      }),
      defensiveProperties: new e.StringField({ required: !0, initial: "" }),
      equippedState: new e.NumberField({
        required: !0,
        initial: 0,
        integer: !0,
        min: 0,
        max: 2
      }),
      // TODO: Container Rework - Remove this in favor of a greedy approach
      flaws: new e.ArrayField(
        new e.StringField({ required: !0, initial: "" }),
        { required: !0, initial: [] }
      ),
      // TODO: Remove this in favor of a greedy approach
      items: new e.ObjectField({ required: !0, initial: {} }),
      materialProperties: new e.ArrayField(
        new e.StringField({ required: !0, initial: "" }),
        { required: !0, initial: [] }
      ),
      mounted: new e.ArrayField(
        new e.StringField({ required: !0, initial: "" }),
        { required: !0, initial: [] }
      ),
      objectType: new e.StringField({ required: !0, initial: "" }),
      plotItem: new e.BooleanField({ required: !0, initial: !1 }),
      price: new e.StringField({ required: !0, initial: "" }),
      proficient: new e.BooleanField({ required: !0, initial: !1 }),
      quantity: new e.NumberField({
        required: !0,
        initial: 1,
        integer: !0,
        min: 0
      }),
      rarity: new e.StringField({ required: !0, initial: "mundane" }),
      requiresAttunement: new e.BooleanField({ required: !0, initial: !1 }),
      shieldCategory: new e.StringField({ required: !0, initial: "" }),
      shieldProperties: new e.ArrayField(
        new e.StringField({ required: !0, initial: "" }),
        { required: !0, initial: [] }
      ),
      unidentified: new e.BooleanField({ required: !0, initial: !1 }),
      unidentifiedDescription: new e.HTMLField({ required: !0, initial: "" }),
      unidentifiedName: new e.StringField({ required: !0, initial: "" }),
      versatile: new e.StringField({ required: !0, initial: "" }),
      weaponProperties: new e.ArrayField(
        new e.StringField({ required: !0, initial: "" }),
        { required: !0, initial: [] }
      ),
      weight: new e.NumberField({
        required: !0,
        initial: 0,
        min: 0,
        nullable: !1
      })
    });
  }
  // Types: armor, ammunition, clothing, consumable, container, helm, jewelry,
  //  miscellaneous, shield, tool, weapon
};
f(u3, "ObjectDataModel");
let gw = u3;
const f3 = class f3 extends ys.mixin(Da) {
  static defineSchema() {
    const { fields: e } = foundry.data;
    return this.mergeSchema(super.defineSchema(), {
      classes: new e.ArrayField(
        new e.StringField({ required: !0, initial: "" }),
        { required: !0, initial: [] }
      ),
      components: new e.SchemaField({
        vocalized: new e.BooleanField({ required: !0, initial: !1 }),
        seen: new e.BooleanField({ required: !0, initial: !1 }),
        material: new e.BooleanField({ required: !0, initial: !1 })
      }),
      concentration: new e.BooleanField({ required: !0, initial: !1 }),
      level: new e.NumberField({
        required: !0,
        initial: 0,
        integer: !0,
        min: 0
      }),
      materials: new e.StringField({ required: !0, initial: "" }),
      materialsConsumed: new e.BooleanField({ required: !0, initial: !1 }),
      prepared: new e.NumberField({ required: !0, initial: 0 }),
      prerequisite: new e.StringField({ required: !0, initial: "" }),
      rare: new e.BooleanField({ required: !0, initial: !1 }),
      ritual: new e.BooleanField({ required: !0, initial: !1 }),
      schools: new e.SchemaField({
        primary: new e.StringField({ required: !0, initial: "" }),
        secondary: new e.ArrayField(
          new e.StringField({ required: !0, initial: "" }),
          { required: !0, initial: [] }
        )
      }),
      spellBook: new e.StringField({ required: !0, initial: "", nullable: !1 })
    });
  }
};
f(f3, "SpellDataModel");
let bw = f3;
const Ipe = {
  background: cw,
  class: uw,
  culture: fw,
  destiny: dw,
  heritage: pw,
  feature: mw,
  maneuver: hw,
  object: gw,
  spell: bw
}, Q5 = Ie.ACTIVE_EFFECT_MODES, Ppe = Object.keys(Q5).filter((i) => i !== "CUSTOM").sort((i, e) => i.localeCompare(e)), Mpe = Object.keys(Q5).filter((i) => !["CUSTOM", "UPGRADE", "DOWNGRADE", "CONDITIONAL"].includes(i)).sort((i, e) => i.localeCompare(e)), Rpe = ["ADD", "OVERRIDE"], Fpe = ["OVERRIDE"], Npe = ["CUSTOM"], jpe = ["CONDITIONAL"], Lpe = ["OVERRIDE", "CONDITIONAL"], Ue = {
  MODES: Q5,
  DEFAULT_MODES: Ppe,
  DEFAULT_STRING_MODES: Mpe,
  ADD_AND_OVERRIDE: Rpe,
  OVERRIDE_ONLY: Fpe,
  CUSTOM_ONLY: Npe,
  CONDITIONAL_ONLY: jpe,
  CONDITIONAL_AND_OVERRIDE: Lpe
}, d3 = class d3 {
  constructor(e, t, s = {
    modes: [],
    options: [],
    phase: "afterDerived",
    type: ""
  }) {
    Ge(this, "effectKey");
    Ge(this, "label");
    Ge(this, "modes");
    Ge(this, "options");
    Ge(this, "phase");
    Ge(this, "sampleValue");
    Ge(this, "type");
    var n;
    this.effectKey = e, this.label = ((n = CONFIG.A5E.effectsKeyLocalizations) == null ? void 0 : n[e]) ?? e, this.sampleValue = t, this.modes = s.modes ?? [], this.options = s.options ?? [], this.phase = s.phase ?? "afterDerived", this.type = s.type ?? "DEFAULT";
  }
};
f(d3, "EffectOption");
let ro = d3;
function Bpe(i) {
  i["system.attributes.inspiration"] = [!1, Ue.OVERRIDE_ONLY, [[!0, "Has Inspiration"], [!1, "Doesn't have Inspiration"]], "RADIO"], i["system.attributes.exertion.recoverOnRest"] = [!1, Ue.OVERRIDE_ONLY, [[!0, "Can Recover"], [!1, "Cannot recover"]], "RADIO"], i["system.attributes.movement.traits.hover"] = [!1, Ue.OVERRIDE_ONLY, [[!0, "Can Hover"], [!1, "Cannot Hover"]], "RADIO"], i["system.attributes.senses.blindsight.otherwiseBlind"] = [!1, Ue.OVERRIDE_ONLY, [[!0, "Blind Beyond Vision"], [!1, "Normal Vision"]], "RADIO"], i["system.details.elite"] = [!1, Ue.OVERRIDE_ONLY, [[!0, "Elite Monster"], [!1, "Normal Monster"]], "RADIO"], i["system.details.isSwarm"] = [!1, Ue.OVERRIDE_ONLY, [[!0, "Is Swarm"], [!1, "Not a Swarm"]], "RADIO"], Object.keys(CONFIG.A5E.abilities).forEach((e) => {
    i[`system.abilities.${e}.save.proficient`] = [!1, Ue.OVERRIDE_ONLY, [[!0, "Proficient"], [!1, "Not Proficient"]], "RADIO"];
  }), Object.keys(CONFIG.A5E.skills).forEach((e) => {
    i[`system.skills.${e}.proficient`] = [0, Ue.OVERRIDE_ONLY, [[0, "Not Proficient"], [1, "Proficient"], [2, "Expertise"]], "RADIO"], i[`system.skills.${e}.ability`] = ["", Ue.OVERRIDE_ONLY, [...Object.entries(CONFIG.A5E.abilities), ["@attributes.spellcasting", "Spellcasting"]], "RADIO"];
  }), i["system.attributes.initiative.ability"] = ["", Ue.OVERRIDE_ONLY, Object.entries(CONFIG.A5E.abilities), "RADIO"], i["system.details.creatureTypes"] = ["", Ue.DEFAULT_MODES, Object.entries(CONFIG.A5E.creatureTypes), "TAG_GROUP"], i["system.traits.conditionImmunities"] = ["", Ue.DEFAULT_STRING_MODES, Object.entries(CONFIG.A5E.conditions), "TAG_GROUP"], i["system.traits.damageImmunities"] = ["", Ue.DEFAULT_STRING_MODES, Object.entries(CONFIG.A5E.damageTypes), "TAG_GROUP"], i["system.traits.damageResistances"] = ["", Ue.DEFAULT_STRING_MODES, Object.entries(CONFIG.A5E.damageTypes), "TAG_GROUP"], i["system.traits.damageVulnerabilities"] = ["", Ue.DEFAULT_STRING_MODES, Object.entries(CONFIG.A5E.damageTypes), "TAG_GROUP"], i["system.traits.size"] = ["", Ue.OVERRIDE_ONLY, Object.entries(CONFIG.A5E.actorSizes), "RADIO"], i["system.proficiencies.armor"] = ["", Ue.DEFAULT_STRING_MODES, Object.entries(CONFIG.A5E.armor), "TAG_GROUP"], i["system.proficiencies.languages"] = ["", Ue.DEFAULT_STRING_MODES, Object.entries(CONFIG.A5E.languages), "TAG_GROUP"], i["system.proficiencies.tools"] = ["", Ue.DEFAULT_STRING_MODES, Object.values(CONFIG.A5E.tools).flatMap((e) => Object.entries(e)), "TAG_GROUP"], i["system.proficiencies.weapons"] = ["", Ue.DEFAULT_STRING_MODES, Object.values(CONFIG.A5E.weapons).flatMap((e) => Object.entries(e)), "TAG_GROUP"], i["system.attributes.prof"] = [0, Ue.DEFAULT_MODES], i["system.attributes.spellcasting"] = ["", Ue.OVERRIDE_ONLY, Object.entries(CONFIG.A5E.abilities), "RADIO"], i["flags.a5e.effects.bonuses.abilities"] = [{}, Ue.CUSTOM_ONLY, null, "ABILITY_BONUS"], i["flags.a5e.effects.bonuses.attacks"] = [{}, Ue.CUSTOM_ONLY, null, "ATTACK_BONUS"], i["flags.a5e.effects.bonuses.damage"] = [{}, Ue.CUSTOM_ONLY, null, "DAMAGE_BONUS"], i["flags.a5e.effects.bonuses.healing"] = [{}, Ue.CUSTOM_ONLY, null, "HEALING_BONUS"], i["flags.a5e.effects.bonuses.initiative"] = [{}, Ue.CUSTOM_ONLY, null, "INITIATIVE_BONUS"], i["flags.a5e.effects.bonuses.skills"] = [{}, Ue.CUSTOM_ONLY, null, "SKILL_BONUS"], delete i["system.bonuses.meleeWeaponAttack"], delete i["system.bonuses.rangedWeaponAttack"], delete i["system.bonuses.meleeSpellAttack"], delete i["system.bonuses.rangedSpellAttack"], delete i["system.attributes.initiative.bonus"], Object.keys(CONFIG.A5E.abilities).forEach((e) => {
    delete i[`system.abilities.${e}.check.mod`], delete i[`system.abilities.${e}.check.bonus`], delete i[`system.abilities.${e}.save.mod`], delete i[`system.abilities.${e}.save.bonus`];
  }), Object.keys(CONFIG.A5E.skills).forEach((e) => {
    delete i[`system.skills.${e}.mod`], delete i[`system.skills.${e}.bonus`];
  }), delete i["system.attributes.initiative.bonus"], delete i["system.attributes.ac.baseFormula"], delete i["system.attributes.ac.value"], delete i["system.spellBooks"], delete i["system.grants"], Object.keys(CONFIG.A5E.abilities).forEach((e) => {
    delete i[`system.abilities.${e}.check.bonus`], delete i[`system.abilities.${e}.save.bonus`];
  }), Object.keys(CONFIG.A5E.skills).forEach((e) => {
    delete i[`system.skills.${e}.bonuses.check`], delete i[`system.skills.${e}.bonuses.passive`];
  }), delete i["system.details.age"], delete i["system.details.appearance"], delete i["system.details.background"], delete i["system.details.bio"], delete i["system.details.classes"], delete i["system.details.culture"], delete i["system.details.destiny"], delete i["system.details.eyeColor"], delete i["system.details.gender"], delete i["system.details.hairColor"], delete i["system.details.height"], delete i["system.details.heritage"], delete i["system.details.level"], delete i["system.details.notes"], delete i["system.details.prestige"], delete i["system.details.skinColor"], delete i["system.details.weight"], delete i["system.details.notes"], delete i["system.details.xp"], delete i["system.details.privateNotes"], delete i["system.source.link"], delete i["system.source.name"], delete i["system.source.publisher"], delete i["system.resources.primary.hideMax"], delete i["system.resources.secondary.hideMax"], delete i["system.resources.tertiary.hideMax"], delete i["system.resources.quaternary.hideMax"], delete i["system.bonuses.abilities"], delete i["system.bonuses.attacks"], delete i["system.bonuses.damage"], delete i["system.bonuses.healing"], delete i["system.bonuses.initiative"], delete i["system.bonuses.movement"], delete i["system.bonuses.senses"], delete i["system.bonuses.skills"], delete i["system.schemaVersion.version"], delete i["system.schemaVersion.lastMigration"];
}
f(Bpe, "modifyBaseOptions");
function qpe(i) {
  i["system.attributes.ac.baseFormula"] = ["", Ue.OVERRIDE_ONLY], i["system.attributes.ac.changes.bonuses.value"] = [0, Ue.DEFAULT_MODES], i["system.attributes.ac.value"] = [0, Ue.CONDITIONAL_AND_OVERRIDE], i["system.attributes.hp.max"] = [0, Ue.DEFAULT_MODES], i["system.attributes.maneuverDC"] = [0, Ue.DEFAULT_MODES], i["system.attributes.spellDC"] = [0, Ue.DEFAULT_MODES], Object.keys(CONFIG.A5E.movement).forEach((e) => {
    i[`system.attributes.movement.${e}.unit`] = ["", Ue.OVERRIDE_ONLY, Object.entries(CONFIG.A5E.distanceUnits), "RADIO"], i["flags.a5e.effects.movement.allDistances"] = [0, Ue.DEFAULT_MODES], i["flags.a5e.effects.movement.allUnits"] = ["", Ue.OVERRIDE_ONLY, Object.entries(CONFIG.A5E.distanceUnits), "RADIO"];
  }), Object.keys(CONFIG.A5E.senses).forEach((e) => {
    i[`system.attributes.senses.${e}.unit`] = ["", Ue.OVERRIDE_ONLY, Object.entries(CONFIG.A5E.visionUnits), "RADIO"], i["flags.a5e.effects.senses.allDistances"] = [0, Ue.DEFAULT_MODES], i["flags.a5e.effects.senses.allUnits"] = ["", Ue.OVERRIDE_ONLY, Object.entries(CONFIG.A5E.visionUnits), "RADIO"];
  }), i["flags.a5e.deathSaveThreshold"] = [0, Ue.DEFAULT_MODES];
}
f(qpe, "modifyDerivedOptions");
function Gpe(i) {
  const e = Object.entries(CONFIG.A5E.ROLL_MODE).map(([s, n]) => [n, s.toLowerCase().capitalize()]);
  i["flags.a5e.effects.rollMode.attack.all"] = [0, Ue.OVERRIDE_ONLY, e, "RADIO"], Object.keys(CONFIG.A5E.attackTypes).forEach((s) => {
    i[`flags.a5e.effects.rollMode.attack.${s}`] = [0, Ue.OVERRIDE_ONLY, e, "RADIO"];
  }), i["flags.a5e.effects.rollMode.abilityCheck.all"] = [0, Ue.OVERRIDE_ONLY, e, "RADIO"], i["flags.a5e.effects.rollMode.abilitySave.all"] = [0, Ue.OVERRIDE_ONLY, e, "RADIO"], i["flags.a5e.effects.rollMode.skillCheck.all"] = [0, Ue.OVERRIDE_ONLY, e, "RADIO"], i["flags.a5e.effects.rollMode.concentration"] = [0, Ue.OVERRIDE_ONLY, e, "RADIO"], i["flags.a5e.effects.rollMode.deathSave"] = [0, Ue.OVERRIDE_ONLY, e, "RADIO"], i["flags.a5e.effects.rollMode.initiative"] = [0, Ue.OVERRIDE_ONLY, e, "RADIO"], Object.keys(CONFIG.A5E.abilities).forEach((s) => {
    i[`flags.a5e.effects.rollMode.abilityCheck.${s}`] = [0, Ue.OVERRIDE_ONLY, e, "RADIO"], i[`flags.a5e.effects.rollMode.abilitySave.${s}`] = [0, Ue.OVERRIDE_ONLY, e, "RADIO"];
  }), Object.keys(CONFIG.A5E.skills).forEach((s) => {
    i[`flags.a5e.effects.rollMode.skillCheck.${s}`] = [0, Ue.OVERRIDE_ONLY, e, "RADIO"];
  }), i["flags.a5e.effects.damageImmunities.all"] = [[], Ue.CUSTOM_ONLY, null, "NONE"], i["flags.a5e.effects.damageResistances.all"] = [[], Ue.CUSTOM_ONLY, null, "NONE"], i["flags.a5e.effects.damageVulnerabilities.all"] = [[], Ue.CUSTOM_ONLY, null, "NONE"], i["flags.a5e.effects.conditionImmunities.all"] = [[], Ue.CUSTOM_ONLY, null, "NONE"];
  const t = Object.entries(CONFIG.A5E.conditions);
  i["flags.a5e.effects.statusConditions"] = [[], Ue.CUSTOM_ONLY, t, "CHECKBOX"], i["@token.width"] = [1, Ue.OVERRIDE_ONLY], i["@token.height"] = [1, Ue.OVERRIDE_ONLY], i["@token.texture.src"] = ["", Ue.OVERRIDE_ONLY], i["@token.texture.scaleX"] = [1, Ue.OVERRIDE_ONLY], i["@token.texture.scaleY"] = [1, Ue.OVERRIDE_ONLY], i["@token.light.alpha"] = [0.5, Ue.OVERRIDE_ONLY], i["@token.light.angle"] = [360, Ue.OVERRIDE_ONLY], i["@token.light.animation.intensity"] = [5, Ue.OVERRIDE_ONLY], i["@token.light.animation.reverse"] = [!1, Ue.OVERRIDE_ONLY], i["@token.light.animation.speed"] = [5, Ue.OVERRIDE_ONLY], i["@token.light.animation.type"] = [null, Ue.OVERRIDE_ONLY], i["@token.light.attenuation"] = [0.5, Ue.OVERRIDE_ONLY], i["@token.light.bright"] = [0, Ue.OVERRIDE_ONLY], i["@token.light.color"] = [null, Ue.OVERRIDE_ONLY], i["@token.light.coloration"] = [1, Ue.OVERRIDE_ONLY], i["@token.light.contrast"] = [0, Ue.OVERRIDE_ONLY], i["@token.light.darkness.min"] = [0, Ue.OVERRIDE_ONLY], i["@token.light.darkness.max"] = [1, Ue.OVERRIDE_ONLY], i["@token.light.dim"] = [0, Ue.OVERRIDE_ONLY], i["@token.light.luminosity"] = [0.5, Ue.OVERRIDE_ONLY], i["@token.light.saturation"] = [0, Ue.OVERRIDE_ONLY], i["@token.light.shadows"] = [0, Ue.OVERRIDE_ONLY];
}
f(Gpe, "modifySpecialOptions");
function zpe() {
  const i = {};
  Object.entries(CONFIG.Actor.dataModels ?? {}).forEach(([t, s]) => {
    var a;
    i[t] = {
      allOptions: {},
      baseOptions: {},
      derivedOptions: {}
    };
    const n = {
      system: foundry.utils.duplicate(s.schema.initial())
    }, l = foundry.utils.flattenObject(n);
    Object.keys(l).forEach((c) => {
      l[c] = [
        l[c],
        typeof l[c] == "string" ? Ue.DEFAULT_STRING_MODES : Ue.DEFAULT_MODES
      ];
    }), Bpe(l), Object.keys(l).forEach((c) => {
      const [u, d, p, m, g] = l[c];
      i[t].baseOptions[c] = new ro(
        c,
        u,
        {
          modes: d ?? Ue.DEFAULT_MODES,
          options: p ?? [],
          type: m ?? "DEFAULT",
          phase: g ?? "applyAEs"
        }
      );
    });
    const r = {};
    qpe(r), Object.keys(r).forEach((c) => {
      const [u, d, p, m, g] = r[c];
      i[t].derivedOptions[c] = new ro(
        c,
        u,
        {
          modes: d ?? Ue.DEFAULT_MODES,
          options: p ?? [],
          type: m ?? "DEFAULT",
          phase: g ?? "afterDerived"
        }
      );
    });
    const o = {};
    Gpe(o), Object.keys(o).forEach((c) => {
      const [u, d, p, m, g] = o[c];
      i[t].derivedOptions[c] = new ro(
        c,
        u,
        {
          modes: d ?? Ue.DEFAULT_MODES,
          options: p ?? [],
          type: m ?? "DEFAULT",
          phase: g ?? "afterDerived"
        }
      );
    }), i[t].allOptions = {
      ...i[t].baseOptions,
      ...i[t].derivedOptions
    }, i[t].allOptions = Object.fromEntries(
      Object.entries(((a = i[t]) == null ? void 0 : a.allOptions) ?? {}).sort(([, c], [, u]) => c.label.localeCompare(u.label))
    );
  });
  const e = {};
  return Object.keys(game.system.model.Actor).forEach((t) => {
    var s;
    t !== "base" && Object.entries(((s = i[t]) == null ? void 0 : s.allOptions) ?? {}).forEach(([n, l]) => {
      e[n] = l;
    });
  }), i.all = { allOptions: e }, i;
}
f(zpe, "constructEffectOptions");
const p3 = class p3 extends ItemDirectory {
  async _handleDroppedEntry(e, t) {
    var l;
    const s = await this._getDroppedEntryFromData(t);
    if (!s)
      return;
    if (s.type !== "object")
      return super._handleDroppedEntry(e, t);
    if (s.system.objectType !== "container")
      return super._handleDroppedEntry(e, t);
    if (this._entryAlreadyExists(s))
      return super._handleDroppedEntry(e, t);
    const n = ((l = e == null ? void 0 : e.dataset) == null ? void 0 : l.folderId) ?? null;
    await Dr.createContainerOnSideBar(s, n);
  }
};
f(p3, "ItemDirectoryA5E");
let _w = p3;
function Ij(i, e, t) {
  const s = i.slice();
  s[5] = e[t][0], s[6] = e[t][1];
  const n = (
    /*attribute*/
    s[6].save.proficient
  );
  s[7] = n;
  const l = (
    /*abilities*/
    s[2][
      /*key*/
      s[5]
    ]
  );
  return s[8] = l, s;
}
f(Ij, "get_each_context$e");
function Pj(i) {
  var h, _, y, k;
  let e, t, s, n = Qn(
    /*attribute*/
    (_ = (h = i[6]) == null ? void 0 : h.check) == null ? void 0 : _.deterministicBonus
  ) + "", l, r, o, a, c, u = Qn(
    /*attribute*/
    (k = (y = i[6]) == null ? void 0 : y.save) == null ? void 0 : k.deterministicBonus
  ) + "", d, p, m, g;
  return {
    c() {
      e = E("div"), t = E("div"), s = E("span"), l = x(n), o = R(), a = E("div"), c = E("span"), d = x(u), m = R(), b(s, "class", "svelte-t9cazk"), b(t, "class", "attribute-wrapper__check svelte-t9cazk"), b(t, "data-tooltip", r = /*abilityLabel*/
      i[8] + " Check Modifier"), b(t, "data-tooltip-direction", "UP"), b(c, "class", "svelte-t9cazk"), b(a, "class", "attribute-wrapper__save svelte-t9cazk"), b(a, "data-tooltip", p = /*proficient*/
      i[7] ? `${/*abilityLabel*/
      i[8]} Saving Throw Modifier (Proficient)` : `${/*abilityLabel*/
      i[8]} Saving Throw Modifier`), b(a, "data-tooltip-direction", "UP"), Q(
        a,
        "attribute-wrapper__save--proficient",
        /*proficient*/
        i[7]
      ), b(e, "class", g = "attribute-wrapper attribute-wrapper--" + /*key*/
      i[5] + " svelte-t9cazk");
    },
    m(v, O) {
      T(v, e, O), A(e, t), A(t, s), A(s, l), A(e, o), A(e, a), A(a, c), A(c, d), A(e, m);
    },
    p(v, O) {
      var P, D, I, B;
      O & /*actorData*/
      2 && n !== (n = Qn(
        /*attribute*/
        (D = (P = v[6]) == null ? void 0 : P.check) == null ? void 0 : D.deterministicBonus
      ) + "") && _e(l, n), O & /*actorData*/
      2 && r !== (r = /*abilityLabel*/
      v[8] + " Check Modifier") && b(t, "data-tooltip", r), O & /*actorData*/
      2 && u !== (u = Qn(
        /*attribute*/
        (B = (I = v[6]) == null ? void 0 : I.save) == null ? void 0 : B.deterministicBonus
      ) + "") && _e(d, u), O & /*actorData*/
      2 && p !== (p = /*proficient*/
      v[7] ? `${/*abilityLabel*/
      v[8]} Saving Throw Modifier (Proficient)` : `${/*abilityLabel*/
      v[8]} Saving Throw Modifier`) && b(a, "data-tooltip", p), O & /*Object, actorData*/
      2 && Q(
        a,
        "attribute-wrapper__save--proficient",
        /*proficient*/
        v[7]
      ), O & /*actorData*/
      2 && g !== (g = "attribute-wrapper attribute-wrapper--" + /*key*/
      v[5] + " svelte-t9cazk") && b(e, "class", g);
    },
    d(v) {
      v && S(e);
    }
  };
}
f(Pj, "create_each_block$e");
function Hpe(i) {
  let e, t = oe(Object.entries(
    /*actorData*/
    i[1].abilities ?? {}
  )), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = Pj(Ij(i, t, n));
  return {
    c() {
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      e = $e();
    },
    m(n, l) {
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(n, l);
      T(n, e, l);
    },
    p(n, [l]) {
      if (l & /*Object, actorData, abilities*/
      6) {
        t = oe(Object.entries(
          /*actorData*/
          n[1].abilities ?? {}
        ));
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = Ij(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = Pj(o), s[r].c(), s[r].m(e.parentNode, e));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    i: ee,
    o: ee,
    d(n) {
      n && S(e), Le(s, n);
    }
  };
}
f(Hpe, "create_fragment$J");
function Upe(i, e, t) {
  let s, n, l = ee, r = /* @__PURE__ */ f(() => (l(), l = Et(o, (u) => t(4, n = u)), o), "$$subscribe_actor");
  i.$$.on_destroy.push(() => l());
  let { actor: o } = e;
  r();
  const a = {}, c = CONFIG.A5E.abilities;
  return i.$$set = (u) => {
    "actor" in u && r(t(0, o = u.actor));
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    16 && t(1, s = n == null ? void 0 : n.system);
  }, [o, s, c, a, n];
}
f(Upe, "instance$D");
const m3 = class m3 extends ie {
  constructor(e) {
    super(), le(this, e, Upe, Hpe, ne, { actor: 0, propData: 3 });
  }
  get propData() {
    return this.$$.ctx[3];
  }
};
f(m3, "PartyViewerAttributesSummary");
let yw = m3;
function Vpe(i) {
  var J, re, ae, be, we, ve, me, he, Ae, Fe, Ve;
  let e, t, s = (
    /*actorData*/
    ((J = i[6]) == null ? void 0 : J.attributes.hp.value) + ""
  ), n, l, r = (
    /*actorData*/
    ((re = i[6]) == null ? void 0 : re.attributes.hp.max) + ""
  ), o, a, c, u, d = (
    /*actorData*/
    ((ae = i[6]) == null ? void 0 : ae.attributes.ac.value) + ""
  ), p, m, g, h = (
    /*actorData*/
    ((be = i[6]) == null ? void 0 : be.attributes.maneuverDC) + ""
  ), _, y, k, v = (
    /*actorData*/
    ((we = i[6]) == null ? void 0 : we.attributes.spellDC) + ""
  ), O, P, D, I = (
    /*actorData*/
    ((me = (ve = i[6]) == null ? void 0 : ve.skills) == null ? void 0 : me.prc.passive) + ""
  ), B, F, H, G = (
    /*actorData*/
    ((Ae = (he = i[6]) == null ? void 0 : he.skills) == null ? void 0 : Ae.ins.passive) + ""
  ), U, q, W, X = (
    /*actorData*/
    ((Ve = (Fe = i[6]) == null ? void 0 : Fe.skills) == null ? void 0 : Ve.inv.passive) + ""
  ), te;
  return {
    c() {
      var je, Pe, rt, Te, Ee, Be;
      e = E("span"), t = E("span"), n = x(s), l = x(" / "), o = x(r), c = R(), u = E("span"), p = x(d), m = R(), g = E("span"), _ = x(h), y = R(), k = E("span"), O = x(v), P = R(), D = E("span"), B = x(I), F = R(), H = E("span"), U = x(G), q = R(), W = E("span"), te = x(X), b(t, "class", "color-blend"), b(e, "class", "field field--hp field--highlight-hp svelte-xfrh6s"), z(
        e,
        "--color-primary-hp-bar",
        /*primaryHPColor*/
        i[3]
      ), z(
        e,
        "--total-hp-percentage",
        /*totalHPPercentage*/
        i[4]
      ), b(e, "data-tooltip", a = /*isBloodied*/
      i[5] ? `${/*$actor*/
      i[2].name} is Bloodied` : null), b(e, "data-tooltip-direction", "UP"), b(u, "class", "field field--ac svelte-xfrh6s"), b(g, "class", "field field--maneuver-dc svelte-xfrh6s"), b(k, "class", "field field--spell-dc svelte-xfrh6s"), b(D, "class", "field field--perception svelte-xfrh6s"), Q(
        D,
        "field--highlight",
        /*actorData*/
        ((Pe = (je = i[6]) == null ? void 0 : je.skills) == null ? void 0 : Pe.prc.passive) === /*propData*/
        i[1].highestPassiveScores.prc
      ), b(H, "class", "field field--insight svelte-xfrh6s"), Q(
        H,
        "field--highlight",
        /*actorData*/
        ((Te = (rt = i[6]) == null ? void 0 : rt.skills) == null ? void 0 : Te.ins.passive) === /*propData*/
        i[1].highestPassiveScores.ins
      ), b(W, "class", "field field--investigation svelte-xfrh6s"), Q(
        W,
        "field--highlight",
        /*actorData*/
        ((Be = (Ee = i[6]) == null ? void 0 : Ee.skills) == null ? void 0 : Be.inv.passive) === /*propData*/
        i[1].highestPassiveScores.inv
      );
    },
    m(je, Pe) {
      T(je, e, Pe), A(e, t), A(t, n), A(t, l), A(t, o), T(je, c, Pe), T(je, u, Pe), A(u, p), T(je, m, Pe), T(je, g, Pe), A(g, _), T(je, y, Pe), T(je, k, Pe), A(k, O), T(je, P, Pe), T(je, D, Pe), A(D, B), T(je, F, Pe), T(je, H, Pe), A(H, U), T(je, q, Pe), T(je, W, Pe), A(W, te);
    },
    p(je, [Pe]) {
      var rt, Te, Ee, Be, Ce, Re, Oe, Je, Xe, Gt, zt, Hi, wl, Ui, St, Xs, $l;
      Pe & /*actorData*/
      64 && s !== (s = /*actorData*/
      ((rt = je[6]) == null ? void 0 : rt.attributes.hp.value) + "") && _e(n, s), Pe & /*actorData*/
      64 && r !== (r = /*actorData*/
      ((Te = je[6]) == null ? void 0 : Te.attributes.hp.max) + "") && _e(o, r), Pe & /*primaryHPColor*/
      8 && z(
        e,
        "--color-primary-hp-bar",
        /*primaryHPColor*/
        je[3]
      ), Pe & /*totalHPPercentage*/
      16 && z(
        e,
        "--total-hp-percentage",
        /*totalHPPercentage*/
        je[4]
      ), Pe & /*isBloodied, $actor*/
      36 && a !== (a = /*isBloodied*/
      je[5] ? `${/*$actor*/
      je[2].name} is Bloodied` : null) && b(e, "data-tooltip", a), Pe & /*actorData*/
      64 && d !== (d = /*actorData*/
      ((Ee = je[6]) == null ? void 0 : Ee.attributes.ac.value) + "") && _e(p, d), Pe & /*actorData*/
      64 && h !== (h = /*actorData*/
      ((Be = je[6]) == null ? void 0 : Be.attributes.maneuverDC) + "") && _e(_, h), Pe & /*actorData*/
      64 && v !== (v = /*actorData*/
      ((Ce = je[6]) == null ? void 0 : Ce.attributes.spellDC) + "") && _e(O, v), Pe & /*actorData*/
      64 && I !== (I = /*actorData*/
      ((Oe = (Re = je[6]) == null ? void 0 : Re.skills) == null ? void 0 : Oe.prc.passive) + "") && _e(B, I), Pe & /*actorData, propData*/
      66 && Q(
        D,
        "field--highlight",
        /*actorData*/
        ((Xe = (Je = je[6]) == null ? void 0 : Je.skills) == null ? void 0 : Xe.prc.passive) === /*propData*/
        je[1].highestPassiveScores.prc
      ), Pe & /*actorData*/
      64 && G !== (G = /*actorData*/
      ((zt = (Gt = je[6]) == null ? void 0 : Gt.skills) == null ? void 0 : zt.ins.passive) + "") && _e(U, G), Pe & /*actorData, propData*/
      66 && Q(
        H,
        "field--highlight",
        /*actorData*/
        ((wl = (Hi = je[6]) == null ? void 0 : Hi.skills) == null ? void 0 : wl.ins.passive) === /*propData*/
        je[1].highestPassiveScores.ins
      ), Pe & /*actorData*/
      64 && X !== (X = /*actorData*/
      ((St = (Ui = je[6]) == null ? void 0 : Ui.skills) == null ? void 0 : St.inv.passive) + "") && _e(te, X), Pe & /*actorData, propData*/
      66 && Q(
        W,
        "field--highlight",
        /*actorData*/
        (($l = (Xs = je[6]) == null ? void 0 : Xs.skills) == null ? void 0 : $l.inv.passive) === /*propData*/
        je[1].highestPassiveScores.inv
      );
    },
    i: ee,
    o: ee,
    d(je) {
      je && (S(e), S(c), S(u), S(m), S(g), S(y), S(k), S(P), S(D), S(F), S(H), S(q), S(W));
    }
  };
}
f(Vpe, "create_fragment$I");
function Wpe(i) {
  return `${i}%`;
}
f(Wpe, "convertToPercentage");
function Kpe(i, e, t) {
  let s, n, l, r, o, a, c = ee, u = /* @__PURE__ */ f(() => (c(), c = Et(d, (h) => t(2, a = h)), d), "$$subscribe_actor");
  i.$$.on_destroy.push(() => c());
  let { actor: d } = e;
  u();
  let { propData: p = {} } = e;
  function m(h) {
    const _ = Math.min(h.value / h.max * 100, 100);
    return `hsl(${Math.round(_)}, 50%, 35%)`;
  }
  f(m, "calculatePrimaryHPColor");
  function g(h) {
    const _ = h.temp || 0;
    return Math.min((h.value + (h.temp || 0)) / (h.max + _) * 100, 100);
  }
  return f(g, "calculateTotalHPPercentage"), i.$$set = (h) => {
    "actor" in h && u(t(0, d = h.actor)), "propData" in h && t(1, p = h.propData);
  }, i.$$.update = () => {
    var h, _, y;
    i.$$.dirty & /*$actor*/
    4 && t(6, s = a == null ? void 0 : a.system), i.$$.dirty & /*$actor*/
    4 && t(5, n = ((h = a == null ? void 0 : a.system) == null ? void 0 : h.attributes.hp.max) / 2 >= ((_ = a == null ? void 0 : a.system) == null ? void 0 : _.attributes.hp.value)), i.$$.dirty & /*$actor*/
    4 && t(7, l = (y = a == null ? void 0 : a.system) == null ? void 0 : y.attributes.hp), i.$$.dirty & /*hp*/
    128 && t(4, r = Wpe(g(l))), i.$$.dirty & /*hp*/
    128 && t(3, o = m(l));
  }, [
    d,
    p,
    a,
    o,
    r,
    n,
    s,
    l
  ];
}
f(Kpe, "instance$C");
const h3 = class h3 extends ie {
  constructor(e) {
    super(), le(this, e, Kpe, Vpe, ne, { actor: 0, propData: 1 });
  }
};
f(h3, "PartyViewerCoreSummary");
let Op = h3;
function Ype(i) {
  let e = K("A5E.None") + "", t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p: ee,
    d(s) {
      s && S(t);
    }
  };
}
f(Ype, "create_else_block$5");
function Xpe(i) {
  let e;
  return {
    c() {
      e = x(
        /*knownLanguages*/
        i[1]
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*knownLanguages*/
      2 && _e(
        e,
        /*knownLanguages*/
        t[1]
      );
    },
    d(t) {
      t && S(e);
    }
  };
}
f(Xpe, "create_if_block$j");
function Jpe(i) {
  let e;
  function t(l, r) {
    return (
      /*knownLanguages*/
      l[1] ? Xpe : Ype
    );
  }
  f(t, "select_block_type");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("span"), n.c(), b(e, "class", "field field--languages svelte-zfmqdk");
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, [r]) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    i: ee,
    o: ee,
    d(l) {
      l && S(e), n.d();
    }
  };
}
f(Jpe, "create_fragment$H");
function Zpe(i, e, t) {
  let s, n, l, r = ee, o = /* @__PURE__ */ f(() => (r(), r = Et(a, (d) => t(4, l = d)), a), "$$subscribe_actor");
  i.$$.on_destroy.push(() => r());
  let { actor: a } = e;
  o();
  const c = {}, { languages: u } = CONFIG.A5E;
  return i.$$set = (d) => {
    "actor" in d && o(t(0, a = d.actor));
  }, i.$$.update = () => {
    var d;
    i.$$.dirty & /*$actor*/
    16 && t(3, s = (l == null ? void 0 : l.system) ?? {}), i.$$.dirty & /*actorData*/
    8 && t(1, n = (((d = s == null ? void 0 : s.proficiencies) == null ? void 0 : d.languages) ?? []).map((p) => u[p] ?? p).sort((p, m) => p.localeCompare(m)).join(", "));
  }, [a, n, c, s, l];
}
f(Zpe, "instance$B");
const g3 = class g3 extends ie {
  constructor(e) {
    super(), le(this, e, Zpe, Jpe, ne, { actor: 0, propData: 2 });
  }
  get propData() {
    return this.$$.ctx[2];
  }
};
f(g3, "PartyViewerLanguagesSummary");
let vw = g3;
function Mj(i, e, t) {
  const s = i.slice();
  return s[8] = e[t][0], s[9] = e[t][1].current, s[10] = e[t][1].max, s;
}
f(Mj, "get_each_context$d");
function Qpe(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = "No resources to display", b(e, "class", "field field--no-resources svelte-cr7hgc");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: ee,
    d(t) {
      t && S(e);
    }
  };
}
f(Qpe, "create_else_block_4");
function xpe(i) {
  let e, t, s, n, l = (
    /*propData*/
    i[1].partyHasInspiration && Rj(i)
  ), r = (
    /*propData*/
    i[1].partyHasExertionPool && Fj(i)
  ), o = (
    /*propData*/
    i[1].partyHasSpellPointPool && Nj(i)
  ), a = (
    /*propData*/
    i[1].highestSpellSlotLevel && jj(i)
  );
  return {
    c() {
      l && l.c(), e = R(), r && r.c(), t = R(), o && o.c(), s = R(), a && a.c(), n = $e();
    },
    m(c, u) {
      l && l.m(c, u), T(c, e, u), r && r.m(c, u), T(c, t, u), o && o.m(c, u), T(c, s, u), a && a.m(c, u), T(c, n, u);
    },
    p(c, u) {
      /*propData*/
      c[1].partyHasInspiration ? l ? l.p(c, u) : (l = Rj(c), l.c(), l.m(e.parentNode, e)) : l && (l.d(1), l = null), /*propData*/
      c[1].partyHasExertionPool ? r ? r.p(c, u) : (r = Fj(c), r.c(), r.m(t.parentNode, t)) : r && (r.d(1), r = null), /*propData*/
      c[1].partyHasSpellPointPool ? o ? o.p(c, u) : (o = Nj(c), o.c(), o.m(s.parentNode, s)) : o && (o.d(1), o = null), /*propData*/
      c[1].highestSpellSlotLevel ? a ? a.p(c, u) : (a = jj(c), a.c(), a.m(n.parentNode, n)) : a && (a.d(1), a = null);
    },
    d(c) {
      c && (S(e), S(t), S(s), S(n)), l && l.d(c), r && r.d(c), o && o.d(c), a && a.d(c);
    }
  };
}
f(xpe, "create_if_block$i");
function Rj(i) {
  let e;
  function t(l, r) {
    var o;
    return (
      /*actorData*/
      (o = l[6]) != null && o.attributes.inspiration ? tme : eme
    );
  }
  f(t, "select_block_type_1");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("span"), n.c(), b(e, "class", "field field--inspiration svelte-cr7hgc");
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    d(l) {
      l && S(e), n.d();
    }
  };
}
f(Rj, "create_if_block_8$2");
function eme(i) {
  let e, t;
  return {
    c() {
      e = E("i"), b(e, "class", "cross fa-solid fa-xmark svelte-cr7hgc"), b(e, "data-tooltip", t = /*$actor*/
      i[2].name + " does not have inspiration."), b(e, "data-tooltip-direction", "UP");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*$actor*/
      4 && t !== (t = /*$actor*/
      s[2].name + " does not have inspiration.") && b(e, "data-tooltip", t);
    },
    d(s) {
      s && S(e);
    }
  };
}
f(eme, "create_else_block_3");
function tme(i) {
  let e, t;
  return {
    c() {
      e = E("i"), b(e, "class", "check fa-solid fa-circle-check svelte-cr7hgc"), b(e, "data-tooltip", t = /*$actor*/
      i[2].name + " has inspiration."), b(e, "data-tooltip-direction", "UP");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*$actor*/
      4 && t !== (t = /*$actor*/
      s[2].name + " has inspiration.") && b(e, "data-tooltip", t);
    },
    d(s) {
      s && S(e);
    }
  };
}
f(tme, "create_if_block_9$2");
function Fj(i) {
  let e;
  function t(l, r) {
    return (
      /*showExertion*/
      l[5] ? nme : sme
    );
  }
  f(t, "select_block_type_2");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("span"), n.c(), b(e, "class", "field field--exertion svelte-cr7hgc");
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    d(l) {
      l && S(e), n.d();
    }
  };
}
f(Fj, "create_if_block_6$2");
function sme(i) {
  let e, t;
  return {
    c() {
      e = E("i"), b(e, "class", "cross fa-solid fa-xmark svelte-cr7hgc"), b(e, "data-tooltip", t = /*$actor*/
      i[2].name + " does not have an exertion pool."), b(e, "data-tooltip-direction", "UP");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*$actor*/
      4 && t !== (t = /*$actor*/
      s[2].name + " does not have an exertion pool.") && b(e, "data-tooltip", t);
    },
    d(s) {
      s && S(e);
    }
  };
}
f(sme, "create_else_block_2");
function nme(i) {
  var r, o, a, c;
  let e = (
    /*actorData*/
    ((o = (r = i[6]) == null ? void 0 : r.attributes.exertion) == null ? void 0 : o.current) + ""
  ), t, s, n = (
    /*actorData*/
    ((c = (a = i[6]) == null ? void 0 : a.attributes.exertion) == null ? void 0 : c.max) + ""
  ), l;
  return {
    c() {
      t = x(e), s = x(" / "), l = x(n);
    },
    m(u, d) {
      T(u, t, d), T(u, s, d), T(u, l, d);
    },
    p(u, d) {
      var p, m, g, h;
      d & /*actorData*/
      64 && e !== (e = /*actorData*/
      ((m = (p = u[6]) == null ? void 0 : p.attributes.exertion) == null ? void 0 : m.current) + "") && _e(t, e), d & /*actorData*/
      64 && n !== (n = /*actorData*/
      ((h = (g = u[6]) == null ? void 0 : g.attributes.exertion) == null ? void 0 : h.max) + "") && _e(l, n);
    },
    d(u) {
      u && (S(t), S(s), S(l));
    }
  };
}
f(nme, "create_if_block_7$2");
function Nj(i) {
  let e;
  function t(l, r) {
    return (
      /*showSpellPoints*/
      l[4] ? lme : ime
    );
  }
  f(t, "select_block_type_3");
  let s = t(i), n = s(i);
  return {
    c() {
      e = E("span"), n.c(), b(e, "class", "field field--spell-points svelte-cr7hgc");
    },
    m(l, r) {
      T(l, e, r), n.m(e, null);
    },
    p(l, r) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e, null)));
    },
    d(l) {
      l && S(e), n.d();
    }
  };
}
f(Nj, "create_if_block_4$3");
function ime(i) {
  let e, t;
  return {
    c() {
      e = E("i"), b(e, "class", "cross fa-solid fa-xmark svelte-cr7hgc"), b(e, "data-tooltip", t = /*$actor*/
      i[2].name + " does not have a spell point pool."), b(e, "data-tooltip-direction", "UP");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*$actor*/
      4 && t !== (t = /*$actor*/
      s[2].name + " does not have a spell point pool.") && b(e, "data-tooltip", t);
    },
    d(s) {
      s && S(e);
    }
  };
}
f(ime, "create_else_block_1$1");
function lme(i) {
  var r, o;
  let e = (
    /*actorData*/
    ((r = i[6]) == null ? void 0 : r.spellResources.points.current) + ""
  ), t, s, n = (
    /*actorData*/
    ((o = i[6]) == null ? void 0 : o.spellResources.points.max) + ""
  ), l;
  return {
    c() {
      t = x(e), s = x(" / "), l = x(n);
    },
    m(a, c) {
      T(a, t, c), T(a, s, c), T(a, l, c);
    },
    p(a, c) {
      var u, d;
      c & /*actorData*/
      64 && e !== (e = /*actorData*/
      ((u = a[6]) == null ? void 0 : u.spellResources.points.current) + "") && _e(t, e), c & /*actorData*/
      64 && n !== (n = /*actorData*/
      ((d = a[6]) == null ? void 0 : d.spellResources.points.max) + "") && _e(l, n);
    },
    d(a) {
      a && (S(t), S(s), S(l));
    }
  };
}
f(lme, "create_if_block_5$3");
function jj(i) {
  var n;
  let e, t = oe(Object.entries(
    /*actorData*/
    ((n = i[6]) == null ? void 0 : n.spellResources.slots) ?? {}
  )), s = [];
  for (let l = 0; l < t.length; l += 1)
    s[l] = Bj(Mj(i, t, l));
  return {
    c() {
      e = E("ol");
      for (let l = 0; l < s.length; l += 1)
        s[l].c();
      b(e, "class", "spell-slots svelte-cr7hgc");
    },
    m(l, r) {
      T(l, e, r);
      for (let o = 0; o < s.length; o += 1)
        s[o] && s[o].m(e, null);
    },
    p(l, r) {
      var o;
      if (r & /*propData, Object, actorData, $actor, spellLevels*/
      198) {
        t = oe(Object.entries(
          /*actorData*/
          ((o = l[6]) == null ? void 0 : o.spellResources.slots) ?? {}
        ));
        let a;
        for (a = 0; a < t.length; a += 1) {
          const c = Mj(l, t, a);
          s[a] ? s[a].p(c, r) : (s[a] = Bj(c), s[a].c(), s[a].m(e, null));
        }
        for (; a < s.length; a += 1)
          s[a].d(1);
        s.length = t.length;
      }
    },
    d(l) {
      l && S(e), Le(s, l);
    }
  };
}
f(jj, "create_if_block_1$d");
function Lj(i) {
  let e, t;
  function s(r, o) {
    return (
      /*max*/
      r[10] && /*max*/
      r[10] > 0 ? ome : rme
    );
  }
  f(s, "select_block_type_4");
  let n = s(i), l = n(i);
  return {
    c() {
      e = E("li"), l.c(), t = R(), b(e, "class", "field field--spell-slot svelte-cr7hgc"), Q(
        e,
        "field--narrow-spell-slot",
        /*propData*/
        i[1].highestSpellSlotLevel >= 8
      );
    },
    m(r, o) {
      T(r, e, o), l.m(e, null), A(e, t);
    },
    p(r, o) {
      n === (n = s(r)) && l ? l.p(r, o) : (l.d(1), l = n(r), l && (l.c(), l.m(e, t))), o & /*propData*/
      2 && Q(
        e,
        "field--narrow-spell-slot",
        /*propData*/
        r[1].highestSpellSlotLevel >= 8
      );
    },
    d(r) {
      r && S(e), l.d();
    }
  };
}
f(Lj, "create_if_block_2$8");
function rme(i) {
  let e, t;
  return {
    c() {
      e = E("i"), b(e, "class", "cross fa-solid fa-xmark svelte-cr7hgc"), b(e, "data-tooltip", t = /*$actor*/
      i[2].name + " has no spell slots of " + K(
        /*spellLevels*/
        i[7][
          /*level*/
          i[8]
        ]
      ).toLowerCase() + "."), b(e, "data-tooltip-direction", "UP");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*$actor, actorData*/
      68 && t !== (t = /*$actor*/
      s[2].name + " has no spell slots of " + K(
        /*spellLevels*/
        s[7][
          /*level*/
          s[8]
        ]
      ).toLowerCase() + ".") && b(e, "data-tooltip", t);
    },
    d(s) {
      s && S(e);
    }
  };
}
f(rme, "create_else_block$4");
function ome(i) {
  let e = (
    /*current*/
    i[9] + ""
  ), t;
  return {
    c() {
      t = x(e);
    },
    m(s, n) {
      T(s, t, n);
    },
    p(s, n) {
      n & /*actorData*/
      64 && e !== (e = /*current*/
      s[9] + "") && _e(t, e);
    },
    d(s) {
      s && S(t);
    }
  };
}
f(ome, "create_if_block_3$4");
function Bj(i) {
  let e, t = (
    /*level*/
    i[8] && /*level*/
    i[8] !== "0" && /*level*/
    i[8] <= /*propData*/
    i[1].highestSpellSlotLevel && Lj(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(s, n) {
      t && t.m(s, n), T(s, e, n);
    },
    p(s, n) {
      /*level*/
      s[8] && /*level*/
      s[8] !== "0" && /*level*/
      s[8] <= /*propData*/
      s[1].highestSpellSlotLevel ? t ? t.p(s, n) : (t = Lj(s), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
    },
    d(s) {
      s && S(e), t && t.d(s);
    }
  };
}
f(Bj, "create_each_block$d");
function ame(i) {
  let e;
  function t(l, r) {
    return (
      /*showResources*/
      l[3] ? xpe : Qpe
    );
  }
  f(t, "select_block_type");
  let s = t(i), n = s(i);
  return {
    c() {
      n.c(), e = $e();
    },
    m(l, r) {
      n.m(l, r), T(l, e, r);
    },
    p(l, [r]) {
      s === (s = t(l)) && n ? n.p(l, r) : (n.d(1), n = s(l), n && (n.c(), n.m(e.parentNode, e)));
    },
    i: ee,
    o: ee,
    d(l) {
      l && S(e), n.d(l);
    }
  };
}
f(ame, "create_fragment$G");
function cme(i) {
  var e, t;
  return (t = (e = i == null ? void 0 : i.system) == null ? void 0 : e.attributes.exertion) == null ? void 0 : t.max;
}
f(cme, "hasExertionPool");
function ume(i) {
  var e, t, s, n, l;
  return !(!((t = (e = i == null ? void 0 : i.flags) == null ? void 0 : e.a5e) != null && t.showSpellPoints) || !((l = (n = (s = i == null ? void 0 : i.system) == null ? void 0 : s.spellResources) == null ? void 0 : n.points) != null && l.max));
}
f(ume, "hasSpellPoints");
function fme(i, e, t) {
  let s, n, l, r, o, a = ee, c = /* @__PURE__ */ f(() => (a(), a = Et(u, (m) => t(2, o = m)), u), "$$subscribe_actor");
  i.$$.on_destroy.push(() => a());
  let { actor: u } = e;
  c();
  let { propData: d = {} } = e;
  const { spellLevels: p } = CONFIG.A5E;
  return i.$$set = (m) => {
    "actor" in m && c(t(0, u = m.actor)), "propData" in m && t(1, d = m.propData);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    4 && t(6, s = o == null ? void 0 : o.system), i.$$.dirty & /*$actor*/
    4 && t(5, n = cme(o)), i.$$.dirty & /*$actor*/
    4 && t(4, l = ume(o)), i.$$.dirty & /*propData*/
    2 && t(3, r = d.partyHasExertionPool || d.partyHasInspiration || d.partyHasSpellPointPool || d.highestSpellSlotLevel);
  }, [
    u,
    d,
    o,
    r,
    l,
    n,
    s,
    p
  ];
}
f(fme, "instance$A");
const b3 = class b3 extends ie {
  constructor(e) {
    super(), le(this, e, fme, ame, ne, { actor: 0, propData: 1 });
  }
};
f(b3, "PartyViewerResourceSummary");
let kw = b3;
function qj(i, e, t) {
  const s = i.slice();
  return s[4] = e[t], s;
}
f(qj, "get_each_context$c");
function Gj(i) {
  var l, r;
  let e, t = (
    /*actorData*/
    ((l = i[1]) != null && l.currency ? (
      /*actorData*/
      (r = i[1]) == null ? void 0 : r.currency[
        /*denomination*/
        i[4]
      ]
    ) : 0) + ""
  ), s, n;
  return {
    c() {
      e = E("span"), s = x(t), n = R(), b(e, "class", "field field--" + /*denomination*/
      i[4] + " svelte-1938tz5");
    },
    m(o, a) {
      T(o, e, a), A(e, s), A(e, n);
    },
    p(o, a) {
      var c, u;
      a & /*actorData*/
      2 && t !== (t = /*actorData*/
      ((c = o[1]) != null && c.currency ? (
        /*actorData*/
        (u = o[1]) == null ? void 0 : u.currency[
          /*denomination*/
          o[4]
        ]
      ) : 0) + "") && _e(s, t);
    },
    d(o) {
      o && S(e);
    }
  };
}
f(Gj, "create_each_block$c");
function dme(i) {
  let e, t = oe(["pp", "gp", "ep", "sp", "cp"]), s = [];
  for (let n = 0; n < 5; n += 1)
    s[n] = Gj(qj(i, t, n));
  return {
    c() {
      for (let n = 0; n < 5; n += 1)
        s[n].c();
      e = $e();
    },
    m(n, l) {
      for (let r = 0; r < 5; r += 1)
        s[r] && s[r].m(n, l);
      T(n, e, l);
    },
    p(n, [l]) {
      if (l & /*actorData*/
      2) {
        t = oe(["pp", "gp", "ep", "sp", "cp"]);
        let r;
        for (r = 0; r < 5; r += 1) {
          const o = qj(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = Gj(o), s[r].c(), s[r].m(e.parentNode, e));
        }
        for (; r < 5; r += 1)
          s[r].d(1);
      }
    },
    i: ee,
    o: ee,
    d(n) {
      n && S(e), Le(s, n);
    }
  };
}
f(dme, "create_fragment$F");
function pme(i, e, t) {
  let s, n, l = ee, r = /* @__PURE__ */ f(() => (l(), l = Et(o, (c) => t(3, n = c)), o), "$$subscribe_actor");
  i.$$.on_destroy.push(() => l());
  let { actor: o } = e;
  r();
  const a = {};
  return i.$$set = (c) => {
    "actor" in c && r(t(0, o = c.actor));
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor*/
    8 && t(1, s = (n == null ? void 0 : n.system) ?? {});
  }, [o, s, a, n];
}
f(pme, "instance$z");
const _3 = class _3 extends ie {
  constructor(e) {
    super(), le(this, e, pme, dme, ne, { actor: 0, propData: 2 });
  }
  get propData() {
    return this.$$.ctx[2];
  }
};
f(_3, "PartyViewerWealthSummary");
let ww = _3;
function zj(i) {
  let e, t, s;
  return {
    c() {
      var n, l;
      e = E("img"), b(e, "class", "actor-image svelte-1taxily"), ze(e.src, t = /*$actor*/
      (n = i[9]) == null ? void 0 : n.img) || b(e, "src", t), b(e, "alt", s = /*$actor*/
      (l = i[9]) == null ? void 0 : l.name);
    },
    m(n, l) {
      T(n, e, l);
    },
    p(n, l) {
      var r, o;
      l & /*$actor*/
      512 && !ze(e.src, t = /*$actor*/
      (r = n[9]) == null ? void 0 : r.img) && b(e, "src", t), l & /*$actor*/
      512 && s !== (s = /*$actor*/
      (o = n[9]) == null ? void 0 : o.name) && b(e, "alt", s);
    },
    d(n) {
      n && S(e);
    }
  };
}
f(zj, "create_if_block_1$c");
function Hj(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("span"), t = E("button"), b(t, "class", "a5e-button a5e-button--delete delete-button fas fa-trash svelte-1taxily"), b(t, "data-tooltip", "Remove Actor from the Party"), b(t, "data-tooltip-direction", "UP"), b(e, "class", "delete-wrapper svelte-1taxily");
    },
    m(l, r) {
      T(l, e, r), A(e, t), s || (n = V(
        t,
        "click",
        /*click_handler*/
        i[14]
      ), s = !0);
    },
    p: ee,
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Hj, "create_if_block$h");
function mme(i) {
  var _;
  let e, t, s, n = (
    /*$actor*/
    ((_ = i[9]) == null ? void 0 : _.name) + ""
  ), l, r, o, a, c, u, d, p = (
    /*$showActorImagesInPartyViewer*/
    i[10] && zj(i)
  );
  var m = (
    /*viewComponent*/
    i[8]
  );
  function g(y, k) {
    return {
      props: {
        actor: (
          /*actor*/
          y[0]
        ),
        propData: {
          highestPassiveScores: (
            /*highestPassiveScores*/
            y[1]
          ),
          highestSpellSlotLevel: (
            /*highestSpellSlotLevel*/
            y[2]
          ),
          partyHasExertionPool: (
            /*partyHasExertionPool*/
            y[3]
          ),
          partyHasInspiration: (
            /*partyHasInspiration*/
            y[4]
          ),
          partyHasSpellPointPool: (
            /*partyHasSpellPointPool*/
            y[5]
          )
        }
      }
    };
  }
  f(g, "switch_props"), m && (o = nt(m, g(i)));
  let h = (
    /*isGM*/
    i[12] && !/*partyIsLocked*/
    i[6] && Hj(i)
  );
  return {
    c() {
      e = E("li"), p && p.c(), t = R(), s = E("span"), l = x(n), r = R(), o && L(o.$$.fragment), a = R(), h && h.c(), b(s, "class", "actor-name svelte-1taxily"), b(e, "class", "a5e-item a5e-item--party-member");
    },
    m(y, k) {
      T(y, e, k), p && p.m(e, null), A(e, t), A(e, s), A(s, l), A(e, r), o && N(o, e, null), A(e, a), h && h.m(e, null), c = !0, u || (d = V(
        e,
        "dblclick",
        /*dblclick_handler*/
        i[15]
      ), u = !0);
    },
    p(y, [k]) {
      var v;
      if (/*$showActorImagesInPartyViewer*/
      y[10] ? p ? p.p(y, k) : (p = zj(y), p.c(), p.m(e, t)) : p && (p.d(1), p = null), (!c || k & /*$actor*/
      512) && n !== (n = /*$actor*/
      ((v = y[9]) == null ? void 0 : v.name) + "") && _e(l, n), k & /*viewComponent*/
      256 && m !== (m = /*viewComponent*/
      y[8])) {
        if (o) {
          ce();
          const O = o;
          C(O.$$.fragment, 1, 0, () => {
            j(O, 1);
          }), ue();
        }
        m ? (o = nt(m, g(y)), L(o.$$.fragment), w(o.$$.fragment, 1), N(o, e, a)) : o = null;
      } else if (m) {
        const O = {};
        k & /*actor*/
        1 && (O.actor = /*actor*/
        y[0]), k & /*highestPassiveScores, highestSpellSlotLevel, partyHasExertionPool, partyHasInspiration, partyHasSpellPointPool*/
        62 && (O.propData = {
          highestPassiveScores: (
            /*highestPassiveScores*/
            y[1]
          ),
          highestSpellSlotLevel: (
            /*highestSpellSlotLevel*/
            y[2]
          ),
          partyHasExertionPool: (
            /*partyHasExertionPool*/
            y[3]
          ),
          partyHasInspiration: (
            /*partyHasInspiration*/
            y[4]
          ),
          partyHasSpellPointPool: (
            /*partyHasSpellPointPool*/
            y[5]
          )
        }), o.$set(O);
      }
      /*isGM*/
      y[12] && !/*partyIsLocked*/
      y[6] ? h ? h.p(y, k) : (h = Hj(y), h.c(), h.m(e, null)) : h && (h.d(1), h = null);
    },
    i(y) {
      c || (o && w(o.$$.fragment, y), c = !0);
    },
    o(y) {
      o && C(o.$$.fragment, y), c = !1;
    },
    d(y) {
      y && S(e), p && p.d(), o && j(o), h && h.d(), u = !1, d();
    }
  };
}
f(mme, "create_fragment$E");
function hme(i, e, t) {
  let s, n, l = ee, r = /* @__PURE__ */ f(() => (l(), l = Et(u, (H) => t(9, n = H)), u), "$$subscribe_actor"), o, a = ee, c = /* @__PURE__ */ f(() => (a(), a = Et(k, (H) => t(10, o = H)), k), "$$subscribe_showActorImagesInPartyViewer");
  i.$$.on_destroy.push(() => l()), i.$$.on_destroy.push(() => a());
  let { actor: u } = e;
  r();
  let { currentViewMode: d = "core" } = e, { highestPassiveScores: p = {} } = e, { highestSpellSlotLevel: m = 0 } = e, { partyHasExertionPool: g = !0 } = e, { partyHasInspiration: h = !1 } = e, { partyHasSpellPointPool: _ = !0 } = e, { partyIsLocked: y = !1 } = e, { showActorImagesInPartyViewer: k = !0 } = e;
  c();
  function v(H) {
    switch (H) {
      case "attributes":
        return yw;
      case "core":
        return Op;
      case "languages":
        return vw;
      case "resources":
        return kw;
      case "wealth":
        return ww;
      default:
        return Op;
    }
  }
  f(v, "getViewModeComponent");
  const O = n.uuid, P = it(), { isGM: D } = game.user, I = u.subscribe((H) => P("actor-updated", O));
  Nt(() => {
    I();
  });
  const B = /* @__PURE__ */ f(() => P("remove-actor", n.uuid), "click_handler"), F = /* @__PURE__ */ f(() => n == null ? void 0 : n.sheet.render(!0), "dblclick_handler");
  return i.$$set = (H) => {
    "actor" in H && r(t(0, u = H.actor)), "currentViewMode" in H && t(13, d = H.currentViewMode), "highestPassiveScores" in H && t(1, p = H.highestPassiveScores), "highestSpellSlotLevel" in H && t(2, m = H.highestSpellSlotLevel), "partyHasExertionPool" in H && t(3, g = H.partyHasExertionPool), "partyHasInspiration" in H && t(4, h = H.partyHasInspiration), "partyHasSpellPointPool" in H && t(5, _ = H.partyHasSpellPointPool), "partyIsLocked" in H && t(6, y = H.partyIsLocked), "showActorImagesInPartyViewer" in H && c(t(7, k = H.showActorImagesInPartyViewer));
  }, i.$$.update = () => {
    i.$$.dirty & /*currentViewMode*/
    8192 && t(8, s = v(d));
  }, [
    u,
    p,
    m,
    g,
    h,
    _,
    y,
    k,
    s,
    n,
    o,
    P,
    D,
    d,
    B,
    F
  ];
}
f(hme, "instance$y");
const y3 = class y3 extends ie {
  constructor(e) {
    super(), le(this, e, hme, mme, ne, {
      actor: 0,
      currentViewMode: 13,
      highestPassiveScores: 1,
      highestSpellSlotLevel: 2,
      partyHasExertionPool: 3,
      partyHasInspiration: 4,
      partyHasSpellPointPool: 5,
      partyIsLocked: 6,
      showActorImagesInPartyViewer: 7
    });
  }
};
f(y3, "PartyViewerActorSummary");
let $w = y3;
function gme(i, e, t) {
  const s = i.slice();
  return s[0] = e[t], s;
}
f(gme, "get_each_context$b");
function bme(i) {
  let e;
  return {
    c() {
      e = E("span"), e.textContent = `${/*attribute*/
      i[0]}`, b(e, "class", "attribute attribute--" + /*attribute*/
      i[0] + " svelte-h7qj1r");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: ee,
    d(t) {
      t && S(e);
    }
  };
}
f(bme, "create_each_block$b");
function _me(i) {
  let e, t = oe(["str", "dex", "con", "int", "wis", "cha"]), s = [];
  for (let n = 0; n < 6; n += 1)
    s[n] = bme(gme(i, t, n));
  return {
    c() {
      e = E("header");
      for (let n = 0; n < 6; n += 1)
        s[n].c();
      b(e, "class", "a5e-section-header a5e-section-header--party-viewer");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < 6; r += 1)
        s[r] && s[r].m(e, null);
    },
    p: ee,
    i: ee,
    o: ee,
    d(n) {
      n && S(e), Le(s, n);
    }
  };
}
f(_me, "create_fragment$D");
const v3 = class v3 extends ie {
  constructor(e) {
    super(), le(this, e, null, _me, ne, {});
  }
};
f(v3, "PartyViewerAttributesHeader");
let Aw = v3;
function yme(i) {
  let e;
  return {
    c() {
      e = E("header"), e.innerHTML = '<i class="heading heading--hp fa-solid fa-heart svelte-1esp7f7" data-tooltip="Hit Points" data-tooltip-direction="UP"></i> <i class="heading heading--ac fa-solid fa-shield svelte-1esp7f7" data-tooltip="Armor Class" data-tooltip-direction="UP"></i> <i class="heading heading--maneuver-dc fa-solid fa-hand-fist svelte-1esp7f7" data-tooltip="Maneuver DC" data-tooltip-direction="UP"></i> <i class="heading heading--spell-dc fa-solid fa-wand-sparkles svelte-1esp7f7" data-tooltip="Spell DC" data-tooltip-direction="UP"></i> <i class="heading heading--perception fa-solid fa-eye svelte-1esp7f7" data-tooltip="Passive Perception" data-tooltip-direction="UP"></i> <i class="heading heading--insight fa-solid fa-brain svelte-1esp7f7" data-tooltip="Passive Insight" data-tooltip-direction="UP"></i> <i class="heading heading--investigation fa-solid fa-magnifying-glass svelte-1esp7f7" data-tooltip="Passive Investigation" data-tooltip-direction="UP"></i>', b(e, "class", "a5e-section-header a5e-section-header--party-viewer");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: ee,
    i: ee,
    o: ee,
    d(t) {
      t && S(e);
    }
  };
}
f(yme, "create_fragment$C");
const k3 = class k3 extends ie {
  constructor(e) {
    super(), le(this, e, null, yme, ne, {});
  }
};
f(k3, "PartyViewerCoreHeader");
let Dp = k3;
function vme(i) {
  let e;
  return {
    c() {
      e = E("header"), e.innerHTML = '<h3 class="heading heading--languages svelte-1lfvj8v" data-tooltip="Known Languages" data-tooltip-direction="UP">Languages</h3>', b(e, "class", "a5e-section-header a5e-section-header--party-viewer");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: ee,
    i: ee,
    o: ee,
    d(t) {
      t && S(e);
    }
  };
}
f(vme, "create_fragment$B");
const w3 = class w3 extends ie {
  constructor(e) {
    super(), le(this, e, null, vme, ne, {});
  }
};
f(w3, "PartyViewerLanguagesHeader");
let Ew = w3;
function Uj(i, e, t) {
  const s = i.slice();
  return s[1] = e[t][0], s[2] = e[t][1], s;
}
f(Uj, "get_each_context$a");
function Vj(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "heading heading--inspiration fa-solid fa-dice-d20 svelte-17pjk8l"), b(e, "data-tooltip", "Inspiration"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(Vj, "create_if_block_3$3");
function Wj(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "heading heading--exertion fa-solid fa-dumbbell svelte-17pjk8l"), b(e, "data-tooltip", "Exertion"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(Wj, "create_if_block_2$7");
function Kj(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "heading heading--spell-points fa-solid fa-hand-sparkles svelte-17pjk8l"), b(e, "data-tooltip", "Spell Points"), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(Kj, "create_if_block_1$b");
function Yj(i) {
  let e, t = oe(Jj(
    /*propData*/
    i[0]
  )), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = Xj(Uj(i, t, n));
  return {
    c() {
      e = E("ol");
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      b(e, "class", "spell-levels svelte-17pjk8l");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l & /*getSpellLevels, propData*/
      1) {
        t = oe(Jj(
          /*propData*/
          n[0]
        ));
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = Uj(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = Xj(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && S(e), Le(s, n);
    }
  };
}
f(Yj, "create_if_block$g");
function Xj(i) {
  let e, t, s = (
    /*spellLevel*/
    i[1] + ""
  ), n, l, r;
  return {
    c() {
      e = E("li"), t = E("span"), n = x(s), l = R(), z(t, "position", "relative"), z(t, "z-index", "1"), b(e, "class", "spell-level svelte-17pjk8l"), b(e, "data-tooltip", r = `${/*tooltip*/
      i[2]} Spell Slots`), b(e, "data-tooltip-direction", "UP"), Q(
        e,
        "spell-level--narrow",
        /*propData*/
        i[0].highestSpellSlotLevel >= 8
      );
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(t, n), A(e, l);
    },
    p(o, a) {
      a & /*propData*/
      1 && s !== (s = /*spellLevel*/
      o[1] + "") && _e(n, s), a & /*propData*/
      1 && r !== (r = `${/*tooltip*/
      o[2]} Spell Slots`) && b(e, "data-tooltip", r), a & /*propData*/
      1 && Q(
        e,
        "spell-level--narrow",
        /*propData*/
        o[0].highestSpellSlotLevel >= 8
      );
    },
    d(o) {
      o && S(e);
    }
  };
}
f(Xj, "create_each_block$a");
function kme(i) {
  let e, t, s, n, l = (
    /*propData*/
    i[0].partyHasInspiration && Vj()
  ), r = (
    /*propData*/
    i[0].partyHasExertionPool && Wj()
  ), o = (
    /*propData*/
    i[0].partyHasSpellPointPool && Kj()
  ), a = (
    /*propData*/
    i[0].highestSpellSlotLevel && Yj(i)
  );
  return {
    c() {
      e = E("header"), l && l.c(), t = R(), r && r.c(), s = R(), o && o.c(), n = R(), a && a.c(), b(e, "class", "a5e-section-header a5e-section-header--party-viewer");
    },
    m(c, u) {
      T(c, e, u), l && l.m(e, null), A(e, t), r && r.m(e, null), A(e, s), o && o.m(e, null), A(e, n), a && a.m(e, null);
    },
    p(c, [u]) {
      /*propData*/
      c[0].partyHasInspiration ? l || (l = Vj(), l.c(), l.m(e, t)) : l && (l.d(1), l = null), /*propData*/
      c[0].partyHasExertionPool ? r || (r = Wj(), r.c(), r.m(e, s)) : r && (r.d(1), r = null), /*propData*/
      c[0].partyHasSpellPointPool ? o || (o = Kj(), o.c(), o.m(e, n)) : o && (o.d(1), o = null), /*propData*/
      c[0].highestSpellSlotLevel ? a ? a.p(c, u) : (a = Yj(c), a.c(), a.m(e, null)) : a && (a.d(1), a = null);
    },
    i: ee,
    o: ee,
    d(c) {
      c && S(e), l && l.d(), r && r.d(), o && o.d(), a && a.d();
    }
  };
}
f(kme, "create_fragment$A");
function Jj({ highestSpellSlotLevel: i }) {
  return Object.entries(CONFIG.A5E.spellLevels).filter(([e]) => e && e !== "0" && e <= i);
}
f(Jj, "getSpellLevels");
function wme(i, e, t) {
  let { propData: s = {} } = e;
  return i.$$set = (n) => {
    "propData" in n && t(0, s = n.propData);
  }, [s];
}
f(wme, "instance$x");
const $3 = class $3 extends ie {
  constructor(e) {
    super(), le(this, e, wme, kme, ne, { propData: 0 });
  }
};
f($3, "PartyViewerResourceHeader");
let Sw = $3;
function $me(i, e, t) {
  const s = i.slice();
  return s[0] = e[t], s;
}
f($me, "get_each_context$9");
function Ame(i) {
  let e;
  return {
    c() {
      e = E("h3"), e.textContent = `${/*denomination*/
      i[0]} `, b(e, "class", "heading heading--" + /*denomination*/
      i[0] + " svelte-xeczqu"), b(e, "data-tooltip", "A5E.effects.keys.currency." + /*denomination*/
      i[0]), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: ee,
    d(t) {
      t && S(e);
    }
  };
}
f(Ame, "create_each_block$9");
function Eme(i) {
  let e, t = oe(["pp", "gp", "ep", "sp", "cp"]), s = [];
  for (let n = 0; n < 5; n += 1)
    s[n] = Ame($me(i, t, n));
  return {
    c() {
      e = E("header");
      for (let n = 0; n < 5; n += 1)
        s[n].c();
      b(e, "class", "a5e-section-header a5e-section-header--party-viewer");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < 5; r += 1)
        s[r] && s[r].m(e, null);
    },
    p: ee,
    i: ee,
    o: ee,
    d(n) {
      n && S(e), Le(s, n);
    }
  };
}
f(Eme, "create_fragment$z");
const A3 = class A3 extends ie {
  constructor(e) {
    super(), le(this, e, null, Eme, ne, {});
  }
};
f(A3, "PartyViewerWealthHeader");
let Tw = A3;
function Zj(i, e, t) {
  const s = i.slice();
  return s[3] = e[t], s;
}
f(Zj, "get_each_context$8");
function Qj(i) {
  let e, t = (
    /*totalPartyWealth*/
    (i[0][
      /*denomination*/
      i[3]
    ] ?? 0) + ""
  ), s, n;
  return {
    c() {
      e = E("span"), s = x(t), n = R(), b(e, "class", "total total--" + /*denomination*/
      i[3] + " svelte-13i9q56");
    },
    m(l, r) {
      T(l, e, r), A(e, s), A(e, n);
    },
    p(l, r) {
      r & /*totalPartyWealth*/
      1 && t !== (t = /*totalPartyWealth*/
      (l[0][
        /*denomination*/
        l[3]
      ] ?? 0) + "") && _e(s, t);
    },
    d(l) {
      l && S(e);
    }
  };
}
f(Qj, "create_each_block$8");
function Sme(i) {
  let e, t, s, n = oe(["pp", "gp", "ep", "sp", "cp"]), l = [];
  for (let r = 0; r < 5; r += 1)
    l[r] = Qj(Zj(i, n, r));
  return {
    c() {
      e = E("footer"), t = E("h3"), t.textContent = "Party Total", s = R();
      for (let r = 0; r < 5; r += 1)
        l[r].c();
      b(t, "class", "heading svelte-13i9q56"), Q(t, "heading--no-actor-image", !/*$showActorImagesInPartyViewer*/
      i[2]), b(e, "class", "wealth-footer svelte-13i9q56");
    },
    m(r, o) {
      T(r, e, o), A(e, t), A(e, s);
      for (let a = 0; a < 5; a += 1)
        l[a] && l[a].m(e, null);
    },
    p(r, [o]) {
      if (o & /*$showActorImagesInPartyViewer*/
      4 && Q(t, "heading--no-actor-image", !/*$showActorImagesInPartyViewer*/
      r[2]), o & /*totalPartyWealth*/
      1) {
        n = oe(["pp", "gp", "ep", "sp", "cp"]);
        let a;
        for (a = 0; a < 5; a += 1) {
          const c = Zj(r, n, a);
          l[a] ? l[a].p(c, o) : (l[a] = Qj(c), l[a].c(), l[a].m(e, null));
        }
        for (; a < 5; a += 1)
          l[a].d(1);
      }
    },
    i: ee,
    o: ee,
    d(r) {
      r && S(e), Le(l, r);
    }
  };
}
f(Sme, "create_fragment$y");
function Tme(i, e, t) {
  let s, n = ee, l = /* @__PURE__ */ f(() => (n(), n = Et(o, (a) => t(2, s = a)), o), "$$subscribe_showActorImagesInPartyViewer");
  i.$$.on_destroy.push(() => n());
  let { totalPartyWealth: r = {} } = e, { showActorImagesInPartyViewer: o = !0 } = e;
  return l(), i.$$set = (a) => {
    "totalPartyWealth" in a && t(0, r = a.totalPartyWealth), "showActorImagesInPartyViewer" in a && l(t(1, o = a.showActorImagesInPartyViewer));
  }, [r, o, s];
}
f(Tme, "instance$w");
const E3 = class E3 extends ie {
  constructor(e) {
    super(), le(this, e, Tme, Sme, ne, {
      totalPartyWealth: 0,
      showActorImagesInPartyViewer: 1
    });
  }
};
f(E3, "PartyViewerWealthFooter");
let Cw = E3;
function xj(i, e, t) {
  const s = i.slice();
  return s[43] = e[t], s;
}
f(xj, "get_each_context$7");
function Cme(i) {
  let e;
  return {
    c() {
      e = E("div"), e.textContent = "Drop actors into this window to populate the party.", b(e, "class", "instructions svelte-nbkq1y");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: ee,
    i: ee,
    o: ee,
    d(t) {
      t && S(e);
    }
  };
}
f(Cme, "create_else_block$3");
function Ome(i) {
  let e, t, s, n, l, r, o, a, c, u;
  e = new bt({
    props: {
      $$slots: { default: [Ime] },
      $$scope: { ctx: i }
    }
  });
  var d = (
    /*getViewModeComponent*/
    i[11](
      /*currentViewMode*/
      i[1]
    )
  );
  function p(y, k) {
    return {
      props: {
        propData: {
          highestSpellSlotLevel: (
            /*highestSpellSlotLevel*/
            y[4]
          ),
          partyHasExertionPool: (
            /*partyHasExertionPool*/
            y[5]
          ),
          partyHasInspiration: (
            /*partyHasInspiration*/
            y[6]
          ),
          partyHasSpellPointPool: (
            /*partyHasSpellPointPool*/
            y[7]
          ),
          partyIsLocked: (
            /*partyIsLocked*/
            y[0]
          ),
          showActorImagesInPartyViewer: (
            /*showActorImagesInPartyViewer*/
            y[20]
          )
        }
      }
    };
  }
  f(p, "switch_props"), d && (n = nt(d, p(i)));
  let m = oe(
    /*$partyMembers*/
    i[2] ?? []
  ), g = [];
  for (let y = 0; y < m.length; y += 1)
    g[y] = eL(xj(i, m, y));
  const h = /* @__PURE__ */ f((y) => C(g[y], 1, 1, () => {
    g[y] = null;
  }), "out");
  let _ = (
    /*currentViewMode*/
    i[1] === "wealth" && tL(i)
  );
  return {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), l = E("div"), n && L(n.$$.fragment), r = R(), o = E("ul");
      for (let y = 0; y < g.length; y += 1)
        g[y].c();
      a = R(), _ && _.c(), c = $e(), z(t, "display", "contents"), z(t, "--background", "none"), z(t, "--gap", "0.75rem"), z(t, "--margin", "0.375rem 0 0.375rem"), z(t, "--padding", "0"), z(t, "--wrap", "no-wrap"), z(l, "display", "contents"), z(
        l,
        "--a5e-section-heading-template-areas",
        /*gridAreaDefinition*/
        i[10]
      ), z(
        l,
        "--a5e-section-heading-template-columns",
        /*gridSizeDefinition*/
        i[9]
      ), b(o, "class", "a5e-item-list a5e-item-list--party");
    },
    m(y, k) {
      T(y, t, k), N(e, t, null), T(y, s, k), T(y, l, k), n && N(n, l, null), T(y, r, k), T(y, o, k);
      for (let v = 0; v < g.length; v += 1)
        g[v] && g[v].m(o, null);
      T(y, a, k), _ && _.m(y, k), T(y, c, k), u = !0;
    },
    p(y, k) {
      const v = {};
      if (k[0] & /*partyIsLocked, currentViewMode*/
      3 | k[1] & /*$$scope*/
      32768 && (v.$$scope = { dirty: k, ctx: y }), e.$set(v), k[0] & /*gridAreaDefinition*/
      1024 && z(
        l,
        "--a5e-section-heading-template-areas",
        /*gridAreaDefinition*/
        y[10]
      ), k[0] & /*gridSizeDefinition*/
      512 && z(
        l,
        "--a5e-section-heading-template-columns",
        /*gridSizeDefinition*/
        y[9]
      ), k[0] & /*currentViewMode*/
      2 && d !== (d = /*getViewModeComponent*/
      y[11](
        /*currentViewMode*/
        y[1]
      ))) {
        if (n) {
          ce();
          const O = n;
          C(O.$$.fragment, 1, 0, () => {
            j(O, 1), S(l);
          }), ue();
        }
        d ? (T(r.parentNode, l, r), n = nt(d, p(y)), L(n.$$.fragment), w(n.$$.fragment, 1), N(n, l, null)) : n = null;
      } else if (d) {
        const O = {};
        k[0] & /*highestSpellSlotLevel, partyHasExertionPool, partyHasInspiration, partyHasSpellPointPool, partyIsLocked*/
        241 && (O.propData = {
          highestSpellSlotLevel: (
            /*highestSpellSlotLevel*/
            y[4]
          ),
          partyHasExertionPool: (
            /*partyHasExertionPool*/
            y[5]
          ),
          partyHasInspiration: (
            /*partyHasInspiration*/
            y[6]
          ),
          partyHasSpellPointPool: (
            /*partyHasSpellPointPool*/
            y[7]
          ),
          partyIsLocked: (
            /*partyIsLocked*/
            y[0]
          ),
          showActorImagesInPartyViewer: (
            /*showActorImagesInPartyViewer*/
            y[20]
          )
        }), n.$set(O);
      }
      if (k[0] & /*$partyMembers, currentViewMode, highestPassiveScores, highestSpellSlotLevel, partyHasExertionPool, partyHasInspiration, partyHasSpellPointPool, partyIsLocked, showActorImagesInPartyViewer, updatePartyData, removeActorFromParty, gridAreaDefinition, gridSizeDefinition*/
      1091327) {
        m = oe(
          /*$partyMembers*/
          y[2] ?? []
        );
        let O;
        for (O = 0; O < m.length; O += 1) {
          const P = xj(y, m, O);
          g[O] ? (g[O].p(P, k), w(g[O], 1)) : (g[O] = eL(P), g[O].c(), w(g[O], 1), g[O].m(o, null));
        }
        for (ce(), O = m.length; O < g.length; O += 1)
          h(O);
        ue();
      }
      /*currentViewMode*/
      y[1] === "wealth" ? _ ? (_.p(y, k), k[0] & /*currentViewMode*/
      2 && w(_, 1)) : (_ = tL(y), _.c(), w(_, 1), _.m(c.parentNode, c)) : _ && (ce(), C(_, 1, 1, () => {
        _ = null;
      }), ue());
    },
    i(y) {
      if (!u) {
        w(e.$$.fragment, y), n && w(n.$$.fragment, y);
        for (let k = 0; k < m.length; k += 1)
          w(g[k]);
        w(_), u = !0;
      }
    },
    o(y) {
      C(e.$$.fragment, y), n && C(n.$$.fragment, y), g = g.filter(Boolean);
      for (let k = 0; k < g.length; k += 1)
        C(g[k]);
      C(_), u = !1;
    },
    d(y) {
      y && (S(s), S(r), S(o), S(a), S(c)), y && e && S(t), j(e, y), y && n && S(l), n && j(n, y), Le(g, y), _ && _.d(y);
    }
  };
}
f(Ome, "create_if_block$f");
function Dme(i) {
  let e, t, s, n, l;
  return {
    c() {
      e = E("button"), b(e, "class", t = "sheet-lock fas " + /*partyIsLocked*/
      (i[0] ? "sheet-lock--locked fa-lock" : "fa-unlock") + " svelte-nbkq1y"), b(e, "data-tooltip", s = /*partyIsLocked*/
      i[0] ? "Unlock this party" : "Lock this party"), b(e, "data-tooltip-direction", "UP");
    },
    m(r, o) {
      T(r, e, o), n || (l = V(
        e,
        "click",
        /*togglePartyLock*/
        i[14]
      ), n = !0);
    },
    p(r, o) {
      o[0] & /*partyIsLocked*/
      1 && t !== (t = "sheet-lock fas " + /*partyIsLocked*/
      (r[0] ? "sheet-lock--locked fa-lock" : "fa-unlock") + " svelte-nbkq1y") && b(e, "class", t), o[0] & /*partyIsLocked*/
      1 && s !== (s = /*partyIsLocked*/
      r[0] ? "Unlock this party" : "Lock this party") && b(e, "data-tooltip", s);
    },
    d(r) {
      r && S(e), n = !1, l();
    }
  };
}
f(Dme, "create_if_block_2$6");
function Ime(i) {
  let e, t, s, n, l;
  e = new Ye({
    props: {
      allowDeselect: !1,
      options: (
        /*viewModes*/
        i[16]
      ),
      selected: (
        /*currentViewMode*/
        i[1]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[25]
  );
  let r = (
    /*isGM*/
    i[21] && Dme(i)
  );
  return {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), r && r.c(), n = $e(), z(t, "display", "contents"), z(t, "--radio-group-width", "fit-content");
    },
    m(o, a) {
      T(o, t, a), N(e, t, null), T(o, s, a), r && r.m(o, a), T(o, n, a), l = !0;
    },
    p(o, a) {
      const c = {};
      a[0] & /*currentViewMode*/
      2 && (c.selected = /*currentViewMode*/
      o[1]), e.$set(c), /*isGM*/
      o[21] && r.p(o, a);
    },
    i(o) {
      l || (w(e.$$.fragment, o), l = !0);
    },
    o(o) {
      C(e.$$.fragment, o), l = !1;
    },
    d(o) {
      o && (S(s), S(n)), o && e && S(t), j(e, o), r && r.d(o);
    }
  };
}
f(Ime, "create_default_slot$g");
function eL(i) {
  let e, t, s;
  return e = new $w({
    props: {
      actor: (
        /*actor*/
        i[43]
      ),
      currentViewMode: (
        /*currentViewMode*/
        i[1]
      ),
      highestPassiveScores: (
        /*highestPassiveScores*/
        i[3]
      ),
      highestSpellSlotLevel: (
        /*highestSpellSlotLevel*/
        i[4]
      ),
      partyHasExertionPool: (
        /*partyHasExertionPool*/
        i[5]
      ),
      partyHasInspiration: (
        /*partyHasInspiration*/
        i[6]
      ),
      partyHasSpellPointPool: (
        /*partyHasSpellPointPool*/
        i[7]
      ),
      partyIsLocked: (
        /*partyIsLocked*/
        i[0]
      ),
      showActorImagesInPartyViewer: (
        /*showActorImagesInPartyViewer*/
        i[20]
      )
    }
  }), e.$on(
    "actor-updated",
    /*actor_updated_handler*/
    i[26]
  ), e.$on(
    "remove-actor",
    /*remove_actor_handler*/
    i[27]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(
        t,
        "--grid-areas",
        /*gridAreaDefinition*/
        i[10]
      ), z(
        t,
        "--grid-template",
        /*gridSizeDefinition*/
        i[9]
      );
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      l[0] & /*gridAreaDefinition*/
      1024 && z(
        t,
        "--grid-areas",
        /*gridAreaDefinition*/
        n[10]
      ), l[0] & /*gridSizeDefinition*/
      512 && z(
        t,
        "--grid-template",
        /*gridSizeDefinition*/
        n[9]
      );
      const r = {};
      l[0] & /*$partyMembers*/
      4 && (r.actor = /*actor*/
      n[43]), l[0] & /*currentViewMode*/
      2 && (r.currentViewMode = /*currentViewMode*/
      n[1]), l[0] & /*highestPassiveScores*/
      8 && (r.highestPassiveScores = /*highestPassiveScores*/
      n[3]), l[0] & /*highestSpellSlotLevel*/
      16 && (r.highestSpellSlotLevel = /*highestSpellSlotLevel*/
      n[4]), l[0] & /*partyHasExertionPool*/
      32 && (r.partyHasExertionPool = /*partyHasExertionPool*/
      n[5]), l[0] & /*partyHasInspiration*/
      64 && (r.partyHasInspiration = /*partyHasInspiration*/
      n[6]), l[0] & /*partyHasSpellPointPool*/
      128 && (r.partyHasSpellPointPool = /*partyHasSpellPointPool*/
      n[7]), l[0] & /*partyIsLocked*/
      1 && (r.partyIsLocked = /*partyIsLocked*/
      n[0]), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(eL, "create_each_block$7");
function tL(i) {
  let e, t, s, n;
  return t = new Cw({
    props: {
      partyIsLocked: (
        /*partyIsLocked*/
        i[0]
      ),
      totalPartyWealth: (
        /*totalPartyWealth*/
        i[8]
      ),
      showActorImagesInPartyViewer: (
        /*showActorImagesInPartyViewer*/
        i[20]
      )
    }
  }), {
    c() {
      e = E("footer"), s = E("div"), L(t.$$.fragment), z(s, "display", "contents"), z(
        s,
        "--grid-areas",
        /*gridAreaDefinition*/
        i[10]
      ), z(
        s,
        "--grid-template",
        /*gridSizeDefinition*/
        i[9]
      );
    },
    m(l, r) {
      T(l, e, r), A(e, s), N(t, s, null), n = !0;
    },
    p(l, r) {
      r[0] & /*gridAreaDefinition*/
      1024 && z(
        s,
        "--grid-areas",
        /*gridAreaDefinition*/
        l[10]
      ), r[0] & /*gridSizeDefinition*/
      512 && z(
        s,
        "--grid-template",
        /*gridSizeDefinition*/
        l[9]
      );
      const o = {};
      r[0] & /*partyIsLocked*/
      1 && (o.partyIsLocked = /*partyIsLocked*/
      l[0]), r[0] & /*totalPartyWealth*/
      256 && (o.totalPartyWealth = /*totalPartyWealth*/
      l[8]), t.$set(o);
    },
    i(l) {
      n || (w(t.$$.fragment, l), n = !0);
    },
    o(l) {
      C(t.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(e), j(t);
    }
  };
}
f(tL, "create_if_block_1$a");
function Pme(i) {
  let e, t, s, n, l, r;
  const o = [Ome, Cme], a = [];
  function c(u, d) {
    return (
      /*$partyMembers*/
      u[2].length ? 0 : 1
    );
  }
  return f(c, "select_block_type"), t = c(i), s = a[t] = o[t](i), {
    c() {
      e = E("article"), s.c(), b(e, "class", "svelte-nbkq1y");
    },
    m(u, d) {
      T(u, e, d), a[t].m(e, null), n = !0, l || (r = V(
        e,
        "drop",
        /*drop_handler*/
        i[28]
      ), l = !0);
    },
    p(u, d) {
      let p = t;
      t = c(u), t === p ? a[t].p(u, d) : (ce(), C(a[p], 1, 1, () => {
        a[p] = null;
      }), ue(), s = a[t], s ? s.p(u, d) : (s = a[t] = o[t](u), s.c()), w(s, 1), s.m(e, null));
    },
    i(u) {
      n || (w(s), n = !0);
    },
    o(u) {
      C(s), n = !1;
    },
    d(u) {
      u && S(e), a[t].d(), l = !1, r();
    }
  };
}
f(Pme, "create_fragment$x");
function Mme(i, e) {
  return i.length ? e.isLocked ?? !1 : !1;
}
f(Mme, "getIsLocked");
function Rme(i, e, t) {
  let s, n, l, r, o, a, c, u, { settings: d, sheet: p } = fe("#external").application, { settings: m = d, sheet: g = p } = e;
  function h() {
    return (a ?? []).some((Ee) => {
      var Ce, Re, Oe;
      const Be = fn(Ee);
      return (Oe = (Re = (Ce = Be == null ? void 0 : Be.system) == null ? void 0 : Ce.attributes) == null ? void 0 : Re.exertion) == null ? void 0 : Oe.max;
    });
  }
  f(h, "getAnyMemberHasExertionPool");
  function _() {
    return (a ?? []).some((Ee) => {
      var Ce, Re;
      const Be = fn(Ee);
      return (Re = (Ce = Be == null ? void 0 : Be.system) == null ? void 0 : Ce.attributes) == null ? void 0 : Re.inspiration;
    });
  }
  f(_, "getAnyMemberHasInspiration");
  function y() {
    return (a ?? []).some((Ee) => {
      var Ce, Re, Oe;
      const Be = fn(Ee);
      return (Oe = (Re = (Ce = Be == null ? void 0 : Be.system) == null ? void 0 : Ce.spellResources) == null ? void 0 : Re.points) == null ? void 0 : Oe.max;
    });
  }
  f(y, "getAnyMemberHasSpellPointPool");
  function k(Ee) {
    let Be;
    u ? Be = "img name" : Be = "name";
    const Ce = game.user.isGM && !n ? "delete" : "";
    switch (Ee) {
      case "attributes":
        return `"${Be} str dex con int wis cha ${Ce}"`;
      case "core":
        return `"${Be} hp ac maneuverDC spellDC perception insight investigation ${Ce}"`;
      case "languages":
        return `"${Be} languages ${Ce}"`;
      case "resources":
        return v();
      case "wealth":
        return `"${Be} pp gp ep sp cp ${Ce}"`;
      default:
        return `"${Be} hp ac maneuverDC spellDC perception insight investigation ${Ce}"`;
    }
  }
  f(k, "getGridAreaDefinition");
  function v() {
    const Ee = [];
    return u ? Ee.push("img", "name") : Ee.push("name"), ve && Ee.push("inspiration"), we && Ee.push("exertion"), me && Ee.push("spellPoints"), be && Ee.push("spellSlots"), !we && !me && !be && Ee.push("noResources"), game.user.isGM && !n && Ee.push("delete"), `"${Ee.join(" ")}"`;
  }
  f(v, "getResourcePanelGridAreaDefinition");
  function O(Ee) {
    let Be;
    u ? Be = "1.75rem 1fr" : Be = "1fr";
    const Ce = game.user.isGM && !n ? "2rem" : "";
    switch (Ee) {
      case "attributes":
        return `${Be} repeat(6, 0.5fr) ${Ce}`;
      case "core":
        return `${Be} 4rem repeat(6, 3rem) ${Ce}`;
      case "languages":
        return `${Be} 2.5fr ${Ce}`;
      case "resources":
        return P();
      case "wealth":
        return `${Be} repeat(5, 3.5rem) ${Ce}`;
      default:
        return `${Be} 4rem repeat(6, 3rem) ${Ce}`;
    }
  }
  f(O, "getGridSizeDefinition");
  function P() {
    const Ee = [];
    u ? Ee.push("1.75rem", "1fr") : Ee.push("1fr");
    let Be = "1.75rem", Ce = "3.5rem";
    return be >= 8 && (Be = "1.5rem", Ce = "3.25rem"), ve && Ee.push(Be), we && Ee.push(Ce), me && Ee.push(Ce), be && Ee.push("min-content"), !we && !me && !be && Ee.push("1fr"), game.user.isGM && !n && Ee.push("2rem"), Ee.join(" ");
  }
  f(P, "getResourcePanelGridSizeDefinition");
  function D(Ee) {
    switch (Ee) {
      case "attributes":
        return Aw;
      case "core":
        return Dp;
      case "languages":
        return Ew;
      case "resources":
        return Sw;
      case "wealth":
        return Tw;
      default:
        return Dp;
    }
  }
  f(D, "getViewModeComponent");
  function I() {
    return (a ?? []).reduce(
      (Ee, Be) => {
        var Re;
        const Ce = fn(Be);
        return Object.entries(((Re = Ce == null ? void 0 : Ce.system) == null ? void 0 : Re.skills) ?? {}).forEach(([Oe, { passive: Je }]) => {
          Ee[Oe] ?? (Ee[Oe] = 0), Je > Ee[Oe] && (Ee[Oe] = Je);
        }), Ee;
      },
      {}
    );
  }
  f(I, "getHighestPassiveScoresForParty");
  function B() {
    return (a ?? []).reduce(
      (Ee, Be) => {
        var Re, Oe;
        const Ce = fn(Be);
        return Object.entries(((Oe = (Re = Ce == null ? void 0 : Ce.system) == null ? void 0 : Re.spellResources) == null ? void 0 : Oe.slots) ?? {}).forEach(([Je, { max: Xe }]) => {
          Je > Ee && Xe && Xe > 0 && (Ee = Je);
        }), Ee;
      },
      0
    );
  }
  f(B, "getHighestSpellSlotLevel");
  function F() {
    return (a ?? []).reduce(
      (Ee, Be) => {
        var Oe;
        const Ce = fn(Be), Re = (Oe = Ce == null ? void 0 : Ce.system) == null ? void 0 : Oe.currency;
        return Ee.cp += (Re == null ? void 0 : Re.cp) ?? 0, Ee.sp += (Re == null ? void 0 : Re.sp) ?? 0, Ee.ep += (Re == null ? void 0 : Re.ep) ?? 0, Ee.gp += (Re == null ? void 0 : Re.gp) ?? 0, Ee.pp += (Re == null ? void 0 : Re.pp) ?? 0, Ee;
      },
      { cp: 0, sp: 0, ep: 0, gp: 0, pp: 0 }
    );
  }
  f(F, "getTotalPartyWealth");
  async function H(Ee) {
    if (!game.user.isGM) {
      ui.notifications.warn("You do not have permission to edit this party.");
      return;
    }
    try {
      const { uuid: Be } = JSON.parse(Ee.dataTransfer.getData("text/plain")), Ce = await fromUuid(Be);
      (Ce == null ? void 0 : Ce.documentName) === "Actor" && G(Be);
    } catch (Be) {
      console.error(Be);
    }
  }
  f(H, "onDropDocument");
  async function G(Ee) {
    var Be, Ce, Re;
    if (n) {
      ui.notifications.warn("This party is locked.");
      return;
    }
    if ((Be = o == null ? void 0 : o.actors) != null && Be.length) {
      if ((Ce = o.actors) != null && Ce.includes(Ee))
        return;
      (Re = o.actors) == null || Re.push(Ee), await game.settings.set("a5e", "parties", c);
    } else
      await game.settings.set("a5e", "parties", {
        [foundry.utils.randomID()]: {
          name: "New Party",
          actors: [Ee],
          isLocked: !1
        }
      });
  }
  f(G, "onDropActor");
  async function U(Ee) {
    const { actors: Be } = o, Ce = Be.indexOf(Ee);
    Ce !== -1 && (Be.splice(Ce, 1), await game.settings.set("a5e", "parties", c));
  }
  f(U, "removeActorFromParty");
  async function q() {
    var Be;
    const Ee = Object.entries(c ?? {}).map(([Ce, Re]) => ({
      id: Ce,
      label: Re.name || "New Party",
      actors: Re.actors ?? [],
      isLocked: Re.isLocked ?? !1
    }));
    if (Ee.length) {
      const Ce = c[(Be = Ee[0]) == null ? void 0 : Be.id];
      Ce.isLocked = !(Ce != null && Ce.isLocked), await game.settings.set("a5e", "parties", c);
    }
  }
  f(q, "togglePartyLock");
  function W(Ee) {
    fromUuidSync(Ee) || U(Ee), t(3, ae = I()), t(4, be = B()), t(5, we = h()), t(6, ve = _()), t(7, me = y()), t(8, he = F()), t(10, l = k(s)), t(9, r = O(s));
  }
  f(W, "updatePartyData");
  const X = [
    ["core", "Core"],
    ["attributes", "Attributes"],
    ["resources", "Resources"],
    ["languages", "Languages"],
    ["wealth", "Wealth"]
  ];
  let te = m.getStore("parties");
  pe(i, te, (Ee) => t(29, c = Ee));
  let J = wc(te, (Ee) => {
    var Ce;
    const Be = Object.entries(Ee ?? {}).map(([Re, Oe]) => ({
      id: Re,
      label: Oe.name || "New Party",
      actors: Oe.actors ?? [],
      isLocked: Oe.isLocked ?? !1
    }));
    return Be.length ? Ee[(Ce = Be[0]) == null ? void 0 : Ce.id] : {};
  });
  pe(i, J, (Ee) => t(24, o = Ee));
  let re = wc(J, (Ee) => ((Ee == null ? void 0 : Ee.actors) ?? []).reduce(
    (Be, Ce) => {
      const Re = fromUuidSync(Ce);
      if (Re) {
        const Oe = new Bt(Re);
        Be.push(Oe);
      }
      return Be;
    },
    []
  ));
  pe(i, re, (Ee) => t(2, a = Ee));
  let ae = I(), be = B(), we = h(), ve = _(), me = y(), he = F();
  const Ae = m.getStore("showActorImagesInPartyViewer");
  pe(i, Ae, (Ee) => t(30, u = Ee));
  const Fe = re.subscribe((Ee) => {
    t(3, ae = I()), t(4, be = B()), t(5, we = h()), t(6, ve = _()), t(7, me = y()), t(8, he = F()), t(10, l = k(s)), t(9, r = O(s));
  }), { isGM: Ve } = game.user;
  Nt(() => {
    Fe();
  });
  const je = /* @__PURE__ */ f((Ee) => t(1, s = Ee.detail), "updateSelection_handler"), Pe = /* @__PURE__ */ f(({ detail: Ee }) => W(Ee), "actor_updated_handler"), rt = /* @__PURE__ */ f(({ detail: Ee }) => U(Ee), "remove_actor_handler"), Te = /* @__PURE__ */ f((Ee) => H(Ee), "drop_handler");
  return i.$$set = (Ee) => {
    "settings" in Ee && t(22, m = Ee.settings), "sheet" in Ee && t(23, g = Ee.sheet);
  }, i.$$.update = () => {
    i.$$.dirty[0] & /*$partyMembers, $currentParty*/
    16777220 && t(0, n = Mme(a, o)), i.$$.dirty[0] & /*currentViewMode, partyIsLocked*/
    3 && t(10, l = k(s)), i.$$.dirty[0] & /*currentViewMode, partyIsLocked*/
    3 && t(9, r = O(s));
  }, t(1, s = X[0][0]), [
    n,
    s,
    a,
    ae,
    be,
    we,
    ve,
    me,
    he,
    r,
    l,
    D,
    H,
    U,
    q,
    W,
    X,
    te,
    J,
    re,
    Ae,
    Ve,
    m,
    g,
    o,
    je,
    Pe,
    rt,
    Te
  ];
}
f(Rme, "instance$v");
var bf;
let Fme = (bf = class extends ie {
  constructor(e) {
    super(), le(this, e, Rme, Pme, ne, { settings: 22, sheet: 23 }, null, [-1, -1]);
  }
}, f(bf, "PartyViewer"), bf);
const S3 = class S3 extends Fs {
  constructor() {
    super({
      title: K("Party Viewer"),
      content: {
        class: Fme,
        props: {
          settings: Aa
        }
      },
      resizable: !0,
      zIndex: null
    }, {
      classes: ["a5e-sheet", "a5e-sheet--party-viewer"],
      width: 672
    }), this.data.content.props.sheet = this;
  }
  close() {
    game.a5e.dialogs.partyViewer = null, super.close();
  }
};
f(S3, "PartyViewer");
let Ow = S3;
function bq(i = !1) {
  var e, t, s, n;
  if (i && ((e = game.a5e.dialogs.partyViewer) != null && e.rendered)) {
    (s = (t = game.a5e.dialogs) == null ? void 0 : t.partyViewer) == null || s.close();
    return;
  }
  (n = game.a5e.dialogs).partyViewer ?? (n.partyViewer = new Ow()), game.a5e.dialogs.partyViewer.render(!0);
}
f(bq, "renderPartyViewer");
function Nme(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.5eStyleDeathSaves",
      checked: (
        /*updates*/
        i[11].get("5eStyleDeathSaves") ?? /*$deathSaves*/
        i[1] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[22]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$deathSaves*/
      2 && (l.checked = /*updates*/
      s[11].get("5eStyleDeathSaves") ?? /*$deathSaves*/
      s[1] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Nme, "create_default_slot_11$2");
function jme(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.5eStyleExpertise",
      checked: (
        /*updates*/
        i[11].get("5eStyleExpertise") ?? /*$expertise*/
        i[2] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[23]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$expertise*/
      4 && (l.checked = /*updates*/
      s[11].get("5eStyleExpertise") ?? /*$expertise*/
      s[2] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(jme, "create_default_slot_10$2");
function Lme(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.hideA5eSkills",
      checked: (
        /*updates*/
        i[11].get("hideA5eSkills") ?? /*$hideA5eSkills*/
        i[3] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[24]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$hideA5eSkills*/
      8 && (l.checked = /*updates*/
      s[11].get("hideA5eSkills") ?? /*$hideA5eSkills*/
      s[3] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Lme, "create_default_slot_9$2");
function Bme(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.hideExpertiseDice",
      checked: (
        /*updates*/
        i[11].get("hideExpertiseDice") ?? /*$hideExpertiseDice*/
        i[4] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[25]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$hideExpertiseDice*/
      16 && (l.checked = /*updates*/
      s[11].get("hideExpertiseDice") ?? /*$hideExpertiseDice*/
      s[4] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Bme, "create_default_slot_8$2");
function qme(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.hideSkillCriticalPrompt",
      checked: (
        /*updates*/
        i[11].get("hideSkillCriticalPrompt") ?? /*$hideSkillCriticalPrompt*/
        i[5] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[26]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$hideSkillCriticalPrompt*/
      32 && (l.checked = /*updates*/
      s[11].get("hideSkillCriticalPrompt") ?? /*$hideSkillCriticalPrompt*/
      s[5] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(qme, "create_default_slot_7$3");
function Gme(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.hideSkillSpecialties",
      checked: (
        /*updates*/
        i[11].get("hideSkillSpecialties") ?? /*$hideSkillSpecialties*/
        i[6] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[27]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$hideSkillSpecialties*/
      64 && (l.checked = /*updates*/
      s[11].get("hideSkillSpecialties") ?? /*$hideSkillSpecialties*/
      s[6] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Gme, "create_default_slot_6$3");
function zme(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.replaceFatigueAndStrife",
      checked: (
        /*updates*/
        i[11].get("replaceFatigueAndStrife") ?? /*$exhaustion*/
        i[7] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_6*/
    i[28]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$exhaustion*/
      128 && (l.checked = /*updates*/
      s[11].get("replaceFatigueAndStrife") ?? /*$exhaustion*/
      s[7] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(zme, "create_default_slot_5$4");
function Hme(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.simpleInitiative",
      checked: (
        /*updates*/
        i[11].get("simpleInitiative") ?? /*$simpleInitiative*/
        i[8] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_7*/
    i[29]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$simpleInitiative*/
      256 && (l.checked = /*updates*/
      s[11].get("simpleInitiative") ?? /*$simpleInitiative*/
      s[8] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Hme, "create_default_slot_4$5");
function Ume(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.simpleRests",
      checked: (
        /*updates*/
        i[11].get("simpleRests") ?? /*$simpleRests*/
        i[9] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_8*/
    i[30]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$simpleRests*/
      512 && (l.checked = /*updates*/
      s[11].get("simpleRests") ?? /*$simpleRests*/
      s[9] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Ume, "create_default_slot_3$6");
function Vme(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k;
  return e = new de({
    props: {
      hint: "A5E.settings.hints.5eStyleDeathSaves",
      $$slots: { default: [Nme] },
      $$scope: { ctx: i }
    }
  }), s = new de({
    props: {
      hint: "A5E.settings.hints.5eStyleExpertise",
      $$slots: { default: [jme] },
      $$scope: { ctx: i }
    }
  }), l = new de({
    props: {
      hint: "A5E.settings.hints.hideA5eSkills",
      $$slots: { default: [Lme] },
      $$scope: { ctx: i }
    }
  }), o = new de({
    props: {
      hint: "A5E.settings.hints.hideExpertiseDice",
      $$slots: { default: [Bme] },
      $$scope: { ctx: i }
    }
  }), c = new de({
    props: {
      hint: "A5E.settings.hints.hideSkillCriticalPrompt",
      $$slots: { default: [qme] },
      $$scope: { ctx: i }
    }
  }), d = new de({
    props: {
      hint: "A5E.settings.hints.hideSkillSpecialties",
      $$slots: { default: [Gme] },
      $$scope: { ctx: i }
    }
  }), m = new de({
    props: {
      hint: "A5E.settings.hints.replaceFatigueAndStrife",
      $$slots: { default: [zme] },
      $$scope: { ctx: i }
    }
  }), h = new de({
    props: {
      hint: "A5E.settings.hints.simpleInitiative",
      $$slots: { default: [Hme] },
      $$scope: { ctx: i }
    }
  }), y = new de({
    props: {
      hint: "A5E.settings.hints.simpleRests",
      $$slots: { default: [Ume] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment), r = R(), L(o.$$.fragment), a = R(), L(c.$$.fragment), u = R(), L(d.$$.fragment), p = R(), L(m.$$.fragment), g = R(), L(h.$$.fragment), _ = R(), L(y.$$.fragment);
    },
    m(v, O) {
      N(e, v, O), T(v, t, O), N(s, v, O), T(v, n, O), N(l, v, O), T(v, r, O), N(o, v, O), T(v, a, O), N(c, v, O), T(v, u, O), N(d, v, O), T(v, p, O), N(m, v, O), T(v, g, O), N(h, v, O), T(v, _, O), N(y, v, O), k = !0;
    },
    p(v, O) {
      const P = {};
      O[0] & /*$deathSaves*/
      2 | O[1] & /*$$scope*/
      4 && (P.$$scope = { dirty: O, ctx: v }), e.$set(P);
      const D = {};
      O[0] & /*$expertise, reload*/
      5 | O[1] & /*$$scope*/
      4 && (D.$$scope = { dirty: O, ctx: v }), s.$set(D);
      const I = {};
      O[0] & /*$hideA5eSkills, reload*/
      9 | O[1] & /*$$scope*/
      4 && (I.$$scope = { dirty: O, ctx: v }), l.$set(I);
      const B = {};
      O[0] & /*$hideExpertiseDice, reload*/
      17 | O[1] & /*$$scope*/
      4 && (B.$$scope = { dirty: O, ctx: v }), o.$set(B);
      const F = {};
      O[0] & /*$hideSkillCriticalPrompt, reload*/
      33 | O[1] & /*$$scope*/
      4 && (F.$$scope = { dirty: O, ctx: v }), c.$set(F);
      const H = {};
      O[0] & /*$hideSkillSpecialties, reload*/
      65 | O[1] & /*$$scope*/
      4 && (H.$$scope = { dirty: O, ctx: v }), d.$set(H);
      const G = {};
      O[0] & /*$exhaustion, reload*/
      129 | O[1] & /*$$scope*/
      4 && (G.$$scope = { dirty: O, ctx: v }), m.$set(G);
      const U = {};
      O[0] & /*$simpleInitiative, reload*/
      257 | O[1] & /*$$scope*/
      4 && (U.$$scope = { dirty: O, ctx: v }), h.$set(U);
      const q = {};
      O[0] & /*$simpleRests, reload*/
      513 | O[1] & /*$$scope*/
      4 && (q.$$scope = { dirty: O, ctx: v }), y.$set(q);
    },
    i(v) {
      k || (w(e.$$.fragment, v), w(s.$$.fragment, v), w(l.$$.fragment, v), w(o.$$.fragment, v), w(c.$$.fragment, v), w(d.$$.fragment, v), w(m.$$.fragment, v), w(h.$$.fragment, v), w(y.$$.fragment, v), k = !0);
    },
    o(v) {
      C(e.$$.fragment, v), C(s.$$.fragment, v), C(l.$$.fragment, v), C(o.$$.fragment, v), C(c.$$.fragment, v), C(d.$$.fragment, v), C(m.$$.fragment, v), C(h.$$.fragment, v), C(y.$$.fragment, v), k = !1;
    },
    d(v) {
      v && (S(t), S(n), S(r), S(a), S(u), S(p), S(g), S(_)), j(e, v), j(s, v), j(l, v), j(o, v), j(c, v), j(d, v), j(m, v), j(h, v), j(y, v);
    }
  };
}
f(Vme, "create_default_slot_2$6");
function Wme(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.hideBrokenAndDamaged",
      checked: (
        /*updates*/
        i[11].get("hideBrokenAndDamaged") ?? /*$hideBrokenAndDamaged*/
        i[10] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_9*/
    i[31]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$hideBrokenAndDamaged*/
      1024 && (l.checked = /*updates*/
      s[11].get("hideBrokenAndDamaged") ?? /*$hideBrokenAndDamaged*/
      s[10] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Wme, "create_default_slot_1$7");
function Kme(i) {
  let e, t;
  return e = new de({
    props: {
      hint: "A5E.settings.hints.hideBrokenAndDamaged",
      $$slots: { default: [Wme] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$hideBrokenAndDamaged*/
      1024 | n[1] & /*$$scope*/
      4 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Kme, "create_default_slot$f");
function Yme(i) {
  let e, t, s, n, l, r;
  return e = new Me({
    props: {
      heading: "A5E.settings.sectionHeader.actorBehavior",
      $$slots: { default: [Vme] },
      $$scope: { ctx: i }
    }
  }), n = new Me({
    props: {
      heading: "A5E.settings.sectionHeader.sheetSettings",
      $$slots: { default: [Kme] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), l = E("div"), L(n.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.5rem"), z(l, "display", "contents"), z(l, "--a5e-section-body-gap", "0.5rem");
    },
    m(o, a) {
      T(o, t, a), N(e, t, null), T(o, s, a), T(o, l, a), N(n, l, null), r = !0;
    },
    p(o, a) {
      const c = {};
      a[0] & /*$simpleRests, reload, $simpleInitiative, $exhaustion, $hideSkillSpecialties, $hideSkillCriticalPrompt, $hideExpertiseDice, $hideA5eSkills, $expertise, $deathSaves*/
      1023 | a[1] & /*$$scope*/
      4 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const u = {};
      a[0] & /*$hideBrokenAndDamaged*/
      1024 | a[1] & /*$$scope*/
      4 && (u.$$scope = { dirty: a, ctx: o }), n.$set(u);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(n.$$.fragment, o), r = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(n.$$.fragment, o), r = !1;
    },
    d(o) {
      o && S(s), o && e && S(t), j(e, o), o && n && S(l), j(n, o);
    }
  };
}
f(Yme, "create_fragment$w");
function Xme(i, e, t) {
  let s, n, l, r, o, a, c, u, d, p, { reload: m } = e;
  const g = fe("settings"), h = fe("updates");
  let _ = g.getStore("5eStyleDeathSaves");
  pe(i, _, (be) => t(1, s = be));
  let y = g.getStore("replaceFatigueAndStrife");
  pe(i, y, (be) => t(7, c = be));
  let k = g.getStore("5eStyleExpertise");
  pe(i, k, (be) => t(2, n = be));
  let v = g.getStore("hideA5eSkills");
  pe(i, v, (be) => t(3, l = be));
  let O = g.getStore("hideBrokenAndDamaged");
  pe(i, O, (be) => t(10, p = be));
  let P = g.getStore("hideExpertiseDice");
  pe(i, P, (be) => t(4, r = be));
  let D = g.getStore("hideSkillCriticalPrompt");
  pe(i, D, (be) => t(5, o = be));
  let I = g.getStore("hideSkillSpecialties");
  pe(i, I, (be) => t(6, a = be));
  let B = g.getStore("simpleInitiative");
  pe(i, B, (be) => t(8, u = be));
  let F = g.getStore("simpleRests");
  pe(i, F, (be) => t(9, d = be));
  const H = /* @__PURE__ */ f(({ detail: be }) => {
    h.set("5eStyleDeathSaves", be);
  }, "updateSelection_handler"), G = /* @__PURE__ */ f(({ detail: be }) => {
    h.set("5eStyleExpertise", be), t(0, m = !0);
  }, "updateSelection_handler_1"), U = /* @__PURE__ */ f(({ detail: be }) => {
    h.set("hideA5eSkills", be), t(0, m = !0);
  }, "updateSelection_handler_2"), q = /* @__PURE__ */ f(({ detail: be }) => {
    h.set("hideExpertiseDice", be), t(0, m = !0);
  }, "updateSelection_handler_3"), W = /* @__PURE__ */ f(({ detail: be }) => {
    h.set("hideSkillCriticalPrompt", be), t(0, m = !0);
  }, "updateSelection_handler_4"), X = /* @__PURE__ */ f(({ detail: be }) => {
    h.set("hideSkillSpecialties", be), t(0, m = !0);
  }, "updateSelection_handler_5"), te = /* @__PURE__ */ f(({ detail: be }) => {
    h.set("replaceFatigueAndStrife", be), t(0, m = !0);
  }, "updateSelection_handler_6"), J = /* @__PURE__ */ f(({ detail: be }) => {
    h.set("simpleInitiative", be), t(0, m = !0);
  }, "updateSelection_handler_7"), re = /* @__PURE__ */ f(({ detail: be }) => {
    h.set("simpleRests", be), t(0, m = !0);
  }, "updateSelection_handler_8"), ae = /* @__PURE__ */ f(({ detail: be }) => {
    h.set("hideBrokenAndDamaged", be);
  }, "updateSelection_handler_9");
  return i.$$set = (be) => {
    "reload" in be && t(0, m = be.reload);
  }, [
    m,
    s,
    n,
    l,
    r,
    o,
    a,
    c,
    u,
    d,
    p,
    h,
    _,
    y,
    k,
    v,
    O,
    P,
    D,
    I,
    B,
    F,
    H,
    G,
    U,
    q,
    W,
    X,
    te,
    J,
    re,
    ae
  ];
}
f(Xme, "instance$u");
const T3 = class T3 extends ie {
  constructor(e) {
    super(), le(this, e, Xme, Yme, ne, { reload: 0 }, null, [-1, -1]);
  }
};
f(T3, "Settings5eTab");
let Dw = T3;
function Jme(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "A5E.settings.sectionHeader.actorBehavior",
      $$slots: { default: [ohe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l[0] & /*$useNPCPassive, reload, $randomHP, $trackCurrency, $blindDeathSaves, $automateTokenSize*/
      125 | l[1] & /*$$scope*/
      2048 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(Jme, "create_if_block$e");
function Zme(i) {
  let e, t;
  return e = new de({
    props: {
      hint: "A5E.settings.hints.automatePrototypeTokenSize",
      $$slots: { default: [Qme] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$automateTokenSize*/
      4 | n[1] & /*$$scope*/
      2048 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Zme, "create_if_block_5$2");
function Qme(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.automatePrototypeTokenSize",
      checked: (
        /*updates*/
        i[13].get("automatePrototypeTokenSize") ?? /*$automateTokenSize*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[28]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$automateTokenSize*/
      4 && (l.checked = /*updates*/
      s[13].get("automatePrototypeTokenSize") ?? /*$automateTokenSize*/
      s[2]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Qme, "create_default_slot_12$1");
function xme(i) {
  let e, t;
  return e = new de({
    props: {
      hint: "A5E.settings.hints.blindDeathSaves",
      $$slots: { default: [ehe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$blindDeathSaves, reload*/
      9 | n[1] & /*$$scope*/
      2048 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(xme, "create_if_block_4$2");
function ehe(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.blindDeathSaves",
      checked: (
        /*updates*/
        i[13].get("blindDeathSaves") ?? /*$blindDeathSaves*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[29]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$blindDeathSaves*/
      8 && (l.checked = /*updates*/
      s[13].get("blindDeathSaves") ?? /*$blindDeathSaves*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(ehe, "create_default_slot_11$1");
function the(i) {
  let e, t;
  return e = new de({
    props: {
      hint: "A5E.settings.hints.trackCurrencyWeight",
      $$slots: { default: [she] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$trackCurrency*/
      16 | n[1] & /*$$scope*/
      2048 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(the, "create_if_block_3$2");
function she(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.trackCurrencyWeight",
      checked: (
        /*updates*/
        i[13].get("currencyWeight") ?? /*$trackCurrency*/
        i[4] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[30]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$trackCurrency*/
      16 && (l.checked = /*updates*/
      s[13].get("currencyWeight") ?? /*$trackCurrency*/
      s[4] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(she, "create_default_slot_10$1");
function nhe(i) {
  let e, t;
  return e = new de({
    props: {
      hint: "A5E.settings.hints.randomizeNPCHitPoints",
      $$slots: { default: [ihe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$randomHP*/
      32 | n[1] & /*$$scope*/
      2048 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(nhe, "create_if_block_2$5");
function ihe(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.randomizeNPCHitPoints",
      checked: (
        /*updates*/
        i[13].get("randomizeNPCHitPoints") ?? /*$randomHP*/
        i[5] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[31]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$randomHP*/
      32 && (l.checked = /*updates*/
      s[13].get("randomizeNPCHitPoints") ?? /*$randomHP*/
      s[5] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(ihe, "create_default_slot_9$1");
function lhe(i) {
  let e, t;
  return e = new de({
    props: {
      hint: "A5E.settings.hints.useNPCExpertisePassiveRulesForCharacters",
      $$slots: { default: [rhe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$useNPCPassive, reload*/
      65 | n[1] & /*$$scope*/
      2048 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(lhe, "create_if_block_1$9");
function rhe(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.useNPCExpertisePassiveRulesForCharacters",
      checked: (
        /*updates*/
        i[13].get("useNPCExpertisePassiveRulesForCharacters") ?? /*$useNPCPassive*/
        i[6] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[32]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$useNPCPassive*/
      64 && (l.checked = /*updates*/
      s[13].get("useNPCExpertisePassiveRulesForCharacters") ?? /*$useNPCPassive*/
      s[6] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(rhe, "create_default_slot_8$1");
function ohe(i) {
  let e, t, s, n, l, r, o = (
    /*isGM*/
    i[14] && Zme(i)
  ), a = (
    /*isGM*/
    i[14] && xme(i)
  ), c = (
    /*isGM*/
    i[14] && the(i)
  ), u = (
    /*isGM*/
    i[14] && nhe(i)
  ), d = (
    /*isGM*/
    i[14] && lhe(i)
  );
  return {
    c() {
      o && o.c(), e = R(), a && a.c(), t = R(), c && c.c(), s = R(), u && u.c(), n = R(), d && d.c(), l = $e();
    },
    m(p, m) {
      o && o.m(p, m), T(p, e, m), a && a.m(p, m), T(p, t, m), c && c.m(p, m), T(p, s, m), u && u.m(p, m), T(p, n, m), d && d.m(p, m), T(p, l, m), r = !0;
    },
    p(p, m) {
      /*isGM*/
      p[14] && o.p(p, m), /*isGM*/
      p[14] && a.p(p, m), /*isGM*/
      p[14] && c.p(p, m), /*isGM*/
      p[14] && u.p(p, m), /*isGM*/
      p[14] && d.p(p, m);
    },
    i(p) {
      r || (w(o), w(a), w(c), w(u), w(d), r = !0);
    },
    o(p) {
      C(o), C(a), C(c), C(u), C(d), r = !1;
    },
    d(p) {
      p && (S(e), S(t), S(s), S(n), S(l)), o && o.d(p), a && a.d(p), c && c.d(p), u && u.d(p), d && d.d(p);
    }
  };
}
f(ohe, "create_default_slot_7$2");
function ahe(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.collapseActionList",
      checked: (
        /*updates*/
        i[13].get("collapseActionList") ?? /*$hideActionList*/
        i[7] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[33]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$hideActionList*/
      128 && (l.checked = /*updates*/
      s[13].get("collapseActionList") ?? /*$hideActionList*/
      s[7] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(ahe, "create_default_slot_6$2");
function che(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.hideDeletionConfirmationDialog",
      checked: (
        /*updates*/
        i[13].get("hideDeleteConfirmation") ?? /*$hideDeleteDialog*/
        i[8] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_6*/
    i[34]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$hideDeleteDialog*/
      256 && (l.checked = /*updates*/
      s[13].get("hideDeleteConfirmation") ?? /*$hideDeleteDialog*/
      s[8] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(che, "create_default_slot_5$3");
function uhe(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.hideActorCompendiumSelectionDialog",
      checked: (
        /*updates*/
        i[13].get("hideActorCompendiumSelectionDialog") ?? /*$hideCompendiumSelection*/
        i[9] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_7*/
    i[35]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$hideCompendiumSelection*/
      512 && (l.checked = /*updates*/
      s[13].get("hideActorCompendiumSelectionDialog") ?? /*$hideCompendiumSelection*/
      s[9] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(uhe, "create_default_slot_4$4");
function fhe(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.itemRightClickConfigure",
      checked: (
        /*updates*/
        i[13].get("itemRightClickConfigure") ?? /*$rightClickConfig*/
        i[10] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_8*/
    i[36]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$rightClickConfig*/
      1024 && (l.checked = /*updates*/
      s[13].get("itemRightClickConfigure") ?? /*$rightClickConfig*/
      s[10] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(fhe, "create_default_slot_3$5");
function dhe(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.reverseAltBehavior",
      checked: (
        /*updates*/
        i[13].get("reverseAltBehavior") ?? /*$reverseAlt*/
        i[11] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_9*/
    i[37]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$reverseAlt*/
      2048 && (l.checked = /*updates*/
      s[13].get("reverseAltBehavior") ?? /*$reverseAlt*/
      s[11] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(dhe, "create_default_slot_2$5");
function phe(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.reverseInitiativeAltBehavior",
      checked: (
        /*updates*/
        i[13].get("reverseInitiativeAltBehavior") ?? /*$reverseInitAlt*/
        i[12] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_10*/
    i[38]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$reverseInitAlt*/
      4096 && (l.checked = /*updates*/
      s[13].get("reverseInitiativeAltBehavior") ?? /*$reverseInitAlt*/
      s[12] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(phe, "create_default_slot_1$6");
function mhe(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g;
  return e = new de({
    props: {
      hint: "A5E.settings.hints.collapseActionList",
      $$slots: { default: [ahe] },
      $$scope: { ctx: i }
    }
  }), s = new de({
    props: {
      hint: "A5E.settings.hints.hideDeletionConfirmationDialog",
      $$slots: { default: [che] },
      $$scope: { ctx: i }
    }
  }), l = new de({
    props: {
      hint: "A5E.settings.hints.hideActorCompendiumSelectionDialog",
      $$slots: { default: [uhe] },
      $$scope: { ctx: i }
    }
  }), o = new de({
    props: {
      hint: "A5E.settings.hints.itemRightClickConfigure",
      $$slots: { default: [fhe] },
      $$scope: { ctx: i }
    }
  }), c = new de({
    props: {
      hint: "A5E.settings.hints.reverseAltBehavior",
      $$slots: { default: [dhe] },
      $$scope: { ctx: i }
    }
  }), d = new de({
    props: {
      hint: "A5E.settings.hints.reverseInitiativeAltBehavior",
      $$slots: { default: [phe] },
      $$scope: { ctx: i }
    }
  }), m = new Ye({
    props: {
      heading: "A5E.settings.skillListFlowDirection",
      hint: "A5E.settings.hints.skillListFlowDirection",
      options: Object.entries(
        /*skillListFlowDirectionChoices*/
        i[15]
      ),
      selected: (
        /*selectedSkillListFlowDirection*/
        i[1]
      )
    }
  }), m.$on(
    "updateSelection",
    /*updateSelection_handler_11*/
    i[39]
  ), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment), r = R(), L(o.$$.fragment), a = R(), L(c.$$.fragment), u = R(), L(d.$$.fragment), p = R(), L(m.$$.fragment);
    },
    m(h, _) {
      N(e, h, _), T(h, t, _), N(s, h, _), T(h, n, _), N(l, h, _), T(h, r, _), N(o, h, _), T(h, a, _), N(c, h, _), T(h, u, _), N(d, h, _), T(h, p, _), N(m, h, _), g = !0;
    },
    p(h, _) {
      const y = {};
      _[0] & /*$hideActionList*/
      128 | _[1] & /*$$scope*/
      2048 && (y.$$scope = { dirty: _, ctx: h }), e.$set(y);
      const k = {};
      _[0] & /*$hideDeleteDialog*/
      256 | _[1] & /*$$scope*/
      2048 && (k.$$scope = { dirty: _, ctx: h }), s.$set(k);
      const v = {};
      _[0] & /*$hideCompendiumSelection*/
      512 | _[1] & /*$$scope*/
      2048 && (v.$$scope = { dirty: _, ctx: h }), l.$set(v);
      const O = {};
      _[0] & /*$rightClickConfig*/
      1024 | _[1] & /*$$scope*/
      2048 && (O.$$scope = { dirty: _, ctx: h }), o.$set(O);
      const P = {};
      _[0] & /*$reverseAlt*/
      2048 | _[1] & /*$$scope*/
      2048 && (P.$$scope = { dirty: _, ctx: h }), c.$set(P);
      const D = {};
      _[0] & /*$reverseInitAlt*/
      4096 | _[1] & /*$$scope*/
      2048 && (D.$$scope = { dirty: _, ctx: h }), d.$set(D);
      const I = {};
      _[0] & /*selectedSkillListFlowDirection*/
      2 && (I.selected = /*selectedSkillListFlowDirection*/
      h[1]), m.$set(I);
    },
    i(h) {
      g || (w(e.$$.fragment, h), w(s.$$.fragment, h), w(l.$$.fragment, h), w(o.$$.fragment, h), w(c.$$.fragment, h), w(d.$$.fragment, h), w(m.$$.fragment, h), g = !0);
    },
    o(h) {
      C(e.$$.fragment, h), C(s.$$.fragment, h), C(l.$$.fragment, h), C(o.$$.fragment, h), C(c.$$.fragment, h), C(d.$$.fragment, h), C(m.$$.fragment, h), g = !1;
    },
    d(h) {
      h && (S(t), S(n), S(r), S(a), S(u), S(p)), j(e, h), j(s, h), j(l, h), j(o, h), j(c, h), j(d, h), j(m, h);
    }
  };
}
f(mhe, "create_default_slot$e");
function hhe(i) {
  let e, t, s, n, l = (
    /*isGM*/
    i[14] && Jme(i)
  );
  return t = new Me({
    props: {
      heading: "A5E.settings.sectionHeader.sheetSettings",
      $$slots: { default: [mhe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      l && l.c(), e = R(), s = E("div"), L(t.$$.fragment), z(s, "display", "contents"), z(s, "--a5e-section-body-gap", "0.5rem");
    },
    m(r, o) {
      l && l.m(r, o), T(r, e, o), T(r, s, o), N(t, s, null), n = !0;
    },
    p(r, o) {
      /*isGM*/
      r[14] && l.p(r, o);
      const a = {};
      o[0] & /*selectedSkillListFlowDirection, reload, $reverseInitAlt, $reverseAlt, $rightClickConfig, $hideCompendiumSelection, $hideDeleteDialog, $hideActionList*/
      8067 | o[1] & /*$$scope*/
      2048 && (a.$$scope = { dirty: o, ctx: r }), t.$set(a);
    },
    i(r) {
      n || (w(l), w(t.$$.fragment, r), n = !0);
    },
    o(r) {
      C(l), C(t.$$.fragment, r), n = !1;
    },
    d(r) {
      r && S(e), l && l.d(r), r && t && S(s), j(t, r);
    }
  };
}
f(hhe, "create_fragment$v");
function ghe(i, e, t) {
  let s, n, l, r, o, a, c, u, d, p, m, g, { reload: h } = e;
  const _ = fe("settings"), y = fe("updates"), k = game.user.isGM, v = game.settings.settings.get("a5e.skillListFlowDirection").choices;
  let O = _.getStore("currencyWeight");
  pe(i, O, (Pe) => t(4, r = Pe));
  let P = _.getStore("randomizeNPCHitPoints");
  pe(i, P, (Pe) => t(5, o = Pe));
  let D = _.getStore("automatePrototypeTokenSize");
  pe(i, D, (Pe) => t(2, n = Pe));
  let I = _.getStore("blindDeathSaves");
  pe(i, I, (Pe) => t(3, l = Pe));
  let B = _.getStore("collapseActionList");
  pe(i, B, (Pe) => t(7, c = Pe));
  let F = _.getStore("hideDeleteConfirmation");
  pe(i, F, (Pe) => t(8, u = Pe));
  let H = _.getStore("hideActorCompendiumSelectionDialog");
  pe(i, H, (Pe) => t(9, d = Pe));
  let G = _.getStore("itemRightClickConfigure");
  pe(i, G, (Pe) => t(10, p = Pe));
  let U = _.getStore("reverseAltBehavior");
  pe(i, U, (Pe) => t(11, m = Pe));
  let q = _.getStore("reverseInitiativeAltBehavior");
  pe(i, q, (Pe) => t(12, g = Pe));
  let W = _.getStore("skillListFlowDirection");
  pe(i, W, (Pe) => t(40, s = Pe));
  let X = _.getStore("useNPCExpertisePassiveRulesForCharacters");
  pe(i, X, (Pe) => t(6, a = Pe));
  let te = y.get("skillListFlowDirection") ?? s;
  const J = /* @__PURE__ */ f(({ detail: Pe }) => {
    y.set("automatePrototypeTokenSize", Pe);
  }, "updateSelection_handler"), re = /* @__PURE__ */ f(({ detail: Pe }) => {
    y.set("blindDeathSaves", Pe), t(0, h = !0);
  }, "updateSelection_handler_1"), ae = /* @__PURE__ */ f(({ detail: Pe }) => {
    y.set("currencyWeight", Pe);
  }, "updateSelection_handler_2"), be = /* @__PURE__ */ f(({ detail: Pe }) => {
    y.set("randomizeNPCHitPoints", Pe);
  }, "updateSelection_handler_3"), we = /* @__PURE__ */ f(({ detail: Pe }) => {
    y.set("useNPCExpertisePassiveRulesForCharacters", Pe), t(0, h = !0);
  }, "updateSelection_handler_4"), ve = /* @__PURE__ */ f(({ detail: Pe }) => y.set("collapseActionList", Pe), "updateSelection_handler_5"), me = /* @__PURE__ */ f(({ detail: Pe }) => y.set("hideDeleteConfirmation", Pe), "updateSelection_handler_6"), he = /* @__PURE__ */ f(({ detail: Pe }) => y.set("hideActorCompendiumSelectionDialog", Pe), "updateSelection_handler_7"), Ae = /* @__PURE__ */ f(({ detail: Pe }) => y.set("itemRightClickConfigure", Pe), "updateSelection_handler_8"), Fe = /* @__PURE__ */ f(({ detail: Pe }) => y.set("reverseAltBehavior", Pe), "updateSelection_handler_9"), Ve = /* @__PURE__ */ f(({ detail: Pe }) => y.set("reverseInitiativeAltBehavior", Pe), "updateSelection_handler_10"), je = /* @__PURE__ */ f(({ detail: Pe }) => {
    y.set("skillListFlowDirection", Pe), t(1, te = Pe), t(0, h = !0);
  }, "updateSelection_handler_11");
  return i.$$set = (Pe) => {
    "reload" in Pe && t(0, h = Pe.reload);
  }, [
    h,
    te,
    n,
    l,
    r,
    o,
    a,
    c,
    u,
    d,
    p,
    m,
    g,
    y,
    k,
    v,
    O,
    P,
    D,
    I,
    B,
    F,
    H,
    G,
    U,
    q,
    W,
    X,
    J,
    re,
    ae,
    be,
    we,
    ve,
    me,
    he,
    Ae,
    Fe,
    Ve,
    je
  ];
}
f(ghe, "instance$t");
const C3 = class C3 extends ie {
  constructor(e) {
    super(), le(this, e, ghe, hhe, ne, { reload: 0 }, null, [-1, -1]);
  }
};
f(C3, "SettingsActorTab");
let Iw = C3;
function bhe(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.automateVisionRules",
      checked: (
        /*updates*/
        i[4].get("automateVisionRules") ?? /*$visionRules*/
        i[2] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[9]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$visionRules*/
      4 && (l.checked = /*updates*/
      s[4].get("automateVisionRules") ?? /*$visionRules*/
      s[2] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(bhe, "create_default_slot_4$3");
function _he(i) {
  let e, t;
  return e = new de({
    props: {
      hint: "A5E.settings.hints.automateVisionRules",
      $$slots: { default: [bhe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $visionRules, reload*/
      16389 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(_he, "create_default_slot_3$4");
function yhe(i) {
  let e, t;
  return e = new Ye({
    props: {
      hint: "A5E.settings.hints.diagonalRule",
      options: Object.entries(
        /*diagonalRuleOptions*/
        i[5]
      ),
      selected: (
        /*selectedDiagonalRule*/
        i[1]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[10]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*selectedDiagonalRule*/
      2 && (l.selected = /*selectedDiagonalRule*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(yhe, "create_default_slot_2$4");
function vhe(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.placeItemTemplateDefault",
      checked: (
        /*updates*/
        i[4].get("placeItemTemplateDefault") ?? /*$placeTemplate*/
        i[3] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[11]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$placeTemplate*/
      8 && (l.checked = /*updates*/
      s[4].get("placeItemTemplateDefault") ?? /*$placeTemplate*/
      s[3] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(vhe, "create_default_slot_1$5");
function khe(i) {
  let e, t;
  return e = new de({
    props: {
      hint: "A5E.settings.hints.placeItemTemplateDefault",
      $$slots: { default: [vhe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $placeTemplate*/
      16392 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(khe, "create_default_slot$d");
function whe(i) {
  let e, t, s, n, l, r, o, a, c;
  return e = new Me({
    props: {
      heading: "VIsion Settings",
      $$slots: { default: [_he] },
      $$scope: { ctx: i }
    }
  }), n = new Me({
    props: {
      heading: "Grid Settings",
      $$slots: { default: [yhe] },
      $$scope: { ctx: i }
    }
  }), o = new Me({
    props: {
      heading: "Template Settings",
      $$slots: { default: [khe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), l = E("div"), L(n.$$.fragment), r = R(), a = E("div"), L(o.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.5rem"), z(l, "display", "contents"), z(l, "--a5e-section-body-gap", "0.5rem"), z(a, "display", "contents"), z(a, "--a5e-section-body-gap", "0.5rem");
    },
    m(u, d) {
      T(u, t, d), N(e, t, null), T(u, s, d), T(u, l, d), N(n, l, null), T(u, r, d), T(u, a, d), N(o, a, null), c = !0;
    },
    p(u, [d]) {
      const p = {};
      d & /*$$scope, $visionRules, reload*/
      16389 && (p.$$scope = { dirty: d, ctx: u }), e.$set(p);
      const m = {};
      d & /*$$scope, selectedDiagonalRule, reload*/
      16387 && (m.$$scope = { dirty: d, ctx: u }), n.$set(m);
      const g = {};
      d & /*$$scope, $placeTemplate*/
      16392 && (g.$$scope = { dirty: d, ctx: u }), o.$set(g);
    },
    i(u) {
      c || (w(e.$$.fragment, u), w(n.$$.fragment, u), w(o.$$.fragment, u), c = !0);
    },
    o(u) {
      C(e.$$.fragment, u), C(n.$$.fragment, u), C(o.$$.fragment, u), c = !1;
    },
    d(u) {
      u && (S(s), S(r)), u && e && S(t), j(e, u), u && n && S(l), j(n, u), u && o && S(a), j(o, u);
    }
  };
}
f(whe, "create_fragment$u");
function $he(i, e, t) {
  let s, n, l, { reload: r } = e;
  const o = fe("settings"), a = fe("updates"), c = game.settings.settings.get("a5e.diagonalRule").choices;
  let u = o.getStore("automateVisionRules");
  pe(i, u, (y) => t(2, n = y));
  let d = o.getStore("diagonalRule");
  pe(i, d, (y) => t(12, s = y));
  let p = a.get("diagonalRule") ?? s, m = o.getStore("placeItemTemplateDefault");
  pe(i, m, (y) => t(3, l = y));
  const g = /* @__PURE__ */ f(({ detail: y }) => {
    a.set("automateVisionRules", y), t(0, r = !0);
  }, "updateSelection_handler"), h = /* @__PURE__ */ f(({ detail: y }) => {
    a.set("diagonalRule", y), t(1, p = y), t(0, r = !0);
  }, "updateSelection_handler_1"), _ = /* @__PURE__ */ f(({ detail: y }) => {
    a.set("placeItemTemplateDefault", y);
  }, "updateSelection_handler_2");
  return i.$$set = (y) => {
    "reload" in y && t(0, r = y.reload);
  }, [
    r,
    p,
    n,
    l,
    a,
    c,
    u,
    d,
    m,
    g,
    h,
    _
  ];
}
f($he, "instance$s");
const O3 = class O3 extends ie {
  constructor(e) {
    super(), le(this, e, $he, whe, ne, { reload: 0 });
  }
};
f(O3, "SettingsCanvasTab");
let Pw = O3;
function Ahe(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.enableDamageRollColors",
      checked: (
        /*updates*/
        i[6].get("enableDamageRollColors") ?? /*$enableDamageRollColors*/
        i[1] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[13]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$enableDamageRollColors*/
      2 && (l.checked = /*updates*/
      s[6].get("enableDamageRollColors") ?? /*$enableDamageRollColors*/
      s[1] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Ahe, "create_default_slot_5$2");
function Ehe(i) {
  let e, t;
  return e = new de({
    props: {
      hint: "A5E.settings.hints.protectRolls",
      $$slots: { default: [She] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $protectRolls, reload*/
      524293 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Ehe, "create_if_block_1$8");
function She(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.protectRolls",
      checked: (
        /*updates*/
        i[6].get("protectRolls") ?? /*$protectRolls*/
        i[2] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[14]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$protectRolls*/
      4 && (l.checked = /*updates*/
      s[6].get("protectRolls") ?? /*$protectRolls*/
      s[2] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(She, "create_default_slot_4$2");
function The(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.hideChatDescriptionsByDefault",
      checked: (
        /*updates*/
        i[6].get("hideChatDescriptionsByDefault") ?? /*$hideDescription*/
        i[3] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[15]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$hideDescription*/
      8 && (l.checked = /*updates*/
      s[6].get("hideChatDescriptionsByDefault") ?? /*$hideDescription*/
      s[3] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(The, "create_default_slot_3$3");
function Che(i) {
  let e, t;
  return e = new de({
    props: {
      hint: "A5E.settings.hints.hideRandomizedHPRolls",
      $$slots: { default: [Ohe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $hideHpRolls*/
      524304 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Che, "create_if_block$d");
function Ohe(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.hideRandomizedHPRolls",
      checked: (
        /*updates*/
        i[6].get("hideRandomizedHPRolls") ?? /*$hideHpRolls*/
        i[4] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[16]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$hideHpRolls*/
      16 && (l.checked = /*updates*/
      s[6].get("hideRandomizedHPRolls") ?? /*$hideHpRolls*/
      s[4] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Ohe, "create_default_slot_2$3");
function Dhe(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.terseRollFormulae",
      checked: (
        /*updates*/
        i[6].get("terseRollFormulae") ?? /*$terseRolls*/
        i[5] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[17]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$terseRolls*/
      32 && (l.checked = /*updates*/
      s[6].get("terseRollFormulae") ?? /*$terseRolls*/
      s[5] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Dhe, "create_default_slot_1$4");
function Ihe(i) {
  let e, t, s, n, l, r, o, a;
  e = new de({
    props: {
      hint: "A5E.settings.hints.enableDamageRollColors",
      $$slots: { default: [Ahe] },
      $$scope: { ctx: i }
    }
  });
  let c = (
    /*isGM*/
    i[7] && Ehe(i)
  );
  n = new de({
    props: {
      hint: "A5E.settings.hints.hideChatDescriptionsByDefault",
      $$slots: { default: [The] },
      $$scope: { ctx: i }
    }
  });
  let u = (
    /*isGM*/
    i[7] && Che(i)
  );
  return o = new de({
    props: {
      hint: "A5E.settings.hints.terseRollFormulae",
      $$slots: { default: [Dhe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), c && c.c(), s = R(), L(n.$$.fragment), l = R(), u && u.c(), r = R(), L(o.$$.fragment);
    },
    m(d, p) {
      N(e, d, p), T(d, t, p), c && c.m(d, p), T(d, s, p), N(n, d, p), T(d, l, p), u && u.m(d, p), T(d, r, p), N(o, d, p), a = !0;
    },
    p(d, p) {
      const m = {};
      p & /*$$scope, $enableDamageRollColors, reload*/
      524291 && (m.$$scope = { dirty: p, ctx: d }), e.$set(m), /*isGM*/
      d[7] && c.p(d, p);
      const g = {};
      p & /*$$scope, $hideDescription, reload*/
      524297 && (g.$$scope = { dirty: p, ctx: d }), n.$set(g), /*isGM*/
      d[7] && u.p(d, p);
      const h = {};
      p & /*$$scope, $terseRolls, reload*/
      524321 && (h.$$scope = { dirty: p, ctx: d }), o.$set(h);
    },
    i(d) {
      a || (w(e.$$.fragment, d), w(c), w(n.$$.fragment, d), w(u), w(o.$$.fragment, d), a = !0);
    },
    o(d) {
      C(e.$$.fragment, d), C(c), C(n.$$.fragment, d), C(u), C(o.$$.fragment, d), a = !1;
    },
    d(d) {
      d && (S(t), S(s), S(l), S(r)), j(e, d), c && c.d(d), j(n, d), u && u.d(d), j(o, d);
    }
  };
}
f(Ihe, "create_default_slot$c");
function Phe(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Chat Card Display Settings",
      $$slots: { default: [Ihe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, $terseRolls, reload, $hideHpRolls, $hideDescription, $protectRolls, $enableDamageRollColors*/
      524351 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(Phe, "create_fragment$t");
function Mhe(i, e, t) {
  let s, n, l, r, o, { reload: a } = e;
  const c = fe("settings"), u = fe("updates"), d = game.user.isGM;
  let p = c.getStore("enableDamageRollColors");
  pe(i, p, (D) => t(1, s = D));
  let m = c.getStore("hideChatDescriptionsByDefault");
  pe(i, m, (D) => t(3, l = D));
  let g = c.getStore("hideRandomizedHPRolls");
  pe(i, g, (D) => t(4, r = D));
  let h = c.getStore("protectRolls");
  pe(i, h, (D) => t(2, n = D));
  let _ = c.getStore("terseRollFormulae");
  pe(i, _, (D) => t(5, o = D));
  const y = /* @__PURE__ */ f(({ detail: D }) => {
    u.set("enableDamageRollColors", D), t(0, a = !0);
  }, "updateSelection_handler"), k = /* @__PURE__ */ f(({ detail: D }) => {
    u.set("protectRolls", D), t(0, a = !0);
  }, "updateSelection_handler_1"), v = /* @__PURE__ */ f(({ detail: D }) => {
    u.set("hideChatDescriptionsByDefault", D), t(0, a = !0);
  }, "updateSelection_handler_2"), O = /* @__PURE__ */ f(({ detail: D }) => {
    u.set("hideRandomizedHPRolls", D);
  }, "updateSelection_handler_3"), P = /* @__PURE__ */ f(({ detail: D }) => {
    u.set("terseRollFormulae", D), t(0, a = !0);
  }, "updateSelection_handler_4");
  return i.$$set = (D) => {
    "reload" in D && t(0, a = D.reload);
  }, [
    a,
    s,
    n,
    l,
    r,
    o,
    u,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    k,
    v,
    O,
    P
  ];
}
f(Mhe, "instance$r");
const D3 = class D3 extends ie {
  constructor(e) {
    super(), le(this, e, Mhe, Phe, ne, { reload: 0 });
  }
};
f(D3, "SettingsChatCardTab");
let Mw = D3;
function Rhe(i) {
  let e, t, s, n, l, r, o;
  return {
    c() {
      e = E("li"), t = E("img"), n = R(), l = x(
        /*conditionName*/
        i[6]
      ), b(t, "class", "condition-icon svelte-1rh020x"), ze(t.src, s = /*icon*/
      i[1] || /*$iconStore*/
      i[2][
        /*conditionKey*/
        i[0]
      ] || /*conditionIconsDefault*/
      i[4][
        /*conditionKey*/
        i[0]
      ]) || b(t, "src", s), b(
        t,
        "alt",
        /*getConditionName*/
        i[3]()
      ), b(e, "class", "condition-grid__item svelte-1rh020x");
    },
    m(a, c) {
      T(a, e, c), A(e, t), A(e, n), A(e, l), r || (o = V(
        e,
        "click",
        /*click_handler*/
        i[8]
      ), r = !0);
    },
    p(a, [c]) {
      c & /*icon, $iconStore, conditionKey*/
      7 && !ze(t.src, s = /*icon*/
      a[1] || /*$iconStore*/
      a[2][
        /*conditionKey*/
        a[0]
      ] || /*conditionIconsDefault*/
      a[4][
        /*conditionKey*/
        a[0]
      ]) && b(t, "src", s);
    },
    i: ee,
    o: ee,
    d(a) {
      a && S(e), r = !1, o();
    }
  };
}
f(Rhe, "create_fragment$s");
function Fhe(i, e, t) {
  let s, { conditionKey: n } = e, { icon: l } = e;
  function r() {
    return n === "dead" ? K("A5E.ConditionDead") : n === "concentration" ? K("A5E.ConditionConcentration") : o[n] ?? n;
  }
  f(r, "getConditionName");
  const { conditions: o, conditionIconsDefault: a } = CONFIG.A5E, c = it(), u = fe("settings"), d = r(), p = u.getStore("customConditionIcons");
  pe(i, p, (g) => t(2, s = g));
  const m = /* @__PURE__ */ f(() => c("updateConditionIcon", [
    n,
    l || s[n] || a[n]
  ]), "click_handler");
  return i.$$set = (g) => {
    "conditionKey" in g && t(0, n = g.conditionKey), "icon" in g && t(1, l = g.icon);
  }, [
    n,
    l,
    s,
    r,
    a,
    c,
    d,
    p,
    m
  ];
}
f(Fhe, "instance$q");
const I3 = class I3 extends ie {
  constructor(e) {
    super(), le(this, e, Fhe, Rhe, ne, { conditionKey: 0, icon: 1 });
  }
};
f(I3, "SettingsCustomIcon");
let Rw = I3;
function Nhe(i) {
  let e, t, s, n, l, r, o, a, c;
  return {
    c() {
      e = E("form"), t = E("p"), t.textContent = `Are you sure you want to reset the system's condition icons to their
        defaults? This cannot be undone.`, s = R(), n = E("div"), l = E("button"), l.textContent = "Reset Icons", r = R(), o = E("button"), o.textContent = "Cancel", b(n, "class", "button-container svelte-1ev6ohd"), b(e, "class", "svelte-1ev6ohd");
    },
    m(u, d) {
      T(u, e, d), A(e, t), A(e, s), A(e, n), A(n, l), A(n, r), A(n, o), a || (c = [
        V(l, "click", tt(
          /*click_handler*/
          i[3]
        )),
        V(o, "click", tt(
          /*click_handler_1*/
          i[4]
        ))
      ], a = !0);
    },
    p: ee,
    i: ee,
    o: ee,
    d(u) {
      u && S(e), a = !1, Ne(c);
    }
  };
}
f(Nhe, "create_fragment$r");
function jhe(i, e, t) {
  let { dialog: s } = fe("#external").application, { dialog: n = s } = e;
  function l() {
    n.submit({ confirmReset: !0 });
  }
  f(l, "onSubmit");
  function r() {
    n.submit({ confirmReset: !1 });
  }
  f(r, "onCancelReset");
  const o = /* @__PURE__ */ f(() => l(), "click_handler"), a = /* @__PURE__ */ f(() => r(), "click_handler_1");
  return i.$$set = (c) => {
    "dialog" in c && t(2, n = c.dialog);
  }, [l, r, n, o, a];
}
f(jhe, "instance$p");
var _f;
let Lhe = (_f = class extends ie {
  constructor(e) {
    super(), le(this, e, jhe, Nhe, ne, { dialog: 2 });
  }
}, f(_f, "ConditionIconResetConfirmationDialog"), _f);
var yf, Nw;
const P3 = class P3 extends Fs {
  constructor() {
    super({
      title: "Condition Icons Reset Confirmation",
      content: {
        class: Lhe,
        props: {}
      }
    }, {
      classes: ["a5e-sheet"],
      width: 420
    });
    Y(this, yf);
    this.data.content.props.dialog = this, this.promise = new Promise((t) => {
      this.resolve = t;
    });
  }
  /** @inheritdoc */
  close(t) {
    return Z(this, yf, Nw).call(this, null), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    return Z(this, yf, Nw).call(this, t), super.close();
  }
};
yf = new WeakSet(), Nw = /* @__PURE__ */ f(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), f(P3, "ConditionIconResetConfirmationDialog");
let Fw = P3;
function sL(i, e, t) {
  const s = i.slice();
  return s[49] = e[t][0], s[50] = e[t][1], s;
}
f(sL, "get_each_context$6");
function Bhe(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.automateBloodiedApplication",
      checked: (
        /*updates*/
        i[13].get("automateBloodiedApplication") ?? /*$automateBloodied*/
        i[6] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[28]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$automateBloodied*/
      64 && (l.checked = /*updates*/
      s[13].get("automateBloodiedApplication") ?? /*$automateBloodied*/
      s[6] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Bhe, "create_default_slot_12");
function qhe(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.automateUnconsciousApplication",
      checked: (
        /*updates*/
        i[13].get("automateUnconsciousApplication") ?? /*$automateUnconscious*/
        i[7] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[29]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$automateUnconscious*/
      128 && (l.checked = /*updates*/
      s[13].get("automateUnconsciousApplication") ?? /*$automateUnconscious*/
      s[7] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(qhe, "create_default_slot_11");
function Ghe(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.enableRadialEffects",
      checked: (
        /*updates*/
        i[13].get("enableRadialEffects") ?? /*$radialEffects*/
        i[8]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[30]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$radialEffects*/
      256 && (l.checked = /*updates*/
      s[13].get("enableRadialEffects") ?? /*$radialEffects*/
      s[8]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Ghe, "create_default_slot_10");
function zhe(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.removeActiveEffectsOnLongRest",
      checked: (
        /*updates*/
        i[13].get("removeActiveEffectsOnLongRest") ?? /*$removeEffects*/
        i[9] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[31]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$removeEffects*/
      512 && (l.checked = /*updates*/
      s[13].get("removeActiveEffectsOnLongRest") ?? /*$removeEffects*/
      s[9] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(zhe, "create_default_slot_9");
function Hhe(i) {
  let e, t, s, n, l, r, o, a, c, u;
  return e = new Ze({
    props: {
      hint: "A5E.settings.hints.automateConditions",
      options: (
        /*automatableConditions*/
        i[14]
      ),
      selected: (
        /*selectedConditions*/
        i[2]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[27]
  ), s = new de({
    props: {
      hint: "A5E.settings.hints.automateBloodiedApplication",
      $$slots: { default: [Bhe] },
      $$scope: { ctx: i }
    }
  }), l = new de({
    props: {
      hint: "A5E.settings.hints.automateUnconsciousApplication",
      $$slots: { default: [qhe] },
      $$scope: { ctx: i }
    }
  }), o = new de({
    props: {
      hint: "A5E.settings.hints.enableRadialEffects",
      $$slots: { default: [Ghe] },
      $$scope: { ctx: i }
    }
  }), c = new de({
    props: {
      hint: "A5E.settings.hints.removeActiveEffectsOnLongRest",
      $$slots: { default: [zhe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment), r = R(), L(o.$$.fragment), a = R(), L(c.$$.fragment);
    },
    m(d, p) {
      N(e, d, p), T(d, t, p), N(s, d, p), T(d, n, p), N(l, d, p), T(d, r, p), N(o, d, p), T(d, a, p), N(c, d, p), u = !0;
    },
    p(d, p) {
      const m = {};
      p[0] & /*selectedConditions*/
      4 && (m.selected = /*selectedConditions*/
      d[2]), e.$set(m);
      const g = {};
      p[0] & /*$automateBloodied, reload*/
      65 | p[1] & /*$$scope*/
      4194304 && (g.$$scope = { dirty: p, ctx: d }), s.$set(g);
      const h = {};
      p[0] & /*$automateUnconscious, reload*/
      129 | p[1] & /*$$scope*/
      4194304 && (h.$$scope = { dirty: p, ctx: d }), l.$set(h);
      const _ = {};
      p[0] & /*$radialEffects, reload*/
      257 | p[1] & /*$$scope*/
      4194304 && (_.$$scope = { dirty: p, ctx: d }), o.$set(_);
      const y = {};
      p[0] & /*$removeEffects*/
      512 | p[1] & /*$$scope*/
      4194304 && (y.$$scope = { dirty: p, ctx: d }), c.$set(y);
    },
    i(d) {
      u || (w(e.$$.fragment, d), w(s.$$.fragment, d), w(l.$$.fragment, d), w(o.$$.fragment, d), w(c.$$.fragment, d), u = !0);
    },
    o(d) {
      C(e.$$.fragment, d), C(s.$$.fragment, d), C(l.$$.fragment, d), C(o.$$.fragment, d), C(c.$$.fragment, d), u = !1;
    },
    d(d) {
      d && (S(t), S(n), S(r), S(a)), j(e, d), j(s, d), j(l, d), j(o, d), j(c, d);
    }
  };
}
f(Hhe, "create_default_slot_8");
function Uhe(i) {
  let e, t;
  return e = new Ye({
    props: {
      heading: "A5E.settings.conditionFlowDirection",
      hint: "A5E.settings.hints.conditionFlowDirection",
      options: Object.entries(
        /*conditionFlowDirectionChoices*/
        i[17]
      ),
      selected: (
        /*selectedConditionFlowDirection*/
        i[1]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[32]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*selectedConditionFlowDirection*/
      2 && (l.selected = /*selectedConditionFlowDirection*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Uhe, "create_default_slot_7$1");
function nL(i) {
  let e, t, s;
  function n(r) {
    i[33](r);
  }
  f(n, "settingscustomicon_reload_binding");
  let l = {
    conditionKey: (
      /*conditionKey*/
      i[49]
    ),
    icon: (
      /*icon*/
      i[50]
    )
  };
  return (
    /*reload*/
    i[0] !== void 0 && (l.reload = /*reload*/
    i[0]), e = new Rw({ props: l }), st.push(() => mt(e, "reload", n)), e.$on(
      "updateConditionIcon",
      /*updateConditionIcon_handler*/
      i[34]
    ), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, o) {
        const a = {};
        o[0] & /*customIcons*/
        8 && (a.conditionKey = /*conditionKey*/
        r[49]), o[0] & /*customIcons*/
        8 && (a.icon = /*icon*/
        r[50]), !t && o[0] & /*reload*/
        1 && (t = !0, a.reload = /*reload*/
        r[0], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(nL, "create_each_block$6");
function Vhe(i) {
  let e, t, s = oe(Object.entries(
    /*customIcons*/
    i[3]
  )), n = [];
  for (let r = 0; r < s.length; r += 1)
    n[r] = nL(sL(i, s, r));
  const l = /* @__PURE__ */ f((r) => C(n[r], 1, 1, () => {
    n[r] = null;
  }), "out");
  return {
    c() {
      e = E("ul");
      for (let r = 0; r < n.length; r += 1)
        n[r].c();
      b(e, "class", "condition-grid svelte-1lckagx");
    },
    m(r, o) {
      T(r, e, o);
      for (let a = 0; a < n.length; a += 1)
        n[a] && n[a].m(e, null);
      t = !0;
    },
    p(r, o) {
      if (o[0] & /*customIcons, reload, updateConditionIcon*/
      4105) {
        s = oe(Object.entries(
          /*customIcons*/
          r[3]
        ));
        let a;
        for (a = 0; a < s.length; a += 1) {
          const c = sL(r, s, a);
          n[a] ? (n[a].p(c, o), w(n[a], 1)) : (n[a] = nL(c), n[a].c(), w(n[a], 1), n[a].m(e, null));
        }
        for (ce(), a = s.length; a < n.length; a += 1)
          l(a);
        ue();
      }
    },
    i(r) {
      if (!t) {
        for (let o = 0; o < s.length; o += 1)
          w(n[o]);
        t = !0;
      }
    },
    o(r) {
      n = n.filter(Boolean);
      for (let o = 0; o < n.length; o += 1)
        C(n[o]);
      t = !1;
    },
    d(r) {
      r && S(e), Le(n, r);
    }
  };
}
f(Vhe, "create_default_slot_6$1");
function Whe(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.showEffectsPanel",
      checked: (
        /*updates*/
        i[13].get("showEffectsPanel") ?? /*$showEffectsPanel*/
        i[10] ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_6*/
    i[35]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*$showEffectsPanel*/
      1024 && (l.checked = /*updates*/
      s[13].get("showEffectsPanel") ?? /*$showEffectsPanel*/
      s[10] ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Whe, "create_default_slot_5$1");
function Khe(i) {
  let e, t, s, n, l, r;
  return {
    c() {
      e = E("label"), e.textContent = "Top Offset", t = R(), s = E("input"), b(e, "for", "top-offset"), b(s, "id", "top-offset"), b(s, "class", "a5e-input a5e-input--slim"), b(s, "type", "number"), s.value = n = /*selectedOffset*/
      i[5].top;
    },
    m(o, a) {
      T(o, e, a), T(o, t, a), T(o, s, a), l || (r = V(
        s,
        "change",
        /*change_handler*/
        i[37]
      ), l = !0);
    },
    p(o, a) {
      a[0] & /*selectedOffset*/
      32 && n !== (n = /*selectedOffset*/
      o[5].top) && s.value !== n && (s.value = n);
    },
    d(o) {
      o && (S(e), S(t), S(s)), l = !1, r();
    }
  };
}
f(Khe, "create_default_slot_4$1");
function Yhe(i) {
  let e, t, s, n, l, r;
  return {
    c() {
      e = E("label"), e.textContent = "Bottom Offset", t = R(), s = E("input"), b(e, "for", "bottom-offset"), b(s, "class", "a5e-input a5e-input--slim"), b(s, "type", "number"), s.value = n = /*selectedOffset*/
      i[5].bottom;
    },
    m(o, a) {
      T(o, e, a), T(o, t, a), T(o, s, a), l || (r = V(
        s,
        "change",
        /*change_handler_1*/
        i[38]
      ), l = !0);
    },
    p(o, a) {
      a[0] & /*selectedOffset*/
      32 && n !== (n = /*selectedOffset*/
      o[5].bottom) && s.value !== n && (s.value = n);
    },
    d(o) {
      o && (S(e), S(t), S(s)), l = !1, r();
    }
  };
}
f(Yhe, "create_default_slot_3$2");
function Xhe(i) {
  let e, t, s, n, l, r;
  return {
    c() {
      e = E("label"), e.textContent = "Right Offset", t = R(), s = E("input"), b(e, "for", "right-offset"), b(s, "class", "a5e-input a5e-input--slim"), b(s, "type", "number"), s.value = n = /*selectedOffset*/
      i[5].right;
    },
    m(o, a) {
      T(o, e, a), T(o, t, a), T(o, s, a), l || (r = V(
        s,
        "change",
        /*change_handler_2*/
        i[39]
      ), l = !0);
    },
    p(o, a) {
      a[0] & /*selectedOffset*/
      32 && n !== (n = /*selectedOffset*/
      o[5].right) && s.value !== n && (s.value = n);
    },
    d(o) {
      o && (S(e), S(t), S(s)), l = !1, r();
    }
  };
}
f(Xhe, "create_default_slot_2$2");
function Jhe(i) {
  let e, t, s, n, l, r, o;
  return t = new de({
    props: {
      $$slots: { default: [Khe] },
      $$scope: { ctx: i }
    }
  }), n = new de({
    props: {
      $$slots: { default: [Yhe] },
      $$scope: { ctx: i }
    }
  }), r = new de({
    props: {
      $$slots: { default: [Xhe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("div"), L(t.$$.fragment), s = R(), L(n.$$.fragment), l = R(), L(r.$$.fragment), b(e, "class", "u-flex u-gap-md");
    },
    m(a, c) {
      T(a, e, c), N(t, e, null), A(e, s), N(n, e, null), A(e, l), N(r, e, null), o = !0;
    },
    p(a, c) {
      const u = {};
      c[0] & /*selectedOffset*/
      32 | c[1] & /*$$scope*/
      4194304 && (u.$$scope = { dirty: c, ctx: a }), t.$set(u);
      const d = {};
      c[0] & /*selectedOffset*/
      32 | c[1] & /*$$scope*/
      4194304 && (d.$$scope = { dirty: c, ctx: a }), n.$set(d);
      const p = {};
      c[0] & /*selectedOffset*/
      32 | c[1] & /*$$scope*/
      4194304 && (p.$$scope = { dirty: c, ctx: a }), r.$set(p);
    },
    i(a) {
      o || (w(t.$$.fragment, a), w(n.$$.fragment, a), w(r.$$.fragment, a), o = !0);
    },
    o(a) {
      C(t.$$.fragment, a), C(n.$$.fragment, a), C(r.$$.fragment, a), o = !1;
    },
    d(a) {
      a && S(e), j(t), j(n), j(r);
    }
  };
}
f(Jhe, "create_default_slot_1$3");
function Zhe(i) {
  let e, t, s, n, l, r;
  return e = new de({
    props: {
      hint: "A5E.settings.hints.showEffectsPanel",
      $$slots: { default: [Whe] },
      $$scope: { ctx: i }
    }
  }), s = new Ye({
    props: {
      heading: "A5E.settings.effectsPanelIconSize",
      hint: "A5E.settings.hints.effectsPanelIconSize",
      options: Object.entries(
        /*iconSizeChoices*/
        i[18]
      ),
      selected: (
        /*selectedIconSize*/
        i[4]
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_7*/
    i[36]
  ), l = new de({
    props: {
      heading: "A5E.settings.effectsPanelPosition",
      hint: "A5E.settings.hints.effectsPanelPosition",
      $$slots: { default: [Jhe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment);
    },
    m(o, a) {
      N(e, o, a), T(o, t, a), N(s, o, a), T(o, n, a), N(l, o, a), r = !0;
    },
    p(o, a) {
      const c = {};
      a[0] & /*$showEffectsPanel, reload*/
      1025 | a[1] & /*$$scope*/
      4194304 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const u = {};
      a[0] & /*selectedIconSize*/
      16 && (u.selected = /*selectedIconSize*/
      o[4]), s.$set(u);
      const d = {};
      a[0] & /*selectedOffset*/
      32 | a[1] & /*$$scope*/
      4194304 && (d.$$scope = { dirty: a, ctx: o }), l.$set(d);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(s.$$.fragment, o), C(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (S(t), S(n)), j(e, o), j(s, o), j(l, o);
    }
  };
}
f(Zhe, "create_default_slot$b");
function Qhe(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p;
  return e = new Me({
    props: {
      heading: "A5E.settings.automateConditions",
      $$slots: { default: [Hhe] },
      $$scope: { ctx: i }
    }
  }), n = new Me({
    props: {
      heading: "Condition Interface Layout",
      $$slots: { default: [Uhe] },
      $$scope: { ctx: i }
    }
  }), o = new Me({
    props: {
      heading: "Custom Effect Icons",
      headerButtons: [
        {
          classes: "reset-button",
          label: "Reset Icons to Defaults",
          handler: (
            /*resetIcons*/
            i[11]
          )
        }
      ],
      $$slots: { default: [Vhe] },
      $$scope: { ctx: i }
    }
  }), u = new Me({
    props: {
      heading: "Effects Panel",
      $$slots: { default: [Zhe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), l = E("div"), L(n.$$.fragment), r = R(), a = E("div"), L(o.$$.fragment), c = R(), d = E("div"), L(u.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.5rem"), z(l, "display", "contents"), z(l, "--a5e-section-body-gap", "0.5rem"), z(a, "display", "contents"), z(a, "--a5e-section-body-gap", "0.5rem"), z(d, "display", "contents"), z(d, "--a5e-section-body-gap", "0.5rem");
    },
    m(m, g) {
      T(m, t, g), N(e, t, null), T(m, s, g), T(m, l, g), N(n, l, null), T(m, r, g), T(m, a, g), N(o, a, null), T(m, c, g), T(m, d, g), N(u, d, null), p = !0;
    },
    p(m, g) {
      const h = {};
      g[0] & /*$removeEffects, $radialEffects, reload, $automateUnconscious, $automateBloodied, selectedConditions*/
      965 | g[1] & /*$$scope*/
      4194304 && (h.$$scope = { dirty: g, ctx: m }), e.$set(h);
      const _ = {};
      g[0] & /*selectedConditionFlowDirection, reload*/
      3 | g[1] & /*$$scope*/
      4194304 && (_.$$scope = { dirty: g, ctx: m }), n.$set(_);
      const y = {};
      g[0] & /*customIcons, reload*/
      9 | g[1] & /*$$scope*/
      4194304 && (y.$$scope = { dirty: g, ctx: m }), o.$set(y);
      const k = {};
      g[0] & /*selectedOffset, selectedIconSize, $showEffectsPanel, reload*/
      1073 | g[1] & /*$$scope*/
      4194304 && (k.$$scope = { dirty: g, ctx: m }), u.$set(k);
    },
    i(m) {
      p || (w(e.$$.fragment, m), w(n.$$.fragment, m), w(o.$$.fragment, m), w(u.$$.fragment, m), p = !0);
    },
    o(m) {
      C(e.$$.fragment, m), C(n.$$.fragment, m), C(o.$$.fragment, m), C(u.$$.fragment, m), p = !1;
    },
    d(m) {
      m && (S(s), S(r), S(c)), m && e && S(t), j(e, m), m && n && S(l), j(n, m), m && o && S(a), j(o, m), m && u && S(d), j(u, m);
    }
  };
}
f(Qhe, "create_fragment$q");
function xhe(i, e, t) {
  let s, n, l, r, o, a, c, u, d, p, { reload: m } = e;
  function g() {
    return Object.entries(O).reduce(
      (Oe, [Je, Xe]) => {
        var Gt;
        return Oe[Je] = ((Gt = k.get("customConditionIcons")) == null ? void 0 : Gt[Je]) ?? (o == null ? void 0 : o[Je]) ?? Xe ?? "", Oe;
      },
      {}
    );
  }
  f(g, "getCustomIcons");
  async function h() {
    const Oe = new Fw();
    await Oe.render(!0);
    let Je = await Oe.promise;
    !Je || !Je.confirmReset || (Object.keys(O).forEach((Xe) => {
      const Gt = O[Xe];
      t(3, be[Xe] = Gt, be);
    }), k.set("customConditionIcons", be), t(0, m = !0), t(3, be = g()));
  }
  f(h, "resetIcons");
  function _(Oe, Je) {
    new FilePicker({
      type: "image",
      current: Je,
      callback: (Gt) => {
        t(3, be[Oe] = Gt, be), k.set("customConditionIcons", be), t(3, be = g()), t(0, m = !0);
      }
    }).browse();
  }
  f(_, "updateConditionIcon");
  const y = fe("settings"), k = fe("updates");
  let { conditions: v, conditionIconsDefault: O } = CONFIG.A5E;
  const P = Object.entries(v).reduce(
    (Oe, Je) => (["frightened"].includes(Je) || Oe.push(Je), Oe),
    []
  ), D = y.getStore("automateUnconsciousApplication");
  pe(i, D, (Oe) => t(7, c = Oe));
  const I = y.getStore("automatedConditions");
  pe(i, I, (Oe) => t(42, l = Oe));
  const B = game.settings.settings.get("a5e.conditionFlowDirection").choices, F = game.settings.settings.get("a5e.effectsPanelIconSize").choices;
  let H = y.getStore("automateBloodiedApplication");
  pe(i, H, (Oe) => t(6, a = Oe));
  let G = y.getStore("conditionFlowDirection");
  pe(i, G, (Oe) => t(43, r = Oe));
  let U = y.getStore("showEffectsPanel");
  pe(i, U, (Oe) => t(10, p = Oe));
  let q = y.getStore("effectsPanelIconSize");
  pe(i, q, (Oe) => t(41, n = Oe));
  let W = y.getStore("effectsPanelOffset");
  pe(i, W, (Oe) => t(40, s = Oe));
  let X = y.getStore("enableRadialEffects");
  pe(i, X, (Oe) => t(8, u = Oe));
  let te = y.getStore("removeActiveEffectsOnLongRest");
  pe(i, te, (Oe) => t(9, d = Oe));
  let J = y.getStore("customConditionIcons");
  pe(i, J, (Oe) => t(44, o = Oe));
  let re = k.get("conditionFlowDirection") ?? r, ae = k.get("automatedConditions") ?? l, be = g(), we = k.get("effectsPanelIconSize") ?? n ?? "medium", ve = k.get("effectsPanelOffset") ?? s;
  const me = /* @__PURE__ */ f(({ detail: Oe }) => {
    k.set("automatedConditions", Oe), t(2, ae = Oe), t(0, m = !0);
  }, "updateSelection_handler"), he = /* @__PURE__ */ f(({ detail: Oe }) => {
    k.set("automateBloodiedApplication", Oe), t(0, m = !0);
  }, "updateSelection_handler_1"), Ae = /* @__PURE__ */ f(({ detail: Oe }) => {
    k.set("automateUnconsciousApplication", Oe), t(0, m = !0);
  }, "updateSelection_handler_2"), Fe = /* @__PURE__ */ f(({ detail: Oe }) => {
    k.set("enableRadialEffects", Oe), t(0, m = !0);
  }, "updateSelection_handler_3"), Ve = /* @__PURE__ */ f(({ detail: Oe }) => {
    k.set("removeActiveEffectsOnLongRest", Oe);
  }, "updateSelection_handler_4"), je = /* @__PURE__ */ f(({ detail: Oe }) => {
    k.set("conditionFlowDirection", Oe), t(1, re = Oe), t(0, m = !0);
  }, "updateSelection_handler_5");
  function Pe(Oe) {
    m = Oe, t(0, m);
  }
  f(Pe, "settingscustomicon_reload_binding");
  const rt = /* @__PURE__ */ f(({ detail: Oe }) => _(...Oe), "updateConditionIcon_handler"), Te = /* @__PURE__ */ f(({ detail: Oe }) => {
    k.set("showEffectsPanel", Oe), t(0, m = !0);
  }, "updateSelection_handler_6"), Ee = /* @__PURE__ */ f(({ detail: Oe }) => {
    k.set("effectsPanelIconSize", Oe), t(4, we = Oe);
  }, "updateSelection_handler_7"), Be = /* @__PURE__ */ f(({ target: Oe }) => {
    const { value: Je } = Oe;
    t(5, ve.top = Number(Je), ve), k.set("effectsPanelOffset", ve);
  }, "change_handler"), Ce = /* @__PURE__ */ f(({ target: Oe }) => {
    const { value: Je } = Oe;
    t(5, ve.bottom = Number(Je), ve), k.set("effectsPanelOffset", ve);
  }, "change_handler_1"), Re = /* @__PURE__ */ f(({ target: Oe }) => {
    const { value: Je } = Oe;
    t(5, ve.right = Number(Je), ve), k.set("effectsPanelOffset", ve);
  }, "change_handler_2");
  return i.$$set = (Oe) => {
    "reload" in Oe && t(0, m = Oe.reload);
  }, [
    m,
    re,
    ae,
    be,
    we,
    ve,
    a,
    c,
    u,
    d,
    p,
    h,
    _,
    k,
    P,
    D,
    I,
    B,
    F,
    H,
    G,
    U,
    q,
    W,
    X,
    te,
    J,
    me,
    he,
    Ae,
    Fe,
    Ve,
    je,
    Pe,
    rt,
    Te,
    Ee,
    Be,
    Ce,
    Re
  ];
}
f(xhe, "instance$o");
const M3 = class M3 extends ie {
  constructor(e) {
    super(), le(this, e, xhe, Qhe, ne, { reload: 0 }, null, [-1, -1]);
  }
};
f(M3, "SettingsEffectsTab");
let jw = M3;
function ege(i) {
  let e, t, s, n, l, r, o;
  return e = new Me({
    props: {
      heading: "Sheet Settings",
      $$slots: { default: [nge] },
      $$scope: { ctx: i }
    }
  }), n = new Me({
    props: {
      heading: "Cascading Damage Settings",
      $$slots: { default: [rge] },
      $$scope: { ctx: i }
    }
  }), r = new Me({
    props: {
      heading: "Other Settings",
      $$slots: { default: [age] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), L(n.$$.fragment), l = R(), L(r.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(a, c) {
      T(a, t, c), N(e, t, null), T(a, s, c), N(n, a, c), T(a, l, c), N(r, a, c), o = !0;
    },
    p(a, c) {
      const u = {};
      c & /*$$scope, $fancySheetsAutoApply, reload, selectedNamingMode, $showLimitedDesc*/
      67108893 && (u.$$scope = { dirty: c, ctx: a }), e.$set(u);
      const d = {};
      c & /*$$scope, newCascadingDamageAndHealingDelay, $enableCascadingDamageAndHealing, reload*/
      67108899 && (d.$$scope = { dirty: c, ctx: a }), n.$set(d);
      const p = {};
      c & /*$$scope, reload*/
      67108865 && (p.$$scope = { dirty: c, ctx: a }), r.$set(p);
    },
    i(a) {
      o || (w(e.$$.fragment, a), w(n.$$.fragment, a), w(r.$$.fragment, a), o = !0);
    },
    o(a) {
      C(e.$$.fragment, a), C(n.$$.fragment, a), C(r.$$.fragment, a), o = !1;
    },
    d(a) {
      a && (S(s), S(l)), a && e && S(t), j(e, a), j(n, a), j(r, a);
    }
  };
}
f(ege, "create_if_block$c");
function tge(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.showDescriptionOnLimitedPerms",
      checked: (
        /*updates*/
        i[6].get("showDescriptionOnLimitedPerms") ?? /*$showLimitedDesc*/
        i[3] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[16]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$showLimitedDesc*/
      8 && (l.checked = /*updates*/
      s[6].get("showDescriptionOnLimitedPerms") ?? /*$showLimitedDesc*/
      s[3] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(tge, "create_default_slot_7");
function sge(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.autoApplyFancySheets",
      checked: (
        /*updates*/
        i[6].get("autoApplyFancySheets") ?? /*$fancySheetsAutoApply*/
        i[4] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[18]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$fancySheetsAutoApply*/
      16 && (l.checked = /*updates*/
      s[6].get("autoApplyFancySheets") ?? /*$fancySheetsAutoApply*/
      s[4] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(sge, "create_default_slot_6");
function nge(i) {
  let e, t, s, n, l, r;
  return e = new de({
    props: {
      hint: "A5E.settings.hints.showDescriptionOnLimitedPerms",
      $$slots: { default: [tge] },
      $$scope: { ctx: i }
    }
  }), s = new Ye({
    props: {
      hint: "A5E.settings.hints.newActionNameType",
      options: (
        /*actionTypeOptions*/
        i[8]
      ),
      selected: (
        /*selectedNamingMode*/
        i[2]
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[17]
  ), l = new de({
    props: {
      hint: "A5E.settings.hints.autoApplyFancySheets",
      $$slots: { default: [sge] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), L(l.$$.fragment);
    },
    m(o, a) {
      N(e, o, a), T(o, t, a), N(s, o, a), T(o, n, a), N(l, o, a), r = !0;
    },
    p(o, a) {
      const c = {};
      a & /*$$scope, $showLimitedDesc, reload*/
      67108873 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c);
      const u = {};
      a & /*selectedNamingMode*/
      4 && (u.selected = /*selectedNamingMode*/
      o[2]), s.$set(u);
      const d = {};
      a & /*$$scope, $fancySheetsAutoApply, reload*/
      67108881 && (d.$$scope = { dirty: a, ctx: o }), l.$set(d);
    },
    i(o) {
      r || (w(e.$$.fragment, o), w(s.$$.fragment, o), w(l.$$.fragment, o), r = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(s.$$.fragment, o), C(l.$$.fragment, o), r = !1;
    },
    d(o) {
      o && (S(t), S(n)), j(e, o), j(s, o), j(l, o);
    }
  };
}
f(nge, "create_default_slot_5");
function ige(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.enableCascadingDamageAndHealing",
      checked: (
        /*updates*/
        i[6].get("enableCascadingDamageAndHealing") ?? /*$enableCascadingDamageAndHealing*/
        i[5] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[19]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$enableCascadingDamageAndHealing*/
      32 && (l.checked = /*updates*/
      s[6].get("enableCascadingDamageAndHealing") ?? /*$enableCascadingDamageAndHealing*/
      s[5] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(ige, "create_default_slot_4");
function lge(i) {
  let e, t, s;
  return {
    c() {
      e = E("input"), b(e, "type", "number"), e.value = /*newCascadingDamageAndHealingDelay*/
      i[1];
    },
    m(n, l) {
      T(n, e, l), t || (s = V(
        e,
        "change",
        /*change_handler*/
        i[20]
      ), t = !0);
    },
    p(n, l) {
      l & /*newCascadingDamageAndHealingDelay*/
      2 && e.value !== /*newCascadingDamageAndHealingDelay*/
      n[1] && (e.value = /*newCascadingDamageAndHealingDelay*/
      n[1]);
    },
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(lge, "create_default_slot_3$1");
function rge(i) {
  let e, t, s, n;
  return e = new de({
    props: {
      hint: "A5E.settings.hints.enableCascadingDamageAndHealing",
      $$slots: { default: [ige] },
      $$scope: { ctx: i }
    }
  }), s = new de({
    props: {
      heading: "A5E.settings.cascadingDamageAndHealingDelay",
      hint: "A5E.settings.hints.cascadingDamageAndHealingDelay",
      $$slots: { default: [lge] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*$$scope, $enableCascadingDamageAndHealing, reload*/
      67108897 && (o.$$scope = { dirty: r, ctx: l }), e.$set(o);
      const a = {};
      r & /*$$scope, newCascadingDamageAndHealingDelay*/
      67108866 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(rge, "create_default_slot_2$1");
function oge(i) {
  let e, t, s;
  return {
    c() {
      e = E("input"), b(e, "type", "text"), e.value = /*selectedGamemasterTitle*/
      i[15];
    },
    m(n, l) {
      T(n, e, l), t || (s = V(
        e,
        "change",
        /*change_handler_1*/
        i[21]
      ), t = !0);
    },
    p: ee,
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(oge, "create_default_slot_1$2");
function age(i) {
  let e, t;
  return e = new de({
    props: {
      heading: "Gamemaster Title",
      $$slots: { default: [oge] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, reload*/
      67108865 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(age, "create_default_slot$a");
function cge(i) {
  let e, t, s = (
    /*isGM*/
    i[7] && ege(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(n, l) {
      s && s.m(n, l), T(n, e, l), t = !0;
    },
    p(n, [l]) {
      /*isGM*/
      n[7] && s.p(n, l);
    },
    i(n) {
      t || (w(s), t = !0);
    },
    o(n) {
      C(s), t = !1;
    },
    d(n) {
      n && S(e), s && s.d(n);
    }
  };
}
f(cge, "create_fragment$p");
function uge(i, e, t) {
  let s, n, l, r, o, a, { reload: c } = e;
  const u = fe("settings"), d = fe("updates"), p = game.user.isGM, m = [["system", "System Defined"], ["action", "New Action"], ["item", "Item Name"]];
  let g = u.getStore("newActionNameType");
  pe(i, g, (q) => t(23, n = q));
  let h = u.getStore("autoApplyFancySheets");
  pe(i, h, (q) => t(4, o = q));
  let _ = u.getStore("gamemasterTitle");
  pe(i, _, (q) => t(22, s = q));
  let y = u.getStore("showDescriptionOnLimitedPerms");
  pe(i, y, (q) => t(3, r = q));
  let k = u.getStore("cascadingDamageAndHealingDelay");
  pe(i, k, (q) => t(24, l = q));
  let v = u.getStore("enableCascadingDamageAndHealing");
  pe(i, v, (q) => t(5, a = q));
  let O = d.get("cascadingDamageAndHealingDelay") ?? l, P = d.get("newActionNameType") ?? n ?? "system", D = d.get("gamemasterTitle") ?? s;
  const I = /* @__PURE__ */ f(({ detail: q }) => {
    d.set("showDescriptionOnLimitedPerms", q), t(0, c = !0);
  }, "updateSelection_handler"), B = /* @__PURE__ */ f(({ detail: q }) => {
    d.set("newActionNameType", q), t(2, P = q);
  }, "updateSelection_handler_1"), F = /* @__PURE__ */ f(({ detail: q }) => {
    d.set("autoApplyFancySheets", q), t(0, c = !0);
  }, "updateSelection_handler_2"), H = /* @__PURE__ */ f(({ detail: q }) => {
    d.set("enableCascadingDamageAndHealing", q), t(0, c = !0);
  }, "updateSelection_handler_3"), G = /* @__PURE__ */ f(({ target: q }) => {
    const { value: W } = q;
    t(1, O = Number(W)), d.set("cascadingDamageAndHealingDelay", Number(W));
  }, "change_handler"), U = /* @__PURE__ */ f(({ target: q }) => {
    var W, X;
    d.set("gamemasterTitle", ((X = (W = q.value) == null ? void 0 : W.trim) == null ? void 0 : X.call(W)) ?? ""), t(0, c = !0);
  }, "change_handler_1");
  return i.$$set = (q) => {
    "reload" in q && t(0, c = q.reload);
  }, [
    c,
    O,
    P,
    r,
    o,
    a,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    k,
    v,
    D,
    I,
    B,
    F,
    H,
    G,
    U
  ];
}
f(uge, "instance$n");
const R3 = class R3 extends ie {
  constructor(e) {
    super(), le(this, e, uge, cge, ne, { reload: 0 });
  }
};
f(R3, "SettingsMiscTab");
let Lw = R3;
function fge(i) {
  let e, t;
  return e = new De({
    props: {
      label: "Show character images in the party viewer",
      checked: (
        /*updates*/
        i[3].get("showActorImagesInPartyViewer") ?? /*$showActorImages*/
        i[1] ?? !0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[7]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$showActorImages*/
      2 && (l.checked = /*updates*/
      s[3].get("showActorImagesInPartyViewer") ?? /*$showActorImages*/
      s[1] ?? !0), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(fge, "create_default_slot_3");
function dge(i) {
  let e, t;
  return e = new de({
    props: {
      $$slots: { default: [fge] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $showActorImages, reload*/
      1027 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(dge, "create_default_slot_2");
function pge(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Player Access",
      $$slots: { default: [hge] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, l) {
      const r = {};
      l & /*$$scope, $playersCanAccess, reload*/
      1029 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(pge, "create_if_block$b");
function mge(i) {
  let e, t;
  return e = new De({
    props: {
      label: "Players can access the Party Viewer",
      checked: (
        /*updates*/
        i[3].get("playersCanAccessPartyViewer") ?? /*$playersCanAccess*/
        i[2] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[8]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$playersCanAccess*/
      4 && (l.checked = /*updates*/
      s[3].get("playersCanAccessPartyViewer") ?? /*$playersCanAccess*/
      s[2] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(mge, "create_default_slot_1$1");
function hge(i) {
  let e, t;
  return e = new de({
    props: {
      hint: "Players will be able to view but not edit the summary information in the Party Viewer window.",
      $$slots: { default: [mge] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope, $playersCanAccess, reload*/
      1029 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(hge, "create_default_slot$9");
function gge(i) {
  let e, t, s, n, l;
  e = new Me({
    props: {
      heading: "Appearance",
      $$slots: { default: [dge] },
      $$scope: { ctx: i }
    }
  });
  let r = (
    /*isGM*/
    i[4] && pge(i)
  );
  return {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), r && r.c(), n = $e(), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(o, a) {
      T(o, t, a), N(e, t, null), T(o, s, a), r && r.m(o, a), T(o, n, a), l = !0;
    },
    p(o, [a]) {
      const c = {};
      a & /*$$scope, $showActorImages, reload*/
      1027 && (c.$$scope = { dirty: a, ctx: o }), e.$set(c), /*isGM*/
      o[4] && r.p(o, a);
    },
    i(o) {
      l || (w(e.$$.fragment, o), w(r), l = !0);
    },
    o(o) {
      C(e.$$.fragment, o), C(r), l = !1;
    },
    d(o) {
      o && (S(s), S(n)), o && e && S(t), j(e, o), r && r.d(o);
    }
  };
}
f(gge, "create_fragment$o");
function bge(i, e, t) {
  let s, n, { reload: l } = e;
  const r = fe("settings"), o = fe("updates"), a = game.user.isGM;
  let c = r.getStore("playersCanAccessPartyViewer");
  pe(i, c, (m) => t(2, n = m));
  let u = r.getStore("showActorImagesInPartyViewer");
  pe(i, u, (m) => t(1, s = m));
  const d = /* @__PURE__ */ f(({ detail: m }) => {
    o.set("showActorImagesInPartyViewer", m), t(0, l = !0);
  }, "updateSelection_handler"), p = /* @__PURE__ */ f(({ detail: m }) => {
    o.set("playersCanAccessPartyViewer", m), t(0, l = !0);
  }, "updateSelection_handler_1");
  return i.$$set = (m) => {
    "reload" in m && t(0, l = m.reload);
  }, [
    l,
    s,
    n,
    o,
    a,
    c,
    u,
    d,
    p
  ];
}
f(bge, "instance$m");
const F3 = class F3 extends ie {
  constructor(e) {
    super(), le(this, e, bge, gge, ne, { reload: 0 });
  }
};
f(F3, "SettingsPartyViewerTab");
let Bw = F3;
function _ge(i) {
  let e, t;
  return e = new De({
    props: {
      label: "A5E.settings.preventActionRollOnWarning",
      checked: (
        /*updates*/
        i[2].get("preventActionRollOnWarning") ?? /*$preventActivationRoll*/
        i[1] ?? !1
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[7]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$preventActivationRoll*/
      2 && (l.checked = /*updates*/
      s[2].get("preventActionRollOnWarning") ?? /*$preventActivationRoll*/
      s[1] ?? !1), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(_ge, "create_default_slot_1");
function yge(i) {
  let e, t, s, n;
  return e = new Ye({
    props: {
      hint: "A5E.settings.hints.critCalculationMode",
      options: Object.entries(
        /*critCalculationModeOptions*/
        i[5]
      ),
      selected: (
        /*selectedCritMode*/
        i[0]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[6]
  ), s = new de({
    props: {
      hint: "A5E.settings.hints.preventActionRollOnWarning",
      $$slots: { default: [_ge] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*selectedCritMode*/
      1 && (o.selected = /*selectedCritMode*/
      l[0]), e.$set(o);
      const a = {};
      r & /*$$scope, $preventActivationRoll*/
      1026 && (a.$$scope = { dirty: r, ctx: l }), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(yge, "create_default_slot$8");
function vge(i) {
  let e, t, s;
  return e = new Me({
    props: {
      heading: "Generic Roll Settings",
      $$slots: { default: [yge] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.5rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, $preventActivationRoll, selectedCritMode*/
      1027 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(vge, "create_fragment$n");
function kge(i, e, t) {
  let s, n;
  const l = fe("settings"), r = fe("updates");
  let o = l.getStore("critCalculationMode");
  pe(i, o, (m) => t(8, s = m));
  let a = l.getStore("preventActionRollOnWarning");
  pe(i, a, (m) => t(1, n = m));
  let c = r.get("critCalculationMode") ?? s;
  const u = game.settings.settings.get("a5e.critCalculationMode").choices;
  return [
    c,
    n,
    r,
    o,
    a,
    u,
    /* @__PURE__ */ f(({ detail: m }) => {
      r.set("critCalculationMode", m), t(0, c = m);
    }, "updateSelection_handler"),
    /* @__PURE__ */ f(({ detail: m }) => {
      r.set("preventActionRollOnWarning", m);
    }, "updateSelection_handler_1")
  ];
}
f(kge, "instance$l");
const N3 = class N3 extends ie {
  constructor(e) {
    super(), le(this, e, kge, vge, ne, {});
  }
};
f(N3, "SettingsRollTab");
let qw = N3;
function wge(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "fas fa-save");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(wge, "create_else_block$2");
function $ge(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "fa-solid fa-circle-exclamation"), z(e, "color", "$color-warning"), b(e, "data-tooltip", K("A5E.settings.reload")), b(e, "data-tooltip-direction", "UP");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f($ge, "create_if_block$a");
function Age(i) {
  let e, t, s, n, l, r, o, a, c, u = K("A5E.SaveSubmit") + "", d, p, m, g;
  t = new bn({
    props: {
      currentTab: (
        /*currentTab*/
        i[1]
      ),
      tabs: (
        /*tabs*/
        i[5]
      )
    }
  }), t.$on(
    "tab-change",
    /*updateCurrentTab*/
    i[4]
  );
  function h(P) {
    i[10](P);
  }
  f(h, "switch_instance_reload_binding");
  var _ = (
    /*currentTab*/
    i[1].component
  );
  function y(P, D) {
    let I = {};
    return (
      /*reload*/
      P[2] !== void 0 && (I.reload = /*reload*/
      P[2]), { props: I }
    );
  }
  f(y, "switch_props"), _ && (l = nt(_, y(i)), st.push(() => mt(l, "reload", h)));
  function k(P, D) {
    return (
      /*reload*/
      P[2] ? $ge : wge
    );
  }
  f(k, "select_block_type");
  let v = k(i), O = v(i);
  return {
    c() {
      e = E("main"), L(t.$$.fragment), s = R(), n = E("section"), l && L(l.$$.fragment), o = R(), a = E("button"), O.c(), c = R(), d = x(u), b(n, "class", "a5e-page-wrapper a5e-page-wrapper--scrollable"), b(a, "class", "submit svelte-12x0wls"), b(e, "class", "svelte-12x0wls");
    },
    m(P, D) {
      T(P, e, D), N(t, e, null), A(e, s), A(e, n), l && N(l, n, null), A(e, o), A(e, a), O.m(a, null), A(a, c), A(a, d), p = !0, m || (g = V(a, "click", tt(
        /*click_handler*/
        i[11]
      )), m = !0);
    },
    p(P, D) {
      const I = {};
      if (D & /*currentTab*/
      2 && (I.currentTab = /*currentTab*/
      P[1]), t.$set(I), D & /*currentTab*/
      2 && _ !== (_ = /*currentTab*/
      P[1].component)) {
        if (l) {
          ce();
          const B = l;
          C(B.$$.fragment, 1, 0, () => {
            j(B, 1);
          }), ue();
        }
        _ ? (l = nt(_, y(P)), st.push(() => mt(l, "reload", h)), L(l.$$.fragment), w(l.$$.fragment, 1), N(l, n, null)) : l = null;
      } else if (_) {
        const B = {};
        !r && D & /*reload*/
        4 && (r = !0, B.reload = /*reload*/
        P[2], _t(() => r = !1)), l.$set(B);
      }
      v !== (v = k(P)) && (O.d(1), O = v(P), O && (O.c(), O.m(a, c)));
    },
    i(P) {
      p || (w(t.$$.fragment, P), l && w(l.$$.fragment, P), p = !0);
    },
    o(P) {
      C(t.$$.fragment, P), l && C(l.$$.fragment, P), p = !1;
    },
    d(P) {
      P && S(e), j(t), l && j(l), O.d(), m = !1, g();
    }
  };
}
f(Age, "create_default_slot$7");
function Ege(i) {
  let e, t, s;
  function n(r) {
    i[12](r);
  }
  f(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [Age] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Ss({ props: l }), st.push(() => mt(e, "elementRoot", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, reload, currentTab*/
        131078 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(Ege, "create_fragment$m");
function Sge(i, e, t) {
  let s, { elementRoot: n } = e, { appId: l, settings: r, dialog: o } = fe("#external").application, { appId: a = l, settings: c = r, dialog: u = o } = e;
  function d() {
    for (const [I, B] of h)
      c.getStore(I).set(B);
    u.submit({ reload: _ });
  }
  f(d, "onSubmit");
  function p(I) {
    t(1, g = m[I.detail]);
  }
  f(p, "updateCurrentTab");
  const m = [
    {
      name: "actor",
      label: "A5E.settings.navigation.actor",
      component: Iw
    },
    {
      name: "canvas",
      label: "A5E.settings.navigation.canvas",
      component: Pw,
      display: game.user.isGM
    },
    {
      name: "chat",
      label: "A5E.settings.navigation.chat",
      component: Mw
    },
    {
      name: "effects",
      label: "A5E.settings.navigation.activeEffects",
      component: jw,
      display: game.user.isGM
    },
    {
      name: "partyViewer",
      label: "Party Viewer",
      component: Bw,
      display: s
    },
    {
      name: "rolls",
      label: "A5E.settings.navigation.rolls",
      component: qw,
      display: game.user.isGM
    },
    {
      name: "5eSettings",
      label: "A5E.settings.navigation.5eSettings",
      component: Dw,
      display: game.user.isGM
    },
    {
      name: "misc",
      label: "A5E.settings.navigation.misc",
      component: Lw,
      display: game.user.isGM
    }
  ];
  let g = m[0], h = /* @__PURE__ */ new Map(), _ = !1, { settingsData: y } = c, k = y.reduce(
    (I, B) => {
      var F;
      return ((F = B == null ? void 0 : B.options) == null ? void 0 : F.scope) === "world" && I.add(B.key), I;
    },
    /* @__PURE__ */ new Set()
  );
  const v = c.getStore("playersCanAccessPartyViewer");
  pe(i, v, (I) => t(13, s = I)), et("appId", a), et("gmSettings", k), et("settings", c), et("updates", h);
  function O(I) {
    _ = I, t(2, _);
  }
  f(O, "switch_instance_reload_binding");
  const P = /* @__PURE__ */ f(() => d(), "click_handler");
  function D(I) {
    n = I, t(0, n);
  }
  return f(D, "applicationshell_elementRoot_binding"), i.$$set = (I) => {
    "elementRoot" in I && t(0, n = I.elementRoot), "appId" in I && t(7, a = I.appId), "settings" in I && t(8, c = I.settings), "dialog" in I && t(9, u = I.dialog);
  }, [
    n,
    g,
    _,
    d,
    p,
    m,
    v,
    a,
    c,
    u,
    O,
    P,
    D
  ];
}
f(Sge, "instance$k");
var vf;
let Tge = (vf = class extends ie {
  constructor(e) {
    super(), le(this, e, Sge, Ege, ne, {
      elementRoot: 0,
      appId: 7,
      settings: 8,
      dialog: 9
    });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Ke();
  }
  get appId() {
    return this.$$.ctx[7];
  }
  set appId(e) {
    this.$$set({ appId: e }), Ke();
  }
  get settings() {
    return this.$$.ctx[8];
  }
  set settings(e) {
    this.$$set({ settings: e }), Ke();
  }
  get dialog() {
    return this.$$.ctx[9];
  }
  set dialog(e) {
    this.$$set({ dialog: e }), Ke();
  }
}, f(vf, "SystemSettings"), vf);
var o1, _q;
const j3 = class j3 extends _s {
  constructor(t = {}, s = {}) {
    super({
      id: "a5e-system-settings",
      title: K("A5E.settings.title"),
      svelte: {
        class: Tge,
        target: document.body,
        props: {
          settings: Aa
        }
      },
      width: 600,
      height: "auto",
      ...t
    }, { dialogData: s });
    Y(this, o1);
    Ge(this, "promise", null);
    Ge(this, "resolve", null);
    this.options.svelte.props.dialog = this, this.promise = new Promise((n) => {
      this.resolve = n;
    });
  }
  /**
   * Default Application options
   *
   * @returns {object} options - Application options.
   * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["a5e-sheet", "a5e-settings-sheet"],
      minimizable: !0,
      svelte: {
        target: document.body
      },
      token: null
    });
  }
  static getActiveApp() {
    return Object.values(ui.windows).find((t) => t.id === "a5e-system-settings");
  }
  static async show(t = {}, s = {}) {
    const n = this.getActiveApp();
    return n ? n.render(!1, { focus: !0 }) : new Promise((l) => {
      t.resolve = l, new this(t, s).render(!0, { focus: !0 });
    });
  }
  submit(t) {
    return Z(this, o1, _q).call(this, t), t.reload && foundry.utils.debounce(() => window.location.reload(), 250)(), super.close();
  }
};
o1 = new WeakSet(), _q = /* @__PURE__ */ f(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), f(j3, "SystemSettings");
let Ip = j3;
function Cge() {
  game.keybindings.register("a5e", "party-sheet-open-close", {
    name: "Open/Close Party Sheet",
    editable: [{ key: "KeyP" }],
    onDown: () => {
      !game.user.isGM && !game.settings.get("a5e", "playersCanAccessPartyViewer") || bq(!0);
    }
  }), game.keybindings.register("a5e", "system-settings-open-close", {
    name: "Open/Close System Settings",
    editable: [{ key: "KeyS", modifiers: ["Alt"] }],
    onDown: () => {
      Ip.show();
    }
  });
}
f(Cge, "registerKeybindings");
async function Oge(i) {
  i.preventDefault();
  const e = this.viewed, t = i.currentTarget;
  if (t.getAttribute("disabled"))
    return;
  t.setAttribute("disabled", !0);
  const s = e[t.dataset.control];
  let n = i.shiftKey ? CONFIG.A5E.ROLL_MODE.ADVANTAGE : CONFIG.A5E.ROLL_MODE.NORMAL;
  n = i.metaKey || i.ctrlKey ? CONFIG.A5E.ROLL_MODE.DISADVANTAGE : n, s && await s.bind(e)({
    rollOptions: {
      rollMode: n,
      skipRollDialog: game.settings.get(
        "a5e",
        "reverseInitiativeAltBehavior"
      ) ? !i.altKey : i.altKey
    }
  }), t.removeAttribute("disabled");
}
f(Oge, "_onCombatControl");
async function Dge(i) {
  i.preventDefault(), i.stopPropagation();
  const e = i.currentTarget, t = e.closest(".combatant"), s = this.viewed, n = s.combatants.get(t.dataset.combatantId);
  let l = i.shiftKey ? CONFIG.A5E.ROLL_MODE.ADVANTAGE : CONFIG.A5E.ROLL_MODE.NORMAL;
  switch (l = i.metaKey || i.ctrlKey ? CONFIG.A5E.ROLL_MODE.DISADVANTAGE : l, e.dataset.control) {
    case "toggleHidden":
      return n.update({ hidden: !n.hidden });
    case "toggleDefeated":
      return this._onToggleDefeatedStatus(n);
    case "rollInitiative":
      return s.rollInitiative([n.id], {
        rollOptions: {
          rollMode: l,
          skipRollDialog: game.settings.get(
            "a5e",
            "reverseInitiativeAltBehavior"
          ) ? !i.altKey : i.altKey
        }
      });
    case "pingCombatant":
      return this._onPingCombatant(n);
  }
}
f(Dge, "_onCombatantControl");
function Ige(i, e = {}) {
  const { skillKey: t } = e, { initiative: s } = i.system.attributes, n = e.abilityKey ?? "dex", l = (e == null ? void 0 : e.rollMode) ?? CONFIG.A5E.ROLL_MODE.NORMAL, r = i.RollOverrideManager.getRollOverride(
    "initiative",
    l,
    { ability: n }
  ), o = new Oc(i, {
    ability: n,
    expertiseDie: e.expertiseDice ?? s.expertiseDice,
    type: "initiative",
    situationalMods: e.situationalMods,
    skill: t
  });
  return V5({
    actor: i,
    rollMode: r,
    modifiers: o.getModifiers()
  }).rollFormula;
}
f(Ige, "getDefaultInitiativeFormula");
function iL(i) {
  let e, t;
  return e = new Ze({
    props: {
      heading: "Ability Bonuses",
      options: (
        /*abilityBonuses*/
        i[12].map(oL)
      ),
      selected: (
        /*selectedAbilityBonuses*/
        i[5]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[27]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*abilityBonuses*/
      4096 && (l.options = /*abilityBonuses*/
      s[12].map(oL)), n[0] & /*selectedAbilityBonuses*/
      32 && (l.selected = /*selectedAbilityBonuses*/
      s[5]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(iL, "create_if_block_2$4");
function lL(i) {
  let e, t;
  return e = new Ze({
    props: {
      heading: "Skill Bonuses",
      options: (
        /*skillBonuses*/
        i[11].map(aL)
      ),
      selected: (
        /*selectedSkillBonuses*/
        i[4]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_5*/
    i[28]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*skillBonuses*/
      2048 && (l.options = /*skillBonuses*/
      s[11].map(aL)), n[0] & /*selectedSkillBonuses*/
      16 && (l.selected = /*selectedSkillBonuses*/
      s[4]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(lL, "create_if_block_1$7");
function rL(i) {
  let e, t;
  return e = new Ze({
    props: {
      heading: "Initiative Bonuses",
      options: (
        /*initiativeBonuses*/
        i[10].map(cL)
      ),
      selected: (
        /*selectedInitiativeBonuses*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_6*/
    i[29]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n[0] & /*initiativeBonuses*/
      1024 && (l.options = /*initiativeBonuses*/
      s[10].map(cL)), n[0] & /*selectedInitiativeBonuses*/
      8 && (l.selected = /*selectedInitiativeBonuses*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(rL, "create_if_block$9");
function Pge(i) {
  let e, t, s, n;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text"), b(e, "id", t = /*$actor*/
      i[8].id + "-" + /*appId*/
      i[16] + "-situational-mods");
    },
    m(l, r) {
      T(l, e, r), qe(
        e,
        /*situationalMods*/
        i[2]
      ), s || (n = V(
        e,
        "input",
        /*input_input_handler*/
        i[30]
      ), s = !0);
    },
    p(l, r) {
      r[0] & /*$actor*/
      256 && t !== (t = /*$actor*/
      l[8].id + "-" + /*appId*/
      l[16] + "-situational-mods") && b(e, "id", t), r[0] & /*situationalMods*/
      4 && e.value !== /*situationalMods*/
      l[2] && qe(
        e,
        /*situationalMods*/
        l[2]
      );
    },
    d(l) {
      l && S(e), s = !1, n();
    }
  };
}
f(Pge, "create_default_slot$6");
function Mge(i) {
  let e, t, s, n, l, r, o, a, c, u = Object.values(
    /*abilityBonuses*/
    i[12]
  ).flat().length, d, p = Object.values(
    /*skillBonuses*/
    i[11]
  ).flat().length, m, g = Object.values(
    /*initiativeBonuses*/
    i[10]
  ).flat().length, h, _, y, k, v, O, P, D, I, B, F;
  t = new ml({
    props: {
      selected: (
        /*rollMode*/
        i[6]
      ),
      source: (
        /*rollModeString*/
        i[13]
      )
    }
  }), t.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[23]
  ), n = new Ye({
    props: {
      heading: "A5E.AbilityScore",
      options: Object.entries(
        /*abilities*/
        i[17]
      ),
      selected: (
        /*abilityKey*/
        i[0]
      )
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[24]
  ), r = new Ye({
    props: {
      heading: "A5E.Skill",
      options: Object.entries(
        /*skills*/
        i[18]
      ),
      selected: (
        /*skillKey*/
        i[1]
      )
    }
  }), r.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[25]
  ), a = new hn({
    props: {
      source: (
        /*expertiseDieSource*/
        i[14]
      ),
      selected: (
        /*expertiseDie*/
        i[7]
      ),
      type: (
        /*$actor*/
        i[8].type
      )
    }
  }), a.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[26]
  );
  let H = u && iL(i), G = p && lL(i), U = g && rL(i);
  return _ = new de({
    props: {
      heading: "A5E.SituationalMods",
      $$slots: { default: [Pge] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), L(t.$$.fragment), s = R(), L(n.$$.fragment), l = R(), L(r.$$.fragment), o = R(), L(a.$$.fragment), c = R(), H && H.c(), d = R(), G && G.c(), m = R(), U && U.c(), h = R(), L(_.$$.fragment), y = R(), k = E("section"), v = x(
        /*rollFormula*/
        i[9]
      ), O = R(), P = E("section"), D = E("button"), D.textContent = "Roll Initiative", b(k, "class", "roll-formula-preview svelte-cfnill"), b(e, "class", "svelte-cfnill");
    },
    m(q, W) {
      T(q, e, W), N(t, e, null), A(e, s), N(n, e, null), A(e, l), N(r, e, null), A(e, o), N(a, e, null), A(e, c), H && H.m(e, null), A(e, d), G && G.m(e, null), A(e, m), U && U.m(e, null), A(e, h), N(_, e, null), A(e, y), A(e, k), A(k, v), A(e, O), A(e, P), A(P, D), I = !0, B || (F = V(D, "click", tt(
        /*onSubmit*/
        i[19]
      )), B = !0);
    },
    p(q, W) {
      const X = {};
      W[0] & /*rollMode*/
      64 && (X.selected = /*rollMode*/
      q[6]), W[0] & /*rollModeString*/
      8192 && (X.source = /*rollModeString*/
      q[13]), t.$set(X);
      const te = {};
      W[0] & /*abilityKey*/
      1 && (te.selected = /*abilityKey*/
      q[0]), n.$set(te);
      const J = {};
      W[0] & /*skillKey*/
      2 && (J.selected = /*skillKey*/
      q[1]), r.$set(J);
      const re = {};
      W[0] & /*expertiseDieSource*/
      16384 && (re.source = /*expertiseDieSource*/
      q[14]), W[0] & /*expertiseDie*/
      128 && (re.selected = /*expertiseDie*/
      q[7]), W[0] & /*$actor*/
      256 && (re.type = /*$actor*/
      q[8].type), a.$set(re), W[0] & /*abilityBonuses*/
      4096 && (u = Object.values(
        /*abilityBonuses*/
        q[12]
      ).flat().length), u ? H ? (H.p(q, W), W[0] & /*abilityBonuses*/
      4096 && w(H, 1)) : (H = iL(q), H.c(), w(H, 1), H.m(e, d)) : H && (ce(), C(H, 1, 1, () => {
        H = null;
      }), ue()), W[0] & /*skillBonuses*/
      2048 && (p = Object.values(
        /*skillBonuses*/
        q[11]
      ).flat().length), p ? G ? (G.p(q, W), W[0] & /*skillBonuses*/
      2048 && w(G, 1)) : (G = lL(q), G.c(), w(G, 1), G.m(e, m)) : G && (ce(), C(G, 1, 1, () => {
        G = null;
      }), ue()), W[0] & /*initiativeBonuses*/
      1024 && (g = Object.values(
        /*initiativeBonuses*/
        q[10]
      ).flat().length), g ? U ? (U.p(q, W), W[0] & /*initiativeBonuses*/
      1024 && w(U, 1)) : (U = rL(q), U.c(), w(U, 1), U.m(e, h)) : U && (ce(), C(U, 1, 1, () => {
        U = null;
      }), ue());
      const ae = {};
      W[0] & /*$actor, situationalMods*/
      260 | W[1] & /*$$scope*/
      8 && (ae.$$scope = { dirty: W, ctx: q }), _.$set(ae), (!I || W[0] & /*rollFormula*/
      512) && _e(
        v,
        /*rollFormula*/
        q[9]
      );
    },
    i(q) {
      I || (w(t.$$.fragment, q), w(n.$$.fragment, q), w(r.$$.fragment, q), w(a.$$.fragment, q), w(H), w(G), w(U), w(_.$$.fragment, q), I = !0);
    },
    o(q) {
      C(t.$$.fragment, q), C(n.$$.fragment, q), C(r.$$.fragment, q), C(a.$$.fragment, q), C(H), C(G), C(U), C(_.$$.fragment, q), I = !1;
    },
    d(q) {
      q && S(e), j(t), j(n), j(r), j(a), H && H.d(), G && G.d(), U && U.d(), j(_), B = !1, F();
    }
  };
}
f(Mge, "create_fragment$l");
const oL = /* @__PURE__ */ f(([i, e]) => [i, e.label || e.defaultLabel], "func$1"), aL = /* @__PURE__ */ f(([i, e]) => [i, e.label || e.defaultLabel], "func_1$1"), cL = /* @__PURE__ */ f(([i, e]) => [i, e.label || e.defaultLabel], "func_2");
function Rge(i, e, t) {
  let s, n, l, r, o, a, c, u, d, p, m, { document: g, dialog: h, options: _ } = fe("#external").application, { document: y = g, dialog: k = h, options: v = _ } = e;
  function O() {
    return B ? 0 : m.RollOverrideManager.getExpertiseDice("initiative", v.expertiseDice ?? 0, { ability: G, skill: q });
  }
  f(O, "getInitialExpertiseDieSelection");
  const P = new Bt(y.actor);
  pe(i, P, (he) => t(8, m = he));
  const D = k.id, I = CONFIG.A5E.abilities, B = game.settings.get("a5e", "hideExpertiseDice"), F = { none: "None", ...CONFIG.A5E.skills };
  game.settings.get("a5e", "hideA5eSkills") && (delete F.cul, delete F.eng);
  function H() {
    k.submit({ rollFormula: W });
  }
  f(H, "onSubmit");
  let G = v.abilityKey ?? m.system.attributes.initiative.ability ?? "dex", U = v.rollMode ?? CONFIG.A5E.ROLL_MODE.NORMAL, q = v.skillKey ?? "none", W, X = v.situationalMods ?? "";
  const te = /* @__PURE__ */ f(({ detail: he }) => t(6, l = he), "updateSelection_handler"), J = /* @__PURE__ */ f(({ detail: he }) => t(0, G = he), "updateSelection_handler_1"), re = /* @__PURE__ */ f(({ detail: he }) => t(1, q = he), "updateSelection_handler_2"), ae = /* @__PURE__ */ f((he) => {
    t(7, s = he.detail);
  }, "updateSelection_handler_3"), be = /* @__PURE__ */ f(({ detail: he }) => t(5, u = he), "updateSelection_handler_4"), we = /* @__PURE__ */ f(({ detail: he }) => t(4, d = he), "updateSelection_handler_5"), ve = /* @__PURE__ */ f(({ detail: he }) => t(3, p = he), "updateSelection_handler_6");
  function me() {
    X = this.value, t(2, X);
  }
  return f(me, "input_input_handler"), i.$$set = (he) => {
    "document" in he && t(20, y = he.document), "dialog" in he && t(21, k = he.dialog), "options" in he && t(22, v = he.options);
  }, i.$$.update = () => {
    i.$$.dirty[0] & /*$actor, options, abilityKey, skillKey*/
    4194563 && t(14, n = m.RollOverrideManager.getExpertiseDiceSource("initiative", v.expertiseDie ?? 0, { ability: G, skill: q })), i.$$.dirty[0] & /*$actor, abilityKey, skillKey*/
    259 && t(6, l = m.RollOverrideManager.getRollOverride("initiative", U, { ability: G, skill: q })), i.$$.dirty[0] & /*$actor, abilityKey, skillKey*/
    259 && t(13, r = m.RollOverrideManager.getRollOverridesSource("initiative", U, { ability: G, skill: q })), i.$$.dirty[0] & /*$actor, abilityKey*/
    257 && t(12, o = m.BonusesManager.prepareAbilityBonuses(G, "check")), i.$$.dirty[0] & /*$actor, skillKey, abilityKey*/
    259 && t(11, a = m.BonusesManager.prepareSkillBonuses(q, G)), i.$$.dirty[0] & /*$actor, abilityKey, skillKey*/
    259 && t(10, c = m.BonusesManager.prepareInitiativeBonuses({ abilityKey: G, skillKey: q })), i.$$.dirty[0] & /*$actor, abilityKey*/
    257 && t(5, u = m.BonusesManager.getDefaultSelections("abilities", { abilityKey: G, abilityType: "check" })), i.$$.dirty[0] & /*$actor, skillKey, abilityKey*/
    259 && t(4, d = m.BonusesManager.getDefaultSelections("skills", { skillKey: q, abilityKey: G })), i.$$.dirty[0] & /*$actor, abilityKey, skillKey*/
    259 && t(3, p = m.BonusesManager.getDefaultSelections("initiative", { abilityKey: G, skillKey: q })), i.$$.dirty[0] & /*$actor, abilityKey, expertiseDie, rollMode, situationalMods, skillKey, selectedAbilityBonuses, selectedSkillBonuses, selectedInitiativeBonuses*/
    511 && t(9, W = si(m, {
      ability: G,
      expertiseDie: s,
      rollMode: l,
      situationalMods: X,
      skill: q,
      selectedAbilityBonuses: u,
      selectedSkillBonuses: d,
      selectedInitiativeBonuses: p,
      type: "initiative"
    }));
  }, t(7, s = O()), [
    G,
    q,
    X,
    p,
    d,
    u,
    l,
    s,
    m,
    W,
    c,
    a,
    o,
    r,
    n,
    P,
    D,
    I,
    F,
    H,
    y,
    k,
    v,
    te,
    J,
    re,
    ae,
    be,
    we,
    ve,
    me
  ];
}
f(Rge, "instance$j");
const L3 = class L3 extends ie {
  constructor(e) {
    super(), le(this, e, Rge, Mge, ne, { document: 20, dialog: 21, options: 22 }, null, [-1, -1]);
  }
};
f(L3, "InitiativeRollDialog");
let Gw = L3;
function uL(i) {
  let e, t;
  return e = new Ze({
    props: {
      heading: "Ability Bonuses",
      options: (
        /*abilityBonuses*/
        i[9].map(dL)
      ),
      selected: (
        /*selectedAbilityBonuses*/
        i[4]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_3*/
    i[20]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*abilityBonuses*/
      512 && (l.options = /*abilityBonuses*/
      s[9].map(dL)), n & /*selectedAbilityBonuses*/
      16 && (l.selected = /*selectedAbilityBonuses*/
      s[4]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(uL, "create_if_block_1$6");
function fL(i) {
  let e, t;
  return e = new Ze({
    props: {
      heading: "Initiative Bonuses",
      options: (
        /*initiativeBonuses*/
        i[8].map(pL)
      ),
      selected: (
        /*selectedInitiativeBonuses*/
        i[3]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler_4*/
    i[21]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*initiativeBonuses*/
      256 && (l.options = /*initiativeBonuses*/
      s[8].map(pL)), n & /*selectedInitiativeBonuses*/
      8 && (l.selected = /*selectedInitiativeBonuses*/
      s[3]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(fL, "create_if_block$8");
function Fge(i) {
  let e, t, s;
  return {
    c() {
      e = E("input"), b(e, "class", "a5e-input"), b(e, "type", "text");
    },
    m(n, l) {
      T(n, e, l), qe(
        e,
        /*situationalMods*/
        i[2]
      ), t || (s = V(
        e,
        "input",
        /*input_input_handler*/
        i[22]
      ), t = !0);
    },
    p(n, l) {
      l & /*situationalMods*/
      4 && e.value !== /*situationalMods*/
      n[2] && qe(
        e,
        /*situationalMods*/
        n[2]
      );
    },
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(Fge, "create_default_slot$5");
function Nge(i) {
  let e, t, s, n, l, r, o, a = Object.values(
    /*abilityBonuses*/
    i[9]
  ).flat().length, c, u = Object.values(
    /*initiativeBonuses*/
    i[8]
  ).flat().length, d, p, m, g, h, _, y, k, v, O, P;
  t = new ml({
    props: {
      selected: (
        /*selectedRollMode*/
        i[7]
      ),
      source: (
        /*rollModeString*/
        i[13]
      )
    }
  }), t.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[17]
  ), n = new Ye({
    props: {
      heading: "A5E.AbilityScore",
      options: Object.entries(
        /*abilities*/
        i[11]
      ),
      selected: (
        /*abilityKey*/
        i[0]
      )
    }
  }), n.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[18]
  ), r = new hn({
    props: {
      selected: (
        /*expertiseDie*/
        i[1]
      ),
      type: (
        /*$actor*/
        i[5].type
      )
    }
  }), r.$on(
    "updateSelection",
    /*updateSelection_handler_2*/
    i[19]
  );
  let D = a && uL(i), I = u && fL(i);
  return p = new de({
    props: {
      heading: "A5E.SituationalMods",
      $$slots: { default: [Fge] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("form"), L(t.$$.fragment), s = R(), L(n.$$.fragment), l = R(), L(r.$$.fragment), o = R(), D && D.c(), c = R(), I && I.c(), d = R(), L(p.$$.fragment), m = R(), g = E("section"), h = x(
        /*rollFormula*/
        i[6]
      ), _ = R(), y = E("section"), k = E("button"), k.textContent = "Roll Initiative", b(g, "class", "roll-formula-preview svelte-cfnill"), b(e, "class", "svelte-cfnill");
    },
    m(B, F) {
      T(B, e, F), N(t, e, null), A(e, s), N(n, e, null), A(e, l), N(r, e, null), A(e, o), D && D.m(e, null), A(e, c), I && I.m(e, null), A(e, d), N(p, e, null), A(e, m), A(e, g), A(g, h), A(e, _), A(e, y), A(y, k), v = !0, O || (P = V(k, "click", tt(
        /*onSubmit*/
        i[12]
      )), O = !0);
    },
    p(B, [F]) {
      const H = {};
      F & /*selectedRollMode*/
      128 && (H.selected = /*selectedRollMode*/
      B[7]), t.$set(H);
      const G = {};
      F & /*abilityKey*/
      1 && (G.selected = /*abilityKey*/
      B[0]), n.$set(G);
      const U = {};
      F & /*expertiseDie*/
      2 && (U.selected = /*expertiseDie*/
      B[1]), F & /*$actor*/
      32 && (U.type = /*$actor*/
      B[5].type), r.$set(U), F & /*abilityBonuses*/
      512 && (a = Object.values(
        /*abilityBonuses*/
        B[9]
      ).flat().length), a ? D ? (D.p(B, F), F & /*abilityBonuses*/
      512 && w(D, 1)) : (D = uL(B), D.c(), w(D, 1), D.m(e, c)) : D && (ce(), C(D, 1, 1, () => {
        D = null;
      }), ue()), F & /*initiativeBonuses*/
      256 && (u = Object.values(
        /*initiativeBonuses*/
        B[8]
      ).flat().length), u ? I ? (I.p(B, F), F & /*initiativeBonuses*/
      256 && w(I, 1)) : (I = fL(B), I.c(), w(I, 1), I.m(e, d)) : I && (ce(), C(I, 1, 1, () => {
        I = null;
      }), ue());
      const q = {};
      F & /*$$scope, situationalMods*/
      134217732 && (q.$$scope = { dirty: F, ctx: B }), p.$set(q), (!v || F & /*rollFormula*/
      64) && _e(
        h,
        /*rollFormula*/
        B[6]
      );
    },
    i(B) {
      v || (w(t.$$.fragment, B), w(n.$$.fragment, B), w(r.$$.fragment, B), w(D), w(I), w(p.$$.fragment, B), v = !0);
    },
    o(B) {
      C(t.$$.fragment, B), C(n.$$.fragment, B), C(r.$$.fragment, B), C(D), C(I), C(p.$$.fragment, B), v = !1;
    },
    d(B) {
      B && S(e), j(t), j(n), j(r), D && D.d(), I && I.d(), j(p), O = !1, P();
    }
  };
}
f(Nge, "create_fragment$k");
const dL = /* @__PURE__ */ f(([i, e]) => [i, e.label || e.defaultLabel], "func"), pL = /* @__PURE__ */ f(([i, e]) => [i, e.label || e.defaultLabel], "func_1");
function jge(i, e, t) {
  let s, n, l, r, o, { document: a, dialog: c, options: u } = fe("#external").application, { document: d = a, dialog: p = c, options: m = u } = e;
  function g() {
    return y ? 0 : m.expertiseDice ?? o.system.attributes.initiative.expertiseDice;
  }
  f(g, "getInitialExpertiseDieSelection");
  const h = new Bt(d.actor);
  pe(i, h, (te) => t(5, o = te)), p.id;
  const _ = CONFIG.A5E.abilities, y = game.settings.get("a5e", "hideExpertiseDice");
  function k() {
    p.submit({ rollFormula: P });
  }
  f(k, "onSubmit");
  let v = m.abilityKey ?? o.system.attributes.initiative.ability ?? "dex", O = g(), P, D = m.rollMode ?? CONFIG.A5E.ROLL_MODE.NORMAL, I = m.situationalMods ?? "", B = o.RollOverrideManager.getRollOverride("initiative", D, { ability: v }), F = o.RollOverrideManager.getRollOverridesSource("initiative", D, { ability: v });
  const H = /* @__PURE__ */ f(({ detail: te }) => t(7, D = te), "updateSelection_handler"), G = /* @__PURE__ */ f(({ detail: te }) => t(0, v = te), "updateSelection_handler_1"), U = /* @__PURE__ */ f((te) => {
    t(1, O = te.detail);
  }, "updateSelection_handler_2"), q = /* @__PURE__ */ f(({ detail: te }) => t(4, l = te), "updateSelection_handler_3"), W = /* @__PURE__ */ f(({ detail: te }) => t(3, r = te), "updateSelection_handler_4");
  function X() {
    I = this.value, t(2, I);
  }
  return f(X, "input_input_handler"), i.$$set = (te) => {
    "document" in te && t(14, d = te.document), "dialog" in te && t(15, p = te.dialog), "options" in te && t(16, m = te.options);
  }, i.$$.update = () => {
    i.$$.dirty & /*$actor, abilityKey*/
    33 && t(9, s = o.BonusesManager.prepareAbilityBonuses(v, "check")), i.$$.dirty & /*$actor, abilityKey*/
    33 && t(8, n = o.BonusesManager.prepareInitiativeBonuses({ abilityKey: v })), i.$$.dirty & /*$actor, abilityKey*/
    33 && t(4, l = o.BonusesManager.getDefaultSelections("abilities", { abilityKey: v, abilityType: "check" })), i.$$.dirty & /*$actor, abilityKey*/
    33 && t(3, r = o.BonusesManager.getDefaultSelections("initiative", { abilityKey: v })), i.$$.dirty & /*$actor, abilityKey, expertiseDie, situationalMods, selectedAbilityBonuses, selectedInitiativeBonuses*/
    63 && t(6, P = si(o, {
      ability: v,
      expertiseDie: O,
      rollMode: B,
      situationalMods: I,
      selectedAbilityBonuses: l,
      selectedInitiativeBonuses: r,
      type: "initiative"
    }));
  }, [
    v,
    O,
    I,
    r,
    l,
    o,
    P,
    D,
    n,
    s,
    h,
    _,
    k,
    F,
    d,
    p,
    m,
    H,
    G,
    U,
    q,
    W,
    X
  ];
}
f(jge, "instance$i");
const B3 = class B3 extends ie {
  constructor(e) {
    super(), le(this, e, jge, Nge, ne, { document: 14, dialog: 15, options: 16 });
  }
};
f(B3, "SimpleInitiativeRollDialog");
let zw = B3;
async function Lge(i) {
  if (i != null && i.skipRollDialog)
    return Ige(this.actor, i);
  const e = game.i18n.format("A5E.InitiativePromptTitle", { name: this.name }), t = game.settings.get("a5e", "simpleInitiative") ? zw : Gw, s = new so(
    this,
    e,
    t,
    {},
    i,
    { width: 530 }
  );
  await s.render(!0);
  const { rollFormula: n } = await s.promise;
  return n;
}
f(Lge, "getInitiativeFormula");
async function Bge(i) {
  const e = await this._getInitiativeFormula(i);
  return Roll.create(e).evaluate({ async: !1 });
}
f(Bge, "getInitiativeRoll");
const qge = /* @__PURE__ */ f(async () => loadTemplates([
  // Settings
  "systems/a5e/templates/conditionAutomationMenu.hbs",
  // Hud
  "systems/a5e/templates/hud/token-hud.hbs"
]), "preloadHandlebarsTemplates");
function Gge(i) {
  Object.entries(i).forEach(([e, t]) => {
    typeof t == "string" && (i[e] = K(t));
  });
}
f(Gge, "localizeObject");
function zge(i) {
  i.PRELOCALIZED_KEYS.forEach((t) => {
    const s = foundry.utils.getProperty(i, t);
    Gge(s);
  });
}
f(zge, "performPreLocalization");
async function Hge(i = {}) {
  const e = await this.getInitiativeRoll(i);
  return this.update({ initiative: e.total });
}
f(Hge, "rollInitiative$1");
async function Uge(i, { updateTurn: e = !0, messageOptions: t = {}, rollOptions: s = {} } = {}) {
  var c, u, d;
  const n = typeof i == "string" ? [i] : i, l = (c = this.combatant) == null ? void 0 : c.id, r = t.rollMode || game.settings.get("core", "rollMode"), o = [], a = [];
  for (const [p, m] of n.entries()) {
    let g;
    const h = this.combatants.get(m);
    if (!(h != null && h.isOwner))
      return results;
    try {
      g = await h.getInitiativeRoll(s);
    } catch {
      continue;
    }
    o.push({ _id: m, initiative: g.total });
    const _ = foundry.utils.mergeObject({
      speaker: {
        scene: this.scene.id,
        actor: (u = h.actor) == null ? void 0 : u.id,
        token: (d = h.token) == null ? void 0 : d.id,
        alias: h.name
      },
      flavor: game.i18n.format("COMBAT.RollsInitiative", { name: h.name }),
      flags: { "core.initiativeRoll": !0 }
    }, t), y = await g.toMessage(_, {
      create: !1,
      rollMode: h.hidden && r === "roll" ? "gmroll" : r
    });
    p > 0 && (y.sound = null), a.push(y);
  }
  return o.length ? (await this.updateEmbeddedDocuments("Combatant", o), e && await this.update({ turn: this.turns.findIndex((p) => p.id === l) }), await ChatMessage.implementation.create(a), this) : this;
}
f(Uge, "rollInitiative");
const Ga = {
  bar: ["attributes.hp"],
  value: [
    ...Object.keys(Ie.skills).map((i) => `skills.${i}.passive`),
    ...Object.keys(Ie.abilities).map((i) => `abilities.${i}.value`),
    "attributes.hp.temp"
  ]
}, Vge = {
  base: Ga,
  character: {
    bar: [...Ga.bar, "resources.primary", "resources.secondary", "resources.tertiary", "resources.quaternary"],
    value: [...Ga.value]
  },
  npc: {
    bar: [...Ga.bar],
    value: [...Ga.value, "details.cr"]
  }
};
function Wge(i, e) {
  const t = ChatMessage.getSpeaker();
  let s;
  t.token && (s = game.actors.tokens[t.token]), s || (s = game.actors.get(t.actor));
  const n = s ? s.items.filter((o) => o.name === i) : [];
  if (n.length > 1)
    ui.notifications.warn(`Your controlled Actor ${s.name} has more than one Item with name ${i}. The first matched item will be chosen.`);
  else if (n.length === 0)
    return ui.notifications.warn(`Your controlled Actor does not have an item named ${i}`);
  const l = n[0];
  return l.actions.get(e) ? l.activate(e) : ui.notifications.warn(`Your selected Item does not have an action with id ${e}`);
}
f(Wge, "activateActionMacro");
function Kge(i) {
  const e = ChatMessage.getSpeaker();
  let t;
  e.token && (t = game.actors.tokens[e.token]), t || (t = game.actors.get(e.actor));
  const s = t ? t.items.filter((l) => l.name === i) : [];
  if (s.length > 1)
    ui.notifications.warn(`Your controlled Actor ${t.name} has more than one Item with name ${i}. The first matched item will be chosen.`);
  else if (s.length === 0)
    return ui.notifications.warn(`Your controlled Actor does not have an item named ${i}`);
  return s[0].activate();
}
f(Kge, "activateItemMacro");
async function Yge(i, e) {
  const t = await fromUuid(i.uuid), s = t.actions.get(i.actionId);
  if (foundry.utils.isEmpty(t) || t.parent === null)
    return ui.notifications.warn(game.i18n.localize("A5E.ActionWarningNoMacrosForUnownedItems"));
  let n;
  i.actionId ? n = `game.a5e.macros.activateActionMacro("${t.name}", "${i.actionId}");` : n = `game.a5e.macros.activateItemMacro("${t.name}");`;
  let l = game.macros.find((r) => {
    var c, u;
    const o = r.name === t.name && r.command === n, a = ((c = r.ownership) == null ? void 0 : c.default) === 3 || ((u = r.ownership) == null ? void 0 : u[game.user.id]) === 3;
    return o && a;
  });
  l || (l = await Macro.create({
    name: `${t.name} ${s ? `(${s.name})` : ""}`,
    type: "script",
    scope: "actor",
    img: s && (s != null && s.img) ? s.img : t.img,
    command: n,
    flags: { "a5e.itemMacro": !0 }
  })), await game.user.assignHotbarMacro(l, e);
}
f(Yge, "createMacro");
var Kn, Yn, ra, kf, wf;
const q3 = class q3 extends Xd {
  constructor(t, s, n) {
    if (!(t instanceof Item))
      throw Error("ForeignDocumentManager: Document must be an instance of Item!");
    if (typeof s != "string")
      throw Error("ForeignDocumentManager: Attribute is required!");
    if (typeof t.system[s] != "object")
      throw Error(`ForeignDocumentManager: Document must have 'system.${s}'`);
    super(foundry.utils.getProperty(t, `system.${s}`));
    Y(this, Kn, void 0);
    Y(this, Yn, void 0);
    Y(this, ra, void 0);
    Y(this, kf, "A5E.validations.warnings.duplicateForeignDocument");
    Y(this, wf, "A5E.validations.warnings.invalidForeignDocument");
    if (ye(this, Kn, t), ye(this, Yn, s), n) {
      const { validate: l, duplicateWarning: r, validateWarning: o } = n;
      typeof l == "function" && ye(this, ra, l), typeof r == "string" && ye(this, kf, r), typeof o == "string" && ye(this, wf, o);
    }
  }
  /** ************************************************
   * Iterator Returns
   * ************************************************ */
  get documents() {
    return M(this, Kn).system[M(this, Yn)];
  }
  getUuid(t) {
    const s = Object.entries(this.documents).find(([, n]) => n.uuid === t);
    return s ? s[1] : void 0;
  }
  getIdByUuid(t) {
    const s = Object.entries(this.documents).find(([, n]) => n.uuid === t);
    return s ? s[0] : void 0;
  }
  /** ************************************************
   * Internal Methods
   * ************************************************ */
  async add(t, s = {}) {
    var o;
    const n = this.getIdByUuid(t);
    if (n)
      return ui.notifications.warn(M(this, kf)), !1;
    const l = await fromUuid(t);
    if (M(this, ra) && !M(this, ra).call(this, l))
      return ui.notifications.warn(M(this, wf)), !1;
    foundry.utils.mergeObject(s, { uuid: t }), (l == null ? void 0 : l.type) === "object" && (s.quantity = ((o = l == null ? void 0 : l.system) == null ? void 0 : o.quantity) ?? 1);
    const r = n || foundry.utils.randomID();
    return await M(this, Kn).update({ [`system.${M(this, Yn)}.${r}`]: s }), !0;
  }
  async delete(t) {
    const s = this.getIdByUuid(t);
    return s ? (await M(this, Kn).update({ [`system.${M(this, Yn)}.-=${s}`]: null }), !0) : !1;
  }
  async deleteDocuments(t) {
    const s = t.map((l) => this.getIdByUuid(l)).filter((l) => l);
    if (s.length === 0)
      return !1;
    const n = {};
    return s.forEach((l) => {
      n[`system.${M(this, Yn)}.-=${l}`] = null;
    }), await M(this, Kn).update(n), !0;
  }
  async clean() {
    const t = {};
    for await (const [s, n] of Object.entries(M(this, Kn).system[M(this, Yn)]))
      await fromUuid(n == null ? void 0 : n.uuid) || (t[`system.${M(this, Yn)}.-=${s}`] = null);
    await M(this, Kn).update(t);
  }
};
Kn = new WeakMap(), Yn = new WeakMap(), ra = new WeakMap(), kf = new WeakMap(), wf = new WeakMap(), f(q3, "ForeignDocumentManager");
let Hw = q3;
var a1, yq, c1, vq, u1, kq, oa, bd, f1, wq, d1, $q, p1, Aq, m1, Eq;
const h1 = class h1 extends ls {
  constructor() {
    super(...arguments);
    Y(this, a1);
    Y(this, c1);
    Y(this, u1);
    Y(this, oa);
    Y(this, f1);
    Y(this, d1);
    Y(this, p1);
    Y(this, m1);
  }
  /**
   * @override
   * @param {Object} itemData
   * @returns {Promise<void>}
   */
  async updateItem(t) {
    const s = game.settings.get("a5e", "systemMigrationVersion");
    foundry.utils.isNewerVersion(s, "0.8.20") || (t.type === "object" && Z(this, c1, vq).call(this, t.system), Z(this, u1, kq).call(this, t));
  }
  /**
   * @override
   * @param {Object} actorData
   * @returns {Promise<void>}
   */
  async updateActor(t) {
    const s = game.settings.get("a5e", "systemMigrationVersion");
    foundry.utils.isNewerVersion(s, "0.8.20") || (Z(this, f1, wq).call(this, t), Z(this, d1, $q).call(this, t), Z(this, p1, Aq).call(this, t), Z(this, m1, Eq).call(this, t));
  }
};
a1 = new WeakSet(), yq = /* @__PURE__ */ f(function(t) {
  if (pd(t) || !t.toLowerCase().includes("ft"))
    return t;
  const n = t.match(/\d+/);
  return t = n && Number(n[0]) === 5 ? "fiveFeet" : t, t;
}, "#updateItemRange"), c1 = new WeakSet(), vq = /* @__PURE__ */ f(function(t) {
  var r;
  if (!((r = t.weight) != null && r.length))
    return;
  const n = t.weight.match(/\d+/), l = n ? Number(n[0]) : 0;
  t.weight = l;
}, "#updateItemWeight"), u1 = new WeakSet(), kq = /* @__PURE__ */ f(function(t) {
  var u, d;
  const { actions: s } = t.system, {
    actionOptions: n,
    activation: l,
    duration: r,
    range: o,
    target: a
  } = t.system;
  if (!(n != null && n.length) && !(l != null && l.type) && !(r != null && r.unit) && !(o != null && o.length) && !(a != null && a.type))
    return;
  const c = {
    name: t.name
  };
  if (c.activation = foundry.utils.duplicate(t.system.activation), c.duration = foundry.utils.duplicate(t.system.duration), (u = t.system.range) != null && u.length && (c.ranges = {}, t.system.range.forEach((p) => {
    p = Z(this, a1, yq).call(this, p), c.ranges[foundry.utils.randomID()] = { range: p };
  })), c.area = foundry.utils.duplicate(t.system.area), c.area.placeTemplate = ((d = t.flags.a5e) == null ? void 0 : d.placeTemplate) ?? !1, t["flags.a5e.-=placeTemplate"] = null, c.target = foundry.utils.duplicate(t.system.target ?? {}), n.includes("attack")) {
    const p = foundry.utils.duplicate(t.system.attack ?? {});
    p.attackType = p.type, p.type = "attack", p.ability = t.system.ability, c.rolls = {
      ...c.rolls,
      [foundry.utils.randomID()]: p
    };
  }
  if (n.includes("damage") && t.system.damage.forEach((p) => {
    const m = foundry.utils.duplicate(p);
    m.type = "damage", m.formula = Z(this, oa, bd).call(this, t, "default", m.formula), c.rolls = {
      ...c.rolls,
      [foundry.utils.randomID()]: m
    };
  }), n.includes("healing") && t.system.healing.forEach((p) => {
    const m = foundry.utils.duplicate(p);
    m.formula = Z(this, oa, bd).call(this, t, "default", m.formula), m.type = "healing", c.rolls = {
      ...c.rolls,
      [foundry.utils.randomID()]: m
    };
  }), n.includes("abilityCheck")) {
    const { check: p } = t.system;
    c.rolls = {
      ...c.rolls,
      [foundry.utils.randomID()]: {
        ability: p.ability,
        type: "abilityCheck"
      }
    };
  }
  if (n.includes("savingThrow")) {
    const { save: p } = t.system;
    c.prompts = {
      ...c.prompts,
      [foundry.utils.randomID()]: {
        ability: p.targetAbility,
        onSave: p.onSave,
        saveDC: {
          type: "custom",
          bonus: Z(this, oa, bd).call(this, t, p.targetAbility, p.dc)
        },
        type: "savingThrow"
      }
    };
  }
  t["system.-=actionOptions"] = null, t["system.-=activation"] = null, t["system.-=actionOptions"] = null, t["system.-=activation"] = null, t["system.-=duration"] = null, t["system.-=range"] = null, t["system.-=area"] = null, t["system.-=target"] = null, t["system.-=attack"] = null, t["system.-=damage"] = null, t["system.-=healing"] = null, t["system.-=check"] = null, t["system.-=savingThrow"] = null, t.system.actions = {
    ...s,
    [foundry.utils.randomID()]: c
  };
}, "#updateActionsConfig"), oa = new WeakSet(), bd = /* @__PURE__ */ f(function(t, s, n) {
  if (!n)
    return n;
  n = String(n);
  const l = t.system.attack.type, { ability: r } = t.system;
  return l && ["meleeWeaponAttack", "rangedWeaponAttack"].includes(l) && t.system.objectType === "weapon" ? l === "rangedWeaponAttack" ? n.replaceAll("@mod", "@dex.mod") : t.system.weaponProperties.includes("finesse") ? n.replaceAll("@mod", "@finesse.mod") : n.replaceAll("@mod", "@str.mod") : r ? s === "default" ? n.replaceAll("@mod", `@${r}.mod`) : n.replaceAll("@mod", `@${s}.mod`) : n;
}, "#replaceMod"), f1 = new WeakSet(), wq = /* @__PURE__ */ f(function(t) {
  var n, l;
  const s = (l = (n = t == null ? void 0 : t.system) == null ? void 0 : n.bonuses) == null ? void 0 : l.spell;
  t.system.bonuses = {
    meleeSpellAttack: (s == null ? void 0 : s.attack) ?? "",
    rangedSpellAttack: (s == null ? void 0 : s.attack) ?? "",
    spellDC: (s == null ? void 0 : s.dc) ?? ""
  }, t["system.bonuses.-=spell"] = null;
}, "#updateActorBonuses"), d1 = new WeakSet(), $q = /* @__PURE__ */ f(function(t) {
  var n;
  const s = (n = t.flags.a5e) == null ? void 0 : n.carryCapacityMultiplier;
  s && foundry.utils.setProperty(t, "flags.a5e.doubleCarryCapacity", s > 1);
}, "#updateCarryCapacity"), p1 = new WeakSet(), Aq = /* @__PURE__ */ f(function(t) {
  var r, o;
  const s = (o = (r = t == null ? void 0 : t.system) == null ? void 0 : r.attributes) == null ? void 0 : o.movement, n = {
    miles: ["mile", "miles", "mi.", "mi"],
    kilometers: ["kilometer", "kilometers", "km.", "km"],
    meters: ["meter", "meters", "m.", "m"]
  }, l = Object.entries(s ?? {}).reduce((a, [c, u]) => {
    if (c === "traits")
      return a[c] = { hover: u.hover }, a;
    for (const [d, p] of Object.entries(n))
      if (p.some((m) => u.toString().includes(m)))
        return a[c] = { distance: parseInt(u, 10) || 0, unit: d }, a;
    return a[c] = { distance: parseInt(u, 10) || 0, unit: "feet" }, a;
  }, {});
  foundry.utils.setProperty(t, "system.attributes.movement", l);
}, "#updateMovements"), m1 = new WeakSet(), Eq = /* @__PURE__ */ f(function(t) {
  var r, o;
  const s = (o = (r = t == null ? void 0 : t.system) == null ? void 0 : r.attributes) == null ? void 0 : o.senses, n = {
    miles: ["mile", "miles", "mi.", "mi"],
    kilometers: ["kilometer", "kilometers", "km.", "km"],
    meters: ["meter", "meters", "m.", "m"],
    unlimited: ["unlimited", "infinite"]
  }, l = Object.entries(s ?? {}).reduce((a, [c, u]) => {
    for (const [d, p] of Object.entries(n))
      if (p.some((m) => u.toString().includes(m)))
        return a[c] = { distance: parseInt(u, 10), unit: d }, a;
    return a[c] = { distance: parseInt(u, 10), unit: "feet" }, a;
  }, {});
  foundry.utils.setProperty(t, "system.attributes.senses", l);
}, "#updateSenses"), f(h1, "Migration001Aboleth"), /** @override */
Ge(h1, "version", 1e-3);
let Uw = h1;
function Xge(i) {
  var r;
  const [e, t] = ((r = Object.entries(i.system.actions ?? {})) == null ? void 0 : r[0]) ?? [[], []];
  if (!e)
    return;
  const s = Object.values(t.rolls ?? {}).filter((o) => o.type === "attack");
  if (!s.length || s[0].attackType !== "rangedWeaponAttack")
    return;
  const l = {
    itemId: "",
    quantity: 1,
    type: "ammunition"
  };
  foundry.utils.setProperty(i, `system.actions.${e}.consumers`, {
    [foundry.utils.randomID()]: l
  });
}
f(Xge, "createAmmoConsumer");
function Jge(i) {
  var l;
  const e = parseInt(i.system.uses.value, 10);
  if (!parseInt(i.system.uses.max, 10) && !e)
    return;
  const s = (l = Object.keys(i.system.actions ?? {})) == null ? void 0 : l[0];
  if (!s)
    return;
  const n = {
    type: "itemUses"
  };
  foundry.utils.setProperty(i, `system.actions.${s}.consumers`, {
    [foundry.utils.randomID()]: n
  });
}
f(Jge, "createUsesConsumer");
function Zge(i) {
  var n;
  const e = parseInt(i.system.exertionCost, 10);
  if (!e || e === 0)
    return;
  const t = (n = Object.keys(i.system.actions ?? {})) == null ? void 0 : n[0];
  if (!t)
    return;
  const s = {
    quantity: e ?? 1,
    resource: "exertion",
    type: "resource"
  };
  foundry.utils.setProperty(i, `system.actions.${t}.consumers`, {
    [foundry.utils.randomID()]: s
  });
}
f(Zge, "createManeuverConsumer");
function Qge(i) {
  var n;
  const e = parseInt(i.system.level, 10);
  if (e === 0)
    return;
  const t = (n = Object.keys(i.system.actions ?? {})) == null ? void 0 : n[0];
  if (!t)
    return;
  const s = {
    mode: "variable",
    spellLevel: e ?? 1,
    points: CONFIG.A5E.spellLevelCost[parseInt(e, 10)] ?? 2,
    type: "spell"
  };
  foundry.utils.setProperty(i, `system.actions.${t}.consumers`, {
    [foundry.utils.randomID()]: s
  });
}
f(Qge, "createSpellConsumer");
var g1, Sq, b1, Tq;
const _1 = class _1 extends ls {
  constructor() {
    super(...arguments);
    Y(this, g1);
    Y(this, b1);
  }
  /**
   * @override
   * @param {Object} itemData
   * @returns {Promise<void>}
   */
  async updateItem(t) {
    const s = game.settings.get("a5e", "systemMigrationVersion");
    foundry.utils.isNewerVersion(s, "0.9.10") || (Z(this, g1, Sq).call(this, t), Z(this, b1, Tq).call(this, t));
  }
};
g1 = new WeakSet(), Sq = /* @__PURE__ */ f(function(t) {
  CONFIG.A5E.originItemTypes.includes(t.type) || (t.type === "object" && t.system.objectType === "weapon" && Xge(t), t.type === "maneuver" && Zge(t), t.type === "spell" && Qge(t), Jge(t));
}, "#createConsumers"), b1 = new WeakSet(), Tq = /* @__PURE__ */ f(function(t) {
  var n;
  const { uses: s } = t.system;
  !(s != null && s.max) || (s == null ? void 0 : s.max) === "" || foundry.utils.setProperty(t, "system.uses.max", (n = s.max) == null ? void 0 : n.toString());
}, "#updateMaxUsesField"), f(_1, "Migration002Ooze"), /** @override */
Ge(_1, "version", 2e-3);
let Vw = _1;
const xge = ["background", "class", "culture", "destiny", "heritage", "subclass"];
var y1, Cq, v1, Oq;
const k1 = class k1 extends ls {
  constructor() {
    super(...arguments);
    Y(this, y1);
    Y(this, v1);
  }
  /**
   * @override
   * @param {Object} itemData
   * @returns {Promise<void>}
   */
  async updateItem(t) {
    xge.includes(t.type) || (Z(this, y1, Cq).call(this, t), Z(this, v1, Oq).call(this, t));
  }
};
y1 = new WeakSet(), Cq = /* @__PURE__ */ f(function(t) {
  Object.entries(t.system.actions ?? {}).forEach(([n, l]) => {
    const r = Object.entries(l.consumers ?? {}).filter(([u, d]) => d.type === "actionUses"), o = Object.entries(l.consumers ?? {}).filter(([u, d]) => d.type === "recharge"), a = [];
    r.length && r.forEach(([u, d]) => {
      const p = {
        value: d.value ?? 0,
        max: d.max ?? "",
        per: d.per,
        recharge: {
          formula: "1d6",
          threshold: 6
        }
      };
      t.system.actions[n].uses = p;
    }), o.length && o.forEach(([u, d]) => {
      const p = {
        formula: d.formula ?? "1d6",
        threshold: d.threshold ?? 6
      };
      t[`system.actions.${n}.uses.per`] = "recharge", t[`system.actions.${n}.uses.recharge`] = p, a.push(u), delete t.system.actions[n].consumers[u];
    });
    const c = {
      ...t.system.actions[n].consumers
    };
    a.forEach((u) => {
      c[`-=${u}`] = null;
    }), t[`system.actions.${n}.consumers`] = c;
  });
}, "#updateActionUses"), v1 = new WeakSet(), Oq = /* @__PURE__ */ f(function(t) {
  var n, l;
  const s = {
    formula: ((n = t.system.recharge) == null ? void 0 : n.formula) ?? "1d6",
    threshold: ((l = t.system.recharge) == null ? void 0 : l.threshold) ?? 6
  };
  t["system.uses.recharge"] = s, t["system.-=recharge"] = null;
}, "#updateRechargeData"), f(k1, "Migration003Uses"), /** @override */
Ge(k1, "version", 3e-3);
let Ww = k1;
const w1 = class w1 extends ls {
  async updateItem(e) {
    if (e.type !== "object")
      return;
    const t = e.system.equipped ? CONFIG.A5E.EQUIPPED_STATES.EQUIPPED : CONFIG.A5E.EQUIPPED_STATES.NOT_CARRIED;
    foundry.utils.setProperty(e, "system.equippedState", t), e["system.-=equipped"] = null;
  }
};
f(w1, "Migration004EquippedState"), /** @override */
Ge(w1, "version", 4e-3);
let Kw = w1;
const $1 = class $1 extends ls {
  /**
   * @override
   * @param {Object} actorData
   * @returns {Promise<void>}
   */
  async updateActor(e) {
    const { ac: t } = e.system.attributes;
    foundry.utils.setProperty(e, "system.attributes.ac", {
      base: parseInt(t, 10) || 10,
      value: 0
    });
  }
};
f($1, "Migration005MigrateAC"), /** @override */
Ge($1, "version", 5e-3);
let Yw = $1;
const A1 = class A1 extends ls {
  /**
   * @override
   * @param {Object} actorData
   * @returns {Promise<void>}
   */
  async updateActor(e) {
    const { base: t } = e.system.attributes.ac ?? { base: 10 };
    typeof e.system.attributes.ac != "object" ? foundry.utils.setProperty(e, "system.attributes.ac", {
      baseFormula: `${e.system.attributes.ac}`,
      value: 0
    }) : (foundry.utils.setProperty(e, "system.attributes.ac.baseFormula", `${t}`), e["system.attributes.ac.-=base"] = null);
  }
  /**
   * @override
   * @param {Object} itemData
   * @returns {Promise<void>}
   */
  async updateItem(e) {
    if (e.type !== "object")
      return;
    const t = e.system.broken ? CONFIG.A5E.DAMAGED_STATES.BROKEN : CONFIG.A5E.DAMAGED_STATES.INTACT;
    foundry.utils.setProperty(e, "system.damagedState", t), e["system.-=broken"] = null;
  }
};
f(A1, "Migration006MigrateFormulaACAndBroken"), /** @override */
Ge(A1, "version", 6e-3);
let Xw = A1;
const mL = {
  0: 0,
  // CUSTOM -> CUSTOM
  1: 1,
  // MULTIPLY -> MULTIPLY
  2: 2,
  // ADD -> ADD
  3: 4,
  // SUBTRACT -> DOWNGRADE
  4: 5,
  // DOWNGRADE -> UPGRADE
  5: 6
  // UPGRADE -> OVERRIDE
}, E1 = class E1 extends ls {
  /**
   * @override
   * @param {Object} actorData
   * @returns {Promise<void>}
   */
  async updateActor(e) {
    const t = e.effects ?? [];
    t.length && (e.effects = t.map((s) => (s.changes = s.changes.map((n) => (n.mode = mL[n.mode] ?? 6, n)), s)));
  }
  /**
   * @override
   * @param {Object} itemData
   * @returns {Promise<void>}
   */
  async updateItem(e) {
    const t = e.effects ?? [];
    t.length && (e.effects = t.map((s) => (s.changes = s.changes.map((n) => (n.mode = mL[n.mode] ?? 6, n)), s)));
  }
};
f(E1, "Migration007MigrateEffectModes"), /** @override */
Ge(E1, "version", 7e-3);
let Jw = E1;
const S1 = class S1 extends ls {
  /**
   * @override
   * @param {ItemData} itemData
   * @returns {Promise<void>}
   */
  async updateItem(e) {
    var n;
    const t = ((n = e == null ? void 0 : e.system) == null ? void 0 : n.actions) ?? {}, s = /* @__PURE__ */ new Map();
    Object.entries(t).forEach(([l, r]) => {
      Object.entries((r == null ? void 0 : r.prompts) ?? {}).filter(([, a]) => a.type === "effect").forEach(([, a]) => {
        if (!(a != null && a.effectId))
          return;
        if (!s.has(a.effectId)) {
          s.set(a.effectId, l);
          return;
        }
        const c = foundry.utils.deepClone(
          e.effects.find(({ _id: d }) => d === a.effectId)
        );
        if (!c)
          return;
        c._id = null;
        const u = new ActiveEffect.implementation(c).toObject();
        foundry.utils.setProperty(u, "flags.a5e.actionId", l), e.effects.push(u);
      });
    }), e.effects.forEach((l) => {
      const r = s.get(l._id);
      r && foundry.utils.setProperty(l, "flags.a5e.actionId", r);
    });
  }
};
f(S1, "Migration008Specter"), /** @override */
Ge(S1, "version", 8e-3);
let Zw = S1;
const T1 = class T1 extends ls {
  /**
   * @override
   * @param {Object} itemData
   * @returns {Promise<void>}
   */
  async updateItem(e) {
    var s, n;
    if (!((n = (s = e.system) == null ? void 0 : s.schema) != null && n.version))
      return;
    const t = e.system.schema;
    foundry.utils.setProperty(e, "system.schemaVersion", t), e["system.-=schema"] = null;
  }
  /**
   * @override
   * @param {Object} actorData
   * @returns {Promise<void>}
   */
  async updateActor(e) {
    var s, n;
    if (!((n = (s = e.system) == null ? void 0 : s.schema) != null && n.version))
      return;
    const t = e.system.schema;
    foundry.utils.setProperty(e, "system.schemaVersion", t), e["system.-=schema"] = null;
  }
};
f(T1, "Migration009Genie"), /** @override */
Ge(T1, "version", 9e-3);
let Qw = T1;
var C1, O1, Dq, D1, Iq, I1, Pq, P1, Mq, M1, Rq, R1, Fq, F1, Nq, N1, jq;
const j1 = class j1 extends ls {
  constructor() {
    super(...arguments);
    Y(this, O1);
    Y(this, D1);
    Y(this, I1);
    Y(this, P1);
    Y(this, M1);
    Y(this, R1);
    Y(this, F1);
    Y(this, N1);
    Y(this, C1, /* @__PURE__ */ new Set([
      "system.bonuses.abilities.check",
      "system.bonuses.abilities.save",
      "system.bonuses.abilities.skill",
      "flags.a5e.effects.bonuses.damage",
      "flags.a5e.effects.bonuses.healing"
    ]));
  }
  /**
   *
   * @param {Object} actorData
   * @returns {Promise<void>}
   */
  async updateActor(t) {
    Z(this, P1, Mq).call(this, t), Z(this, O1, Dq).call(this, t), Z(this, D1, Iq).call(this, t), Z(this, I1, Pq).call(this, t);
  }
  async updateEffect(t) {
    const s = t.changes ?? [];
    s.length && s.forEach((n, l) => {
      const { key: r } = n, o = M(this, C1).has(r), a = r.split("."), c = (a == null ? void 0 : a[1]) === "abilities" && a.at(-1) === "bonus", u = (a == null ? void 0 : a[1]) === "skills" && a.at(-2) === "bonuses";
      if (!(!o && !c && !u)) {
        if (r === "flags.a5e.effects.bonuses.damage") {
          const d = Z(this, M1, Rq).call(this, n);
          s[l] = d;
        } else if (r === "flags.a5e.effects.bonuses.healing") {
          const d = Z(this, R1, Fq).call(this, n);
          s[l] = d;
        } else if (c || a.length !== 5 && ["check", "save"].includes(a.at(-1))) {
          const d = Z(this, F1, Nq).call(this, n);
          s[l] = d;
        } else if (u || a.at(-1) === "skill") {
          const d = Z(this, N1, jq).call(this, n);
          s[l] = d;
        }
      }
    });
  }
};
C1 = new WeakMap(), O1 = new WeakSet(), Dq = /* @__PURE__ */ f(function(t) {
  const { abilities: s } = t.system, n = {}, { checks: l, saves: r } = Object.entries(s).reduce(
    (c, [u, d]) => {
      var g, h;
      const p = (d.check.bonus ?? "").replaceAll(/\s/g, ""), m = (d.save.bonus ?? "").replaceAll(/\s/g, "");
      return p && ((g = c.checks)[p] ?? (g[p] = []), c.checks[p].push(u)), m && ((h = c.saves)[m] ?? (h[m] = []), c.saves[m].push(u)), c;
    },
    { checks: {}, saves: {} }
  );
  Object.entries(l).forEach(([c, u]) => {
    n[foundry.utils.randomID()] = {
      context: {
        abilities: u
      },
      formula: c,
      label: "Check Bonus",
      default: !0
    };
  }), Object.entries(r).forEach(([c, u]) => {
    n[foundry.utils.randomID()] = {
      context: {
        abilities: u
      },
      formula: c,
      label: "Save Bonus",
      default: !0
    };
  });
  const o = t.system.bonuses.abilities.check, a = t.system.bonuses.abilities.save;
  o && (n[foundry.utils.randomID()] = {
    context: {},
    formula: o,
    label: "Global Check Bonus",
    default: !0
  }), a && (n[foundry.utils.randomID()] = {
    context: {},
    formula: a,
    label: "Global Save Bonus",
    default: !0
  }), t.system.bonuses.abilities = {
    ...n,
    "-=check": null,
    "-=save": null,
    "-=skill": null
  };
}, "#updateAbilityBonuses"), D1 = new WeakSet(), Iq = /* @__PURE__ */ f(function(t) {
  const s = t.system.bonuses.damage;
  Object.entries(s ?? {}).forEach(([n, l]) => {
    l.context;
  });
}, "#updateDamageBonuses"), I1 = new WeakSet(), Pq = /* @__PURE__ */ f(function(t) {
  const s = t.system.bonuses.healing;
  Object.entries(s ?? {}).forEach(([n, l]) => {
    l.context;
  });
}, "#updateHealingBonuses"), P1 = new WeakSet(), Mq = /* @__PURE__ */ f(function(t) {
  var a, c;
  const { skills: s } = t.system, n = {}, l = ((c = (a = t.system.bonuses) == null ? void 0 : a.abilities) == null ? void 0 : c.skill) || "", { passives: r, checks: o } = Object.entries(s).reduce((u, [d, p]) => {
    var h, _;
    const m = p.bonuses.passive || "", g = (p.bonuses.check || "").replaceAll(/\s/g, "");
    return m && ((h = u.passives)[m] ?? (h[m] = []), u.passives[m].push(d)), g && ((_ = u.checks)[g] ?? (_[g] = []), u.checks[g].push(d)), u;
  }, { passives: {}, checks: {} });
  Object.entries(r).forEach(([u, d]) => {
    n[foundry.utils.randomID()] = {
      context: {
        skills: d,
        passiveOnly: !0
      },
      formula: u,
      label: "Passive Bonus",
      default: !0
    };
  }), Object.entries(o).forEach(([u, d]) => {
    n[foundry.utils.randomID()] = {
      context: {
        skills: d
      },
      formula: u,
      label: "Check Bonus",
      default: !0
    };
  }), l && (n[foundry.utils.randomID()] = {
    context: {},
    formula: l,
    label: "Global Skill Bonus",
    default: !0
  }), t.system.bonuses.skills = n;
}, "#updateSkillBonuses"), M1 = new WeakSet(), Rq = /* @__PURE__ */ f(function(t) {
  let s = null;
  try {
    s = JSON.parse(t.value);
  } catch {
    s = t.value;
  }
  if (!s)
    return t;
  const { context: n } = s;
  n || (s.context = {});
  let l = [];
  n === "all" ? l = ["meleeWeaponAttack", "rangedWeaponAttack", "meleeSpellAttack", "rangedSpellAttack"] : n === "weaponAttacks" ? l = ["meleeWeaponAttack", "rangedWeaponAttack"] : n === "spellAttacks" ? l = ["meleeSpellAttack", "rangedSpellAttack"] : l = [n], s.context = {
    attackTypes: l,
    damageTypes: [],
    isCritBonus: !1,
    spellLevels: []
  };
  const r = foundry.utils.deepClone(t);
  return r.value = JSON.stringify(s), r.mode = 0, r;
}, "#getEffectDamageChange"), R1 = new WeakSet(), Fq = /* @__PURE__ */ f(function(t) {
  let s = null;
  try {
    s = JSON.parse(t.value);
  } catch {
    s = t.value;
  }
  if (!s)
    return t;
  const { context: n } = s;
  n || (s.context = {});
  let l = [];
  n === "all" ? l = ["healing", "temporaryHealing"] : l = [n], s.context = {
    healingTypes: l,
    spellLevels: []
  };
  const r = foundry.utils.deepClone(t);
  return r.value = JSON.stringify(s), r.mode = 0, r;
}, "#getEffectHealingChange"), F1 = new WeakSet(), Nq = /* @__PURE__ */ f(function(t) {
  const s = t.key === "system.bonuses.abilities.check", n = t.key === "system.bonuses.abilities.save", l = t.key.startsWith("system.abilities.") && t.key.endsWith(".check"), r = t.key.startsWith("system.abilities.") && t.key.endsWith(".save"), o = t.value;
  let a = [];
  if (s || n)
    a = Object.keys(Ie.abilities);
  else {
    const p = t.key.split("."), m = (p == null ? void 0 : p[2]) ?? null;
    a = m ? [m] : [];
  }
  const c = [];
  s || l ? c.push("check") : (n || r) && c.push("save");
  const u = {
    context: {
      abilities: a,
      types: c,
      requiresProficiency: !1
    },
    formula: o,
    label: "Ability Bonus",
    default: !0
  }, d = foundry.utils.deepClone(t);
  return d.key = "flags.a5e.effects.bonuses.abilities", d.value = JSON.stringify(u), d.mode = 0, d;
}, "#getEffectAbilityChange"), N1 = new WeakSet(), jq = /* @__PURE__ */ f(function(t) {
  const s = t.key === "system.bonuses.abilities.skill", n = t.key.startsWith("system.skills.") && t.key.endsWith(".passive"), l = t.value;
  let r = [];
  if (s)
    r = Object.keys(Ie.skills);
  else {
    const c = t.key.split("."), u = (c == null ? void 0 : c[2]) ?? null;
    r = u ? [u] : [];
  }
  const o = {
    context: {
      skills: r,
      passiveOnly: n,
      requiresProficiency: !1
    },
    formula: l,
    label: "Skill Bonus",
    default: !0
  }, a = foundry.utils.deepClone(t);
  return a.key = "flags.a5e.effects.bonuses.skills", a.value = JSON.stringify(o), a.mode = 0, a;
}, "#getEffectSkillChange"), f(j1, "Migration010MigrateContexts"), Ge(j1, "version", 0.01);
let xw = j1;
var L1, B1, Lq, yr, ec;
const q1 = class q1 extends ls {
  constructor() {
    super(...arguments);
    Y(this, B1);
    Y(this, yr);
    Y(this, L1, /* @__PURE__ */ new Set([
      "system.bonuses.meleeSpellAttack",
      "system.bonuses.meleeWeaponAttack",
      "system.bonuses.rangedSpellAttack",
      "system.bonuses.rangedWeaponAttack"
    ]));
  }
  async updateActor(t) {
    Z(this, B1, Lq).call(this, t);
  }
  async updateEffect(t) {
    const s = t.changes ?? [];
    s.length && s.forEach((n, l) => {
      const { key: r } = n;
      if (M(this, L1).has(r)) {
        if (r === "system.bonuses.meleeWeaponAttack") {
          const o = Z(this, yr, ec).call(this, n, "meleeWeaponAttack");
          s[l] = o;
        } else if (r === "system.bonuses.meleeSpellAttack") {
          const o = Z(this, yr, ec).call(this, n, "meleeSpellAttack");
          s[l] = o;
        } else if (r === "system.bonuses.rangedWeaponAttack") {
          const o = Z(this, yr, ec).call(this, n, "rangedWeaponAttack");
          s[l] = o;
        } else if (r === "system.bonuses.rangedSpellAttack") {
          const o = Z(this, yr, ec).call(this, n, "rangedSpellAttack");
          s[l] = o;
        }
      }
    });
  }
};
L1 = new WeakMap(), B1 = new WeakSet(), Lq = /* @__PURE__ */ f(function(t) {
  const {
    meleeWeaponAttack: s,
    meleeSpellAttack: n,
    rangedWeaponAttack: l,
    rangedSpellAttack: r
  } = t.system.bonuses ?? {}, o = {};
  s && (o[foundry.utils.randomID()] = {
    context: {
      attackTypes: ["meleeWeaponAttack"]
    },
    formula: s,
    label: "Melee Weapon Attack",
    default: !0
  }), n && (o[foundry.utils.randomID()] = {
    context: {
      attackTypes: ["meleeSpellAttack"]
    },
    formula: n,
    label: "Melee Spell Attack",
    default: !0
  }), l && (o[foundry.utils.randomID()] = {
    context: {
      attackTypes: ["rangedWeaponAttack"]
    },
    formula: l,
    label: "Ranged Weapon Attack",
    default: !0
  }), r && (o[foundry.utils.randomID()] = {
    context: {
      attackTypes: ["rangedSpellAttack"]
    },
    formula: r,
    label: "Ranged Spell Attack",
    default: !0
  }), t.system.bonuses.attacks = o;
}, "#updateAttackBonuses"), yr = new WeakSet(), ec = /* @__PURE__ */ f(function(t, s) {
  const n = t.value ?? "", l = {
    context: {
      attackTypes: [s]
    },
    formula: n,
    label: Ie.attackTypes[s],
    img: "icons/svg/upgrade.svg",
    default: !0
  }, r = foundry.utils.deepClone(t);
  return r.key = "flags.a5e.effects.bonuses.attacks", r.value = JSON.stringify(l), r.mode = 0, r;
}, "#getEffectChange"), f(q1, "Migration011MigrateAttackBonuses"), Ge(q1, "version", 0.011);
let e5 = q1;
var G1, Bq;
const z1 = class z1 extends ls {
  constructor() {
    super(...arguments);
    Y(this, G1);
  }
  async updateActor(t) {
    Z(this, G1, Bq).call(this, t);
  }
  async updateEffect(t) {
    const s = t.changes ?? [];
    s.length && s.forEach((n, l) => {
      const { key: r } = n;
      if (r !== "system.attributes.initiative.bonus")
        return;
      const o = n.value ?? "", a = {
        context: {
          abilities: Object.keys(Ie.abilities),
          skills: Object.keys(Ie.skills)
        },
        formula: o,
        label: "Initiative Bonus",
        img: "icons/svg/upgrade.svg",
        default: !0
      }, c = foundry.utils.deepClone(n);
      c.key = "flags.a5e.effects.bonuses.initiative", c.value = JSON.stringify(a), c.mode = 0, s[l] = c;
    });
  }
};
G1 = new WeakSet(), Bq = /* @__PURE__ */ f(function(t) {
  const { bonus: s } = t.system.attributes.initiative ?? {};
  s && (t.system.bonuses.initiative = {
    [foundry.utils.randomID()]: {
      context: {
        abilities: Object.keys(Ie.abilities),
        skills: Object.keys(Ie.skills)
      },
      formula: s.trim(),
      label: "Initiative Bonus",
      default: !0
    }
  });
}, "#updateInitiativeBonus"), f(z1, "Migration012MigrateInitiativeBonus"), Ge(z1, "version", 0.012);
let t5 = z1;
var H1;
const U1 = class U1 extends ls {
  constructor() {
    super(...arguments);
    Y(this, H1, /* @__PURE__ */ new Set([
      "system.abilities.str.value",
      "system.abilities.dex.value",
      "system.abilities.con.value",
      "system.abilities.int.value",
      "system.abilities.wis.value",
      "system.abilities.cha.value"
    ]));
  }
  async updateEffect(t) {
    const s = t.changes ?? [];
    s.length && s.forEach((n, l) => {
      const { key: r } = n;
      if (!M(this, H1).has(r))
        return;
      const o = n.value ?? "";
      if (!o)
        return;
      const a = r.split(".").at(-2);
      if (!a)
        return;
      const c = {
        context: {
          abilities: [a],
          types: ["base"],
          requiresProficiency: !1
        },
        formula: o,
        label: "Ability Bonus",
        img: t.icon || t.img || "",
        default: !0
      }, u = foundry.utils.deepClone(n);
      u.key = "flags.a5e.effects.bonuses.abilities", u.value = JSON.stringify(c), u.mode = 0, s[l] = u;
    });
  }
};
H1 = new WeakMap(), f(U1, "MigrateAbilityBonusEffects"), Ge(U1, "version", 0.013);
let s5 = U1;
const V1 = class V1 extends ls {
  async updateActor(e) {
    var r;
    const t = ((r = Object.keys(e.system.spellBooks ?? {})) == null ? void 0 : r[0]) || foundry.utils.randomID(), s = foundry.utils.getProperty(e, "flags.a5e.showSpellPoints") ?? !1, n = foundry.utils.getProperty(e, "flags.a5e.showSpellSlots") ?? !0, l = {
      _id: t,
      name: "New Spell Book",
      img: "icons/svg/book.svg",
      ability: "default",
      disableSpellConsumers: !1,
      showSpellPoints: s,
      showSpellSlots: n
    };
    e["system.spellBooks"] = { [t]: l }, e["flags.a5e.filters.-=exclusive"] = null, e["flags.a5e.filters.-=inclusive"] = null, e["flags.a5e.-=showSpellPoints"] = null, e["flags.a5e.-=showSpellSlots"] = null, foundry.utils.setProperty(e, "flags.a5e.sortMode", {});
    for (const o of e.items)
      o.type === "spell" && (o.system.spellBook = t);
  }
};
f(V1, "Migration014SpellBooks"), Ge(V1, "version", 0.014);
let n5 = V1;
const W1 = class W1 extends ls {
  async updateItem(e) {
    if (e.type !== "object")
      return;
    const t = e.system.weaponProperties ?? [];
    t.includes("defensiveHeavy") ? foundry.utils.setProperty(e, "system.defensiveProperties", "heavy") : t.includes("defensiveMedium") ? foundry.utils.setProperty(e, "system.defensiveProperties", "medium") : t.includes("defensiveLight") && foundry.utils.setProperty(e, "system.defensiveProperties", "light");
    const s = [];
    t.includes("breakerStone") && s.push("stone"), t.includes("breakerWood") && s.push("wood"), e.system.breakerProperties = s;
  }
};
f(W1, "Migration015MigrateProperties"), Ge(W1, "version", 0.015);
let i5 = W1;
const K1 = class K1 extends ls {
  async updateEffect(e) {
    const t = e.changes ?? [];
    t.length && t.forEach((s, n) => {
      const { key: l, value: r } = s;
      if (l.startsWith("system.skills") && l.endsWith(".proficient")) {
        const o = foundry.utils.deepClone(s);
        o.value = r === "true" ? 1 : 0, t[n] = o;
      }
    });
  }
};
f(K1, "Migration016MigrateSkillProficiency"), Ge(K1, "version", 0.016);
let l5 = K1;
const Y1 = class Y1 extends ls {
  async updateActor(e) {
    var s;
    if (e.type !== "character")
      return;
    const t = e.system.spellResources ?? {};
    Object.entries(t.slots ?? {}).forEach(([n, l]) => {
      foundry.utils.setProperty(
        e,
        `system.spellResources.slots.${n}.override`,
        l.max ?? 0
      ), foundry.utils.setProperty(
        e,
        `system.spellResources.slots.${n}.max`,
        0
      );
    }), foundry.utils.setProperty(
      e,
      "system.spellResources.points.override",
      ((s = t.points) == null ? void 0 : s.max) ?? 0
    ), foundry.utils.setProperty(
      e,
      "system.spellResources.points.max",
      0
    );
  }
};
f(Y1, "Migration017MigrateSpellMax"), Ge(Y1, "version", 0.017);
let r5 = Y1;
const X1 = class X1 extends ls {
  constructor() {
    super(...arguments);
    Ge(this, "traitTypes", ["armorTypes", "maneuverTraditions", "tools", "weapons"]);
  }
  async updateActor(t) {
    const s = t.system.grants ?? {};
    Object.entries(s).forEach(([n, l]) => {
      if (!["proficiency", "trait"].includes(l.grantType) || (l.grantType === "proficiency" && l.proficiencyData.proficiencyType === "ability" && foundry.utils.setProperty(
        t,
        `system.grants.${n}.proficiencyData.proficiencyType`,
        "savingThrow"
      ), l.grantType !== "trait"))
        return;
      const { traits: r, traitType: o } = l.traitData;
      if (!this.traitTypes.includes(o))
        return;
      let a;
      o === "armorTypes" ? a = "armor" : o === "maneuverTraditions" ? a = "tradition" : o === "tools" ? a = "tool" : o === "weapons" ? a = "weapon" : a = o;
      const c = {
        grantType: "proficiency",
        proficiencyData: {
          keys: r,
          total: r.length,
          proficiencyType: a
        }
      };
      foundry.utils.setProperty(t, `system.grants.${n}`, c);
    });
  }
  async updateItem(t) {
    const s = t.system.grants ?? {};
    Object.entries(s).forEach(([n, l]) => {
      if (!["proficiency", "trait"].includes(l.grantType) || (l.grantType === "proficiency" && l.proficiencyType === "ability" && foundry.utils.setProperty(
        t,
        `system.grants.${n}.proficiencyType`,
        "savingThrow"
      ), l.grantType !== "trait"))
        return;
      const { traits: r } = l, { traitType: o } = r;
      if (!this.traitTypes.includes(o))
        return;
      let a;
      o === "armorTypes" ? a = "armor" : o === "maneuverTraditions" ? a = "tradition" : o === "tools" ? a = "tool" : o === "weapons" ? a = "weapon" : a = o;
      const c = {
        grantType: "proficiency",
        keys: {
          base: r.base,
          options: r.options,
          total: r.total
        },
        proficiencyType: a
      };
      foundry.utils.setProperty(t, `system.grants.${n}`, c);
    });
  }
};
f(X1, "Migration018MigrateTraitProficiencyGrant"), Ge(X1, "version", 0.018);
let o5 = X1;
const J1 = class J1 extends ls {
  async updateItem(e) {
    const t = e.system.grants ?? {};
    Object.entries(t).forEach(([s, n]) => {
      var c;
      if (n.grantType !== "feature")
        return;
      const { base: l = [], options: r = [] } = n.features ?? {}, o = l.map((u) => ({ uuid: u, limitedReselection: !0, selectionLimit: 1 })), a = r.map((u) => ({ uuid: u, limitedReselection: !0, selectionLimit: 1 }));
      e.system.grants[s].features = {
        base: o,
        options: a,
        total: ((c = n.features) == null ? void 0 : c.total) ?? 0
      };
    });
  }
};
f(J1, "Migration019MigrateFeatureGrant"), Ge(J1, "version", 0.019);
let a5 = J1;
const e1e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Migration001Aboleth: Uw,
  Migration002Ooze: Vw,
  Migration003Uses: Ww,
  Migration004EquippedState: Kw,
  Migration005MigrateAC: Yw,
  Migration006MigrateFormulaACAndBroken: Xw,
  Migration007MigrateEffectModes: Jw,
  Migration008MigrateSpecter: Zw,
  Migration009MigrateToGenie: Qw,
  Migration010MigrateContexts: xw,
  Migration011MigrateAttackBonuses: e5,
  Migration012MigrateInitiativeBonus: t5,
  Migration013MigrateAbilityBonusEffects: s5,
  Migration014MigrateSpellBooks: n5,
  Migration015MigrateProperties: i5,
  Migration016MigrateSkillProficiency: l5,
  Migration017MigrateSpellMax: r5,
  Migration018MigrateTraitProficiencyGrant: o5,
  Migration019MigrateFeatureGrant: a5
}, Symbol.toStringTag, { value: "Module" }));
var vr;
const Z1 = class Z1 {
  /**
   * @returns {Number}
   */
  static get latestVersion() {
    return Math.max(...M(this, vr).map((e) => e.version));
  }
  /**
   * @returns {Array<MigrationBase>}
   */
  static constructAll() {
    return M(this, vr).map((e) => new e());
  }
  /**
   *
   * @param {Number} version
   * @returns {Array<MigrationBase>}
   */
  static constructFromVersion(e = null) {
    const t = Number(e) || Dn.RECOMMENDED_SAFE_VERSION;
    return M(this, vr).filter((s) => s.version > t).map((s) => new s());
  }
  /**
   *
   * @param {Number} minimum
   * @param {Number} maximum
   * @returns {Array<MigrationBase>}
   */
  static constructRange(e, t = 1 / 0) {
    return M(this, vr).filter((s) => s.version >= e && s.version <= t).map((s) => new s());
  }
};
vr = new WeakMap(), f(Z1, "MigrationList"), Y(Z1, vr, Object.values(e1e ?? {}));
let Ia = Z1;
async function qq() {
  if (!game.user.isGM)
    return;
  const i = game.settings.get("a5e", "systemMigrationVersion"), t = foundry.utils.isNewerVersion("0.10.8", i) ? "0.000" : game.settings.get("a5e", "worldSchemaVersion");
  if (!game.settings.storage.get("world").getItem("a5e.worldSchemaVersion")) {
    const r = Dn.RECOMMENDED_SAFE_VERSION, o = game.actors.size === 0 ? game.settings.get("a5e", "worldSchemaVersion") : Math.max(
      Math.min(...new Set(game.actors.map((a) => a.schemaVersion ?? r))),
      r
    );
    await game.settings.set("a5e", "worldSchemaVersion", o);
  }
  const n = Ia.constructFromVersion(t);
  console.debug("A5E | Migration List", n);
  const l = new Dn(n);
  l.needsMigration() && (t && t < Dn.MIN_SAFE_VERSION && ui.notifications.error(
    "Your A5E system data is from too old a Foundry version and cannot be reliably migrated to the latest version. The process will be attempted, but errors may occur.",
    { permanent: !0 }
  ), await l.runMigration());
}
f(qq, "handleMigration");
async function Gq(i, e = !1) {
  if (!game.user.isGM)
    return;
  ui.notifications.info(`Migrating ${i.metadata.label} to the latest version.`, { permanent: !0 }), await new Dn(
    Ia.constructFromVersion(null)
  ).runCompendiumMigration(i, e), ui.notifications.info(`Migrated ${i.metadata.label} to the latest version.`, { permanent: !0 });
}
f(Gq, "handlePackMigration");
const t1e = It({
  classes: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  },
  featureType: {
    inclusive: [],
    inclusiveMode: 0,
    exclusive: [],
    exclusiveMode: 0
  }
}), G3 = class G3 extends _s {
  constructor(e, t = {}) {
    const { collection: s } = e;
    super(foundry.utils.mergeObject(t, {
      id: "collection.metadata.package",
      title: `${s.metadata.label} ${s.locked ? "[LOCKED]" : ""}`,
      width: 560,
      height: "auto",
      resizable: !0,
      svelte: {
        class: kl,
        props: {
          compendiumType: "classFeature",
          customImporter: t.importer ?? null,
          document: null,
          filterStore: t1e
        }
      }
    })), this.compendiumCollection = e, this.options.svelte.props.document = s, this.options.svelte.props.sheet = this;
  }
  /**
  * Default Application options
  *
  * @returns {object} options - Application options.
  * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
  */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["a5efc-compendium-sheet"],
      minimizable: !0,
      svelte: {
        target: document.body
      }
    });
  }
};
f(G3, "ClassFeatureCompendiumSheet");
let c5 = G3;
async function zq(i) {
  const e = game.packs.get(i);
  e.getIndex({
    fields: [
      "system.description",
      "system.classes",
      "system.concentration",
      "system.featureType",
      "system.prerequisite",
      "system.source"
    ]
  }), e.applicationClass = c5;
}
f(zq, "createClassFeatureLikeIndex");
async function Hq(i) {
  const e = game.packs.get(i);
  e.getIndex({
    fields: [
      "system.description",
      "system.exertionCost",
      "system.concentration",
      "system.degree",
      "system.isStance",
      "system.source",
      "system.tradition"
    ]
  }), e.applicationClass = qc;
}
f(Hq, "createManeuverLikeIndex");
async function x5(i) {
  const e = game.packs.get(i);
  e.getIndex({
    fields: [
      "system.description",
      "system.details.cr",
      "system.details.creatureTypes",
      "system.details.elite",
      "system.details.isSquad",
      "system.details.isSwarm",
      "system.details.terrain",
      "system.traits.size",
      "system.source"
    ]
  }), e.applicationClass = Gc;
}
f(x5, "createMonsterLikeIndex");
async function Uq(i) {
  const e = game.packs.get(i);
  e.getIndex({
    fields: [
      "system.description",
      "system.details.cr",
      "system.details.creatureTypes",
      "system.details.elite",
      "system.details.isSwarm",
      "system.traits.size",
      "system.source"
    ]
  }), e.applicationClass = Gc;
}
f(Uq, "create5eMonsterLikeIndex");
async function e$(i) {
  const e = game.packs.get(i);
  e.getIndex({
    fields: [
      "system.requiresAttunement",
      "system.bulky",
      "system.objectType",
      "system.price",
      "system.quantity",
      "system.rarity",
      "system.source"
    ]
  }), e.applicationClass = Bc;
}
f(e$, "createObjectLikeIndex");
async function t$(i) {
  const e = game.packs.get(i);
  e.getIndex({
    fields: [
      "system.concentration",
      "system.components",
      "system.classes",
      "system.description",
      "system.level",
      "system.rare",
      "system.ritual",
      "system.schools",
      "system.source"
    ]
  }), e.applicationClass = zc;
}
f(t$, "createSpellLikeIndex");
async function Vq(i) {
  const e = game.packs.get(i);
  e.getIndex({
    fields: [
      "system.concentration",
      "system.components",
      "system.description",
      "system.level",
      "system.ritual",
      "system.schools",
      "system.source"
    ]
  }), e.applicationClass = Sp;
}
f(Vq, "create5eSpellLikeIndex");
const s1e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  create5eMonsterLikeIndex: Uq,
  create5eSpellLikeIndex: Vq,
  createClassFeatureLikeIndex: zq,
  createManeuverLikeIndex: Hq,
  createMonsterLikeIndex: x5,
  createObjectLikeIndex: e$,
  createSpellLikeIndex: t$
}, Symbol.toStringTag, { value: "Module" }));
function n1e(i) {
  let e, t;
  return e = new Ye({
    props: {
      options: (
        /*selections*/
        i[2]
      ),
      selected: (
        /*selected*/
        i[0]
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[6]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*selected*/
      1 && (l.selected = /*selected*/
      s[0]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(n1e, "create_default_slot$4");
function i1e(i) {
  let e, t, s, n, l, r, o;
  return t = new de({
    props: {
      hint: "Select which compendium to access",
      $$slots: { default: [n1e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      e = E("article"), L(t.$$.fragment), s = R(), n = E("button"), n.textContent = "Submit", b(e, "class", "svelte-b4620z");
    },
    m(a, c) {
      T(a, e, c), N(t, e, null), A(e, s), A(e, n), l = !0, r || (o = V(n, "click", tt(
        /*onSubmit*/
        i[1]
      )), r = !0);
    },
    p(a, [c]) {
      const u = {};
      c & /*$$scope, selected*/
      129 && (u.$$scope = { dirty: c, ctx: a }), t.$set(u);
    },
    i(a) {
      l || (w(t.$$.fragment, a), l = !0);
    },
    o(a) {
      C(t.$$.fragment, a), l = !1;
    },
    d(a) {
      a && S(e), j(t), r = !1, o();
    }
  };
}
f(i1e, "create_fragment$j");
function l1e(i, e, t) {
  let { dialog: s, packOptions: n, defaultSelection: l } = (
    // @ts-ignore
    fe("#external").application
  ), { dialog: r = s, packOptions: o = n, defaultSelection: a = l } = e;
  function c() {
    r.submit({ pack: d });
  }
  f(c, "onSubmit");
  const u = o;
  let d = a;
  const p = /* @__PURE__ */ f(({ detail: m }) => t(0, d = m), "updateSelection_handler");
  return i.$$set = (m) => {
    "dialog" in m && t(3, r = m.dialog), "packOptions" in m && t(4, o = m.packOptions), "defaultSelection" in m && t(5, a = m.defaultSelection);
  }, [
    d,
    c,
    u,
    r,
    o,
    a,
    p
  ];
}
f(l1e, "instance$h");
const z3 = class z3 extends ie {
  constructor(e) {
    super(), le(this, e, l1e, i1e, ne, {
      dialog: 3,
      packOptions: 4,
      defaultSelection: 5
    });
  }
  get dialog() {
    return this.$$.ctx[3];
  }
  set dialog(e) {
    this.$$set({ dialog: e }), Ke();
  }
  get packOptions() {
    return this.$$.ctx[4];
  }
  set packOptions(e) {
    this.$$set({ packOptions: e }), Ke();
  }
  get defaultSelection() {
    return this.$$.ctx[5];
  }
  set defaultSelection(e) {
    this.$$set({ defaultSelection: e }), Ke();
  }
};
f(z3, "ImportCompendiumSelectionDialog");
let u5 = z3;
const r1e = {
  inventory: Bc,
  maneuvers: qc,
  spells: zc
}, o1e = {
  inventory: "object",
  maneuvers: "maneuver",
  spells: "spell"
};
async function a1e(i, e, t = {}) {
  const { importFunction: s } = t;
  let { pack: n } = t;
  const l = o1e[e], r = game.packs.reduce((d, p) => {
    const m = p.metadata.id || p.collection;
    return !m || p.metadata.type !== "Item" || !p.testUserPermission(game.user, CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER) || ![...p.index].map((_) => _.type).filter(Boolean).every((_) => _ === l) || d.push([m, p.metadata.label]), d;
  }, []);
  if (!(game.settings.get("a5e", "hideActorCompendiumSelectionDialog") ?? !1) && r.length > 1) {
    const d = new pa(
      "Select Compendium",
      u5,
      { packOptions: r, defaultSelection: CONFIG.A5E.defaultActorImportCompendia[e] }
    );
    await d.render(!0);
    const p = await d.promise;
    if (!(p != null && p.pack))
      return;
    n = p.pack;
  }
  const a = n ? game.packs.get(n) : game.packs.get(CONFIG.A5E.defaultActorImportCompendia[e]);
  if (!a) {
    ui.notifications.error(`No compendium found for ${e}`);
    return;
  }
  const c = s ?? ((d) => i.createEmbeddedDocuments("Item", d));
  new r1e[e]({ collection: a }, { importer: c }).render(!0);
}
f(a1e, "openCompendium");
function c1e() {
  return CONFIG.A5E = Ie, CONFIG.ActiveEffect.documentClass = da, CONFIG.Actor.documentClass = Wfe, CONFIG.Actor.trackableAttributes = Vge, CONFIG.Item.documentClass = Kfe, CONFIG.Token.documentClass = _p, CONFIG.Token.objectClass = bp, CONFIG.ui.items = _w, CONFIG.Dice.D20Roll = ic, CONFIG.Dice.rolls.push(ic), CONFIG.MeasuredTemplate.defaults.angle = 60, (game.settings.storage.get("world").getItem("a5e.worldSchemaVersion") ?? 1) > 8e-3 && (CONFIG.Actor.dataModels.character = ow, CONFIG.Actor.dataModels.npc = aw), CONFIG.Item.dataModels = Ipe, game.a5e = {
    applications: {
      ActorSheetA5e: Pb,
      ItemSheetA5e: _8
    },
    activeEffects: {
      EffectOption: ro,
      options: {},
      effectsPanel: null
    },
    compendiumSheets: {
      DND5ESpellCompendiumSheet: Sp,
      ItemCompendiumSheet: Bc,
      ManeuverCompendiumSheet: qc,
      MonsterCompendiumSheet: Gc,
      SpellCompendiumSheet: zc
    },
    config: Ie,
    dice: {
      D20Roll: ic
    },
    documentClasses: {
      ...Ie.Actor.documentClasses,
      ...Ie.Item.documentClasses,
      TokenDocumentA5e: _p,
      TokenA5e: bp
    },
    dialogs: {
      bonuses: {
        abilities: {},
        damage: {},
        healing: {},
        skills: {}
      }
    },
    macros: {
      activateActionMacro: Wge,
      activateItemMacro: Kge,
      createMacro: Yge
    },
    managers: {
      ActionsManager: ri,
      ForeignDocumentManager: Hw,
      HitDiceManager: Ic,
      ItemGrantsManager: _a,
      ModifierManager: Oc,
      ResourceConsumptionManager: np,
      RestManager: qd,
      RollPreparationManager: $r,
      SubObjectManager: Dr,
      TemplatePreparationManager: wa
    },
    migrations: {
      MigrationList: Ia,
      MigrationRunner: Dn,
      handleMigration: qq,
      handlePackMigration: Gq
    },
    settings: {
      store: Aa
    },
    utils: {
      getDeterministicBonus: at,
      compendiaIndexFunctions: s1e,
      openCompendium: a1e
    }
  }, Actors.unregisterSheet("core", ActorSheet), Actors.registerSheet("a5e", Pb, {
    types: ["character"],
    makeDefault: !0,
    label: "A5E.SheetClassCharacter"
  }), Actors.registerSheet("a5e", Pb, {
    types: ["npc"],
    makeDefault: !0,
    label: "A5E.SheetClassNPC"
  }), Items.unregisterSheet("core", ItemSheet), Items.registerSheet("a5e", _8, {
    makeDefault: !0,
    label: "A5E.SheetClassItem"
  }), DocumentSheetConfig.unregisterSheet(ActiveEffect, "core", ActiveEffectConfig), DocumentSheetConfig.registerSheet(ActiveEffect, "a5e", $k, {
    makeDefault: !0,
    label: "A5E.SheetClassActiveEffectConfig"
  }), Combatant.prototype._getInitiativeFormula = Lge, Combatant.prototype.getInitiativeRoll = Bge, Combatant.prototype.rollInitiative = Hge, Combat.prototype.rollInitiative = Uge, CombatTracker.prototype._onCombatantControl = Dge, CombatTracker.prototype._onCombatControl = Oge, Yfe(), TooltipManager.TOOLTIP_ACTIVATION_MS = 100, Hooks.once("i18nInit", () => {
    zge(CONFIG.A5E), game.a5e.activeEffects.options = zpe();
  }), Cge(), qge();
}
f(c1e, "init");
async function u1e(i) {
  var n;
  if (!game.user.isGM)
    return;
  const e = game.settings.get("a5e", "systemMigrationVersion");
  foundry.utils.isNewerVersion("0.10.8", e);
  const t = new Dn(
    Ia.constructFromVersion(
      ((n = i.system.schemaVersion) == null ? void 0 : n.version) ?? i.system.schema.version ?? 0
    )
  );
  await t.runDocumentMigration(
    i,
    t.migrations
  ) ? ui.notifications.info(`Migrated ${i.name} to the latest version.`) : ui.notifications.info(`No migration for ${i.name} not available.`);
}
f(u1e, "handleDocumentMigration");
function s$(i, e, t, s) {
  if (!game.user.isGM)
    return;
  const n = {
    name: K("A5E.migration.migrateDocument", { type: s }),
    icon: '<i class="fa-solid fa-crow"></i>',
    callback: (l) => f1e(l, s)
  };
  e.push(n);
}
f(s$, "getDocumentDirectoryContext");
function f1e(i, e) {
  if (e === "Pack") {
    const t = game.packs.get(i.data("pack"));
    t && Gq(t);
  } else {
    const t = e === "Actor" ? "actors" : "items", s = game[t].get(i.data("document-id"));
    s && u1e(s);
  }
}
f(f1e, "callMigration");
function d1e(i) {
  var t, s;
  typeof ((t = i == null ? void 0 : i.flags) == null ? void 0 : t.a5e) == "object" && typeof ((s = i == null ? void 0 : i._svelteComponent) == null ? void 0 : s.$destroy) == "function" && i._svelteComponent.$destroy();
}
f(d1e, "preDeleteChatMessage");
function p1e(i, e, t, s) {
  game.user.id === s && i.updateSource({
    "flags.core.canPopout": !0
  });
}
f(p1e, "preCreateChatMessage");
function m1e(i, e, t) {
  if (e.type === "Item")
    return game.a5e.macros.createMacro(e, t), !1;
}
f(m1e, "hotbarDrop");
function h1e(i) {
  let e;
  return {
    c() {
      e = E("article"), e.innerHTML = `<p class="svelte-fyqitg">Welcome to the A5e Foundry system!</p> <p class="svelte-fyqitg">It&#39;s been a while since we&#39;ve done one of these in-system announcements,
        but a lot has changed recently, and I think it&#39;s worth updating everyone
        on some current and upcoming features.</p> <section class="announcement-section svelte-fyqitg"><header><h3 class="announcement-section-heading svelte-fyqitg"><i class="fa-brands fa-patreon"></i>
                Patreon</h3></header> <p class="svelte-fyqitg">First of all, we now have a <a href="https://www.patreon.com/ForgemasterModules" target="_blank" class="svelte-fyqitg">Patreon page</a>!</p> <p class="svelte-fyqitg">This is part of an effort to streamline donations to the system,
            which were previously being split between several user accounts and
            platforms. As part of our move to Patreon, we&#39;ve also begun offering
            Patreon exclusive modules to our patrons, including a set of
            <a href="https://www.patreon.com/posts/5e-a5e-tools-89802245" target="_blank" class="svelte-fyqitg">conversion tools</a> for getting content from a 5e Foundry world into one using A5e.</p> <p class="svelte-fyqitg">Our latest module provides a set of
            <a href="https://www.patreon.com/posts/preview-of-our-90869285" target="_blank" class="svelte-fyqitg">new compendium sheets</a>
            that include powerful filters, as well as summary details for each document.
            These new sheets will be rolled into the core system towards the end
            of November.</p> <img class="announcement-image announcement-image--full svelte-fyqitg" src="systems/a5e/assets/announcements/fancy-compendium-preview.webp" alt="A preview of the Fancy Compendium Sheets module"/></section> <section class="announcement-section svelte-fyqitg"><header><h3 class="announcement-section-heading svelte-fyqitg"><i class="fa-brands fa-d-and-d"></i>
                D&amp;D 5e Support</h3></header> <p class="svelte-fyqitg">Next up, we&#39;ve been expanding our support for D&amp;D 5e in the system,
            and you&#39;ll start to see more and more 5e-specific settings in the
            coming weeks.</p> <p class="svelte-fyqitg">We&#39;ve also just released a set of 5e compendium packs that come
            baked into the A5e system. At the time of writing, we don&#39;t yet have
            a pack for 5e adventuring gear or magic items, but these will be
            coming soon.</p></section> <section class="announcement-section svelte-fyqitg"><header><h3 class="announcement-section-heading svelte-fyqitg"><i class="fa-solid fa-users"></i>
                The Party Viewer</h3></header> <p class="svelte-fyqitg">The system now includes a special interface for keeping track of
            your party&#39;s key statistics and resources. There&#39;s a button to
            access this interface on the left side of your screen (<i class="button-hint fa-solid fa-users svelte-fyqitg"></i>), and can also quickly toggle the Party Viewer by pressing the
            <i class="button-hint button-hint--letter-key fa-solid fa-p svelte-fyqitg"></i>
            key.</p> <p class="svelte-fyqitg">Below you can see the Party Viewer showcasing my own party, familiar
            and all!</p> <img class="announcement-image announcement-image--full svelte-fyqitg" src="systems/a5e/assets/announcements/party-viewer-preview.webp" alt="Party Viewer Preview"/></section> <section class="announcement-section svelte-fyqitg"><header><h3 class="announcement-section-heading svelte-fyqitg"><i class="fa-solid fa-person-rays"></i>
                The Effects Panel</h3></header> <p class="svelte-fyqitg">We&#39;ve added a handy effects interface to keep track of the effects
            affecting a given token. This includes both temporary Active Effects
            and conditions. Conditions automatically include a handy summary of
            the relevant rules when you hover over an icon in the panel.</p> <img class="announcement-image announcement-image--full svelte-fyqitg" src="systems/a5e/assets/announcements/effects-interface-preview.webp" alt="Effects Interface Preview"/></section> <section class="announcement-section svelte-fyqitg"><header><h3 class="announcement-section-heading svelte-fyqitg"><i class="fa-solid fa-message"></i>
                Chat Card Improvements</h3></header> <p class="svelte-fyqitg">We&#39;ve made a number of improvements to the chat cards recently. You
            can now modify rolls that are already in the chat by clicking the
            dice button next to the roll in the chat card. This will allow you
            to retroactively apply advantage / disadvantage or change the
            expertise die size for a given roll.</p> <p class="svelte-fyqitg">The chat now also includes a handy crit toggle for cases where crits
            are negated or where you get a critical hit without hitting your
            usual critical hit threshold.</p></section> <section class="announcement-section svelte-fyqitg"><header><h3 class="announcement-section-heading svelte-fyqitg"><i class="fa-brands fa-discord"></i>
                Join our Discord Server</h3></header> <p class="svelte-fyqitg">If you want to keep up to date with the latest developments,
            definitely <a href="https://discord.gg/U3PtYfPKb2" target="_blank" class="svelte-fyqitg">join our Discord server</a>. It&#39;s also the best place to get help and support if you need it.</p> <p class="svelte-fyqitg">Our server is also home to almost all of the A5e third-party
            publishers, so it&#39;s also a great place to keep up to date with Level
            Up&#39;s vibrant 3PP scene.</p></section>`, b(e, "class", "main-announcement-container svelte-fyqitg");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: ee,
    i: ee,
    o: ee,
    d(t) {
      t && S(e);
    }
  };
}
f(h1e, "create_fragment$i");
var $f;
let g1e = ($f = class extends ie {
  constructor(e) {
    super(), le(this, e, null, h1e, ne, {});
  }
}, f($f, "AnnouncementDialog"), $f);
var Af, f5;
const H3 = class H3 extends Fs {
  constructor(t) {
    super({
      title: t,
      content: {
        class: g1e,
        props: {}
      }
    }, {
      classes: ["a5e-sheet a5e-sheet--announcement"],
      width: 540
    });
    Y(this, Af);
    this.data.content.props.dialog = this, this.promise = new Promise((s) => {
      this.resolve = s;
    });
  }
  /** @inheritdoc */
  close(t) {
    return Z(this, Af, f5).call(this, null), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    return Z(this, Af, f5).call(this, t), super.close();
  }
};
Af = new WeakSet(), f5 = /* @__PURE__ */ f(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), f(H3, "AnnouncementDialog");
let Pp = H3;
function b1e(i) {
  let e, t;
  return {
    c: ee,
    m(s, n) {
      e || (t = [
        V(
          window,
          "keydown",
          /*keydown_handler*/
          i[2]
        ),
        V(
          window,
          "keyup",
          /*keyup_handler*/
          i[3]
        ),
        V(
          window,
          "blur",
          /*blur_handler*/
          i[4]
        )
      ], e = !0);
    },
    p: ee,
    i: ee,
    o: ee,
    d(s) {
      e = !1, Ne(t);
    }
  };
}
f(b1e, "create_fragment$h");
function _1e(i) {
  let e;
  const t = Mi.subscribe((a) => e = a);
  function s(a) {
    e.Alt = a.altKey, e.Control = a.metaKey || a.ctrlKey, e.Shift = a.shiftKey, Mi.update(() => ({ ...e }));
  }
  f(s, "logKey");
  function n() {
    Object.keys(e).forEach((a) => e[a] = !1), Mi.update(() => ({ ...e }));
  }
  return f(n, "resetKeys"), Nt(t), [s, n, /* @__PURE__ */ f((a) => s(a), "keydown_handler"), /* @__PURE__ */ f((a) => s(a), "keyup_handler"), /* @__PURE__ */ f(() => n(), "blur_handler")];
}
f(_1e, "instance$g");
const U3 = class U3 extends ie {
  constructor(e) {
    super(), le(this, e, _1e, b1e, ne, {});
  }
};
f(U3, "KeyPressHandler");
let d5 = U3;
function hL(i, e, t) {
  const s = i.slice();
  return s[4] = e[t][0], s[5] = e[t][1], s[6] = e[t][2], s;
}
f(hL, "get_each_context$5");
function gL(i) {
  let e, t, s, n = (
    /*moduleTitle*/
    i[4] + ""
  ), l, r, o, a, c, u, d = (
    /*reason*/
    i[5] + ""
  ), p, m;
  return {
    c() {
      e = E("li"), t = E("header"), s = E("h3"), l = x(n), r = R(), o = E("i"), u = R(), p = x(d), m = R(), b(s, "class", "module__title svelte-z454kk"), b(o, "class", "module__priority-icon fa-solid fa-circle svelte-z454kk"), b(o, "style", a = bL(
        /*priority*/
        i[6]
      )), b(o, "data-tooltip", c = _L(
        /*priority*/
        i[6]
      )), b(o, "data-tooltip-direction", "UP"), b(t, "class", "module__header svelte-z454kk");
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(t, s), A(s, l), A(t, r), A(t, o), A(e, u), A(e, p), A(e, m);
    },
    p(g, h) {
      h & /*modules*/
      1 && n !== (n = /*moduleTitle*/
      g[4] + "") && _e(l, n), h & /*modules*/
      1 && a !== (a = bL(
        /*priority*/
        g[6]
      )) && b(o, "style", a), h & /*modules*/
      1 && c !== (c = _L(
        /*priority*/
        g[6]
      )) && b(o, "data-tooltip", c), h & /*modules*/
      1 && d !== (d = /*reason*/
      g[5] + "") && _e(p, d);
    },
    d(g) {
      g && S(e);
    }
  };
}
f(gL, "create_each_block$5");
function y1e(i) {
  let e, t, s, n, l, r, o = oe(
    /*modules*/
    i[0]
  ), a = [];
  for (let c = 0; c < o.length; c += 1)
    a[c] = gL(hL(i, o, c));
  return {
    c() {
      e = E("article"), t = E("ul");
      for (let c = 0; c < a.length; c += 1)
        a[c].c();
      s = R(), n = E("button"), n.textContent = "Deactivate All", b(t, "class", "module-list svelte-z454kk"), b(e, "class", "main-announcement-container svelte-z454kk");
    },
    m(c, u) {
      T(c, e, u), A(e, t);
      for (let d = 0; d < a.length; d += 1)
        a[d] && a[d].m(t, null);
      A(e, s), A(e, n), l || (r = V(
        n,
        "click",
        /*click_handler*/
        i[3]
      ), l = !0);
    },
    p(c, [u]) {
      if (u & /*modules, getPriorityColor, getPriorityTooltipLabel*/
      1) {
        o = oe(
          /*modules*/
          c[0]
        );
        let d;
        for (d = 0; d < o.length; d += 1) {
          const p = hL(c, o, d);
          a[d] ? a[d].p(p, u) : (a[d] = gL(p), a[d].c(), a[d].m(t, null));
        }
        for (; d < a.length; d += 1)
          a[d].d(1);
        a.length = o.length;
      }
    },
    i: ee,
    o: ee,
    d(c) {
      c && S(e), Le(a, c), l = !1, r();
    }
  };
}
f(y1e, "create_fragment$g");
function bL(i) {
  switch (i) {
    case "low":
      return "color: #ffb404;";
    case "medium":
      return "color: #fe8006;";
    case "high":
      return "color: #fe3901;";
  }
}
f(bL, "getPriorityColor");
function _L(i) {
  switch (i) {
    case "low":
      return "Low Priority: No Adverse Effects";
    case "medium":
      return "Medium Priority: Limited Adverse Effects on System Functionality";
    case "high":
      return "High Priority: Adverse Effects on System Functionality";
  }
}
f(_L, "getPriorityTooltipLabel");
function v1e(i, e, t) {
  let s;
  async function n() {
    const a = game.settings.get("core", "moduleConfiguration"), c = r.reduce(
      (u, [d]) => (u[d] = !1, u),
      {}
    );
    await game.settings.set("core", "moduleConfiguration", foundry.utils.mergeObject(a, c)), window.location.reload();
  }
  f(n, "deactivateIncompatibleModules");
  let { activeIncompatibleModules: l } = fe("#external").application, { activeIncompatibleModules: r = l } = e;
  const o = /* @__PURE__ */ f(() => n(), "click_handler");
  return i.$$set = (a) => {
    "activeIncompatibleModules" in a && t(2, r = a.activeIncompatibleModules);
  }, i.$$.update = () => {
    i.$$.dirty & /*activeIncompatibleModules*/
    4 && t(0, s = r.map(([a, { reason: c, priority: u }]) => {
      var d;
      return [(d = game.modules.get(a)) == null ? void 0 : d.title, c, u];
    }));
  }, [
    s,
    n,
    r,
    o
  ];
}
f(v1e, "instance$f");
var Ef;
let k1e = (Ef = class extends ie {
  constructor(e) {
    super(), le(this, e, v1e, y1e, ne, { activeIncompatibleModules: 2 });
  }
  get activeIncompatibleModules() {
    return this.$$.ctx[2];
  }
  set activeIncompatibleModules(e) {
    this.$$set({ activeIncompatibleModules: e }), Ke();
  }
}, f(Ef, "ModuleIncompatibilityDialog"), Ef);
var Sf, m5;
const V3 = class V3 extends Fs {
  constructor(t) {
    super({
      title: "Module Notices",
      content: {
        class: k1e,
        props: { activeIncompatibleModules: t }
      },
      zIndex: null
    }, {
      classes: ["a5e-sheet a5e-sheet--announcement"],
      width: 540
    });
    Y(this, Sf);
    this.data.content.props.dialog = this, this.promise = new Promise((s) => {
      this.resolve = s;
    });
  }
  /** @inheritdoc */
  close(t) {
    return Z(this, Sf, m5).call(this, null), super.close(t);
  }
  /**
   * Resolves the dialog's promise and closes it.
   *
   * @param {object} results
   * @returns
   */
  submit(t) {
    return Z(this, Sf, m5).call(this, t), super.close();
  }
};
Sf = new WeakSet(), m5 = /* @__PURE__ */ f(function(t) {
  this.resolve && this.resolve(t);
}, "#resolvePromise"), f(V3, "ModuleIncompatibilityDialog");
let p5 = V3;
async function w1e() {
  const i = "0.16.4", e = game.user.getFlag("a5e", "latestAnnouncement");
  if (!(!e || foundry.utils.isNewerVersion(i, e)))
    return;
  new Pp("A5e Version 0.16.4 Announcements").render(!0), game.user.setFlag("a5e", "latestAnnouncement", game.system.version);
}
f(w1e, "handleAnnouncement");
async function $1e() {
  if (!game.user.isGM)
    return;
  const i = Object.entries(CONFIG.A5E.moduleIncompatibilities).filter(([t]) => {
    var s;
    return (s = game.modules.get(t)) == null ? void 0 : s.active;
  });
  if (!i.length)
    return;
  new p5(i).render(!0);
}
f($1e, "handleIncompatibilityWarning");
async function A1e() {
  new d5({ target: document.body });
}
f(A1e, "addKeyPressLogger");
async function E1e() {
  Hooks.on("hotbarDrop", m1e), qq(), w1e(), $1e(), A1e();
}
f(E1e, "ready");
function S1e(i) {
  if (i.constructor.name !== "SceneControls" || !game.settings.get("a5e", "playersCanAccessPartyViewer") && !game.user.isGM)
    return;
  const e = document.querySelector("nav#controls .main-controls"), t = document.createElement("li"), s = document.createElement("i");
  s.classList.add("fa-solid", "fa-users"), t.id = "a5e-js-toggle-party-viewer-visibility", t.classList.add("scene-control"), t.setAttribute("data-tooltip", "Party Viewer"), t.addEventListener("click", bq), t.append(s), e.append(t);
}
f(S1e, "renderApplication");
const Mp = /* @__PURE__ */ f((...i) => [...i[0]].map((e, t) => i.map((s) => s[t])), "zip");
function yL(i) {
  let e, t;
  return {
    c() {
      e = E("h3"), t = x(
        /*subtitle*/
        i[4]
      ), b(e, "class", "a5e-card-header__subtitle");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n & /*subtitle*/
      16 && _e(
        t,
        /*subtitle*/
        s[4]
      );
    },
    d(s) {
      s && S(e);
    }
  };
}
f(yL, "create_if_block_1$5");
function vL(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "a5e-card-header__crit-toggle-button fa-solid fa-bullseye"), b(e, "data-tooltip", "Toggle Critical Damage"), b(e, "data-tooltip-direction", "LEFT"), Q(
        e,
        "a5e-card-header__crit-toggle-button--crit",
        /*critDamageEnabled*/
        i[5]
      );
    },
    m(n, l) {
      T(n, e, l), t || (s = V(e, "click", We(
        /*click_handler*/
        i[10]
      )), t = !0);
    },
    p(n, l) {
      l & /*critDamageEnabled*/
      32 && Q(
        e,
        "a5e-card-header__crit-toggle-button--crit",
        /*critDamageEnabled*/
        n[5]
      );
    },
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(vL, "create_if_block$7");
function T1e(i) {
  let e, t, s, n, l, r, o, a, c, u, d = (
    /*subtitle*/
    i[4] && yL(i)
  ), p = (
    /*showCritDamageToggle*/
    i[6] && vL(i)
  );
  return {
    c() {
      e = E("header"), t = E("img"), n = R(), l = E("h2"), r = x(
        /*title*/
        i[3]
      ), o = R(), d && d.c(), a = R(), p && p.c(), b(t, "class", "a5e-card-header__image"), ze(t.src, s = /*img*/
      i[2]) || b(t, "src", s), b(
        t,
        "alt",
        /*altText*/
        i[0]
      ), b(l, "class", "a5e-card-header__title"), b(e, "class", "a5e-card-header"), b(e, "role", "button"), b(e, "tabindex", "0"), Q(
        e,
        "a5e-card-header--subtitle",
        /*subtitle*/
        i[4]
      ), Q(
        e,
        "a5e-card-header--clickable",
        /*clickableHeader*/
        i[1]
      );
    },
    m(m, g) {
      T(m, e, g), A(e, t), A(e, n), A(e, l), A(l, r), A(e, o), d && d.m(e, null), A(e, a), p && p.m(e, null), c || (u = V(
        e,
        "click",
        /*click_handler_1*/
        i[11]
      ), c = !0);
    },
    p(m, [g]) {
      g & /*img*/
      4 && !ze(t.src, s = /*img*/
      m[2]) && b(t, "src", s), g & /*altText*/
      1 && b(
        t,
        "alt",
        /*altText*/
        m[0]
      ), g & /*title*/
      8 && _e(
        r,
        /*title*/
        m[3]
      ), /*subtitle*/
      m[4] ? d ? d.p(m, g) : (d = yL(m), d.c(), d.m(e, a)) : d && (d.d(1), d = null), /*showCritDamageToggle*/
      m[6] ? p ? p.p(m, g) : (p = vL(m), p.c(), p.m(e, null)) : p && (p.d(1), p = null), g & /*subtitle*/
      16 && Q(
        e,
        "a5e-card-header--subtitle",
        /*subtitle*/
        m[4]
      ), g & /*clickableHeader*/
      2 && Q(
        e,
        "a5e-card-header--clickable",
        /*clickableHeader*/
        m[1]
      );
    },
    i: ee,
    o: ee,
    d(m) {
      m && S(e), d && d.d(), p && p.d(), c = !1, u();
    }
  };
}
f(T1e, "create_fragment$f");
function C1e(i, e, t) {
  let s, n, l, { altText: r } = e, { clickableHeader: o } = e, { img: a } = e, { title: c } = e, { subtitle: u = null } = e;
  const d = it(), p = fe("message");
  pe(i, p, (h) => t(9, l = h));
  const m = /* @__PURE__ */ f(() => d("toggleCriticalDamage"), "click_handler"), g = /* @__PURE__ */ f(() => d("toggleDescription"), "click_handler_1");
  return i.$$set = (h) => {
    "altText" in h && t(0, r = h.altText), "clickableHeader" in h && t(1, o = h.clickableHeader), "img" in h && t(2, a = h.img), "title" in h && t(3, c = h.title), "subtitle" in h && t(4, u = h.subtitle);
  }, i.$$.update = () => {
    var h, _, y, k;
    i.$$.dirty & /*$message*/
    512 && t(6, s = (((_ = (h = l == null ? void 0 : l.flags) == null ? void 0 : h.a5e) == null ? void 0 : _.rollData) ?? []).some((v) => v.type === "damage" && (v.canCrit ?? !0) && v.critRoll && v.baseRoll)), i.$$.dirty & /*$message*/
    512 && t(5, n = Mp(l.rolls ?? [], ((k = (y = l == null ? void 0 : l.flags) == null ? void 0 : y.a5e) == null ? void 0 : k.rollData) ?? []).some(([v, O]) => !(O.type !== "damage" || !O.canCrit || !O.critRoll || !O.baseRoll || O.baseRoll.formula === v.formula)));
  }, [
    r,
    o,
    a,
    c,
    u,
    n,
    s,
    d,
    p,
    l,
    m,
    g
  ];
}
f(C1e, "instance$e");
const W3 = class W3 extends ie {
  constructor(e) {
    super(), le(this, e, C1e, T1e, ne, {
      altText: 0,
      clickableHeader: 1,
      img: 2,
      title: 3,
      subtitle: 4
    });
  }
};
f(W3, "BaseHeader");
let Rp = W3;
function O1e(i) {
  let e, t, s;
  return e = new Rp({
    props: {
      img: (
        /*img*/
        i[1]
      ),
      altText: (
        /*name*/
        i[2]
      ),
      clickableHeader: !1,
      title: (
        /*name*/
        i[2]
      )
    }
  }), e.$on(
    "repeatCard",
    /*repeatCard_handler*/
    i[6]
  ), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--bottom-padding", "0.25rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p: ee,
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(O1e, "create_if_block$6");
function D1e(i) {
  var l;
  let e = (
    /*user*/
    i[5].isGM || /*actor*/
    ((l = i[3]) == null ? void 0 : l.testUserPermission(
      /*user*/
      i[5],
      1
    ))
  ), t, s, n = e && O1e(i);
  return {
    c() {
      n && n.c(), t = $e();
    },
    m(r, o) {
      n && n.m(r, o), T(r, t, o), s = !0;
    },
    p(r, [o]) {
      e && n.p(r, o);
    },
    i(r) {
      s || (w(n), s = !0);
    },
    o(r) {
      C(n), s = !1;
    },
    d(r) {
      r && S(t), n && n.d(r);
    }
  };
}
f(D1e, "create_fragment$e");
function I1e(i, e, t) {
  var g;
  let s, n = ee, l = /* @__PURE__ */ f(() => (n(), n = Et(r, (h) => t(7, s = h)), r), "$$subscribe_message");
  i.$$.on_destroy.push(() => n());
  let { message: r } = e;
  l();
  const { actorId: o, img: a, name: c } = (g = s == null ? void 0 : s.flags) == null ? void 0 : g.a5e, u = fromUuidSync(o), d = it(), { user: p } = game, m = /* @__PURE__ */ f(() => d("repeatCard"), "repeatCard_handler");
  return i.$$set = (h) => {
    "message" in h && l(t(0, r = h.message));
  }, [r, a, c, u, d, p, m];
}
f(I1e, "instance$d");
const K3 = class K3 extends ie {
  constructor(e) {
    super(), le(this, e, I1e, D1e, ne, { message: 0 });
  }
};
f(K3, "CheckHeader");
let h5 = K3;
function P1e(i) {
  let e;
  return {
    c() {
      e = E("i"), b(e, "class", "die fa-solid fa-dice-d20 svelte-134pqo6"), Q(
        e,
        "die--generic-prompt",
        /*prompt*/
        i[1].type === "generic"
      );
    },
    m(t, s) {
      T(t, e, s);
    },
    p(t, s) {
      s & /*prompt*/
      2 && Q(
        e,
        "die--generic-prompt",
        /*prompt*/
        t[1].type === "generic"
      );
    },
    d(t) {
      t && S(e);
    }
  };
}
f(P1e, "create_else_block$1");
function M1e(i) {
  let e, t;
  return {
    c() {
      e = E("img"), b(e, "class", "effect-icon svelte-134pqo6"), ze(e.src, t = /*icon*/
      i[0]) || b(e, "src", t), b(e, "alt", "title");
    },
    m(s, n) {
      T(s, e, n);
    },
    p(s, n) {
      n & /*icon*/
      1 && !ze(e.src, t = /*icon*/
      s[0]) && b(e, "src", t);
    },
    d(s) {
      s && S(e);
    }
  };
}
f(M1e, "create_if_block_1$4");
function kL(i) {
  let e, t;
  return {
    c() {
      e = E("span"), t = x(
        /*subtitle*/
        i[3]
      ), b(e, "class", "subtitle svelte-134pqo6");
    },
    m(s, n) {
      T(s, e, n), A(e, t);
    },
    p(s, n) {
      n & /*subtitle*/
      8 && _e(
        t,
        /*subtitle*/
        s[3]
      );
    },
    d(s) {
      s && S(e);
    }
  };
}
f(kL, "create_if_block$5");
function R1e(i) {
  let e, t, s, n, l, r, o, a, c;
  function u(g, h) {
    return (
      /*prompt*/
      g[1].type === "effect" ? M1e : P1e
    );
  }
  f(u, "select_block_type");
  let d = u(i), p = d(i), m = (
    /*subtitle*/
    i[3] && kL(i)
  );
  return {
    c() {
      e = E("button"), t = E("div"), p.c(), s = R(), n = E("header"), l = E("span"), r = x(
        /*title*/
        i[2]
      ), o = R(), m && m.c(), b(t, "class", "icon-wrapper svelte-134pqo6"), Q(
        t,
        "icon-wrapper--effect",
        /*prompt*/
        i[1].type === "effect"
      ), b(l, "class", "title svelte-134pqo6"), b(n, "class", "title-wrapper svelte-134pqo6"), b(e, "class", "save-prompt svelte-134pqo6");
    },
    m(g, h) {
      T(g, e, h), A(e, t), p.m(t, null), A(e, s), A(e, n), A(n, l), A(l, r), A(n, o), m && m.m(n, null), a || (c = V(
        e,
        "click",
        /*click_handler*/
        i[5]
      ), a = !0);
    },
    p(g, [h]) {
      d === (d = u(g)) && p ? p.p(g, h) : (p.d(1), p = d(g), p && (p.c(), p.m(t, null))), h & /*prompt*/
      2 && Q(
        t,
        "icon-wrapper--effect",
        /*prompt*/
        g[1].type === "effect"
      ), h & /*title*/
      4 && _e(
        r,
        /*title*/
        g[2]
      ), /*subtitle*/
      g[3] ? m ? m.p(g, h) : (m = kL(g), m.c(), m.m(n, null)) : m && (m.d(1), m = null);
    },
    i: ee,
    o: ee,
    d(g) {
      g && S(e), p.d(), m && m.d(), a = !1, c();
    }
  };
}
f(R1e, "create_fragment$d");
function F1e(i, e, t) {
  let { icon: s = null } = e, { prompt: n } = e, { title: l } = e, { subtitle: r = null } = e;
  const o = it(), a = /* @__PURE__ */ f(() => o("triggerPrompt"), "click_handler");
  return i.$$set = (c) => {
    "icon" in c && t(0, s = c.icon), "prompt" in c && t(1, n = c.prompt), "title" in c && t(2, l = c.title), "subtitle" in c && t(3, r = c.subtitle);
  }, [s, n, l, r, o, a];
}
f(F1e, "instance$c");
const Y3 = class Y3 extends ie {
  constructor(e) {
    super(), le(this, e, F1e, R1e, ne, {
      icon: 0,
      prompt: 1,
      title: 2,
      subtitle: 3
    });
  }
};
f(Y3, "PromptButton");
let g5 = Y3;
function N1e(i) {
  var s, n;
  if (!game.settings.get("a5e", "protectRolls"))
    return !0;
  const e = (n = (s = i == null ? void 0 : i.flags) == null ? void 0 : s.a5e) == null ? void 0 : n.actorId, t = fromUuidSync(e);
  return !t || t.type === "character" ? !0 : t.permission >= 2;
}
f(N1e, "getTooltipPermissions");
function j1e(i) {
  const e = game.settings.get("a5e", "terseRollFormulae");
  return `<div class="a5e-roll-formula">${i.terms.reduce((s, n) => {
    let l = `<span class="a5e-roll-formula__term">${n.expression}`;
    return n.flavor && !e && (l += ` [${n.flavor}]`), l += "</span>", s + l;
  }, "")}</div>`;
}
f(j1e, "prepareRollTooltipFormula");
function L1e({ faces: i, results: e }, t) {
  return e.reduce((s, { rerolled: n, discarded: l, result: r }) => {
    const o = i === 20 && r >= t.critThreshold || r === i, a = l || n, c = r === 1;
    let u = `a5e-die a5e-die--${i}`;
    return a ? u += " a5e-die--discarded" : c ? u += " a5e-die--min" : o && (u += " a5e-die--max"), `${s}<li class="${u}">${r}</li>`;
  }, "");
}
f(L1e, "prepareRollTooltipDiceResults");
function B1e(i, e) {
  return i.dice.reduce((t, s) => {
    let n = `<section class="u-mb-md">
          <header class="u-align-center u-flex u-justify-space-between u-text-bold">
              <div class="a5e-dice-tooltip__formula">
                  ${s.expression}
                  <span class="a5e-dice-tooltip__flavor">`;
    return s.flavor && (n += ` [${s.flavor}]`), n += `</span></div>
              <span class="a5e-dice-tooltip__total">${s.total}</span>
          </header>

      <ol class="u-align-center u-flex u-flex-wrap u-gap-xs u-list-style-none u-my-xs u-p-0">`, n += L1e(s, e), n += "</ol></section>", t + n;
  }, "");
}
f(B1e, "prepareRollTooltipRollParts");
function wL(i, e, t) {
  return N1e(i) ? [B1e(e, t), j1e(e)].join("") : null;
}
f(wL, "prepareRollTooltip");
function $L(i, e, t) {
  const s = i.slice();
  return s[8] = e[t].label, s[9] = e[t].multiplier, s[10] = e[t].temp, s[11] = e[t].icon, s;
}
f($L, "get_each_context$4");
function q1e(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), e.innerHTML = '<i class="fa-solid fa-heart-circle-plus button__icon"></i>', b(e, "class", "healing-button svelte-gwecro"), b(e, "data-tooltip", "Apply Healing"), b(e, "data-tooltip-direction", "LEFT");
    },
    m(n, l) {
      T(n, e, l), t || (s = V(e, "click", We(
        /*click_handler_2*/
        i[7]
      )), t = !0);
    },
    p: ee,
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(q1e, "create_if_block_2$3");
function G1e(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), e.innerHTML = '<i class="fa-solid fa-heart-circle-bolt button__icon"></i>', b(e, "class", "healing-button svelte-gwecro"), b(e, "data-tooltip", "Apply Temporary Healing"), b(e, "data-tooltip-direction", "LEFT");
    },
    m(n, l) {
      T(n, e, l), t || (s = V(e, "click", We(
        /*click_handler_1*/
        i[6]
      )), t = !0);
    },
    p: ee,
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(G1e, "create_if_block_1$3");
function z1e(i) {
  let e, t, s, n, l = oe(
    /*damageButtons*/
    i[3]
  ), r = [];
  for (let o = 0; o < l.length; o += 1)
    r[o] = AL($L(i, l, o));
  return {
    c() {
      e = E("div"), t = E("i"), s = R(), n = E("ol");
      for (let o = 0; o < r.length; o += 1)
        r[o].c();
      b(t, "class", "damage-menu__button fa-heart-circle-minus fa-solid svelte-gwecro"), b(n, "class", "damage-buttons svelte-gwecro"), b(e, "class", "damage-menu svelte-gwecro");
    },
    m(o, a) {
      T(o, e, a), A(e, t), A(e, s), A(e, n);
      for (let c = 0; c < r.length; c += 1)
        r[c] && r[c].m(n, null);
    },
    p(o, a) {
      if (a & /*applyDamage, rollData, damageButtons*/
      11) {
        l = oe(
          /*damageButtons*/
          o[3]
        );
        let c;
        for (c = 0; c < l.length; c += 1) {
          const u = $L(o, l, c);
          r[c] ? r[c].p(u, a) : (r[c] = AL(u), r[c].c(), r[c].m(n, null));
        }
        for (; c < r.length; c += 1)
          r[c].d(1);
        r.length = l.length;
      }
    },
    d(o) {
      o && S(e), Le(r, o);
    }
  };
}
f(z1e, "create_if_block$4");
function AL(i) {
  let e, t, s, n, l, r, o;
  function a() {
    return (
      /*click_handler*/
      i[5](
        /*multiplier*/
        i[9],
        /*temp*/
        i[10]
      )
    );
  }
  return f(a, "click_handler"), {
    c() {
      e = E("li"), t = E("span"), t.textContent = `${/*label*/
      i[8]}`, s = R(), n = E("i"), l = R(), b(n, "class", "fa-solid " + /*icon*/
      i[11] + " button__icon svelte-gwecro"), b(e, "class", "damage-buttons__item svelte-gwecro"), b(e, "role", "button");
    },
    m(c, u) {
      T(c, e, u), A(e, t), A(e, s), A(e, n), A(e, l), r || (o = V(e, "click", We(a)), r = !0);
    },
    p(c, u) {
      i = c;
    },
    d(c) {
      c && S(e), r = !1, o();
    }
  };
}
f(AL, "create_each_block$4");
function H1e(i) {
  let e;
  function t(l, r) {
    if (
      /*rollData*/
      l[0].type === "damage"
    )
      return z1e;
    if (
      /*rollData*/
      l[0].healingType === "temporaryHealing"
    )
      return G1e;
    if (
      /*rollData*/
      l[0].healingType === "healing"
    )
      return q1e;
  }
  f(t, "select_block_type");
  let s = t(i), n = s && s(i);
  return {
    c() {
      n && n.c(), e = $e();
    },
    m(l, r) {
      n && n.m(l, r), T(l, e, r);
    },
    p(l, [r]) {
      s === (s = t(l)) && n ? n.p(l, r) : (n && n.d(1), n = s && s(l), n && (n.c(), n.m(e.parentNode, e)));
    },
    i: ee,
    o: ee,
    d(l) {
      l && S(e), n && n.d(l);
    }
  };
}
f(H1e, "create_fragment$c");
function U1e(i, e, t) {
  function s(d = null, p = 1, m = !1) {
    if (p < 0) {
      n(m ? "temporaryHealing" : "healing");
      return;
    }
    const { character: g } = game.user, h = canvas.tokens.controlled, _ = l.total * p;
    h.length ? h.forEach((y) => y.actor.applyDamage(_, d)) : g ? g.applyDamage(_, d) : ui.notifications.warn("No tokens selected");
  }
  f(s, "applyDamage");
  async function n(d) {
    const { character: p } = game.user, m = canvas.tokens.controlled;
    m.length ? m.forEach((g) => {
      g.actor.applyHealing(l.total, d);
    }) : p ? p.applyHealing(l.total, d) : ui.notifications.warn("No tokens selected");
  }
  f(n, "applyHealing");
  let { roll: l } = e, { rollData: r } = e;
  const o = [
    {
      label: "Grant Temporary Hit Points",
      multiplier: -1,
      temp: !0,
      icon: "fa-heart-circle-bolt"
    },
    {
      label: "Apply Damage as Healing",
      multiplier: -1,
      icon: "fa-heart-circle-plus"
    },
    {
      label: "Apply Double Damage",
      multiplier: 2,
      icon: "fa-skull"
    },
    {
      label: "Apply Quarter Damage",
      multiplier: 0.25,
      icon: "fa-shield"
    },
    {
      label: "Apply Half Damage",
      multiplier: 0.5,
      icon: "fa-shield-halved"
    },
    {
      label: "Apply Damage",
      multiplier: 1,
      icon: "fa-heart-crack"
    }
  ], a = /* @__PURE__ */ f((d, p) => s(r.damageType, d, p), "click_handler"), c = /* @__PURE__ */ f(() => n(r.healingType), "click_handler_1"), u = /* @__PURE__ */ f(() => n(r.healingType), "click_handler_2");
  return i.$$set = (d) => {
    "roll" in d && t(4, l = d.roll), "rollData" in d && t(0, r = d.rollData);
  }, [
    r,
    s,
    n,
    o,
    l,
    a,
    c,
    u
  ];
}
f(U1e, "instance$b");
const X3 = class X3 extends ie {
  constructor(e) {
    super(), le(this, e, U1e, H1e, ne, { roll: 4, rollData: 0 });
  }
};
f(X3, "DamageButtons");
let b5 = X3;
function V1e(i) {
  let e, t, s, n;
  return e = new Ye({
    props: {
      heading: "Configure Roll Mode",
      options: (
        /*damageButtons*/
        i[1]
      ),
      selected: (
        /*rollData*/
        i[0].rollMode ?? 0
      )
    }
  }), e.$on(
    "updateSelection",
    /*updateSelection_handler*/
    i[4]
  ), s = new Ye({
    props: {
      heading: "Configure Expertise Die",
      options: (
        /*expertiseDice*/
        i[2]
      ),
      selected: (
        /*rollData*/
        i[0].expertiseDice ?? 0
      )
    }
  }), s.$on(
    "updateSelection",
    /*updateSelection_handler_1*/
    i[5]
  ), {
    c() {
      L(e.$$.fragment), t = R(), L(s.$$.fragment);
    },
    m(l, r) {
      N(e, l, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r & /*rollData*/
      1 && (o.selected = /*rollData*/
      l[0].rollMode ?? 0), e.$set(o);
      const a = {};
      r & /*rollData*/
      1 && (a.selected = /*rollData*/
      l[0].expertiseDice ?? 0), s.$set(a);
    },
    i(l) {
      n || (w(e.$$.fragment, l), w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(e.$$.fragment, l), C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && S(t), j(e, l), j(s, l);
    }
  };
}
f(V1e, "create_default_slot$3");
function W1e(i) {
  let e, t, s;
  return e = new Me({
    props: {
      $$slots: { default: [V1e] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(t, "--a5e-section-body-gap", "0.75rem");
    },
    m(n, l) {
      T(n, t, l), N(e, t, null), s = !0;
    },
    p(n, [l]) {
      const r = {};
      l & /*$$scope, rollData*/
      65 && (r.$$scope = { dirty: l, ctx: n }), e.$set(r);
    },
    i(n) {
      s || (w(e.$$.fragment, n), s = !0);
    },
    o(n) {
      C(e.$$.fragment, n), s = !1;
    },
    d(n) {
      n && e && S(t), j(e, n);
    }
  };
}
f(W1e, "create_fragment$b");
function K1e(i, e, t) {
  let { rollData: s = {} } = e;
  const n = [[1, "Advantage"], [0, "Normal"], [-1, "Disadvantage"]], l = [[0, "None"], [1, "1d4"], [2, "1d6"], [3, "1d8"], [4, "1d10"], [5, "1d12"]], r = it(), o = /* @__PURE__ */ f(({ detail: c }) => r("toggleRollMode", c), "updateSelection_handler"), a = /* @__PURE__ */ f(({ detail: c }) => r("toggleExpertiseDice", c), "updateSelection_handler_1");
  return i.$$set = (c) => {
    "rollData" in c && t(0, s = c.rollData);
  }, [
    s,
    n,
    l,
    r,
    o,
    a
  ];
}
f(K1e, "instance$a");
const J3 = class J3 extends ie {
  constructor(e) {
    super(), le(this, e, K1e, W1e, ne, { rollData: 0 });
  }
};
f(J3, "RollConfigurationOptions");
let _5 = J3;
function EL(i) {
  let e, t, s, n = (
    /*rollData*/
    i[1].rollMode && SL(i)
  ), l = (
    /*rollData*/
    i[1].expertiseDice && TL(i)
  ), r = (
    /*rollData*/
    i[1].userLabel && CL(i)
  );
  return {
    c() {
      e = E("div"), n && n.c(), t = R(), l && l.c(), s = R(), r && r.c(), b(e, "class", "subtitle-wrapper svelte-1ck1d58");
    },
    m(o, a) {
      T(o, e, a), n && n.m(e, null), A(e, t), l && l.m(e, null), A(e, s), r && r.m(e, null);
    },
    p(o, a) {
      /*rollData*/
      o[1].rollMode ? n ? n.p(o, a) : (n = SL(o), n.c(), n.m(e, t)) : n && (n.d(1), n = null), /*rollData*/
      o[1].expertiseDice ? l ? l.p(o, a) : (l = TL(o), l.c(), l.m(e, s)) : l && (l.d(1), l = null), /*rollData*/
      o[1].userLabel ? r ? r.p(o, a) : (r = CL(o), r.c(), r.m(e, null)) : r && (r.d(1), r = null);
    },
    d(o) {
      o && S(e), n && n.d(), l && l.d(), r && r.d();
    }
  };
}
f(EL, "create_if_block_6$1");
function SL(i) {
  let e, t = (
    /*getRollModeLabel*/
    i[6](
      /*rollData*/
      i[1]
    ) + ""
  ), s;
  return {
    c() {
      e = E("span"), s = x(t), b(e, "class", "roll-mode svelte-1ck1d58"), Q(
        e,
        "roll-mode--disadvantage",
        /*rollData*/
        i[1].rollMode === -1
      );
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*rollData*/
      2 && t !== (t = /*getRollModeLabel*/
      n[6](
        /*rollData*/
        n[1]
      ) + "") && _e(s, t), l & /*rollData*/
      2 && Q(
        e,
        "roll-mode--disadvantage",
        /*rollData*/
        n[1].rollMode === -1
      );
    },
    d(n) {
      n && S(e);
    }
  };
}
f(SL, "create_if_block_9$1");
function TL(i) {
  let e, t = (
    /*getExpertiseLabel*/
    i[7](
      /*rollData*/
      i[1]
    ) + ""
  ), s;
  return {
    c() {
      e = E("span"), s = x(t), b(e, "class", "expertise-label svelte-1ck1d58");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*rollData*/
      2 && t !== (t = /*getExpertiseLabel*/
      n[7](
        /*rollData*/
        n[1]
      ) + "") && _e(s, t);
    },
    d(n) {
      n && S(e);
    }
  };
}
f(TL, "create_if_block_8$1");
function CL(i) {
  let e, t = (
    /*rollData*/
    i[1].userLabel + ""
  ), s;
  return {
    c() {
      e = E("span"), s = x(t), b(e, "class", "roll-sublabel svelte-1ck1d58");
    },
    m(n, l) {
      T(n, e, l), A(e, s);
    },
    p(n, l) {
      l & /*rollData*/
      2 && t !== (t = /*rollData*/
      n[1].userLabel + "") && _e(s, t);
    },
    d(n) {
      n && S(e);
    }
  };
}
f(CL, "create_if_block_7$1");
function Y1e(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), b(e, "class", "roll-mode-button fa-dice fa-solid svelte-1ck1d58"), b(e, "data-tooltip", "Modify Roll"), b(e, "data-tooltip-direction", "LEFT");
    },
    m(n, l) {
      T(n, e, l), t || (s = V(
        e,
        "click",
        /*toggleRollConfig*/
        i[9]
      ), t = !0);
    },
    p: ee,
    i: ee,
    o: ee,
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(Y1e, "create_if_block_5$1");
function X1e(i) {
  let e, t;
  return e = new b5({
    props: {
      roll: (
        /*roll*/
        i[0]
      ),
      rollData: (
        /*rollData*/
        i[1]
      )
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*roll*/
      1 && (l.roll = /*roll*/
      s[0]), n & /*rollData*/
      2 && (l.rollData = /*rollData*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(X1e, "create_if_block_4$1");
function OL(i) {
  let e, t, s = (
    /*isCriticalSuccess*/
    i[4] && DL(i)
  ), n = (
    /*isCriticalFailure*/
    i[5] && IL(i)
  );
  return {
    c() {
      s && s.c(), e = R(), n && n.c(), t = $e();
    },
    m(l, r) {
      s && s.m(l, r), T(l, e, r), n && n.m(l, r), T(l, t, r);
    },
    p(l, r) {
      /*isCriticalSuccess*/
      l[4] ? s ? s.p(l, r) : (s = DL(l), s.c(), s.m(e.parentNode, e)) : s && (s.d(1), s = null), /*isCriticalFailure*/
      l[5] ? n ? n.p(l, r) : (n = IL(l), n.c(), n.m(t.parentNode, t)) : n && (n.d(1), n = null);
    },
    d(l) {
      l && (S(e), S(t)), s && s.d(l), n && n.d(l);
    }
  };
}
f(OL, "create_if_block_1$2");
function DL(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), e.innerHTML = `<i class="fa-solid fa-dice-d20"></i>
            Roll on the skill critical success table`;
    },
    m(n, l) {
      T(n, e, l), t || (s = V(
        e,
        "click",
        /*click_handler*/
        i[14]
      ), t = !0);
    },
    p: ee,
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(DL, "create_if_block_3$1");
function IL(i) {
  let e, t, s;
  return {
    c() {
      e = E("button"), e.innerHTML = `<i class="fa-solid fa-dice-d20"></i>
            Roll on the skill critical failure table`;
    },
    m(n, l) {
      T(n, e, l), t || (s = V(
        e,
        "click",
        /*click_handler_1*/
        i[15]
      ), t = !0);
    },
    p: ee,
    d(n) {
      n && S(e), t = !1, s();
    }
  };
}
f(IL, "create_if_block_2$2");
function PL(i) {
  let e, t;
  return e = new _5({ props: { rollData: (
    /*rollData*/
    i[1]
  ) } }), e.$on(
    "toggleRollMode",
    /*toggleRollMode_handler*/
    i[16]
  ), e.$on(
    "toggleExpertiseDice",
    /*toggleExpertiseDice_handler*/
    i[17]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*rollData*/
      2 && (l.rollData = /*rollData*/
      s[1]), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(PL, "create_if_block$3");
function J1e(i) {
  let e, t, s = (
    /*roll*/
    i[0].total + ""
  ), n, l, r, o, a, c = (
    /*rollData*/
    i[1].label + ""
  ), u, d, p, m, g, h, _, y, k, v, O = !/*showRollConfig*/
  i[3] && /*rollData*/
  (i[1].expertiseDice || /*rollData*/
  i[1].rollMode || /*rollData*/
  i[1].userLabel) && EL(i);
  const P = [X1e, Y1e], D = [];
  function I(H, G) {
    var U;
    return G & /*rollData*/
    2 && (m = null), /*rollData*/
    H[1].type === "damage" || /*rollData*/
    H[1].type === "healing" ? 0 : (m == null && (m = !!/*user*/
    ((H[13].isGM || /*actor*/
    (U = H[12]) != null && U.testUserPermission(
      /*user*/
      H[13],
      2
    )) && ["abilityCheck", "attack", "savingThrow", "skillCheck", "toolCheck"].includes(
      /*rollData*/
      H[1].type
    ))), m ? 1 : -1);
  }
  f(I, "select_block_type"), ~(g = I(i, -1)) && (h = D[g] = P[g](i));
  let B = !/*hideSkillCriticalPrompt*/
  i[10] && /*rollData*/
  i[1].type === "skillCheck" && /*rollData*/
  i[1].skillKey && OL(i), F = (
    /*showRollConfig*/
    i[3] && PL(i)
  );
  return {
    c() {
      e = E("div"), t = E("div"), n = x(s), r = R(), o = E("header"), a = E("h3"), u = x(c), d = R(), O && O.c(), p = R(), h && h.c(), _ = R(), B && B.c(), y = R(), F && F.c(), k = $e(), b(t, "class", "roll svelte-1ck1d58"), b(t, "data-tooltip", l = wL(
        /*message*/
        i[11],
        /*roll*/
        i[0],
        /*rollData*/
        i[1]
      )), b(t, "data-tooltip-class", "a5e-tooltip a5e-tooltip--roll"), b(t, "data-tooltip-direction", "LEFT"), Q(
        t,
        "roll--max",
        /*isCriticalSuccess*/
        i[4]
      ), Q(
        t,
        "roll--min",
        /*isCriticalFailure*/
        i[5]
      ), Q(t, "roll--wide", !/*isAction*/
      i[2]), b(a, "class", "roll-label svelte-1ck1d58"), b(o, "class", "roll-header svelte-1ck1d58"), b(e, "class", "roll-container svelte-1ck1d58");
    },
    m(H, G) {
      T(H, e, G), A(e, t), A(t, n), A(e, r), A(e, o), A(o, a), A(a, u), A(o, d), O && O.m(o, null), A(e, p), ~g && D[g].m(e, null), T(H, _, G), B && B.m(H, G), T(H, y, G), F && F.m(H, G), T(H, k, G), v = !0;
    },
    p(H, [G]) {
      (!v || G & /*roll*/
      1) && s !== (s = /*roll*/
      H[0].total + "") && _e(n, s), (!v || G & /*roll, rollData*/
      3 && l !== (l = wL(
        /*message*/
        H[11],
        /*roll*/
        H[0],
        /*rollData*/
        H[1]
      ))) && b(t, "data-tooltip", l), (!v || G & /*isCriticalSuccess*/
      16) && Q(
        t,
        "roll--max",
        /*isCriticalSuccess*/
        H[4]
      ), (!v || G & /*isCriticalFailure*/
      32) && Q(
        t,
        "roll--min",
        /*isCriticalFailure*/
        H[5]
      ), (!v || G & /*isAction*/
      4) && Q(t, "roll--wide", !/*isAction*/
      H[2]), (!v || G & /*rollData*/
      2) && c !== (c = /*rollData*/
      H[1].label + "") && _e(u, c), !/*showRollConfig*/
      H[3] && /*rollData*/
      (H[1].expertiseDice || /*rollData*/
      H[1].rollMode || /*rollData*/
      H[1].userLabel) ? O ? O.p(H, G) : (O = EL(H), O.c(), O.m(o, null)) : O && (O.d(1), O = null);
      let U = g;
      g = I(H, G), g === U ? ~g && D[g].p(H, G) : (h && (ce(), C(D[U], 1, 1, () => {
        D[U] = null;
      }), ue()), ~g ? (h = D[g], h ? h.p(H, G) : (h = D[g] = P[g](H), h.c()), w(h, 1), h.m(e, null)) : h = null), !/*hideSkillCriticalPrompt*/
      H[10] && /*rollData*/
      H[1].type === "skillCheck" && /*rollData*/
      H[1].skillKey ? B ? B.p(H, G) : (B = OL(H), B.c(), B.m(y.parentNode, y)) : B && (B.d(1), B = null), /*showRollConfig*/
      H[3] ? F ? (F.p(H, G), G & /*showRollConfig*/
      8 && w(F, 1)) : (F = PL(H), F.c(), w(F, 1), F.m(k.parentNode, k)) : F && (ce(), C(F, 1, 1, () => {
        F = null;
      }), ue());
    },
    i(H) {
      v || (w(h), w(F), v = !0);
    },
    o(H) {
      C(h), C(F), v = !1;
    },
    d(H) {
      H && (S(e), S(_), S(y), S(k)), O && O.d(), ~g && D[g].d(), B && B.d(H), F && F.d(H);
    }
  };
}
f(J1e, "create_fragment$a");
function Z1e(i) {
  const e = i.terms.find((t) => t.faces === 20);
  return e ? e.results.some(({ result: t, active: s }) => s && t === 1) : !1;
}
f(Z1e, "determineIfCriticalFailure");
function Q1e(i, e, t) {
  var I, B;
  let s, n, l, { roll: r } = e, { rollData: o = {} } = e, { isAction: a = !0 } = e;
  function c(F) {
    const H = F.terms.find((G) => G.faces === 20);
    return H ? H.results.some(({ result: G, active: U }) => U && G >= (o.critThreshold ?? 20)) : !1;
  }
  f(c, "determineIfCriticalSuccess");
  function u({ rollMode: F }) {
    return F ? K(F === 1 ? "A5E.RollModeAdvantage" : "A5E.RollModeDisadvantage") : null;
  }
  f(u, "getRollModeLabel");
  function d({ expertiseDice: F }) {
    return F ? K("A5E.ExpertiseDieSpecific", {
      dieSize: Cc(F)
    }) : null;
  }
  f(d, "getExpertiseLabel");
  async function p(F, H) {
    var J, re, ae, be;
    const G = H === "critical" ? "skillCriticalTables" : "skillFumbleTables", U = (J = CONFIG.A5E[G]) == null ? void 0 : J[F], q = await fromUuid(U);
    if (!q)
      return;
    const W = await q.roll(), X = (re = W == null ? void 0 : W.results) == null ? void 0 : re[0], te = {
      user: (ae = game.user) == null ? void 0 : ae.id,
      speaker: ChatMessage.getSpeaker({ actor: y }),
      flags: {
        a5e: {
          actorId: y.uuid,
          cardType: "rollTableOutput",
          itemDescription: X == null ? void 0 : X.text,
          img: q == null ? void 0 : q.img,
          name: q == null ? void 0 : q.name,
          actionName: (be = X == null ? void 0 : X.flags) == null ? void 0 : be.title
        }
      },
      content: "<article></article>"
    };
    return ChatMessage.applyRollMode(te, game.settings.get("core", "rollMode")), ChatMessage.create(te);
  }
  f(p, "rollOnSkillTable");
  async function m() {
    if (t(3, h = !h), h) {
      const F = [...game.messages ?? []], H = F[F.length - 1];
      l.id === (H == null ? void 0 : H.id) && setTimeout(() => ui.chat.scrollBottom(), 0);
    }
  }
  f(m, "toggleRollConfig");
  let g = game.settings.get("a5e", "hideSkillCriticalPrompt"), h = !1;
  const _ = fe("message");
  pe(i, _, (F) => t(18, l = F));
  const y = fromUuidSync((B = (I = l == null ? void 0 : l.flags) == null ? void 0 : I.a5e) == null ? void 0 : B.actorId), { user: k } = game, v = /* @__PURE__ */ f(() => p(o.skillKey, "critical"), "click_handler"), O = /* @__PURE__ */ f(() => p(o.skillKey, "fumble"), "click_handler_1");
  function P(F) {
    gt.call(this, i, F);
  }
  f(P, "toggleRollMode_handler");
  function D(F) {
    gt.call(this, i, F);
  }
  return f(D, "toggleExpertiseDice_handler"), i.$$set = (F) => {
    "roll" in F && t(0, r = F.roll), "rollData" in F && t(1, o = F.rollData), "isAction" in F && t(2, a = F.isAction);
  }, i.$$.update = () => {
    i.$$.dirty & /*roll*/
    1 && t(5, s = Z1e(r)), i.$$.dirty & /*roll*/
    1 && t(4, n = c(r));
  }, [
    r,
    o,
    a,
    h,
    n,
    s,
    u,
    d,
    p,
    m,
    g,
    _,
    y,
    k,
    v,
    O,
    P,
    D
  ];
}
f(Q1e, "instance$9");
const Z3 = class Z3 extends ie {
  constructor(e) {
    super(), le(this, e, Q1e, J1e, ne, { roll: 0, rollData: 1, isAction: 2 });
  }
};
f(Z3, "RollSummary");
let y5 = Z3;
function x1e(i) {
  const { abilities: e } = CONFIG.A5E;
  return K("A5E.AbilityCheckPrompt", {
    ability: e[i.ability]
  });
}
f(x1e, "getAbilityCheckPromptTitle");
function ebe(i) {
  return fromUuidSync(i.effectUuid).name;
}
f(ebe, "getEffectPromptTitle");
function tbe(i, e) {
  const { abilities: t } = CONFIG.A5E;
  if (game.settings.get("a5e", "protectRolls") ?? !1) {
    const s = fromUuidSync(e);
    if (s && s.type !== "character" && s.permission < 2)
      return K("A5E.RollPromptSavingThrow", {
        ability: t[i.ability]
      });
  }
  return K("A5E.RollPromptSavingThrowWithDC", {
    ability: t[i.ability],
    dc: i.dc
  });
}
f(tbe, "getSavingThrowPromptTitle");
function sbe(i) {
  const { skills: e } = CONFIG.A5E;
  return K("A5E.SkillCheckPrompt", {
    skill: e[i.skill]
  });
}
f(sbe, "getSkillCheckPromptTitle");
function ML(i, e) {
  switch (i.type) {
    case "abilityCheck":
      return x1e(i);
    case "effect":
      return ebe(i);
    case "savingThrow":
      return tbe(i, e);
    case "skillCheck":
      return sbe(i);
    default:
      return (i == null ? void 0 : i.label) || K("A5E.Other");
  }
}
f(ML, "getPromptTitle");
function nbe(i) {
  switch (i.type) {
    case "effect":
      return "Apply effect";
    case "savingThrow":
      return i.onSave;
    default:
      return null;
  }
}
f(nbe, "getPromptSubtitle");
function ibe(i) {
  var e, t, s;
  return ((s = (t = (e = i.flags) == null ? void 0 : e.a5e) == null ? void 0 : t.prompts) == null ? void 0 : s.reduce((n, l) => {
    var r;
    return n[r = l.type] ?? (n[r] = []), n[l.type].push(l), n;
  }, {})) ?? {};
}
f(ibe, "preparePrompts");
function lbe(i) {
  const { abilities: e, skills: t } = CONFIG.A5E, { abilityKey: s, saveType: n, skillKey: l } = i, r = K(e[s]), o = t[l];
  switch (i.cardType) {
    case "abilityCheck":
      return K("A5E.AbilityCheckSpecific", { ability: r });
    case "hitDice":
      return i.title;
    case "savingThrow":
      switch (n) {
        case "concentration":
          return K("A5E.ConcentrationCheck");
        case "death":
          return K("A5E.DeathSavingThrow");
        default:
          return K("A5E.SavingThrowSpecific", { ability: r });
      }
    case "skillCheck":
      return r ? K("A5E.SkillCheckAbility", { skill: o, ability: r }) : K("A5E.SkillCheck", { skill: o });
    default:
      return null;
  }
}
f(lbe, "getCheckLabel");
function rbe(i) {
  return {
    label: lbe(i),
    expertiseDice: i.expertiseDice,
    rollMode: i.rollMode,
    type: i.cardType
  };
}
f(rbe, "prepareCheckRollData");
const RL = {
  attack: 0,
  damage: 1,
  healing: 2,
  abilityCheck: 3,
  skillCheck: 4,
  savingThrow: 5,
  toolCheck: 6,
  generic: 7
};
function obe(i) {
  var s;
  const { rolls: e } = i, t = ((s = i.flags) == null ? void 0 : s.a5e) ?? {};
  return t.rollData ? Mp(e, t.rollData).sort(
    (n, l) => {
      var r, o;
      return RL[(r = n[1]) == null ? void 0 : r.type] - RL[(o = l[1]) == null ? void 0 : o.type];
    }
  ) : e != null && e.length ? [[e[0], rbe(t)]] : [];
}
f(obe, "prepareRolls");
function abe() {
  var t;
  const i = (t = canvas == null ? void 0 : canvas.tokens) == null ? void 0 : t.controlled;
  return i != null && i.length ? i.map((s) => s.document.actor) : [];
}
f(abe, "prepareSelectedTokenActors");
const { Boolean: n$ } = q5;
function FL(i, e, t) {
  const s = i.slice();
  return s[24] = e[t], s;
}
f(FL, "get_each_context$3");
function NL(i, e, t) {
  const s = i.slice();
  return s[27] = e[t], s;
}
f(NL, "get_each_context_1$2");
function jL(i, e, t) {
  const s = i.slice();
  return s[30] = e[t][0], s[31] = e[t][1], s[33] = t, s;
}
f(jL, "get_each_context_2");
function LL(i) {
  let e, t, s, n;
  return s = new va({
    props: { summaryData: (
      /*summaryData*/
      i[3]
    ) }
  }), {
    c() {
      e = E("hr"), t = R(), L(s.$$.fragment), b(e, "class", "a5e-rule a5e-rule--card");
    },
    m(l, r) {
      T(l, e, r), T(l, t, r), N(s, l, r), n = !0;
    },
    p(l, r) {
      const o = {};
      r[0] & /*summaryData*/
      8 && (o.summaryData = /*summaryData*/
      l[3]), s.$set(o);
    },
    i(l) {
      n || (w(s.$$.fragment, l), n = !0);
    },
    o(l) {
      C(s.$$.fragment, l), n = !1;
    },
    d(l) {
      l && (S(e), S(t)), j(s, l);
    }
  };
}
f(LL, "create_if_block_9");
function BL(i) {
  let e, t, s, n, l, r = (
    /*itemDescription*/
    (i[10] || /*unidentifiedDescription*/
    i[11]) && cbe(i)
  ), o = (
    /*actionDescription*/
    i[9] && dbe(i)
  );
  return {
    c() {
      e = E("section"), r && r.c(), t = R(), o && o.c(), b(e, "class", "description-block svelte-1rm0hbd");
    },
    m(a, c) {
      T(a, e, c), r && r.m(e, null), A(e, t), o && o.m(e, null), l = !0;
    },
    p(a, c) {
      /*itemDescription*/
      (a[10] || /*unidentifiedDescription*/
      a[11]) && r.p(a, c), /*actionDescription*/
      a[9] && o.p(a, c);
    },
    i(a) {
      l || (a && is(() => {
        l && (n && n.end(1), s = sb(e, Ec, { duration: 150 }), s.start());
      }), l = !0);
    },
    o(a) {
      s && s.invalidate(), a && (n = nb(e, Ec, { duration: 150 })), l = !1;
    },
    d(a) {
      a && S(e), r && r.d(), o && o.d(), a && n && n.end();
    }
  };
}
f(BL, "create_if_block_5");
function cbe(i) {
  let e, t, s;
  function n(o, a) {
    var c, u, d;
    return !/*isGM*/
    o[12] && /*item*/
    ((c = o[17]) == null ? void 0 : c.type) === "object" && /*item*/
    ((d = (u = o[17]) == null ? void 0 : u.system) != null && d.unidentified) ? fbe : ube;
  }
  f(n, "select_block_type");
  let r = n(i)(i);
  return {
    c() {
      e = E("hr"), t = R(), s = E("div"), r.c(), b(e, "class", "a5e-rule a5e-rule--card");
    },
    m(o, a) {
      T(o, e, a), T(o, t, a), T(o, s, a), r.m(s, null);
    },
    p(o, a) {
      r.p(o, a);
    },
    d(o) {
      o && (S(e), S(t), S(s)), r.d();
    }
  };
}
f(cbe, "create_if_block_7");
function ube(i) {
  let e, t;
  return {
    c() {
      e = new As(!1), t = $e(), e.a = t;
    },
    m(s, n) {
      e.m(
        /*itemDescription*/
        i[10],
        s,
        n
      ), T(s, t, n);
    },
    p: ee,
    d(s) {
      s && (S(t), e.d());
    }
  };
}
f(ube, "create_else_block_1");
function fbe(i) {
  let e, t;
  return {
    c() {
      e = new As(!1), t = $e(), e.a = t;
    },
    m(s, n) {
      e.m(
        /*unidentifiedDescription*/
        i[11],
        s,
        n
      ), T(s, t, n);
    },
    p: ee,
    d(s) {
      s && (S(t), e.d());
    }
  };
}
f(fbe, "create_if_block_8");
function dbe(i) {
  let e, t, s;
  return {
    c() {
      e = E("hr"), t = R(), s = E("div"), b(e, "class", "a5e-rule a5e-rule--card");
    },
    m(n, l) {
      T(n, e, l), T(n, t, l), T(n, s, l), s.innerHTML = /*actionDescription*/
      i[9];
    },
    p: ee,
    d(n) {
      n && (S(e), S(t), S(s));
    }
  };
}
f(dbe, "create_if_block_6");
function pbe(i) {
  let e, t, s, n, l = oe(
    /*rolls*/
    i[15] ?? []
  ), r = [];
  for (let a = 0; a < l.length; a += 1)
    r[a] = qL(jL(i, l, a));
  const o = /* @__PURE__ */ f((a) => C(r[a], 1, 1, () => {
    r[a] = null;
  }), "out");
  return {
    c() {
      e = E("hr"), t = R(), s = E("section");
      for (let a = 0; a < r.length; a += 1)
        r[a].c();
      b(e, "class", "a5e-rule a5e-rule--card"), b(s, "class", "rolls svelte-1rm0hbd");
    },
    m(a, c) {
      T(a, e, c), T(a, t, c), T(a, s, c);
      for (let u = 0; u < r.length; u += 1)
        r[u] && r[u].m(s, null);
      n = !0;
    },
    p(a, c) {
      if (c[0] & /*rolls, toggleRollMode, toggleExpertiseDice*/
      32864) {
        l = oe(
          /*rolls*/
          a[15] ?? []
        );
        let u;
        for (u = 0; u < l.length; u += 1) {
          const d = jL(a, l, u);
          r[u] ? (r[u].p(d, c), w(r[u], 1)) : (r[u] = qL(d), r[u].c(), w(r[u], 1), r[u].m(s, null));
        }
        for (ce(), u = l.length; u < r.length; u += 1)
          o(u);
        ue();
      }
    },
    i(a) {
      if (!n) {
        for (let c = 0; c < l.length; c += 1)
          w(r[c]);
        n = !0;
      }
    },
    o(a) {
      r = r.filter(n$);
      for (let c = 0; c < r.length; c += 1)
        C(r[c]);
      n = !1;
    },
    d(a) {
      a && (S(e), S(t), S(s)), Le(r, a);
    }
  };
}
f(pbe, "create_if_block_2$1");
function mbe(i) {
  let e, t, s, n, l;
  function r(...c) {
    return (
      /*toggleRollMode_handler*/
      i[19](
        /*i*/
        i[33],
        ...c
      )
    );
  }
  f(r, "toggleRollMode_handler");
  function o(...c) {
    return (
      /*toggleExpertiseDice_handler*/
      i[20](
        /*i*/
        i[33],
        ...c
      )
    );
  }
  f(o, "toggleExpertiseDice_handler"), e = new y5({
    props: {
      roll: (
        /*roll*/
        i[30]
      ),
      rollData: (
        /*rollData*/
        i[31]
      )
    }
  }), e.$on("toggleRollMode", r), e.$on("toggleExpertiseDice", o);
  let a = (
    /*rolls*/
    i[15].length > 1 && /*rollData*/
    i[31].type === "attack" && gbe()
  );
  return {
    c() {
      t = E("div"), L(e.$$.fragment), s = R(), a && a.c(), n = $e(), z(t, "display", "contents"), z(t, "--a5e-roll-color", wbe(
        /*rollData*/
        i[31]
      ));
    },
    m(c, u) {
      T(c, t, u), N(e, t, null), T(c, s, u), a && a.m(c, u), T(c, n, u), l = !0;
    },
    p(c, u) {
      i = c;
    },
    i(c) {
      l || (w(e.$$.fragment, c), l = !0);
    },
    o(c) {
      C(e.$$.fragment, c), l = !1;
    },
    d(c) {
      c && (S(s), S(n)), c && e && S(t), j(e, c), a && a.d(c);
    }
  };
}
f(mbe, "create_else_block");
function hbe(i) {
  return {
    c: ee,
    m: ee,
    p: ee,
    i: ee,
    o: ee,
    d: ee
  };
}
f(hbe, "create_if_block_3");
function gbe(i) {
  let e;
  return {
    c() {
      e = E("hr"), b(e, "class", "a5e-rule");
    },
    m(t, s) {
      T(t, e, s);
    },
    d(t) {
      t && S(e);
    }
  };
}
f(gbe, "create_if_block_4");
function qL(i) {
  let e, t, s, n;
  const l = [hbe, mbe], r = [];
  function o(a, c) {
    var u, d;
    return (
      /*rollData*/
      ((d = (u = a[31]) == null ? void 0 : u.baseRoll) == null ? void 0 : d.formula) === "0" && /*roll*/
      a[30]._formula === "0" ? 0 : 1
    );
  }
  return f(o, "select_block_type_1"), e = o(i), t = r[e] = l[e](i), {
    c() {
      t.c(), s = $e();
    },
    m(a, c) {
      r[e].m(a, c), T(a, s, c), n = !0;
    },
    p(a, c) {
      t.p(a, c);
    },
    i(a) {
      n || (w(t), n = !0);
    },
    o(a) {
      C(t), n = !1;
    },
    d(a) {
      a && S(s), r[e].d(a);
    }
  };
}
f(qL, "create_each_block_2");
function bbe(i) {
  let e, t, s, n, l = oe(
    /*promptTypes*/
    i[8]
  ), r = [];
  for (let a = 0; a < l.length; a += 1)
    r[a] = zL(FL(i, l, a));
  const o = /* @__PURE__ */ f((a) => C(r[a], 1, 1, () => {
    r[a] = null;
  }), "out");
  return {
    c() {
      e = E("hr"), t = R(), s = E("section");
      for (let a = 0; a < r.length; a += 1)
        r[a].c();
      b(e, "class", "a5e-rule a5e-rule--card"), b(s, "class", "prompts svelte-1rm0hbd");
    },
    m(a, c) {
      T(a, e, c), T(a, t, c), T(a, s, c);
      for (let u = 0; u < r.length; u += 1)
        r[u] && r[u].m(s, null);
      n = !0;
    },
    p(a, c) {
      if (c[0] & /*prompts, promptTypes, $message, triggerPrompt, hoverColor*/
      8596) {
        l = oe(
          /*promptTypes*/
          a[8]
        );
        let u;
        for (u = 0; u < l.length; u += 1) {
          const d = FL(a, l, u);
          r[u] ? (r[u].p(d, c), w(r[u], 1)) : (r[u] = zL(d), r[u].c(), w(r[u], 1), r[u].m(s, null));
        }
        for (ce(), u = l.length; u < r.length; u += 1)
          o(u);
        ue();
      }
    },
    i(a) {
      if (!n) {
        for (let c = 0; c < l.length; c += 1)
          w(r[c]);
        n = !0;
      }
    },
    o(a) {
      r = r.filter(n$);
      for (let c = 0; c < r.length; c += 1)
        C(r[c]);
      n = !1;
    },
    d(a) {
      a && (S(e), S(t), S(s)), Le(r, a);
    }
  };
}
f(bbe, "create_if_block$2");
function _be(i) {
  let e, t, s, n = oe(
    /*prompts*/
    i[13][
      /*promptType*/
      i[24]
    ]
  ), l = [];
  for (let o = 0; o < n.length; o += 1)
    l[o] = GL(NL(i, n, o));
  const r = /* @__PURE__ */ f((o) => C(l[o], 1, 1, () => {
    l[o] = null;
  }), "out");
  return {
    c() {
      e = E("section");
      for (let o = 0; o < l.length; o += 1)
        l[o].c();
      t = R(), b(e, "class", "prompt-button-wrapper svelte-1rm0hbd");
    },
    m(o, a) {
      T(o, e, a);
      for (let c = 0; c < l.length; c += 1)
        l[c] && l[c].m(e, null);
      A(e, t), s = !0;
    },
    p(o, a) {
      if (a[0] & /*prompts, promptTypes, $message, triggerPrompt, hoverColor*/
      8596) {
        n = oe(
          /*prompts*/
          o[13][
            /*promptType*/
            o[24]
          ]
        );
        let c;
        for (c = 0; c < n.length; c += 1) {
          const u = NL(o, n, c);
          l[c] ? (l[c].p(u, a), w(l[c], 1)) : (l[c] = GL(u), l[c].c(), w(l[c], 1), l[c].m(e, t));
        }
        for (ce(), c = n.length; c < l.length; c += 1)
          r(c);
        ue();
      }
    },
    i(o) {
      if (!s) {
        for (let a = 0; a < n.length; a += 1)
          w(l[a]);
        s = !0;
      }
    },
    o(o) {
      l = l.filter(n$);
      for (let a = 0; a < l.length; a += 1)
        C(l[a]);
      s = !1;
    },
    d(o) {
      o && S(e), Le(l, o);
    }
  };
}
f(_be, "create_if_block_1$1");
function GL(i) {
  var l, r, o;
  let e, t, s;
  function n() {
    return (
      /*triggerPrompt_handler*/
      i[21](
        /*prompt*/
        i[27]
      )
    );
  }
  return f(n, "triggerPrompt_handler"), e = new g5({
    props: {
      prompt: (
        /*prompt*/
        i[27]
      ),
      icon: vbe(
        /*prompt*/
        i[27]
      ),
      title: ML(
        /*prompt*/
        i[27],
        /*$message*/
        (o = (r = (l = i[2]) == null ? void 0 : l.flags) == null ? void 0 : r.a5e) == null ? void 0 : o.actorId
      ),
      subtitle: nbe(
        /*prompt*/
        i[27]
      )
    }
  }), e.$on("triggerPrompt", n), {
    c() {
      t = E("div"), L(e.$$.fragment), z(t, "display", "contents"), z(
        t,
        "--hover-color",
        /*hoverColor*/
        i[4]
      );
    },
    m(a, c) {
      T(a, t, c), N(e, t, null), s = !0;
    },
    p(a, c) {
      var d, p, m;
      i = a, c[0] & /*hoverColor*/
      16 && z(
        t,
        "--hover-color",
        /*hoverColor*/
        i[4]
      );
      const u = {};
      c[0] & /*$message*/
      4 && (u.title = ML(
        /*prompt*/
        i[27],
        /*$message*/
        (m = (p = (d = i[2]) == null ? void 0 : d.flags) == null ? void 0 : p.a5e) == null ? void 0 : m.actorId
      )), e.$set(u);
    },
    i(a) {
      s || (w(e.$$.fragment, a), s = !0);
    },
    o(a) {
      C(e.$$.fragment, a), s = !1;
    },
    d(a) {
      a && e && S(t), j(e, a);
    }
  };
}
f(GL, "create_each_block_1$2");
function zL(i) {
  var n;
  let e, t, s = (
    /*prompts*/
    ((n = i[13][
      /*promptType*/
      i[24]
    ]) == null ? void 0 : n.length) && _be(i)
  );
  return {
    c() {
      s && s.c(), e = $e();
    },
    m(l, r) {
      s && s.m(l, r), T(l, e, r), t = !0;
    },
    p(l, r) {
      var o;
      /*prompts*/
      (o = l[13][
        /*promptType*/
        l[24]
      ]) != null && o.length && s.p(l, r);
    },
    i(l) {
      t || (w(s), t = !0);
    },
    o(l) {
      C(s), t = !1;
    },
    d(l) {
      l && S(e), s && s.d(l);
    }
  };
}
f(zL, "create_each_block$3");
function ybe(i) {
  let e, t = Object.values(
    /*summaryData*/
    i[3] ?? {}
  ).some(Boolean), s, n, l, r, o = t && LL(i), a = (
    /*itemDescription*/
    (i[10] || /*unidentifiedDescription*/
    i[11] || /*actionDescription*/
    i[9]) && !/*hideDescription*/
    i[1] && BL(i)
  ), c = (
    /*hasRolls*/
    i[16] && pbe(i)
  ), u = (
    /*hasPrompts*/
    i[14] && bbe(i)
  );
  return {
    c() {
      e = E("article"), o && o.c(), s = R(), a && a.c(), n = R(), c && c.c(), l = R(), u && u.c(), b(e, "class", "svelte-1rm0hbd");
    },
    m(d, p) {
      T(d, e, p), o && o.m(e, null), A(e, s), a && a.m(e, null), A(e, n), c && c.m(e, null), A(e, l), u && u.m(e, null), r = !0;
    },
    p(d, p) {
      p[0] & /*summaryData*/
      8 && (t = Object.values(
        /*summaryData*/
        d[3] ?? {}
      ).some(Boolean)), t ? o ? (o.p(d, p), p[0] & /*summaryData*/
      8 && w(o, 1)) : (o = LL(d), o.c(), w(o, 1), o.m(e, s)) : o && (ce(), C(o, 1, 1, () => {
        o = null;
      }), ue()), /*itemDescription*/
      (d[10] || /*unidentifiedDescription*/
      d[11] || /*actionDescription*/
      d[9]) && !/*hideDescription*/
      d[1] ? a ? (a.p(d, p), p[0] & /*hideDescription*/
      2 && w(a, 1)) : (a = BL(d), a.c(), w(a, 1), a.m(e, n)) : a && (ce(), C(a, 1, 1, () => {
        a = null;
      }), ue()), /*hasRolls*/
      d[16] && c.p(d, p), /*hasPrompts*/
      d[14] && u.p(d, p);
    },
    i(d) {
      r || (w(o), w(a), w(c), w(u), r = !0);
    },
    o(d) {
      C(o), C(a), C(c), C(u), r = !1;
    },
    d(d) {
      d && S(e), o && o.d(), a && a.d(), c && c.d(), u && u.d();
    }
  };
}
f(ybe, "create_fragment$9");
function vbe(i) {
  return i.type !== "effect" ? null : fromUuidSync(i.effectUuid).icon;
}
f(vbe, "getEffectIcon");
function kbe(i) {
  return i.Shift ? "#2b6537" : i.Control ? "$color-secondary" : "$color-dark-text";
}
f(kbe, "getHoverColor");
function wbe(i) {
  if (!game.settings.get("a5e", "enableDamageRollColors"))
    return null;
  const { damageColors: e, healingColors: t } = CONFIG.A5E;
  return i.type === "damage" ? e[i.damageType] : i.type === "healing" ? t[i.healingType] : null;
}
f(wbe, "prepareRollColor");
async function $be(i, e, t) {
  i.forEach((s) => {
    s.rollAbilityCheck(e.ability, t);
  });
}
f($be, "triggerAbilityCheckPrompt");
async function Abe(i, e) {
  const t = fromUuidSync(e.effectUuid);
  i.forEach((s) => {
    t.transferEffect(s);
  });
}
f(Abe, "triggerEffectPrompt");
async function Ebe(i, e, t) {
  i.forEach((s) => {
    s.rollSavingThrow(e.ability, t);
  });
}
f(Ebe, "triggerSavingThrowPrompt");
async function Sbe(i, e, t) {
  i.forEach((s) => {
    s.rollSkillCheck(e.skill, { abilityKey: e.ability, ...t });
  });
}
f(Sbe, "triggerSkillCheckPrompt");
function Tbe(i, e, t) {
  var q, W, X;
  let s, n, l, r = ee, o = /* @__PURE__ */ f(() => (r(), r = Et(c, (te) => t(2, l = te)), c), "$$subscribe_message"), a;
  pe(i, Mi, (te) => t(18, a = te)), i.$$.on_destroy.push(() => r());
  let { message: c } = e;
  o();
  let { hideDescription: u = !1 } = e;
  async function d(te, J) {
    var Ae, Fe, Ve, je, Pe, rt;
    const { rollData: re } = ((Ae = l == null ? void 0 : l.flags) == null ? void 0 : Ae.a5e) ?? {}, [ae, be] = D[te], we = be.expertiseDice;
    if (we === J)
      return;
    const ve = new Roll(ae.formula, { ...ae.data }, { ...ae.options });
    ve.terms = [...ae.terms];
    const me = ve.terms.findIndex((Te) => {
      var Ee;
      return ((Ee = Te.options) == null ? void 0 : Ee.flavor) === "Expertise Die";
    });
    if ((me !== -1 ? ve.terms[me] : null) && ((Fe = re[te]).expertiseDiceResults ?? (Fe.expertiseDiceResults = {}), (Pe = re[te].expertiseDiceResults)[we] ?? (Pe[we] = (je = (Ve = ve.terms[me]) == null ? void 0 : Ve.results[0]) == null ? void 0 : je.result)), !J)
      ve.terms.splice(me - 1, 2);
    else {
      const Te = new Die({
        number: 1,
        faces: parseInt(Cc(J).slice(2), 10),
        options: { flavor: "Expertise Die" }
      }), Ee = re[te].expertiseDiceResults ?? {};
      Ee[J] ? (Te.results.push({
        active: !0,
        result: Ee[J]
      }), Te._evaluated = !0) : await Te.evaluate({ async: !0 }), we ? ve.terms.splice(me, 1, Te) : ve.terms.push(new OperatorTerm({ operator: "+" }), Te), (rt = game.modules.get("dice-so-nice")) != null && rt.active && game.dice3d.showForRoll(Roll.fromTerms([Te]), game.users.get(l.user.id), !0, l.whisper, l.blind, null, l.speaker);
    }
    ve._formula = Roll.getFormula(ve.terms), ve._total = ve._evaluateTotal(), await ve.evaluate(), l.rolls.splice(te, 1, ve), re[te].expertiseDice = J, await l.update({
      rolls: l.rolls,
      "flags.a5e.rollData": re
    });
  }
  f(d, "toggleExpertiseDice");
  async function p(te, J) {
    var he, Ae, Fe, Ve;
    const [re, ae] = D[te], be = ae.rollMode;
    if (be === J)
      return;
    const we = new Roll(re.formula, { ...re.data }, { ...re.options });
    we.terms = [...re.terms];
    const ve = we.terms[0], me = ve.results.length;
    if (ve.number === 2) {
      const je = ve.results[1].result;
      fl(c, (he = l.flags.a5e.rollData[te]).secondDieResult ?? (he.secondDieResult = je), l);
    }
    if (ve.modifiers = ve.modifiers.filter((je) => !["kh", "kl"].includes(je)), !J)
      ve.number = 1, ve.results = [ve.results.shift()];
    else if (ve.modifiers.push(J === 1 ? "kh" : "kl"), !be) {
      ve.number = 2;
      const { secondDieResult: je } = (Fe = (Ae = l == null ? void 0 : l.flags) == null ? void 0 : Ae.a5e) == null ? void 0 : Fe.rollData[te];
      je ? ve.results.push({ result: je }) : await ve.roll();
    }
    if (ve.results.forEach((je) => {
      je.active = !0, delete je.discarded, delete je.indexThrow;
    }), ve._evaluateModifiers(), we._formula = Roll.getFormula(we.terms), we._total = we._evaluateTotal(), await we.evaluate(), (Ve = game.modules.get("dice-so-nice")) != null && Ve.active && ve.results.length > me) {
      const je = Roll.fromTerms([new Die({ ...ve })]);
      je.terms[0].number = je.terms[0].results.length, je.terms[0].results = je.terms[0].results.filter((Pe, rt) => rt > 0), game.dice3d.showForRoll(je, game.users.get(l.user.id), !0, l.whisper, l.blind, null, l.speaker);
    }
    l.rolls.splice(te, 1, we), fl(c, l.flags.a5e.rollData[te].rollMode = J, l), await l.update({
      rolls: l.rolls,
      "flags.a5e.rollData": l.flags.a5e.rollData
    }), ae.type === "attack" && F("reevaluateCritMode");
  }
  f(p, "toggleRollMode");
  async function m(te) {
    const J = abe(), re = Bi(a);
    if (!J.length) {
      ui.notifications.warn("No tokens selected");
      return;
    }
    te.type === "abilityCheck" ? await $be(J, te, re) : te.type === "effect" ? await Abe(J, te) : te.type === "savingThrow" ? await Ebe(J, te, re) : te.type === "skillCheck" ? await Sbe(J, te, re) : te.type === "generic" && await g(J, te);
  }
  f(m, "triggerPrompt");
  async function g(te, J) {
    for (const re of te) {
      const { rollFormula: ae } = Ya({
        actor: re,
        formula: J.formula,
        item: B
      });
      await new Roll(ae).toMessage({ async: !0 });
    }
  }
  f(g, "triggerGenericRollPrompt");
  const h = ["abilityCheck", "savingThrow", "skillCheck", "generic", "effect"], { actionDescription: _, itemDescription: y, unidentifiedDescription: k } = (q = l.flags) == null ? void 0 : q.a5e, { isGM: v } = game.user, O = ibe(l), P = Object.values(O).flat().length, D = obe(l), I = D.length, B = fromUuidSync(((X = (W = l == null ? void 0 : l.flags) == null ? void 0 : W.a5e) == null ? void 0 : X.itemId) ?? ""), F = it(), H = /* @__PURE__ */ f((te, { detail: J }) => p(te, J), "toggleRollMode_handler"), G = /* @__PURE__ */ f((te, { detail: J }) => d(te, J), "toggleExpertiseDice_handler"), U = /* @__PURE__ */ f((te) => m(te), "triggerPrompt_handler");
  return i.$$set = (te) => {
    "message" in te && o(t(0, c = te.message)), "hideDescription" in te && t(1, u = te.hideDescription);
  }, i.$$.update = () => {
    var te, J;
    i.$$.dirty[0] & /*$pressedKeysStore*/
    262144 && t(4, s = kbe(a)), i.$$.dirty[0] & /*$message*/
    4 && t(3, n = (J = (te = l == null ? void 0 : l.flags) == null ? void 0 : te.a5e) == null ? void 0 : J.summaryData);
  }, [
    c,
    u,
    l,
    n,
    s,
    d,
    p,
    m,
    h,
    _,
    y,
    k,
    v,
    O,
    P,
    D,
    I,
    B,
    a,
    H,
    G,
    U
  ];
}
f(Tbe, "instance$8");
const Q3 = class Q3 extends ie {
  constructor(e) {
    super(), le(this, e, Tbe, ybe, ne, { message: 0, hideDescription: 1 }, null, [-1, -1]);
  }
};
f(Q3, "CardBody");
let v5 = Q3;
function HL(i, e, t) {
  const s = i.slice();
  return s[7] = e[t], s;
}
f(HL, "get_each_context$2");
function Cbe(i) {
  let e, t, s, n, l, r, o, a = (
    /*castingLevel*/
    i[4] && /*spellLevel*/
    i[3] !== /*castingLevel*/
    i[4] && Obe(i)
  ), c = (
    /*spellComponents*/
    i[2].length && Dbe(i)
  );
  return {
    c() {
      e = E("hr"), t = R(), s = E("footer"), n = E("span"), l = x(
        /*spellLevel*/
        i[3]
      ), r = R(), a && a.c(), o = R(), c && c.c(), b(e, "class", "a5e-rule a5e-rule--card"), z(e, "margin-block", "0.5rem"), b(n, "class", "spell-level svelte-1febmjn"), b(s, "class", "card-footer svelte-1febmjn");
    },
    m(u, d) {
      T(u, e, d), T(u, t, d), T(u, s, d), A(s, n), A(n, l), A(n, r), a && a.m(n, null), A(s, o), c && c.m(s, null);
    },
    p(u, d) {
      /*castingLevel*/
      u[4] && /*spellLevel*/
      u[3] !== /*castingLevel*/
      u[4] && a.p(u, d), /*spellComponents*/
      u[2].length && c.p(u, d);
    },
    d(u) {
      u && (S(e), S(t), S(s)), a && a.d(), c && c.d();
    }
  };
}
f(Cbe, "create_if_block$1");
function Obe(i) {
  let e, t, s;
  return {
    c() {
      e = x("(Cast at "), t = x(
        /*castingLevel*/
        i[4]
      ), s = x(")");
    },
    m(n, l) {
      T(n, e, l), T(n, t, l), T(n, s, l);
    },
    p: ee,
    d(n) {
      n && (S(e), S(t), S(s));
    }
  };
}
f(Obe, "create_if_block_2");
function Dbe(i) {
  let e, t = oe(
    /*spellComponents*/
    i[2]
  ), s = [];
  for (let n = 0; n < t.length; n += 1)
    s[n] = UL(HL(i, t, n));
  return {
    c() {
      e = E("ul");
      for (let n = 0; n < s.length; n += 1)
        s[n].c();
      b(e, "class", "component-wrapper svelte-1febmjn");
    },
    m(n, l) {
      T(n, e, l);
      for (let r = 0; r < s.length; r += 1)
        s[r] && s[r].m(e, null);
    },
    p(n, l) {
      if (l & /*spellComponents*/
      4) {
        t = oe(
          /*spellComponents*/
          n[2]
        );
        let r;
        for (r = 0; r < t.length; r += 1) {
          const o = HL(n, t, r);
          s[r] ? s[r].p(o, l) : (s[r] = UL(o), s[r].c(), s[r].m(e, null));
        }
        for (; r < s.length; r += 1)
          s[r].d(1);
        s.length = t.length;
      }
    },
    d(n) {
      n && S(e), Le(s, n);
    }
  };
}
f(Dbe, "create_if_block_1");
function UL(i) {
  let e, t = (
    /*component*/
    i[7].label + ""
  ), s, n;
  return {
    c() {
      e = E("li"), s = x(t), n = R(), b(e, "class", "component svelte-1febmjn"), b(
        e,
        "data-tooltip",
        /*component*/
        i[7].tooltip
      ), b(e, "data-tooltip-direction", "UP");
    },
    m(l, r) {
      T(l, e, r), A(e, s), A(e, n);
    },
    p: ee,
    d(l) {
      l && S(e);
    }
  };
}
f(UL, "create_each_block$2");
function Ibe(i) {
  var s;
  let e, t = (
    /*item*/
    ((s = i[1]) == null ? void 0 : s.type) === "spell" && Cbe(i)
  );
  return {
    c() {
      t && t.c(), e = $e();
    },
    m(n, l) {
      t && t.m(n, l), T(n, e, l);
    },
    p(n, [l]) {
      var r;
      /*item*/
      ((r = n[1]) == null ? void 0 : r.type) === "spell" && t.p(n, l);
    },
    i: ee,
    o: ee,
    d(n) {
      n && S(e), t && t.d(n);
    }
  };
}
f(Ibe, "create_fragment$8");
function Pbe(i, e, t) {
  var p, m, g, h, _;
  let s, n = ee, l = /* @__PURE__ */ f(() => (n(), n = Et(o, (y) => t(5, s = y)), o), "$$subscribe_message");
  i.$$.on_destroy.push(() => n());
  function r(y) {
    var P;
    if (!((P = y == null ? void 0 : y.system) != null && P.components))
      return [];
    const { spellComponents: k, spellComponentAbbreviations: v } = CONFIG.A5E, O = Object.entries(y.system.components).filter(([, D]) => D).map(([D]) => ({
      label: v[D] ?? D,
      tooltip: k[D] ?? D
    }));
    return y.system.concentration && O.push({
      label: K("A5E.SpellConcentrationAbbr"),
      tooltip: K("A5E.SpellConcentration")
    }), y.system.ritual && O.push({
      label: K("A5E.SpellRitualAbbr"),
      tooltip: K("A5E.SpellRitual")
    }), O;
  }
  f(r, "getSpellComponents");
  let { message: o } = e;
  l();
  const a = fromUuidSync(((m = (p = s == null ? void 0 : s.flags) == null ? void 0 : p.a5e) == null ? void 0 : m.itemId) ?? ""), c = r(a), u = CONFIG.A5E.spellLevels[(g = a == null ? void 0 : a.system) == null ? void 0 : g.level], d = CONFIG.A5E.spellLevels[((_ = (h = s == null ? void 0 : s.flags) == null ? void 0 : h.a5e) == null ? void 0 : _.castingLevel) ?? ""];
  return i.$$set = (y) => {
    "message" in y && l(t(0, o = y.message));
  }, [o, a, c, u, d];
}
f(Pbe, "instance$7");
const x3 = class x3 extends ie {
  constructor(e) {
    super(), le(this, e, Pbe, Ibe, ne, { message: 0 });
  }
};
f(x3, "ItemActivationFooter");
let k5 = x3;
function Mbe(i) {
  let e, t;
  return e = new Rp({
    props: {
      img: (
        /*img*/
        i[2]
      ),
      altText: (
        /*name*/
        i[3]
      ),
      clickableHeader: !0,
      subtitle: Rbe(
        /*name*/
        i[3],
        /*actionName*/
        i[1]
      ),
      title: (
        /*name*/
        i[3]
      )
    }
  }), e.$on(
    "toggleCriticalDamage",
    /*toggleCriticalDamage_handler*/
    i[4]
  ), e.$on(
    "toggleDescription",
    /*toggleDescription_handler*/
    i[5]
  ), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p: ee,
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(Mbe, "create_fragment$7");
function Rbe(i, e) {
  return !e || typeof e != "string" || i.trim() === e.trim() ? null : e;
}
f(Rbe, "getSubtitle");
function Fbe(i, e, t) {
  var p;
  let s, n = ee, l = /* @__PURE__ */ f(() => (n(), n = Et(r, (m) => t(6, s = m)), r), "$$subscribe_message");
  i.$$.on_destroy.push(() => n());
  let { message: r } = e;
  l();
  const { actionName: o, img: a, name: c } = (p = s.flags) == null ? void 0 : p.a5e;
  function u(m) {
    gt.call(this, i, m);
  }
  f(u, "toggleCriticalDamage_handler");
  function d(m) {
    gt.call(this, i, m);
  }
  return f(d, "toggleDescription_handler"), i.$$set = (m) => {
    "message" in m && l(t(0, r = m.message));
  }, [
    r,
    o,
    a,
    c,
    u,
    d
  ];
}
f(Fbe, "instance$6");
const eO = class eO extends ie {
  constructor(e) {
    super(), le(this, e, Fbe, Mbe, ne, { message: 0 });
  }
};
f(eO, "ItemActivationHeader");
let w5 = eO;
function VL(i) {
  let e, t;
  return e = new k5({ props: { message: (
    /*message*/
    i[5]
  ) } }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p: ee,
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(VL, "create_if_block");
function Nbe(i) {
  var u, d, p, m, g, h, _, y, k;
  let e, t, s, n, l, r;
  var o = (
    /*getHeaderComponent*/
    i[2]()
  );
  function a(v, O) {
    return { props: { message: (
      /*message*/
      v[5]
    ) } };
  }
  f(a, "switch_props"), o && (e = nt(o, a(i)), e.$on(
    "toggleCriticalDamage",
    /*toggleCriticalDamage*/
    i[4]
  ), e.$on(
    "toggleDescription",
    /*toggleDescription_handler*/
    i[7]
  )), s = new v5({
    props: {
      message: (
        /*message*/
        i[5]
      ),
      hideDescription: (
        /*hideDescription*/
        i[0] || /*$message*/
        ((p = (d = (u = i[1]) == null ? void 0 : u.flags) == null ? void 0 : d.a5e) == null ? void 0 : p.cardType) !== "item" && /*$message*/
        ((h = (g = (m = i[1]) == null ? void 0 : m.flags) == null ? void 0 : g.a5e) == null ? void 0 : h.cardType) !== "rollTableOutput"
      )
    }
  }), s.$on(
    "reevaluateCritMode",
    /*reevaluateCritMode*/
    i[3]
  );
  let c = (
    /*$message*/
    ((k = (y = (_ = i[1]) == null ? void 0 : _.flags) == null ? void 0 : y.a5e) == null ? void 0 : k.cardType) === "item" && VL(i)
  );
  return {
    c() {
      e && L(e.$$.fragment), t = R(), L(s.$$.fragment), n = R(), c && c.c(), l = $e();
    },
    m(v, O) {
      e && N(e, v, O), T(v, t, O), N(s, v, O), T(v, n, O), c && c.m(v, O), T(v, l, O), r = !0;
    },
    p(v, [O]) {
      var D, I, B, F, H, G, U, q, W;
      if (o !== (o = /*getHeaderComponent*/
      v[2]())) {
        if (e) {
          ce();
          const X = e;
          C(X.$$.fragment, 1, 0, () => {
            j(X, 1);
          }), ue();
        }
        o ? (e = nt(o, a(v)), e.$on(
          "toggleCriticalDamage",
          /*toggleCriticalDamage*/
          v[4]
        ), e.$on(
          "toggleDescription",
          /*toggleDescription_handler*/
          v[7]
        ), L(e.$$.fragment), w(e.$$.fragment, 1), N(e, t.parentNode, t)) : e = null;
      }
      const P = {};
      O & /*hideDescription, $message*/
      3 && (P.hideDescription = /*hideDescription*/
      v[0] || /*$message*/
      ((B = (I = (D = v[1]) == null ? void 0 : D.flags) == null ? void 0 : I.a5e) == null ? void 0 : B.cardType) !== "item" && /*$message*/
      ((G = (H = (F = v[1]) == null ? void 0 : F.flags) == null ? void 0 : H.a5e) == null ? void 0 : G.cardType) !== "rollTableOutput"), s.$set(P), /*$message*/
      ((W = (q = (U = v[1]) == null ? void 0 : U.flags) == null ? void 0 : q.a5e) == null ? void 0 : W.cardType) === "item" ? c ? (c.p(v, O), O & /*$message*/
      2 && w(c, 1)) : (c = VL(v), c.c(), w(c, 1), c.m(l.parentNode, l)) : c && (ce(), C(c, 1, 1, () => {
        c = null;
      }), ue());
    },
    i(v) {
      r || (e && w(e.$$.fragment, v), w(s.$$.fragment, v), w(c), r = !0);
    },
    o(v) {
      e && C(e.$$.fragment, v), C(s.$$.fragment, v), C(c), r = !1;
    },
    d(v) {
      v && (S(t), S(n), S(l)), e && j(e, v), j(s, v), c && c.d(v);
    }
  };
}
f(Nbe, "create_fragment$6");
function jbe(i, e, t) {
  let s;
  function n() {
    var d, p;
    switch ((p = (d = s == null ? void 0 : s.flags) == null ? void 0 : d.a5e) == null ? void 0 : p.cardType) {
      case "item":
      case "rollTableOutput":
        return w5;
      case "abilityCheck":
      case "hitDice":
      case "savingThrow":
      case "skillCheck":
        return h5;
    }
  }
  f(n, "getHeaderComponent");
  function l() {
    var p, m;
    const d = Mp(s.rolls, (m = (p = s == null ? void 0 : s.flags) == null ? void 0 : p.a5e) == null ? void 0 : m.rollData).some(([g, h]) => {
      if (h.type !== "attack")
        return !1;
      const _ = g.terms.find((y) => y.faces === 20);
      return _ ? _.results.some(({ result: y, active: k }) => k && y >= (h.critThreshold ?? 20)) : !1;
    });
    d != null && r(d ? 1 : 0);
  }
  f(l, "reevaluateCritMode");
  function r(d) {
    var m, g;
    const p = Mp(s.rolls, (g = (m = s == null ? void 0 : s.flags) == null ? void 0 : m.a5e) == null ? void 0 : g.rollData).map(([h, _]) => _.type !== "damage" || !_.canCrit || !_.critRoll || !_.baseRoll ? h : d === 1 ? Roll.fromData(_.critRoll) : d === 0 ? Roll.fromData(_.baseRoll) : _.baseRoll.formula === h.formula ? Roll.fromData(_.critRoll) : Roll.fromData(_.baseRoll));
    s.update({ rolls: p });
  }
  f(r, "toggleCriticalDamage");
  let { messageDocument: o } = e, a = game.settings.get("a5e", "hideChatDescriptionsByDefault") ?? !1;
  const c = new Bt(o);
  pe(i, c, (d) => t(1, s = d)), et("message", c);
  const u = /* @__PURE__ */ f(() => t(0, a = !a), "toggleDescription_handler");
  return i.$$set = (d) => {
    "messageDocument" in d && t(6, o = d.messageDocument);
  }, [
    a,
    s,
    n,
    l,
    r,
    c,
    o,
    u
  ];
}
f(jbe, "instance$5");
const tO = class tO extends ie {
  constructor(e) {
    super(), le(this, e, jbe, Nbe, ne, { messageDocument: 6 });
  }
  get messageDocument() {
    return this.$$.ctx[6];
  }
  set messageDocument(e) {
    this.$$set({ messageDocument: e }), Ke();
  }
};
f(tO, "ChatCard");
let $5 = tO;
function Lbe(i, e) {
  const t = $(e).find(".message-content article")[0];
  t && CONFIG.A5E.chatCardTypes.includes(i.getFlag("a5e", "cardType")) && (i._svelteComponent = new $5({
    target: t,
    props: { messageDocument: i }
  }));
}
f(Lbe, "renderChatMessage");
function Bbe(i) {
  let e;
  return {
    c() {
      e = E("article"), e.innerHTML = `<h3>Community Discord Server</h3> <p>The best way to get support is to <a href="https://discord.gg/XtkZ6RkN9E" target="_blank">join our Discord server</a>. We have a very friendly community with lots of experienced users
            who can provide live support should you need any help. We also have
            dedicated channels for filing issue reports or submitting feature
            requests.</p> <p>Our Discord server is also home to most of the Level Up third-party
            publishers, and we make regular posts showcasing new official and
            third-party releases in the announcements channel.</p> <h3>GitHub</h3> <p>If you&#39;re not into Discord, you can also submit issue reports and
            feature requests on <a href="https://github.com/Pjb518/FoundryVTT-Level-Up-Official" target="_blank">the system&#39;s GitHub repository</a>. We check these tickets very frequently, but you&#39;re not typically
            going to get a response as quickly as you would on Discord.</p>`, b(e, "class", "svelte-1bfb8gs");
    },
    m(t, s) {
      T(t, e, s);
    },
    p: ee,
    d(t) {
      t && S(e);
    }
  };
}
f(Bbe, "create_default_slot$2");
function qbe(i) {
  let e, t, s;
  function n(r) {
    i[1](r);
  }
  f(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [Bbe] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Ss({ props: l }), st.push(() => mt(e, "elementRoot", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope*/
        4 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(qbe, "create_fragment$5");
function Gbe(i, e, t) {
  let { elementRoot: s } = e;
  function n(l) {
    s = l, t(0, s);
  }
  return f(n, "applicationshell_elementRoot_binding"), i.$$set = (l) => {
    "elementRoot" in l && t(0, s = l.elementRoot);
  }, [s, n];
}
f(Gbe, "instance$4");
var Tf;
let zbe = (Tf = class extends ie {
  constructor(e) {
    super(), le(this, e, Gbe, qbe, ne, { elementRoot: 0 });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Ke();
  }
}, f(Tf, "HelpAndSupportDialog"), Tf);
const sO = class sO extends _s {
  /**
   * Default Application options
   *
   * @returns {object} options - Application options.
   * @see https://foundryvtt.com/api/Application.html#options
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      title: "Help and Support",
      height: "auto",
      width: 400,
      classes: ["a5e-help-and-support-dialog"],
      resizable: !0,
      svelte: {
        class: zbe,
        target: document.body
      }
    });
  }
};
f(sO, "HelpAndSupportDialog");
let A5 = sO;
function Hbe(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h;
  return {
    c() {
      e = E("p"), e.innerHTML = `There is a <a href="https://preview.drivethrurpg.com/en/browse?ruleSystem=1000104&amp;?affiliate_id=1388381" target="_blank">huge amount of 3PP material available for A5e</a>, and we&#39;ve worked hard to forge relationships with third-party publishers
    to ensure that all of this great content is supported in the A5e system.
    Much of it is even included in the system by default.`, t = R(), s = E("p"), n = x(`For content that isn't integrated into the system, we provide modules that
    are either sold by the publisher as standalone products or included for free
    when you purchase the original content. We've provided a handy list of these
    products in the `), l = E("button"), l.textContent = "Premium Content", r = x(`
    tab. You can also find a list of all the modules available for A5e, both free
    and premium, on
    `), o = E("a"), o.textContent = "our GitHub repository", a = x("."), c = R(), u = E("p"), d = x(`We've also started producing exclusive modules for our Patreon supporters.
    You can find more information about this in the `), p = E("button"), p.textContent = "Patreon Exclusive", m = x(" tab."), b(l, "class", "false-link svelte-11vmpmi"), b(o, "href", "https://github.com/Pjb518/FoundryVTT-Level-Up-Official/wiki/Modules"), b(o, "target", "_blank"), b(p, "class", "false-link svelte-11vmpmi");
    },
    m(_, y) {
      T(_, e, y), T(_, t, y), T(_, s, y), A(s, n), A(s, l), A(s, r), A(s, o), A(s, a), T(_, c, y), T(_, u, y), A(u, d), A(u, p), A(u, m), g || (h = [
        V(
          l,
          "click",
          /*click_handler*/
          i[1]
        ),
        V(
          p,
          "click",
          /*click_handler_1*/
          i[2]
        )
      ], g = !0);
    },
    p: ee,
    i: ee,
    o: ee,
    d(_) {
      _ && (S(e), S(t), S(s), S(c), S(u)), g = !1, Ne(h);
    }
  };
}
f(Hbe, "create_fragment$4");
function Ube(i) {
  const e = it();
  return [e, /* @__PURE__ */ f(() => e("change-tab", 1), "click_handler"), /* @__PURE__ */ f(() => e("change-tab", 2), "click_handler_1")];
}
f(Ube, "instance$3");
const nO = class nO extends ie {
  constructor(e) {
    super(), le(this, e, Ube, Hbe, ne, {});
  }
};
f(nO, "PremiumContentListIntroduction");
let Fp = nO;
function Vbe(i) {
  let e, t, s, n, l, r, o, a, c, u, d, p, m, g, h, _, y, k, v, O, P;
  return {
    c() {
      e = E("p"), e.textContent = `In addition to helping with all the great content published for A5e, we've
    recently begun publishing exclusive tools on Patreon as a thank you to those
    that help support the system's development. Many of these tools are destined
    to one day be included in the core system software, with patrons getting
    early access.`, t = R(), s = E("p"), s.innerHTML = `If you want to help support the development of new system features or you
    want access to these exclusive tools, please consider visiting our <a href="https://www.patreon.com/ForgemasterModules" target="_blank">Patreon page</a>. You can find a summary of these tools below.`, n = R(), l = E("h3"), l.innerHTML = '<a class="patreon-link svelte-ljt19o" href="https://www.patreon.com/posts/5e-a5e-tools-89802245" target="_blank"><i class="tier-indicator tier-indicator--bronze fa-solid fa-circle svelte-ljt19o" data-tooltip="This tool is available to bronze tier patrons"></i> 5e → A5e Converter</a>', r = R(), o = E("p"), o.textContent = `The first of our Patreon release is a much requested converter that takes
    content for the 5e Foundry system and makes it usable in an A5e world. The
    application contains a number of handy instructions pages to help you
    prepare your 5e content for conversion.`, a = R(), c = E("p"), c.innerHTML = 'You can see the conversion tools in action <a href="https://www.patreon.com/posts/5e-a5e-tools-89802245" target="_blank">here</a>.', u = R(), d = E("h3"), d.innerHTML = '<a class="patreon-link svelte-ljt19o" href="https://www.patreon.com/posts/preview-builder-92995236" target="_blank"><i class="tier-indicator tier-indicator--bronze fa-solid fa-circle svelte-ljt19o" data-tooltip="This tool is available to bronze tier patrons"></i> Encounter Builder</a>', p = R(), m = E("p"), m.textContent = `The encounter builder is an combat encounter planning utility that allows
    you to quickly an easily evaluate the difficulty of a combat encounter
    against your current party.`, g = R(), h = E("p"), h.textContent = `Future versions of this tool will see it transform into a full encounter
    management suite, with helpful summaries for tracking combats, handy
    import/export functionality, xp management, and module integration to
    automatically set up encounters for published adventures.`, _ = R(), y = E("h3"), y.innerHTML = `<a class="patreon-link svelte-ljt19o" href="https://www.patreon.com/posts/preview-flanking-99659434" target="_blank"><i class="tier-indicator tier-indicator--silver fa-solid fa-circle svelte-ljt19o" data-tooltip="This tool is available to silver tier patrons"></i>
        Flanking Automation</a>`, k = R(), v = E("p"), v.textContent = `Our new Flanking Automation module automatically detects flanking conditions
    against targeted tokens and preselects an additional expertise die in the
    roll dialog when you make attack rolls.`, O = R(), P = E("p"), P.textContent = `If you're using the A5e Foundry system to play standard D&D 5e, you can
    instead configure the module to grant advantage in the module settings.`, z(s, "margin-bottom", "1rem"), b(l, "class", "svelte-ljt19o"), b(d, "class", "svelte-ljt19o"), b(y, "class", "svelte-ljt19o");
    },
    m(D, I) {
      T(D, e, I), T(D, t, I), T(D, s, I), T(D, n, I), T(D, l, I), T(D, r, I), T(D, o, I), T(D, a, I), T(D, c, I), T(D, u, I), T(D, d, I), T(D, p, I), T(D, m, I), T(D, g, I), T(D, h, I), T(D, _, I), T(D, y, I), T(D, k, I), T(D, v, I), T(D, O, I), T(D, P, I);
    },
    p: ee,
    i: ee,
    o: ee,
    d(D) {
      D && (S(e), S(t), S(s), S(n), S(l), S(r), S(o), S(a), S(c), S(u), S(d), S(p), S(m), S(g), S(h), S(_), S(y), S(k), S(v), S(O), S(P));
    }
  };
}
f(Vbe, "create_fragment$3");
const iO = class iO extends ie {
  constructor(e) {
    super(), le(this, e, null, Vbe, ne, {});
  }
};
f(iO, "PremiumContentListPatreon");
let E5 = iO;
function WL(i, e, t) {
  const s = i.slice();
  return s[1] = e[t].name, s[2] = e[t].releases, s;
}
f(WL, "get_each_context$1");
function KL(i, e, t) {
  const s = i.slice();
  return s[5] = e[t].title, s[6] = e[t].url, s;
}
f(KL, "get_each_context_1$1");
function YL(i) {
  let e, t, s = (
    /*title*/
    i[5] + ""
  ), n, l;
  return {
    c() {
      e = E("li"), t = E("a"), n = x(s), l = R(), b(
        t,
        "href",
        /*url*/
        i[6]
      ), b(t, "target", "_blank"), b(t, "class", "svelte-s5s5cg"), b(e, "class", "content-list__item svelte-s5s5cg");
    },
    m(r, o) {
      T(r, e, o), A(e, t), A(t, n), A(e, l);
    },
    p: ee,
    d(r) {
      r && S(e);
    }
  };
}
f(YL, "create_each_block_1$1");
function Wbe(i) {
  let e, t, s = oe(
    /*releases*/
    i[2]
  ), n = [];
  for (let l = 0; l < s.length; l += 1)
    n[l] = YL(KL(i, s, l));
  return {
    c() {
      e = E("ul");
      for (let l = 0; l < n.length; l += 1)
        n[l].c();
      t = R(), b(e, "class", "content-list svelte-s5s5cg");
    },
    m(l, r) {
      T(l, e, r);
      for (let o = 0; o < n.length; o += 1)
        n[o] && n[o].m(e, null);
      T(l, t, r);
    },
    p(l, r) {
      if (r & /*Object, premiumContent*/
      1) {
        s = oe(
          /*releases*/
          l[2]
        );
        let o;
        for (o = 0; o < s.length; o += 1) {
          const a = KL(l, s, o);
          n[o] ? n[o].p(a, r) : (n[o] = YL(a), n[o].c(), n[o].m(e, null));
        }
        for (; o < n.length; o += 1)
          n[o].d(1);
        n.length = s.length;
      }
    },
    d(l) {
      l && (S(e), S(t)), Le(n, l);
    }
  };
}
f(Wbe, "create_default_slot$1");
function XL(i) {
  let e, t;
  return e = new Me({
    props: {
      heading: (
        /*name*/
        i[1]
      ),
      $$slots: { default: [Wbe] },
      $$scope: { ctx: i }
    }
  }), {
    c() {
      L(e.$$.fragment);
    },
    m(s, n) {
      N(e, s, n), t = !0;
    },
    p(s, n) {
      const l = {};
      n & /*$$scope*/
      512 && (l.$$scope = { dirty: n, ctx: s }), e.$set(l);
    },
    i(s) {
      t || (w(e.$$.fragment, s), t = !0);
    },
    o(s) {
      C(e.$$.fragment, s), t = !1;
    },
    d(s) {
      j(e, s);
    }
  };
}
f(XL, "create_each_block$1");
function Kbe(i) {
  let e, t, s, n, l, r, o = oe(Object.values(
    /*premiumContent*/
    i[0]
  )), a = [];
  for (let u = 0; u < o.length; u += 1)
    a[u] = XL(WL(i, o, u));
  const c = /* @__PURE__ */ f((u) => C(a[u], 1, 1, () => {
    a[u] = null;
  }), "out");
  return {
    c() {
      e = E("p"), e.textContent = `Below you'll find a list of premium content modules organized by publisher.
    Some of these modules are included for free when you purchase the a PDF or
    physical book. Others modules are sold as standalone products.`, t = R(), s = E("p"), s.innerHTML = `<b>Disclaimer.</b> This page contains affiliate links. If you choose to make
    a purchase after clicking a link, we may receive a small amount of kickback from
    DriveThruRPG that will go towards developing and maintaining the A5e Foundry
    system and its modules.`, n = R();
      for (let u = 0; u < a.length; u += 1)
        a[u].c();
      l = $e(), b(s, "class", "a5e-content-disclaimer svelte-s5s5cg");
    },
    m(u, d) {
      T(u, e, d), T(u, t, d), T(u, s, d), T(u, n, d);
      for (let p = 0; p < a.length; p += 1)
        a[p] && a[p].m(u, d);
      T(u, l, d), r = !0;
    },
    p(u, [d]) {
      if (d & /*Object, premiumContent*/
      1) {
        o = oe(Object.values(
          /*premiumContent*/
          u[0]
        ));
        let p;
        for (p = 0; p < o.length; p += 1) {
          const m = WL(u, o, p);
          a[p] ? (a[p].p(m, d), w(a[p], 1)) : (a[p] = XL(m), a[p].c(), w(a[p], 1), a[p].m(l.parentNode, l));
        }
        for (ce(), p = o.length; p < a.length; p += 1)
          c(p);
        ue();
      }
    },
    i(u) {
      if (!r) {
        for (let d = 0; d < o.length; d += 1)
          w(a[d]);
        r = !0;
      }
    },
    o(u) {
      a = a.filter(Boolean);
      for (let d = 0; d < a.length; d += 1)
        C(a[d]);
      r = !1;
    },
    d(u) {
      u && (S(e), S(t), S(s), S(n), S(l)), Le(a, u);
    }
  };
}
f(Kbe, "create_fragment$2");
function Ybe(i) {
  const { premiumContent: e } = CONFIG.A5E;
  return [e];
}
f(Ybe, "instance$2");
const lO = class lO extends ie {
  constructor(e) {
    super(), le(this, e, Ybe, Kbe, ne, {});
  }
};
f(lO, "PremiumContentListPremium");
let S5 = lO;
function Xbe(i) {
  let e, t, s, n, l;
  e = new bn({
    props: {
      currentTab: (
        /*currentTab*/
        i[1]
      ),
      tabs: (
        /*tabs*/
        i[3]
      )
    }
  }), e.$on(
    "tab-change",
    /*tab_change_handler*/
    i[4]
  );
  var r = (
    /*getCurrentTabComponent*/
    i[2](
      /*currentTab*/
      i[1]
    )
  );
  function o(a, c) {
    return {};
  }
  return f(o, "switch_props"), r && (n = nt(r, o()), n.$on(
    "change-tab",
    /*change_tab_handler*/
    i[5]
  )), {
    c() {
      L(e.$$.fragment), t = R(), s = E("article"), n && L(n.$$.fragment), b(s, "class", "svelte-1d0prc6");
    },
    m(a, c) {
      N(e, a, c), T(a, t, c), T(a, s, c), n && N(n, s, null), l = !0;
    },
    p(a, c) {
      const u = {};
      if (c & /*currentTab*/
      2 && (u.currentTab = /*currentTab*/
      a[1]), e.$set(u), c & /*currentTab*/
      2 && r !== (r = /*getCurrentTabComponent*/
      a[2](
        /*currentTab*/
        a[1]
      ))) {
        if (n) {
          ce();
          const d = n;
          C(d.$$.fragment, 1, 0, () => {
            j(d, 1);
          }), ue();
        }
        r ? (n = nt(r, o()), n.$on(
          "change-tab",
          /*change_tab_handler*/
          a[5]
        ), L(n.$$.fragment), w(n.$$.fragment, 1), N(n, s, null)) : n = null;
      }
    },
    i(a) {
      l || (w(e.$$.fragment, a), n && w(n.$$.fragment, a), l = !0);
    },
    o(a) {
      C(e.$$.fragment, a), n && C(n.$$.fragment, a), l = !1;
    },
    d(a) {
      a && (S(t), S(s)), j(e, a), n && j(n);
    }
  };
}
f(Xbe, "create_default_slot");
function Jbe(i) {
  let e, t, s;
  function n(r) {
    i[6](r);
  }
  f(n, "applicationshell_elementRoot_binding");
  let l = {
    $$slots: { default: [Xbe] },
    $$scope: { ctx: i }
  };
  return (
    /*elementRoot*/
    i[0] !== void 0 && (l.elementRoot = /*elementRoot*/
    i[0]), e = new Ss({ props: l }), st.push(() => mt(e, "elementRoot", n)), {
      c() {
        L(e.$$.fragment);
      },
      m(r, o) {
        N(e, r, o), s = !0;
      },
      p(r, [o]) {
        const a = {};
        o & /*$$scope, currentTab*/
        130 && (a.$$scope = { dirty: o, ctx: r }), !t && o & /*elementRoot*/
        1 && (t = !0, a.elementRoot = /*elementRoot*/
        r[0], _t(() => t = !1)), e.$set(a);
      },
      i(r) {
        s || (w(e.$$.fragment, r), s = !0);
      },
      o(r) {
        C(e.$$.fragment, r), s = !1;
      },
      d(r) {
        j(e, r);
      }
    }
  );
}
f(Jbe, "create_fragment$1");
function Zbe(i, e, t) {
  let { elementRoot: s } = e;
  function n({ name: u }) {
    switch (u) {
      case "intro":
        return Fp;
      case "premiumContent":
        return S5;
      case "patreon":
        return E5;
      default:
        return Fp;
    }
  }
  f(n, "getCurrentTabComponent");
  const l = [
    { name: "intro", label: "Introduction" },
    {
      name: "premiumContent",
      label: "Premium Content"
    },
    {
      name: "patreon",
      label: "Patreon Exclusive"
    }
  ];
  let r = l[0];
  const o = /* @__PURE__ */ f(({ detail: u }) => t(1, r = l[u]), "tab_change_handler"), a = /* @__PURE__ */ f(({ detail: u }) => t(1, r = l[u]), "change_tab_handler");
  function c(u) {
    s = u, t(0, s);
  }
  return f(c, "applicationshell_elementRoot_binding"), i.$$set = (u) => {
    "elementRoot" in u && t(0, s = u.elementRoot);
  }, [
    s,
    r,
    n,
    l,
    o,
    a,
    c
  ];
}
f(Zbe, "instance$1");
var Cf;
let Qbe = (Cf = class extends ie {
  constructor(e) {
    super(), le(this, e, Zbe, Jbe, ne, { elementRoot: 0 });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(e) {
    this.$$set({ elementRoot: e }), Ke();
  }
}, f(Cf, "PremiumContentListDialog"), Cf);
const rO = class rO extends _s {
  /**
   * Default Application options
   *
   * @returns {object} options - Application options.
   * @see https://foundryvtt.com/api/Application.html#options
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      title: "Premium Content",
      height: "auto",
      width: 500,
      classes: ["a5e-premium-content-list-dialog"],
      resizable: !0,
      svelte: {
        class: Qbe,
        target: document.body
      }
    });
  }
};
f(rO, "PremiumContentListDialog");
let T5 = rO;
function xbe(i, e) {
  var u;
  const t = e[0], s = t.querySelector(".settings-sidebar .system-title");
  s.innerText = "Level Up: Advanced 5th Edition";
  const n = t.querySelector(".settings-sidebar li.system"), l = n == null ? void 0 : n.cloneNode(!1);
  l.classList.remove("system"), l.classList.add("a5e-community-links");
  const r = [
    {
      classes: ["a5e-community-link", "a5e-community-link--discord"],
      icon: '<i class="fa-brands fa-discord"></i>',
      label: "Discord",
      tooltip: "Join the community Discord server",
      url: "https://discord.gg/XtkZ6RkN9E"
    },
    {
      classes: ["a5e-community-link", "a5e-community-link--patreon"],
      icon: '<i class="fa-brands fa-patreon"></i>',
      label: "Patreon",
      tooltip: "Support the system",
      url: "https://www.patreon.com/ForgemasterModules"
    }
  ].map(({
    classes: d,
    icon: p,
    label: m,
    tooltip: g,
    url: h
  }) => {
    const _ = document.createElement("a");
    return _.href = h, _.innerHTML = `${p} ${m}`, _.target = "_blank", _.setAttribute("data-tooltip", g), _.classList.add(...d), _;
  });
  l.append(...r), n == null || n.after(l);
  const o = document.createElement("h2");
  o.innerText = "Level Up: Advanced 5th Edition";
  const a = document.createElement("div");
  (u = t.querySelector("#settings-game")) == null || u.after(o, a);
  const c = [
    {
      DialogApplication: A5,
      dialogName: "helpAndSupport",
      iconClasses: ["fa-solid", "fa-life-ring"],
      label: "Help and Support"
    },
    {
      DialogApplication: Pp,
      dialogName: "latestAnnouncements",
      iconClasses: ["fa-solid", "fa-bullhorn"],
      label: "Latest Announcements"
    },
    {
      DialogApplication: T5,
      dialogName: "premiumContentList",
      iconClasses: ["fa-solid", "fa-wallet"],
      label: "Premium Content"
    }
  ].map(({
    DialogApplication: d,
    dialogName: p,
    iconClasses: m,
    label: g
  }) => {
    const h = document.createElement("button");
    h.type = "button";
    const _ = document.createElement("i");
    return _.classList.add(...m), h.append(_, g), h.addEventListener("click", () => {
      var y;
      (y = game.a5e.dialogs)[p] ?? (y[p] = new d()), game.a5e.dialogs[p].render(!0);
    }), h;
  });
  a.append(...c);
}
f(xbe, "renderSettings");
function JL(i, e, t) {
  const s = i.slice();
  return s[19] = e[t], s;
}
f(JL, "get_each_context");
function ZL(i, e, t) {
  const s = i.slice();
  return s[19] = e[t], s;
}
f(ZL, "get_each_context_1");
function QL(i) {
  let e, t, s, n, l, r = (
    /*effect*/
    i[19].title + ""
  ), o, a, c, u, d;
  function p() {
    return (
      /*click_handler*/
      i[13](
        /*effect*/
        i[19]
      )
    );
  }
  f(p, "click_handler");
  function m() {
    return (
      /*auxclick_handler*/
      i[14](
        /*effect*/
        i[19]
      )
    );
  }
  return f(m, "auxclick_handler"), {
    c() {
      var g, h;
      e = E("button"), t = E("img"), n = R(), l = E("h3"), o = x(r), a = R(), b(t, "class", ni(
        /*effect*/
        i[19].cssClass
      ) + " svelte-x2kcqi"), ze(t.src, s = /*effect*/
      i[19].src) || b(t, "src", s), b(
        t,
        "alt",
        /*effect*/
        i[19].title ?? ""
      ), b(
        t,
        "title",
        /*effect*/
        i[19].title ?? ""
      ), b(
        t,
        "data-status-id",
        /*effect*/
        i[19].id
      ), b(l, "class", "condition-title svelte-x2kcqi"), z(l, "--strife", "'" + /*strife*/
      i[1] + "'"), z(l, "--fatigue", "'" + /*fatigue*/
      i[2] + "'"), z(
        l,
        "--fatigue-col",
        /*colors*/
        i[11][
          /*fatigue*/
          i[2]
        ]
      ), z(
        l,
        "--strife-col",
        /*colors*/
        i[11][
          /*strife*/
          i[1]
        ]
      ), b(e, "class", "condition-container " + /*effect*/
      i[19].cssClass + " svelte-x2kcqi"), b(
        e,
        "title",
        /*effect*/
        i[19].title ?? ""
      ), b(
        e,
        "data-status-id",
        /*effect*/
        i[19].id
      ), e.disabled = c = /*conditionImmunities*/
      i[4].includes(
        /*effect*/
        i[19].id
      ) || /*subConditions*/
      ((g = i[10][
        /*effect*/
        i[19].id
      ]) == null ? void 0 : g.some(
        /*func*/
        i[12]
      )), Q(
        e,
        "linked",
        /*subConditions*/
        (h = i[10][
          /*effect*/
          i[19].id
        ]) == null ? void 0 : h.some(
          /*func_1*/
          i[15]
        )
      ), Q(
        e,
        "locked",
        /*conditionImmunities*/
        i[4].includes(
          /*effect*/
          i[19].id
        )
      ), Q(
        e,
        "fatigue-counter",
        /*effect*/
        i[19].id === "fatigue" && /*fatigue*/
        i[2] > 0
      ), Q(
        e,
        "strife-counter",
        /*effect*/
        i[19].id === "strife" && /*strife*/
        i[1] > 0
      );
    },
    m(g, h) {
      T(g, e, h), A(e, t), A(e, n), A(e, l), A(l, o), A(e, a), u || (d = [
        V(e, "click", We(tt(p))),
        V(e, "auxclick", We(tt(m)))
      ], u = !0);
    },
    p(g, h) {
      var _;
      i = g, h & /*strife*/
      2 && z(l, "--strife", "'" + /*strife*/
      i[1] + "'"), h & /*fatigue*/
      4 && z(l, "--fatigue", "'" + /*fatigue*/
      i[2] + "'"), h & /*fatigue*/
      4 && z(
        l,
        "--fatigue-col",
        /*colors*/
        i[11][
          /*fatigue*/
          i[2]
        ]
      ), h & /*strife*/
      2 && z(
        l,
        "--strife-col",
        /*colors*/
        i[11][
          /*strife*/
          i[1]
        ]
      ), h & /*conditionImmunities*/
      16 && c !== (c = /*conditionImmunities*/
      i[4].includes(
        /*effect*/
        i[19].id
      ) || /*subConditions*/
      ((_ = i[10][
        /*effect*/
        i[19].id
      ]) == null ? void 0 : _.some(
        /*func*/
        i[12]
      ))) && (e.disabled = c), h & /*conditionImmunities, statusEffects*/
      144 && Q(
        e,
        "locked",
        /*conditionImmunities*/
        i[4].includes(
          /*effect*/
          i[19].id
        )
      ), h & /*statusEffects, fatigue*/
      132 && Q(
        e,
        "fatigue-counter",
        /*effect*/
        i[19].id === "fatigue" && /*fatigue*/
        i[2] > 0
      ), h & /*statusEffects, strife*/
      130 && Q(
        e,
        "strife-counter",
        /*effect*/
        i[19].id === "strife" && /*strife*/
        i[1] > 0
      );
    },
    d(g) {
      g && S(e), u = !1, Ne(d);
    }
  };
}
f(QL, "create_each_block_1");
function xL(i) {
  let e, t, s, n, l, r;
  function o() {
    return (
      /*click_handler_1*/
      i[16](
        /*effect*/
        i[19]
      )
    );
  }
  f(o, "click_handler_1");
  function a() {
    return (
      /*auxclick_handler_1*/
      i[17](
        /*effect*/
        i[19]
      )
    );
  }
  return f(a, "auxclick_handler_1"), {
    c() {
      e = E("button"), t = E("img"), n = R(), b(t, "class", ni(
        /*effect*/
        i[19].cssClass
      ) + " svelte-x2kcqi"), ze(t.src, s = /*effect*/
      i[19].src) || b(t, "src", s), b(
        t,
        "alt",
        /*effect*/
        i[19].title ?? ""
      ), b(
        t,
        "title",
        /*effect*/
        i[19].title ?? ""
      ), b(
        t,
        "data-status-id",
        /*effect*/
        i[19].id
      ), b(e, "class", "condition-container " + /*effect*/
      i[19].cssClass + " svelte-x2kcqi"), b(
        e,
        "title",
        /*effect*/
        i[19].title ?? ""
      ), b(
        e,
        "data-status-id",
        /*effect*/
        i[19].id
      );
    },
    m(c, u) {
      T(c, e, u), A(e, t), A(e, n), l || (r = [
        V(e, "click", We(tt(o))),
        V(e, "auxclick", We(tt(a)))
      ], l = !0);
    },
    p(c, u) {
      i = c;
    },
    d(c) {
      c && S(e), l = !1, Ne(r);
    }
  };
}
f(xL, "create_each_block");
function e_e(i) {
  let e, t, s, n, l, r, o, a, c, u = K("A5E.UIClearAll") + "", d, p, m, g = oe(
    /*statusEffects*/
    i[7]
  ), h = [];
  for (let k = 0; k < g.length; k += 1)
    h[k] = QL(ZL(i, g, k));
  let _ = oe(
    /*genericEffects*/
    i[8]
  ), y = [];
  for (let k = 0; k < _.length; k += 1)
    y[k] = xL(JL(i, _, k));
  return {
    c() {
      e = E("div");
      for (let k = 0; k < h.length; k += 1)
        h[k].c();
      t = R(), s = E("hr"), n = R(), l = E("div");
      for (let k = 0; k < y.length; k += 1)
        y[k].c();
      r = R(), o = E("button"), a = E("i"), c = R(), d = x(u), b(e, "class", "status-effects-container svelte-x2kcqi"), Q(
        e,
        "status-effects-container--column-flow",
        /*conditionsFlowDirection*/
        i[3] === "column"
      ), b(s, "class", "a5e-rule"), b(l, "class", "generic-effects-container svelte-x2kcqi"), b(a, "class", "fa-solid fa-octagon-xmark"), b(o, "class", "clear-all-conditions svelte-x2kcqi");
    },
    m(k, v) {
      T(k, e, v);
      for (let O = 0; O < h.length; O += 1)
        h[O] && h[O].m(e, null);
      T(k, t, v), T(k, s, v), T(k, n, v), T(k, l, v);
      for (let O = 0; O < y.length; O += 1)
        y[O] && y[O].m(l, null);
      T(k, r, v), T(k, o, v), A(o, a), A(o, c), A(o, d), p || (m = V(o, "click", function() {
        var O, P;
        $t(
          /*HUD*/
          (O = i[0]) == null ? void 0 : O._clearAllConditions.bind(
            /*HUD*/
            i[0]
          )
        ) && ((P = i[0]) == null || P._clearAllConditions.bind(
          /*HUD*/
          i[0]
        ).apply(this, arguments));
      }), p = !0);
    },
    p(k, [v]) {
      if (i = k, v & /*statusEffects, conditionImmunities, subConditions, activeConditions, fatigue, strife, handleStatusEffectAdd, handleStatusEffectRemove, colors*/
      3830) {
        g = oe(
          /*statusEffects*/
          i[7]
        );
        let O;
        for (O = 0; O < g.length; O += 1) {
          const P = ZL(i, g, O);
          h[O] ? h[O].p(P, v) : (h[O] = QL(P), h[O].c(), h[O].m(e, null));
        }
        for (; O < h.length; O += 1)
          h[O].d(1);
        h.length = g.length;
      }
      if (v & /*conditionsFlowDirection*/
      8 && Q(
        e,
        "status-effects-container--column-flow",
        /*conditionsFlowDirection*/
        i[3] === "column"
      ), v & /*genericEffects, handleStatusEffectAdd, handleStatusEffectRemove*/
      352) {
        _ = oe(
          /*genericEffects*/
          i[8]
        );
        let O;
        for (O = 0; O < _.length; O += 1) {
          const P = JL(i, _, O);
          y[O] ? y[O].p(P, v) : (y[O] = xL(P), y[O].c(), y[O].m(l, null));
        }
        for (; O < y.length; O += 1)
          y[O].d(1);
        y.length = _.length;
      }
    },
    i: ee,
    o: ee,
    d(k) {
      k && (S(e), S(t), S(s), S(n), S(l), S(r), S(o)), Le(h, k), Le(y, k), p = !1, m();
    }
  };
}
f(e_e, "create_fragment");
function t_e(i, e, t) {
  let s, n, l, r, { HUD: o } = e;
  function a({ id: D, src: I }, B = "status") {
    o.object._addStatusEffect({ id: D, src: I });
  }
  f(a, "handleStatusEffectAdd");
  function c({ id: D, src: I }, B = "status") {
    o.object._removeStatusEffect({ id: D, src: I });
  }
  f(c, "handleStatusEffectRemove");
  const u = o.getData(), d = Object.values(u.statusEffects), p = Object.values(u.genericConditions), m = o.object._getActiveConditions(), g = CONFIG.statusEffects.reduce(
    (D, I) => {
      var B;
      return (B = I == null ? void 0 : I.statuses) != null && B.length && I.statuses.forEach((F) => {
        D[F] ?? (D[F] = []), D[F].push(I.id);
      }), D;
    },
    {}
  ), h = {
    1: "#919f00",
    2: "#a09200",
    3: "#af8300",
    4: "#bd7100",
    5: "#cb5c00",
    6: "#d63f00",
    7: "#e00006"
  }, _ = /* @__PURE__ */ f((D) => m.includes(D), "func"), y = /* @__PURE__ */ f((D) => a(D), "click_handler"), k = /* @__PURE__ */ f((D) => c(D), "auxclick_handler"), v = /* @__PURE__ */ f((D) => m.includes(D), "func_1"), O = /* @__PURE__ */ f((D) => a(D), "click_handler_1"), P = /* @__PURE__ */ f((D) => c(D), "auxclick_handler_1");
  return i.$$set = (D) => {
    "HUD" in D && t(0, o = D.HUD);
  }, i.$$.update = () => {
    var D, I, B, F, H, G, U, q, W, X, te, J;
    i.$$.dirty & /*HUD*/
    1 && t(4, s = ((F = (B = (I = (D = o == null ? void 0 : o.object) == null ? void 0 : D.actor) == null ? void 0 : I.system) == null ? void 0 : B.traits) == null ? void 0 : F.conditionImmunities) ?? []), i.$$.dirty & /*HUD*/
    1 && t(2, l = ((q = (U = (G = (H = o == null ? void 0 : o.object) == null ? void 0 : H.actor) == null ? void 0 : G.system) == null ? void 0 : U.attributes) == null ? void 0 : q.fatigue) ?? 0), i.$$.dirty & /*HUD*/
    1 && t(1, r = ((J = (te = (X = (W = o == null ? void 0 : o.object) == null ? void 0 : W.actor) == null ? void 0 : X.system) == null ? void 0 : te.attributes) == null ? void 0 : J.strife) ?? 0);
  }, t(3, n = game.settings.get("a5e", "conditionFlowDirection")), [
    o,
    r,
    l,
    n,
    s,
    a,
    c,
    d,
    p,
    m,
    g,
    h,
    _,
    y,
    k,
    v,
    O,
    P
  ];
}
f(t_e, "instance");
const oO = class oO extends ie {
  constructor(e) {
    super(), le(this, e, t_e, e_e, ne, { HUD: 0 });
  }
  get HUD() {
    return this.$$.ctx[0];
  }
  set HUD(e) {
    this.$$set({ HUD: e }), Ke();
  }
};
f(oO, "A5ETokenHUD");
let C5 = oO;
function s_e(i, e, t) {
  const s = $(e).find(".status-effects")[0];
  s && (s.innerHTML = "", i._svelteComponent = new C5({
    target: s,
    props: { HUD: i }
  }));
}
f(s_e, "renderTokenHUDA5E");
const aO = class aO extends FormApplication {
  constructor() {
    super({}), Ip.show();
  }
  /** @override */
  async updateObject() {
  }
  render() {
    this.close();
  }
};
f(aO, "SettingsShim");
let O5 = aO;
function n_e() {
  Aa.init(), game.settings.registerMenu("a5e", "SystemSettings", {
    name: "System Settings",
    label: "Configure System Settings",
    icon: "fas fa bars",
    type: O5,
    restricted: !1
  });
}
f(n_e, "registerSystemSettings");
function i_e(i) {
  const e = i.ACTIVE_EFFECT_MODES;
  return {
    blinded: [
      {
        key: "flags.a5e.effects.rollMode.attack.all",
        value: -1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionBlinded"
      },
      {
        key: "flags.a5e.effects.grants.rollMode.attack.all",
        value: 1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionBlinded"
      }
    ],
    bloodied: [],
    charmed: [],
    concentration: [],
    confused: [],
    deafened: [],
    dead: [],
    doomed: [],
    encumbered: [
      ...Object.keys(i.movement).map((t) => ({
        key: `system.attributes.movement.${t}.distance`,
        value: '{"comparisonOperator":"==","comparisonValue":"0","positiveValue":"0","negativeValue":"5"}',
        mode: e.CONDITIONAL,
        priority: e.CONDITIONAL * 10,
        label: "A5E.ConditionGrappled"
      }))
    ],
    fatigue: [],
    frightened: [],
    grappled: [
      ...Object.keys(i.movement).map((t) => ({
        key: `system.attributes.movement.${t}.distance`,
        value: "0",
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionGrappled"
      }))
    ],
    incapacitated: [],
    invisible: [
      {
        key: "flags.a5e.effects.rollMode.attack.all",
        value: 1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionInvisible"
      },
      {
        key: "flags.a5e.effects.grants.rollMode.attack.all",
        value: -1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionInvisible"
      }
    ],
    paralyzed: [
      {
        key: "flags.a5e.effects.grants.rollMode.attack.all",
        value: -1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionParalyzed"
      }
    ],
    petrified: [
      ...Object.keys(i.damageTypes).map((t) => ({
        key: "system.traits.damageResistances",
        value: t,
        mode: e.ADD,
        priority: e.ADD * 10,
        label: "A5E.ConditionPetrified"
      }))
      // TODO: Possible immunity to poisoned?
    ],
    poisoned: [
      {
        key: "flags.a5e.effects.rollMode.attack.all",
        value: -1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionPoisoned"
      },
      {
        key: "flags.a5e.effects.rollMode.abilityCheck.all",
        value: -1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionPoisoned"
      }
    ],
    prone: [
      {
        key: "flags.a5e.effects.rollMode.attack.meleeWeapon",
        value: -1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionProne"
      }
    ],
    rattled: [
      {
        key: "flags.a5e.effects.expertiseDice",
        value: 0,
        mode: e.OVERRIDE,
        priority: 200,
        label: "A5E.ConditionRattled"
      }
    ],
    restrained: [
      {
        key: "flags.a5e.effects.grants.rollMode.attack.all",
        value: 1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionRestrained"
      },
      {
        key: "flags.a5e.effects.rollMode.attack.all",
        value: -1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionRestrained"
      },
      {
        key: "flags.a5e.effects.rollMode.abilitySave.dex",
        value: -1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionRestrained"
      },
      ...Object.keys(i.movement).map((t) => ({
        key: `system.attributes.movement.${t}.distance`,
        value: "0",
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionGrappled"
      }))
    ],
    slowed: [
      {
        key: "system.attributes.ac.changes.bonuses.value",
        value: "-2",
        mode: e.ADD,
        priority: e.ADD * 10,
        label: "A5E.ConditionSlowed"
      },
      {
        key: "system.abilities.dex.save.bonus",
        value: "-2",
        mode: e.ADD,
        priority: e.ADD * 10,
        label: "A5E.ConditionSlowed"
      },
      ...Object.keys(i.movement).map((t) => ({
        key: `system.attributes.movement.${t}.distance`,
        value: "0.5",
        mode: e.MULTIPLY,
        priority: e.MULTIPLY * 10,
        label: "A5E.ConditionSlowed"
      }))
    ],
    strife: [],
    stunned: [
      {
        key: "flags.a5e.effects.grants.rollMode.attack.all",
        value: 1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionStunned"
      }
    ],
    unconscious: [
      {
        key: "flags.a5e.effects.grants.rollMode.attack.all",
        value: 1,
        mode: e.OVERRIDE,
        priority: e.OVERRIDE * 10,
        label: "A5E.ConditionStunned"
      }
    ]
  };
}
f(i_e, "generateChanges");
function l_e() {
  const { A5E: i } = CONFIG, e = i.ACTIVE_EFFECT_MODES, t = new Set(
    game.settings.storage.get("world").getItem("a5e.automatedConditions")
  ), s = game.settings.get("a5e", "replaceFatigueAndStrife"), n = game.settings.get("a5e", "customConditionIcons"), l = i_e(i);
  i.multiLevelConditionsMaxLevel = {
    fatigue: s ? 6 : 7,
    strife: 7
  }, i.multiLevelConditions = {
    fatigue: {
      1: [],
      2: [
        {
          key: "flags.a5e.effects.rollMode.abilityCheck.con",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Fatigue 2"
        },
        {
          key: "flags.a5e.effects.rollMode.abilityCheck.dex",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Fatigue 2"
        },
        {
          key: "flags.a5e.effects.rollMode.abilityCheck.str",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Fatigue 2"
        }
      ],
      3: [
        ...Object.keys(i.movement).map((o) => ({
          key: `system.attributes.movement.${o}.distance`,
          value: "0.5",
          mode: e.MULTIPLY,
          priority: e.MULTIPLY * 10,
          label: "Fatigue 3"
        }))
      ],
      4: [],
      5: [],
      6: [
        ...Object.keys(i.movement).map((o) => ({
          key: `system.attributes.movement.${o}.distance`,
          value: '{"comparisonOperator":"==","comparisonValue":"0","positiveValue":"0","negativeValue":"5"}',
          mode: e.CONDITIONAL,
          priority: e.CONDITIONAL * 10,
          label: "Fatigue 6"
        }))
      ]
    },
    exhaustion: {
      1: [
        {
          key: "flags.a5e.effects.rollMode.abilityCheck.all",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Exhaustion 1"
        }
      ],
      2: [
        ...Object.keys(i.movement).map((o) => ({
          key: `system.attributes.movement.${o}.distance`,
          value: "0.5",
          mode: e.MULTIPLY,
          priority: e.MULTIPLY * 10,
          label: "Exhaustion 2"
        }))
      ],
      3: [
        {
          key: "flags.a5e.effects.rollMode.savingThrow.all",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Exhaustion 3"
        },
        {
          key: "flags.a5e.effects.rollMode.attack.all",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Exhaustion 3"
        }
      ],
      4: [
        {
          key: "system.attributes.hp.max",
          value: "0.5",
          mode: e.MULTIPLY,
          priority: e.MULTIPLY * 10,
          label: "Exhaustion 4"
        }
      ],
      5: [
        ...Object.keys(i.movement).map((o) => ({
          key: `system.attributes.movement.${o}.distance`,
          value: "0",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Exhaustion 5"
        }))
      ],
      6: []
    },
    strife: {
      1: [
        {
          key: "flags.a5e.effects.rollMode.abilityCheck.cha",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Strife 1"
        },
        {
          key: "flags.a5e.effects.rollMode.abilityCheck.int",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Strife 1"
        },
        {
          key: "flags.a5e.effects.rollMode.abilityCheck.wis",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Strife 1"
        }
      ],
      2: [
        {
          key: "flags.a5e.effects.rollMode.concentration",
          value: "-1",
          mode: e.OVERRIDE,
          priority: e.OVERRIDE * 10,
          label: "Strife 2"
        }
      ],
      3: [],
      4: [],
      5: [],
      6: [],
      7: []
    }
  };
  let r = [
    // Blinded
    {
      id: "blinded",
      description: `<ul class="a5e-tooltip__list"><li>A blinded creature can't see and it automatically fails ability checks that require sight.</li><li>Attack rolls against a blinded creature are made with advantage, and the creature's attack rolls are made with disadvantage.</li></ul>`,
      label: "A5E.ConditionBlinded",
      icon: "icons/svg/blind.svg",
      changes: l.blinded,
      duration: {}
    },
    // Bloodied
    {
      id: "bloodied",
      description: '<ul class="a5e-tooltip__list"><li>A creature is bloodied when reduced to half its hit points or less.</li></ul>',
      label: "A5E.ConditionBloodied",
      icon: "icons/svg/blood.svg",
      changes: l.bloodied,
      duration: {}
    },
    // Charmed
    {
      id: "charmed",
      description: `<ul class="a5e-tooltip__list"><li>A charmed creature can't take any hostile action against the charmer.</li><li>Ability checks the charmer makes to socially interact with the charmed creature have advantage.</li></ul>`,
      label: "A5E.ConditionCharmed",
      icon: "systems/a5e/assets/icons/charmed.svg",
      changes: l.charmed,
      duration: {}
    },
    // Concentration
    {
      id: "concentration",
      description: "<p>A spellcaster's concentration can be ended by any of the following:</p><ul><li>The spellcaster chooses to end concentration at any time.</li><li>The spellcaster is incapacitated or killed.</li><li>The spellcaster successfully casts another spell that requires concentration.</li><li>The GM may rule that a sudden interruption, such as a push, may force the spellcaster to make a DC 10 Constitution check. On a failure, the spell ends.</li><li>If the spellcaster takes damage while concentrating on a spell, they must make a Constitution saving throw; on a failure, the spell ends.The DC is 10 or half the damage taken, whichever is higher.</li></ul>",
      label: "A5E.ConditionConcentration",
      icon: "systems/a5e/assets/icons/concentration.svg",
      changes: l.concentration,
      duration: {}
    },
    // Confused
    {
      id: "confused",
      description: `<ul class="a5e-tooltip__list"><li>A confused creature can't take reactions.</li><li>On its turn a confused creature rolls a d8 to determine what it does.</li><ul><li>On a 1 to 4, a confused creature does nothing.</li><li>On a 5 or 6, a confused creature takes no action or bonus action and uses all its movement to move in a randomly determined direction.</li><li>On a 7 or 8, a confused creature makes a melee attack against a randomly determined creature within its reach or does nothing if it can't make such an attack.</li></ul ></ul >`,
      label: "A5E.ConditionConfused",
      icon: "systems/a5e/assets/icons/confused.svg",
      changes: l.confused,
      duration: {}
    },
    // Deafened
    {
      id: "deafened",
      description: `<ul class="a5e-tooltip__list"><li>A deafened creature can't hear and automatically fails ability checks that require hearing.</li></ul>`,
      label: "A5E.ConditionDeafened",
      icon: "icons/svg/deaf.svg",
      changes: l.deafened,
      duration: {}
    },
    // Dead
    {
      id: "dead",
      label: "EFFECT.StatusDead",
      icon: "icons/svg/skull.svg",
      changes: l.dead,
      duration: {},
      flags: { core: { overlay: !0 } }
    },
    // Doomed
    {
      id: "doomed",
      description: '<ul class="a5e-tooltip__list"><li>A doomed creature dies at a time determined by the Narrator, or within 13 (2d12) hours.</li><li>A doomed creature continues to be doomed even after it dies. Magic equivalent to a 7th-level or higher spell can remove the doomed condition (such as regenerate cast on a living creature, resurrection, true resurrection, or wish).</li></ul >',
      label: "A5E.ConditionDoomed",
      icon: "systems/a5e/assets/icons/doomed.svg",
      changes: l.doomed,
      duration: {}
    },
    // Encumbered
    {
      id: "encumbered",
      description: `<ul class="a5e-tooltip__list"><li>An encumbered creature's Speed is reduced to 5 ft.</li></ul>`,
      label: "A5E.ConditionEncumbered",
      icon: "systems/a5e/assets/icons/encumbered.svg",
      changes: l.encumbered,
      duration: {}
    },
    // Fatigue
    {
      id: "fatigue",
      label: "A5E.ConditionFatigue",
      icon: "systems/a5e/assets/icons/fatigue.svg",
      changes: l.fatigue,
      duration: {}
    },
    // Frightened
    {
      id: "frightened",
      description: `<ul class="a5e-tooltip__list"><li>A frightened creature has disadvantage on ability checks and attack rolls while it is able to see the source of its fear.</li><li>A frightened creature can't willingly move closer to the source of its fear.</li></ul>`,
      label: "A5E.ConditionFrightened",
      icon: "icons/svg/terror.svg",
      changes: l.frightened,
      duration: {}
    },
    // Grappled
    {
      id: "grappled",
      description: `<ul class="a5e-tooltip__list"><li>A grappled creature's Speed becomes 0, and it can't benefit from bonuses to movement speeds.</li><li>If the grappler becomes incapacitated the condition ends.</li><li>If an effect removes the grappled creature from the reach of the grappler or grappling effect (such as when a creature is shoved away by the Doubleteam combat maneuver) the condition ends.</li></ul>`,
      label: "A5E.ConditionGrappled",
      icon: "systems/a5e/assets/icons/grappled.svg",
      changes: l.grappled,
      duration: {}
    },
    // Incapacitated
    {
      id: "incapacitated",
      description: `<ul class="a5e-tooltip__list"><li>An incapacitated creature can't take actions, bonus actions, or reactions.</li></ul>`,
      label: "A5E.ConditionIncapacitated",
      icon: "systems/a5e/assets/icons/incapacitated.svg",
      changes: l.incapacitated,
      duration: {}
    },
    // Invisible
    {
      id: "invisible",
      description: `<ul class="a5e-tooltip__list"><li>An invisible creature is impossible to see without the aid of magic or a special sense (it gains no benefits from this condition against creatures still able to see it).</li><li>An invisible creature is heavily obscured for the purpose of hiding.</li><li>An invisible creature's location can be detected by noises it makes or tracks it leaves.</li><li>Attack rolls against an invisible creature are made with disadvantage.</li><li>An invisible creature makes attack rolls with advantage.</li></ul>`,
      label: "A5E.ConditionInvisible",
      icon: "icons/svg/invisible.svg",
      changes: l.invisible,
      duration: {}
    },
    // Paralyzed
    {
      id: "paralyzed",
      description: `<ul class="a5e-tooltip__list"><li>A paralyzed creature is incapacitated and can't move or speak.</li><li>A paralyzed creature automatically fails Strength and Dexterity saving throws.</li><li>Attack rolls against a paralyzed creature have advantage.</li><li>Any attack that hits a paralyzed creature is a critical hit if the attacker is within 5 feet.</li></ul>`,
      label: "A5E.ConditionParalyzed",
      icon: "icons/svg/paralysis.svg",
      changes: l.paralyzed,
      duration: {},
      statuses: ["incapacitated"]
    },
    // Petrified
    {
      id: "petrified",
      description: `<ul class="a5e-tooltip__list"><li>A petrified creature (and all of its mundane possessions) is transformed into a solid inanimate substance (usually stone).</li><li>A petrified creature's weight is increased by a factor of ten and it ceases aging.</li><li>A petrified creature is incapacitated, can't move or speak, and is unaware of its surroundings.</li><li>A petrified creature automatically fails Strength and Dexterity saving throws.</li><li>A petrified creature has resistance to all damage.</li><li>A petrified creature is immune to poison and disease (time spent petrified does not affect the duration of a poison or disease already in its system).</li></ul>`,
      label: "A5E.ConditionPetrified",
      icon: "systems/a5e/assets/icons/petrified.svg",
      changes: l.petrified,
      duration: {},
      statuses: ["incapacitated"]
    },
    // Poisoned
    {
      id: "poisoned",
      description: '<ul class="a5e-tooltip__list"><li>A poisoned creature has disadvantage on attack rolls and ability checks.</li></ul>',
      label: "A5E.ConditionPoisoned",
      icon: "icons/svg/poison.svg",
      changes: l.poisoned,
      duration: {}
    },
    // Prone
    {
      id: "prone",
      description: `<ul class="a5e-tooltip__list"><li>A prone creature's only movement option is to crawl (every 1 foot of movement while crawling costs 1 extra foot) until it stands up.</li><li>Standing up requires half a creature's movement.</li><li>A prone creature makes melee attack rolls with disadvantage.</li><li>An attack roll against a prone creature is made with advantage if the attacker is within 5 feet. Otherwise, the attack roll is made with disadvantage.</li></ul>`,
      label: "A5E.ConditionProne",
      icon: "icons/svg/falling.svg",
      changes: l.prone,
      duration: {}
    },
    // Rattled
    {
      id: "rattled",
      description: '<ul class="a5e-tooltip__list"><li>A rattled creature cannot benefit from expertise dice.</li><li>A creature that is immune to being stunned is immune to being rattled.</li><li>A rattled creature cannot take reactions.</li></ul>',
      label: "A5E.ConditionRattled",
      icon: "systems/a5e/assets/icons/rattled.svg",
      changes: l.rattled,
      duration: {}
    },
    // Restrained
    {
      id: "restrained",
      description: `<ul class="a5e-tooltip__list"><li>A restrained creature's Speed becomes 0, and it can't benefit from bonuses to speed.</li><li>Attack rolls against a restrained creature are made with advantage.</li><li>A restrained creature makes attack rolls with disadvantage.</li><li>The restrained creature has disadvantage on Dexterity saving throws.</li></ul>`,
      label: "A5E.ConditionRestrained",
      icon: "icons/svg/net.svg",
      changes: l.restrained,
      duration: {}
    },
    // Slowed
    {
      id: "slowed",
      description: `<ul class="a5e-tooltip__list"><li>A slowed creature's Speed is halved.</li><li>A slowed creature takes a −2 penalty to AC and Dexterity saving throws.</li><li>A slowed creature cannot take reactions.</li><li>On its turn, a slowed creature can take either an action or a bonus action, not both. In addition, it can't make more than one melee or ranged attack during its turn.</li></ul>`,
      label: "A5E.ConditionSlowed",
      icon: "systems/a5e/assets/icons/slowed.svg",
      changes: l.slowed,
      duration: {}
    },
    // Strife
    {
      id: "strife",
      label: "A5E.ConditionStrife",
      icon: "systems/a5e/assets/icons/strife.svg",
      changes: l.strife,
      duration: {}
    },
    // Stunned
    {
      id: "stunned",
      description: `<ul class="a5e-tooltip__list"><li>A stunned creature is incapacitated (see the condition), can't move, and can speak only falteringly.</li><li>The creature automatically fails Strength and Dexterity saving throws.</li><li>Attack rolls against the creature have advantage.</li><li>A creature that is immune to being stunned is immune to being rattled.</li></ul>`,
      label: "A5E.ConditionStunned",
      icon: "icons/svg/daze.svg",
      changes: l.stunned,
      duration: {},
      statuses: ["incapacitated"]
    },
    // Unconscious
    {
      id: "unconscious",
      description: `<ul class="a5e-tooltip__list"><li>An unconscious creature is incapacitated, can't move or speak, and is unaware of its surroundings.</li><li>An unconscious creature drops whatever it's holding and falls prone.</li><li>An unconscious creature automatically fails Strength and Dexterity saving throws.</li><li>Attack rolls against an unconscious creature are made with advantage.</li><li>Any attack that hits an unconscious creature is a critical hit if the attacker is within 5 feet.</li></ul>`,
      label: "A5E.ConditionUnconscious",
      icon: "icons/svg/unconscious.svg",
      changes: l.unconscious,
      duration: {},
      flags: {
        core: { overlay: !0 }
      },
      statuses: ["incapacitated"]
    },
    ...Array.from({ length: 10 }, (o, a) => ({
      id: `generic${a + 1}`,
      label: `Generic ${a + 1}`,
      icon: `systems/a5e/assets/icons/circle${a + 1}.svg`,
      changes: [],
      duration: {}
    }))
  ];
  r = r.reduce((o, a) => {
    var c;
    return s && a.id === "strife" || (a.icon = n[a.id] || i.conditionIconsDefault[a.id] || a.icon, !t.has(a.id) && a.changes.length && (a.changes = []), s && a.id === "fatigue" && (a.changes = ((c = i.multiLevelConditions) == null ? void 0 : c.exhaustion) ?? [], a.label = "Exhaustion"), o.push(a)), o;
  }, []), CONFIG.statusEffects = r, CONFIG.A5E.linkedStatusEffects = r.reduce((o, a) => {
    var c;
    return (c = a.statuses) != null && c.length && a.statuses.forEach((u) => {
      o[u] ?? (o[u] = []), o[u].push(a.id);
    }), o;
  }, {});
}
f(l_e, "registerConditionsConfig");
const r_e = {
  classFeatures: {
    packs: ["a5e.a5e-class-features"],
    func: zq
  },
  manuevers: {
    packs: ["a5e.a5e-maneuvers"],
    func: Hq
  },
  monsters: {
    packs: ["a5e.a5e-monsters"],
    func: x5
  },
  spells: {
    packs: ["a5e.a5e-spells"],
    func: t$
  },
  dnd5eMonsters: {
    packs: ["a5e.dnd5e-monsters"],
    func: Uq
  },
  dnd5eSpells: {
    packs: ["a5e.dnd5e-spells"],
    func: Vq
  },
  objects: {
    packs: ["a5e.a5e-adventuring-gear", "a5e.dnd5e-items"],
    func: e$
  }
}, o_e = {
  npc: x5,
  spell: t$,
  object: e$
};
function a_e() {
  const i = /* @__PURE__ */ new Set();
  if (Object.values(r_e).forEach(({ packs: e, func: t }) => {
    e.forEach((s) => {
      t(s), i.add(s);
    });
  }), !!game.settings.storage.get("world").getItem("a5e.autoApplyFancySheets"))
    for (const e of game.packs) {
      const t = e.metadata.id || e.collection;
      if (!t || !e.metadata.type)
        continue;
      const n = [...e.index].map((o) => o.type).filter(Boolean);
      if (!n.every((o) => n[0] === o))
        continue;
      const l = n[0], r = o_e[l];
      r && r(t);
    }
}
f(a_e, "setupFancySheets");
function c_e() {
  const i = game.settings.get("a5e", "gamemasterTitle") || "Narrator";
  game.i18n.translations.USER.GM = i, game.i18n.translations.GM = i;
}
f(c_e, "updateGMTitle");
function u_e() {
  n_e(), l_e(), a_e(), c_e();
}
f(u_e, "setup");
function f_e(i, e, t, s) {
  const n = Object.keys(e).filter((r) => r !== "_id");
  new Set(n).has("ownership") && (i._sheet = void 0, i.getActiveTokens().forEach((o) => {
    o.actor._sheet = void 0;
  }));
}
f(f_e, "updateActor");
Hooks.once("init", c1e);
Hooks.once("setup", u_e);
Hooks.once("ready", E1e);
Hooks.on("canvasInit", fz);
Hooks.on("canvasReady", yse);
Hooks.on("getActorDirectoryEntryContext", (i, e, t) => s$(i, e, t, "Actor"));
Hooks.on("getItemDirectoryEntryContext", (i, e, t) => s$(i, e, t, "Item"));
Hooks.on("getCompendiumDirectoryEntryContext", (i, e, t) => s$(i, e, t, "Pack"));
Hooks.on("createActor", vse);
Hooks.on("createToken", $se);
Hooks.on("updateActor", f_e);
Hooks.on("renderApplication", S1e);
Hooks.on("renderChatMessage", Lbe);
Hooks.on("preCreateChatMessage", p1e);
Hooks.on("preDeleteChatMessage", d1e);
Hooks.on("renderSettings", xbe);
Hooks.on("renderTokenHUDA5e", s_e);
//# sourceMappingURL=index.js.map
